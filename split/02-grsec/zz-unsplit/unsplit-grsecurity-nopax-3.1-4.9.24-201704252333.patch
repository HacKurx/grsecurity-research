diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 44e08f4e7aa1..fdf60423fb17 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1436,6 +1436,12 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			[KNL] Should the hard-lockup detector generate
 			backtraces on all cpus.
 			Format: <integer>
+	grsec_proc_gid= [GRKERNSEC_PROC_USERGROUP] Chooses GID to
+			ignore grsecurity's /proc restrictions
+
+	grsec_sysfs_restrict= Format: 0 | 1
+			Default: 1
+			Disables GRKERNSEC_SYSFS_RESTRICT if enabled in config
 
 	hashdist=	[KNL,NUMA] Large hashes allocated during boot
 			are distributed across NUMA nodes.  Defaults on
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index d5f4b186a6f7..c47cdf5d9fbc 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -64,7 +64,9 @@ ret_fast_syscall:
  UNWIND(.cantunwind	)
 	disable_irq_notrace			@ disable interrupts
 	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing
-	tst	r1, #_TIF_SYSCALL_WORK | _TIF_WORK_MASK
+	tst	r1, #_TIF_SYSCALL_WORK
+	bne	fast_work_pending
+	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 
 	/* perform architecture specific actions before user return */
@@ -90,7 +92,9 @@ ret_fast_syscall:
 	str	r0, [sp, #S_R0 + S_OFF]!	@ save returned r0
 	disable_irq_notrace			@ disable interrupts
 	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing
-	tst	r1, #_TIF_SYSCALL_WORK | _TIF_WORK_MASK
+	tst	r1, #_TIF_SYSCALL_WORK
+	bne	__sys_trace_return_nosave
+	tst	r1, #_TIF_WORK_MASK
 	beq	no_work_pending
  UNWIND(.fnend		)
 ENDPROC(ret_fast_syscall)
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 368d01d6bba9..9111dcc934b1 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -844,7 +844,7 @@ config KUSER_HELPERS
 
 config VDSO
 	bool "Enable VDSO for acceleration of some system calls"
-	depends on AEABI && MMU && CPU_V7
+	depends on AEABI && MMU && CPU_V7 && !PAX_KERNEXEC && !PAX_MEMORY_UDEREF
 	default y if ARM_ARCH_TIMER
 	select GENERIC_TIME_VSYSCALL
 	help
diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c
index 0843291ec6b9..2db6d9995251 100644
--- a/arch/arm/net/bpf_jit_32.c
+++ b/arch/arm/net/bpf_jit_32.c
@@ -73,54 +73,38 @@ struct jit_ctx {
 #endif
 };
 
+#ifdef CONFIG_GRKERNSEC_BPF_HARDEN
+int bpf_jit_enable __read_only;
+#else
 int bpf_jit_enable __read_mostly;
+#endif
 
-static inline int call_neg_helper(struct sk_buff *skb, int offset, void *ret,
-		      unsigned int size)
-{
-	void *ptr = bpf_internal_load_pointer_neg_helper(skb, offset, size);
-
-	if (!ptr)
-		return -EFAULT;
-	memcpy(ret, ptr, size);
-	return 0;
-}
-
-static u64 jit_get_skb_b(struct sk_buff *skb, int offset)
+static u64 jit_get_skb_b(struct sk_buff *skb, unsigned offset)
 {
 	u8 ret;
 	int err;
 
-	if (offset < 0)
-		err = call_neg_helper(skb, offset, &ret, 1);
-	else
-		err = skb_copy_bits(skb, offset, &ret, 1);
+	err = skb_copy_bits(skb, offset, &ret, 1);
 
 	return (u64)err << 32 | ret;
 }
 
-static u64 jit_get_skb_h(struct sk_buff *skb, int offset)
+static u64 jit_get_skb_h(struct sk_buff *skb, unsigned offset)
 {
 	u16 ret;
 	int err;
 
-	if (offset < 0)
-		err = call_neg_helper(skb, offset, &ret, 2);
-	else
-		err = skb_copy_bits(skb, offset, &ret, 2);
+	err = skb_copy_bits(skb, offset, &ret, 2);
 
 	return (u64)err << 32 | ntohs(ret);
 }
 
-static u64 jit_get_skb_w(struct sk_buff *skb, int offset)
+static u64 jit_get_skb_w(struct sk_buff *skb, unsigned offset)
 {
 	u32 ret;
 	int err;
 
-	if (offset < 0)
-		err = call_neg_helper(skb, offset, &ret, 4);
-	else
-		err = skb_copy_bits(skb, offset, &ret, 4);
+	err = skb_copy_bits(skb, offset, &ret, 4);
 
 	return (u64)err << 32 | ntohl(ret);
 }
@@ -557,6 +541,9 @@ static int build_body(struct jit_ctx *ctx)
 		case BPF_LD | BPF_B | BPF_ABS:
 			load_order = 0;
 load:
+			/* the interpreter will deal with the negative K */
+			if ((int)k < 0)
+				return -ENOTSUPP;
 			emit_mov_i(r_off, k, ctx);
 load_common:
 			ctx->seen |= SEEN_DATA | SEEN_CALL;
@@ -571,18 +558,6 @@ static int build_body(struct jit_ctx *ctx)
 				condt = ARM_COND_HI;
 			}
 
-			/*
-			 * test for negative offset, only if we are
-			 * currently scheduled to take the fast
-			 * path. this will update the flags so that
-			 * the slowpath instruction are ignored if the
-			 * offset is negative.
-			 *
-			 * for loard_order == 0 the HI condition will
-			 * make loads at offset 0 take the slow path too.
-			 */
-			_emit(condt, ARM_CMP_I(r_off, 0), ctx);
-
 			_emit(condt, ARM_ADD_R(r_scratch, r_off, r_skb_data),
 			      ctx);
 
diff --git a/arch/arm64/include/asm/atomic.h b/arch/arm64/include/asm/atomic.h
index efc792c2b7da..86eb6849cbdd 100644
--- a/arch/arm64/include/asm/atomic.h
+++ b/arch/arm64/include/asm/atomic.h
@@ -130,6 +130,8 @@
 #define __atomic_add_unless(v, a, u)	___atomic_add_unless(v, a, u,)
 #define atomic_andnot			atomic_andnot
 
+#define atomic_inc_return_unchecked_relaxed(v)	atomic_add_return_relaxed(1, (v))
+
 /*
  * 64-bit atomic operations.
  */
diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h
index 8663d5b962d5..d8b49ffdb58c 100644
--- a/arch/arm64/include/asm/pgtable.h
+++ b/arch/arm64/include/asm/pgtable.h
@@ -23,6 +23,9 @@
 #include <asm/pgtable-hwdef.h>
 #include <asm/pgtable-prot.h>
 
+#define ktla_ktva(addr)		(addr)
+#define ktva_ktla(addr)		(addr)
+
 /*
  * VMALLOC range.
  *
diff --git a/arch/m68k/kernel/time.c b/arch/m68k/kernel/time.c
index 4e5aa2f4f522..172c46953cb2 100644
--- a/arch/m68k/kernel/time.c
+++ b/arch/m68k/kernel/time.c
@@ -107,6 +107,7 @@ static int rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case RTC_PLL_GET:
+		memset(&pll, 0, sizeof(pll));
 		if (!mach_get_rtc_pll || mach_get_rtc_pll(&pll))
 			return -EINVAL;
 		return copy_to_user(argp, &pll, sizeof pll) ? -EFAULT : 0;
diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index adb52d101133..a1841acd5fe9 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -31,6 +31,8 @@ CFLAGS_REMOVE_ftrace.o = -mno-sched-epilog $(CC_FLAGS_FTRACE)
 CFLAGS_REMOVE_time.o = -mno-sched-epilog $(CC_FLAGS_FTRACE)
 endif
 
+CFLAGS_REMOVE_prom_init.o += $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+
 obj-y				:= cputable.o ptrace.o syscalls.o \
 				   irq.o align.o signal_32.o pmc.o vdso.o \
 				   process.o systbl.o idle.o \
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 6fd9109002c6..1775eac0acb1 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1246,6 +1248,7 @@ choice
 
 config NOHIGHMEM
 	bool "off"
+	depends on !(PAX_PAGEEXEC && PAX_ENABLE_PAE)
 	---help---
 	  Linux can use up to 64 Gigabytes of physical memory on x86 systems.
 	  However, the address space of 32-bit x86 processors is only 4
@@ -1282,6 +1285,7 @@ config NOHIGHMEM
 
 config HIGHMEM4G
 	bool "4GB"
+	depends on !(PAX_PAGEEXEC && PAX_ENABLE_PAE)
 	---help---
 	  Select this if you have a 32-bit processor and between 1 and 4
 	  gigabytes of physical RAM.
diff --git a/arch/x86/entry/entry_32.S b/arch/x86/entry/entry_32.S
index 24fdfbac9264..d684e0fdb4f2 100644
--- a/arch/x86/entry/entry_32.S
+++ b/arch/x86/entry/entry_32.S
@@ -257,7 +257,7 @@ ENTRY(pax_erase_kstack)
 
 	GET_CURRENT(%ebp)
 	mov TASK_lowest_stack(%ebp), %edi
-	mov $0xB4DD00D5, %eax
+	mov $-0xBEEF, %eax
 	std
 
 1:	mov %edi, %ecx
diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S
index 803eccf0d472..d3f0e593fbe6 100644
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@ -401,7 +401,7 @@ ENTRY(pax_erase_kstack)
 
 	GET_CURRENT(%r11)
 	mov	TASK_lowest_stack(%r11), %rdi
-	mov	$0xB4DD00D5BADBABE5, %rax
+	mov	$-0xBEEF, %rax
 	std
 
 1:	mov	%edi, %ecx
diff --git a/arch/x86/ia32/ia32_aout.c b/arch/x86/ia32/ia32_aout.c
index cb26f18d43af..4f43f2399f6b 100644
--- a/arch/x86/ia32/ia32_aout.c
+++ b/arch/x86/ia32/ia32_aout.c
@@ -153,6 +153,8 @@ static int aout_core_dump(struct coredump_params *cprm)
 	unsigned long dump_start, dump_size;
 	struct user32 dump;
 
+	memset(&dump, 0, sizeof(dump));
+
 	fs = get_fs();
 	set_fs(KERNEL_DS);
 	has_dumped = 1;
diff --git a/arch/x86/include/asm/fpu/types.h b/arch/x86/include/asm/fpu/types.h
index 4ae5fd68d543..e32babddda6c 100644
--- a/arch/x86/include/asm/fpu/types.h
+++ b/arch/x86/include/asm/fpu/types.h
@@ -276,6 +276,39 @@ union fpregs_state {
  */
 struct fpu {
 	/*
+	 * @state:
+	 *
+	 * In-memory copy of all FPU registers that we save/restore
+	 * over context switches. If the task is using the FPU then
+	 * the registers in the FPU are more recent than this state
+	 * copy. If the task context-switches away then they get
+	 * saved here and represent the FPU state.
+	 *
+	 * After context switches there may be a (short) time period
+	 * during which the in-FPU hardware registers are unchanged
+	 * and still perfectly match this state, if the tasks
+	 * scheduled afterwards are not using the FPU.
+	 *
+	 * This is the 'lazy restore' window of optimization, which
+	 * we track though 'fpu_fpregs_owner_ctx' and 'fpu->last_cpu'.
+	 *
+	 * We detect whether a subsequent task uses the FPU via setting
+	 * CR0::TS to 1, which causes any FPU use to raise a #NM fault.
+	 *
+	 * During this window, if the task gets scheduled again, we
+	 * might be able to skip having to do a restore from this
+	 * memory buffer to the hardware registers - at the cost of
+	 * incurring the overhead of #NM fault traps.
+	 *
+	 * Note that on modern CPUs that support the XSAVEOPT (or other
+	 * optimized XSAVE instructions), we don't use #NM traps anymore,
+	 * as the hardware can track whether FPU registers need saving
+	 * or not. On such CPUs we activate the non-lazy ('eagerfpu')
+	 * logic, which unconditionally saves/restores all FPU state
+	 * across context switches. (if FPU state exists.)
+	 */
+	union fpregs_state		*state;
+	/*
 	 * @last_cpu:
 	 *
 	 * Records the last CPU on which this context was loaded into
@@ -332,42 +365,6 @@ struct fpu {
 	 * deal with bursty apps that only use the FPU for a short time:
 	 */
 	unsigned char			counter;
-	/*
-	 * @state:
-	 *
-	 * In-memory copy of all FPU registers that we save/restore
-	 * over context switches. If the task is using the FPU then
-	 * the registers in the FPU are more recent than this state
-	 * copy. If the task context-switches away then they get
-	 * saved here and represent the FPU state.
-	 *
-	 * After context switches there may be a (short) time period
-	 * during which the in-FPU hardware registers are unchanged
-	 * and still perfectly match this state, if the tasks
-	 * scheduled afterwards are not using the FPU.
-	 *
-	 * This is the 'lazy restore' window of optimization, which
-	 * we track though 'fpu_fpregs_owner_ctx' and 'fpu->last_cpu'.
-	 *
-	 * We detect whether a subsequent task uses the FPU via setting
-	 * CR0::TS to 1, which causes any FPU use to raise a #NM fault.
-	 *
-	 * During this window, if the task gets scheduled again, we
-	 * might be able to skip having to do a restore from this
-	 * memory buffer to the hardware registers - at the cost of
-	 * incurring the overhead of #NM fault traps.
-	 *
-	 * Note that on modern CPUs that support the XSAVEOPT (or other
-	 * optimized XSAVE instructions), we don't use #NM traps anymore,
-	 * as the hardware can track whether FPU registers need saving
-	 * or not. On such CPUs we activate the non-lazy ('eagerfpu')
-	 * logic, which unconditionally saves/restores all FPU state
-	 * across context switches. (if FPU state exists.)
-	 */
-	union fpregs_state		*state;
-	/*
-	 * WARNING: 'state' is dynamically-sized.
-	 */
 };
 
 #endif /* _ASM_X86_FPU_H */
diff --git a/arch/x86/include/asm/io.h b/arch/x86/include/asm/io.h
index 45ed2fe949dc..08f3231179cc 100644
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -116,7 +116,7 @@ build_mmio_write(writeq, "q", unsigned long, "r", :"memory")
  *	this function
  */
 
-static inline phys_addr_t virt_to_phys(volatile void *address)
+static inline phys_addr_t __intentional_overflow(-1) virt_to_phys(volatile void *address)
 {
 	return __pa(address);
 }
diff --git a/arch/x86/include/asm/irqflags.h b/arch/x86/include/asm/irqflags.h
index 844b04f5e2e9..90e119ce41a5 100644
--- a/arch/x86/include/asm/irqflags.h
+++ b/arch/x86/include/asm/irqflags.h
@@ -27,13 +27,17 @@ static inline asmlinkage unsigned long native_save_fl(void)
 		     : /* no input */
 		     : "memory");
 
+#if !defined(CONFIG_GRKERNSEC_CONFIG_VIRT_HOST) || !defined(CONFIG_GRKERNSEC_CONFIG_VIRT_VIRTUALBOX)
 	BUG_ON(flags & X86_EFLAGS_AC);
+#endif
 	return flags;
 }
 
 static inline void native_restore_fl(unsigned long flags)
 {
+#if !defined(CONFIG_GRKERNSEC_CONFIG_VIRT_HOST) || !defined(CONFIG_GRKERNSEC_CONFIG_VIRT_VIRTUALBOX)
 	BUG_ON(flags & X86_EFLAGS_AC);
+#endif
 	asm volatile("push %0 ; popf"
 		     : /* no output */
 		     :"g" (flags)
diff --git a/arch/x86/include/asm/page_64.h b/arch/x86/include/asm/page_64.h
index cb419e73e16b..2c3570f2f839 100644
--- a/arch/x86/include/asm/page_64.h
+++ b/arch/x86/include/asm/page_64.h
@@ -9,7 +9,7 @@
 extern unsigned long max_pfn;
 extern const unsigned long phys_base;
 
-static inline unsigned long __intentional_overflow(-1) __phys_addr_nodebug(unsigned long x)
+static __always_inline unsigned long __intentional_overflow(-1) __phys_addr_nodebug(unsigned long x)
 {
 	unsigned long y = x - __START_KERNEL_map;
 
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 12544be44fc2..0ad5d22ee0d5 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -343,6 +343,7 @@ DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union) __visible;
 DECLARE_INIT_PER_CPU(irq_stack_union);
 
 DECLARE_PER_CPU(char *, irq_stack_ptr);
+DECLARE_PER_CPU(char *, irq_stack_ptr_lowmem);
 DECLARE_PER_CPU(unsigned int, irq_count);
 extern asmlinkage void ignore_sysret(void);
 #else	/* X86_64 */
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 4870ac891553..9eeb03bc4194 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1381,6 +1381,8 @@ EXPORT_PER_CPU_SYMBOL(current_task);
 
 DEFINE_PER_CPU(char *, irq_stack_ptr) =
 	init_per_cpu_var(irq_stack_union.irq_stack) + IRQ_STACK_SIZE;
+DEFINE_PER_CPU(char *, irq_stack_ptr_lowmem) =
+	init_per_cpu_var(irq_stack_union.irq_stack) + IRQ_STACK_SIZE;
 
 DEFINE_PER_CPU(unsigned int, irq_count) __visible = -1;
 
diff --git a/arch/x86/kernel/dumpstack_32.c b/arch/x86/kernel/dumpstack_32.c
index 7cfef2210e0e..ca545b8e21c2 100644
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@ -15,6 +15,7 @@
 #include <linux/nmi.h>
 
 #include <asm/stacktrace.h>
+#include <asm/desc.h>
 
 void stack_type_str(enum stack_type type, const char **begin, const char **end)
 {
diff --git a/arch/x86/kernel/irq_64.c b/arch/x86/kernel/irq_64.c
index 9ebd0b0e73d9..685de4ae632c 100644
--- a/arch/x86/kernel/irq_64.c
+++ b/arch/x86/kernel/irq_64.c
@@ -44,9 +46,8 @@ static inline void stack_overflow_check(struct pt_regs *regs)
 	    regs->sp <= curbase + THREAD_SIZE)
 		return;
 
-	irq_stack_top = (u64)this_cpu_ptr(irq_stack_union.irq_stack) +
-			STACK_TOP_MARGIN;
 	irq_stack_bottom = (u64)__this_cpu_read(irq_stack_ptr);
+	irq_stack_top = irq_stack_bottom - IRQ_STACK_SIZE + STACK_TOP_MARGIN;
 	if (regs->sp >= irq_stack_top && regs->sp <= irq_stack_bottom)
 		return;
 
diff --git a/arch/x86/kernel/setup_percpu.c b/arch/x86/kernel/setup_percpu.c
index 337e35abb330..99987a3239c2 100644
--- a/arch/x86/kernel/setup_percpu.c
+++ b/arch/x86/kernel/setup_percpu.c
@@ -247,7 +247,7 @@ void __init setup_per_cpu_areas(void)
 			early_per_cpu_map(x86_cpu_to_logical_apicid, cpu);
 #endif
 #ifdef CONFIG_X86_64
-		per_cpu(irq_stack_ptr, cpu) =
+		per_cpu(irq_stack_ptr, cpu) = per_cpu(irq_stack_ptr_lowmem, cpu) =
 			per_cpu(irq_stack_union.irq_stack, cpu) +
 			IRQ_STACK_SIZE;
 #endif
diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c
index 14d6a3f2426e..de6997132326 100644
--- a/arch/x86/mm/init_32.c
+++ b/arch/x86/mm/init_32.c
@@ -232,13 +232,13 @@ page_table_range_init(unsigned long start, unsigned long end, pgd_t *pgd_base)
 
 static inline int is_kernel_text(unsigned long start, unsigned long end)
 {
-	if ((start > ktla_ktva((unsigned long)_etext) ||
+	if ((start >= ktla_ktva((unsigned long)_etext) ||
 	     end <= ktla_ktva((unsigned long)_stext)) &&
-	    (start > ktla_ktva((unsigned long)_einittext) ||
+	    (start >= ktla_ktva((unsigned long)_einittext) ||
 	     end <= ktla_ktva((unsigned long)_sinittext)) &&
 
 #ifdef CONFIG_ACPI_SLEEP
-	    (start > (unsigned long)__va(acpi_wakeup_address) + 0x4000 || end <= (unsigned long)__va(acpi_wakeup_address)) &&
+	    (start >= (unsigned long)__va(acpi_wakeup_address) + 0x4000 || end <= (unsigned long)__va(acpi_wakeup_address)) &&
 #endif
 
 	    (start > (unsigned long)__va(0xfffff) || end <= (unsigned long)__va(0xc0000)))
diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
index 4bc6d52f2785..41dfc2bf295e 100644
--- a/arch/x86/mm/mmap.c
+++ b/arch/x86/mm/mmap.c
@@ -99,23 +99,13 @@ static unsigned long mmap_base(struct mm_struct *mm, unsigned long rnd)
 	return PAGE_ALIGN(pax_task_size - gap - rnd);
 }
 
-/*
- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64
- * does, but not when emulating X86_32
- */
 static unsigned long mmap_legacy_base(struct mm_struct *mm, unsigned long rnd)
 {
-	if (mmap_is_ia32()) {
-
 #ifdef CONFIG_PAX_SEGMEXEC
-		if (mm->pax_flags & MF_PAX_SEGMEXEC)
-			return SEGMEXEC_TASK_UNMAPPED_BASE;
-		else
+	if (mmap_is_ia32() && (mm->pax_flags & MF_PAX_SEGMEXEC))
+		return SEGMEXEC_TASK_UNMAPPED_BASE + rnd;
 #endif
-
-		return TASK_UNMAPPED_BASE;
-	} else
-		return TASK_UNMAPPED_BASE + rnd;
+	return TASK_UNMAPPED_BASE + rnd;
 }
 
 /*
diff --git a/arch/x86/platform/olpc/xo1-wakeup.S b/arch/x86/platform/olpc/xo1-wakeup.S
index d5679d15db74..16a434a3091a 100644
--- a/arch/x86/platform/olpc/xo1-wakeup.S
+++ b/arch/x86/platform/olpc/xo1-wakeup.S
@@ -1,5 +1,6 @@
 .text
 #include <linux/linkage.h>
+#include <asm/alternative-asm.h>
 #include <asm/segment.h>
 #include <asm/page.h>
 #include <asm/pgtable_32.h>
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 1b29b28b8e18..0b23b0664848 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -292,9 +292,6 @@
 /*
  * To allow fractional bits to be tracked, the entropy_count field is
  * denominated in units of 1/8th bits.
- *
- * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
- * credit_entropy_bits() needs to be 64 bits wide.
  */
 #define ENTROPY_SHIFT 3
 #define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)
diff --git a/drivers/cpufreq/sparc-us3-cpufreq.c b/drivers/cpufreq/sparc-us3-cpufreq.c
index eefba1cce838..b01b4a2ddf62 100644
--- a/drivers/cpufreq/sparc-us3-cpufreq.c
+++ b/drivers/cpufreq/sparc-us3-cpufreq.c
@@ -168,7 +168,6 @@ static struct cpufreq_driver cpufreq_us3_driver = {
 	.target_index	= us3_freq_target,
 	.get		= us3_freq_get,
 	.exit		= us3_freq_cpu_exit,
-	.owner		= THIS_MODULE,
 	.name		= "UltraSPARC-III",
 
 };
diff --git a/drivers/firewire/ohci.c b/drivers/firewire/ohci.c
index 8bf89267dc25..55a4930ebf66 100644
--- a/drivers/firewire/ohci.c
+++ b/drivers/firewire/ohci.c
@@ -2049,10 +2049,12 @@ static void bus_reset_work(struct work_struct *work)
 			  be32_to_cpu(ohci->next_header));
 	}
 
+#ifndef CONFIG_GRKERNSEC
 	if (param_remote_dma) {
 		reg_write(ohci, OHCI1394_PhyReqFilterHiSet, ~0);
 		reg_write(ohci, OHCI1394_PhyReqFilterLoSet, ~0);
 	}
+#endif
 
 	spin_unlock_irq(&ohci->lock);
 
@@ -2585,8 +2587,10 @@ static int ohci_enable_phys_dma(struct fw_card *card,
 	unsigned long flags;
 	int n, ret = 0;
 
+#ifndef CONFIG_GRKERNSEC
 	if (param_remote_dma)
 		return 0;
+#endif
 
 	/*
 	 * FIXME:  Make sure this bitmask is cleared when we clear the busReset
diff --git a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_kms.c b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_kms.c
index ed7143d35b25..527b26ab1f6b 100644
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_kms.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_kms.c
@@ -647,9 +647,12 @@ struct msm_kms *mdp5_kms_init(struct drm_device *dev)
 	dev->mode_config.max_width = config->hw->lm.max_width;
 	dev->mode_config.max_height = config->hw->lm.max_height;
 
-	dev->driver->get_vblank_timestamp = mdp5_get_vblank_timestamp;
-	dev->driver->get_scanout_position = mdp5_get_scanoutpos;
-	dev->driver->get_vblank_counter = mdp5_get_vblank_counter;
+	pax_open_kernel();
+	const_cast(dev->driver->get_vblank_timestamp) = mdp5_get_vblank_timestamp;
+	const_cast(dev->driver->get_scanout_position) = mdp5_get_scanoutpos;
+	const_cast(dev->driver->get_vblank_counter) = mdp5_get_vblank_counter;
+	pax_close_kernel();
+
 	dev->max_vblank_count = 0xffffffff;
 	dev->vblank_disable_immediate = true;
 
diff --git a/drivers/net/wireless/ath/ath9k/Kconfig b/drivers/net/wireless/ath/ath9k/Kconfig
index 8f231c67dd51..48902b842258 100644
--- a/drivers/net/wireless/ath/ath9k/Kconfig
+++ b/drivers/net/wireless/ath/ath9k/Kconfig
@@ -3,7 +3,6 @@ config ATH9K_HW
 config ATH9K_COMMON
 	tristate
 	select ATH_COMMON
-	select DEBUG_FS
 	select RELAY
 config ATH9K_DFS_DEBUGFS
 	def_bool y
diff --git a/drivers/staging/wilc1000/host_interface.h b/drivers/staging/wilc1000/host_interface.h
index ddfea29df2a7..5305b3846064 100644
--- a/drivers/staging/wilc1000/host_interface.h
+++ b/drivers/staging/wilc1000/host_interface.h
@@ -1,6 +1,7 @@
 #ifndef HOST_INT_H
 #define HOST_INT_H
 
+#include <linux/netdevice.h>
 #include "coreconfigurator.h"
 
 #define IP_ALEN  4
diff --git a/drivers/staging/wilc1000/wilc_spi.c b/drivers/staging/wilc1000/wilc_spi.c
index f08cf6d9e1af..9ccd7a46e703 100644
--- a/drivers/staging/wilc1000/wilc_spi.c
+++ b/drivers/staging/wilc1000/wilc_spi.c
@@ -19,6 +19,7 @@
 #include <linux/of_gpio.h>
 
 #include <linux/string.h>
+#include <linux/netdevice.h>
 #include "wilc_wlan_if.h"
 #include "wilc_wlan.h"
 #include "wilc_wfi_netdevice.h"
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 3a4707746157..5cf8b9c0b25c 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -982,7 +982,7 @@ EXPORT_SYMBOL_GPL(usb_get_status);
  * Return: Zero on success, or else the status code returned by the
  * underlying usb_control_msg() call.
  */
-int usb_clear_halt(struct usb_device *dev, int pipe)
+int usb_clear_halt(struct usb_device *dev, unsigned int pipe)
 {
 	int result;
 	int endp = usb_pipeendpoint(pipe);
diff --git a/drivers/usb/gadget/function/f_uac1.c b/drivers/usb/gadget/function/f_uac1.c
index f2ac0cbc29a4..40382623c0bb 100644
--- a/drivers/usb/gadget/function/f_uac1.c
+++ b/drivers/usb/gadget/function/f_uac1.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/atomic.h>
+#include <linux/module.h>
 
 #include "u_uac1.h"
 
diff --git a/drivers/usb/gadget/function/u_uac1.c b/drivers/usb/gadget/function/u_uac1.c
index c78c84138a28..48fd281c0be0 100644
--- a/drivers/usb/gadget/function/u_uac1.c
+++ b/drivers/usb/gadget/function/u_uac1.c
@@ -17,6 +17,7 @@
 #include <linux/ctype.h>
 #include <linux/random.h>
 #include <linux/syscalls.h>
+#include <linux/module.h>
 
 #include "u_uac1.h"
 
diff --git a/drivers/usb/usbip/stub_rx.c b/drivers/usb/usbip/stub_rx.c
index 191b176ffedf..960b4ae6181e 100644
--- a/drivers/usb/usbip/stub_rx.c
+++ b/drivers/usb/usbip/stub_rx.c
@@ -80,7 +80,7 @@ static int tweak_clear_halt_cmd(struct urb *urb)
 	struct usb_ctrlrequest *req;
 	int target_endp;
 	int target_dir;
-	int target_pipe;
+	unsigned int target_pipe;
 	int ret;
 
 	req = (struct usb_ctrlrequest *) urb->setup_packet;
@@ -336,7 +336,7 @@ static struct stub_priv *stub_priv_alloc(struct stub_device *sdev,
 	return priv;
 }
 
-static int get_pipe(struct stub_device *sdev, int epnum, int dir)
+static unsigned int get_pipe(struct stub_device *sdev, int epnum, int dir)
 {
 	struct usb_device *udev = sdev->udev;
 	struct usb_host_endpoint *ep;
@@ -447,7 +447,7 @@ static void stub_recv_cmd_submit(struct stub_device *sdev,
 	struct stub_priv *priv;
 	struct usbip_device *ud = &sdev->ud;
 	struct usb_device *udev = sdev->udev;
-	int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);
+	unsigned int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);
 
 	priv = stub_priv_alloc(sdev, pdu);
 	if (!priv)
diff --git a/fs/binfmt_aout.c b/fs/binfmt_aout.c
index a6b038f337a6..15cfacf11ef5 100644
--- a/fs/binfmt_aout.c
+++ b/fs/binfmt_aout.c
@@ -58,6 +59,8 @@ static int aout_core_dump(struct coredump_params *cprm)
 #endif
 #       define START_STACK(u)   ((void __user *)u.start_stack)
 
+	memset(&dump, 0, sizeof(dump));
+
 	fs = get_fs();
 	set_fs(KERNEL_DS);
 	has_dumped = 1;
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index d8bda950fd40..e3bff2f9fa62 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -1451,7 +1459,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 		start = ELF_PAGEALIGN(elf_brk);
 		size = PAGE_SIZE + ((pax_get_random_long() & ((1UL << 22) - 1UL)) << 4);
 		flags = MAP_FIXED | MAP_PRIVATE;
-		vm_flags = VM_NONE | VM_DONTEXPAND | VM_DONTDUMP;
+		vm_flags = VM_DONTEXPAND | VM_DONTDUMP;
 
 		down_write(&current->mm->mmap_sem);
 		start = get_unmapped_area(NULL, start, PAGE_ALIGN(size), 0, flags);
diff --git a/fs/compat.c b/fs/compat.c
index 46a5d8b83745..8280c0f87c3a 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -829,6 +829,7 @@ struct compat_old_linux_dirent {
 struct compat_readdir_callback {
 	struct dir_context ctx;
 	struct compat_old_linux_dirent __user *dirent;
+	struct file * file;
 	int result;
 };
 
@@ -879,6 +884,7 @@ COMPAT_SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
@@ -898,6 +904,7 @@ struct compat_getdents_callback {
 	struct dir_context ctx;
 	struct compat_linux_dirent __user *current_dir;
 	struct compat_linux_dirent __user *previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -967,6 +978,7 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -987,6 +999,7 @@ struct compat_getdents_callback64 {
 	struct dir_context ctx;
 	struct linux_dirent64 __user *current_dir;
 	struct linux_dirent64 __user *previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -1056,6 +1073,7 @@ COMPAT_SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
diff --git a/fs/dcache.c b/fs/dcache.c
index 85c5e4498635..2cdeaf6a1719 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -756,8 +756,6 @@ void dput(struct dentry *dentry)
 		return;
 
 repeat:
-	might_sleep();
-
 	rcu_read_lock();
 	if (likely(fast_dput(dentry))) {
 		rcu_read_unlock();
diff --git a/fs/exec.c b/fs/exec.c
index 12169f1226f8..4368e21d4d9d 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -67,7 +67,10 @@
 #include <linux/kdebug.h>
 #endif
 
+#include <trace/events/fs.h>
+
 #include <asm/uaccess.h>
+#include <asm/sections.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
 
@@ -93,6 +96,9 @@ int suid_dumpable = 0;
 static LIST_HEAD(formats);
 static DEFINE_RWLOCK(binfmt_lock);
 
+extern int gr_process_kernel_exec_ban(void);
+extern int gr_process_sugid_exec_ban(const struct linux_binprm *bprm);
+
 void __register_binfmt(struct linux_binfmt * fmt, int insert)
 {
 	BUG_ON(!fmt);
@@ -317,7 +334,7 @@ static int __bprm_mm_init(struct linux_binprm *bprm)
 
 #ifdef CONFIG_PAX_RANDUSTACK
 	if (randomize_va_space)
-		bprm->p ^= (pax_get_random_long() & ~15) & ~PAGE_MASK;
+		bprm->p ^= prandom_u32() & ~PAGE_MASK;
 #endif
 
 	return 0;
@@ -437,7 +454,7 @@ struct user_arg_ptr {
 	} ptr;
 };
 
-static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)
+const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)
 {
 	const char __user *native;
 
@@ -902,8 +920,10 @@ static struct file *do_open_execat(int fd, struct filename *name, int flags)
 	if (err)
 		goto exit;
 
-	if (name->name[0] != '\0')
+	if (name->name[0] != '\0') {
 		fsnotify_open(file);
+		trace_open_exec(name->name);
+	}
 
 out:
 	return file;
@@ -1721,6 +1774,11 @@ static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 	char *pathbuf = NULL;
 	struct linux_binprm *bprm;
 	struct file *file;
@@ -1809,26 +1874,72 @@ static int do_execveat_common(int fd, struct filename *filename,
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->signal->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	/* limit suid stack to 8MB
+	 * we saved the old limits above and will restore them if this exec fails
+	 */
+	if (((!uid_eq(bprm->cred->euid, current_euid())) || (!gid_eq(bprm->cred->egid, current_egid()))) &&
+	    (old_rlim[RLIMIT_STACK].rlim_cur > (8 * 1024 * 1024)))
+		current->signal->rlim[RLIMIT_STACK].rlim_cur = 8 * 1024 * 1024;
+#endif
+
+	if (gr_process_kernel_exec_ban() || gr_process_sugid_exec_ban(bprm)) {
+		retval = -EPERM;
+		goto out_fail;
+	}
+
+	if (!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out_fail;
+	}
+
+	if (gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out_fail;
+	}
+
+	retval = gr_set_proc_label(file->f_path.dentry, file->f_path.mnt,
+					bprm->unsafe);
+	if (retval < 0)
+		goto out_fail;
+
 	retval = copy_strings_kernel(1, &bprm->filename, bprm);
 	if (retval < 0)
-		goto out;
+		goto out_fail;
 
 	bprm->exec = bprm->p;
 	retval = copy_strings(bprm->envc, envp, bprm);
 	if (retval < 0)
-		goto out;
+		goto out_fail;
 
 	retval = copy_strings(bprm->argc, argv, bprm);
 	if (retval < 0)
-		goto out;
+		goto out_fail;
+
+	gr_log_chroot_exec(file->f_path.dentry, file->f_path.mnt);
+
+	gr_handle_exec_args(bprm, argv);
 
 	would_dump(bprm, bprm->file);
 
 	retval = exec_binprm(bprm);
 	if (retval < 0)
-		goto out;
+		goto out_fail;
+#ifdef CONFIG_GRKERNSEC
+	if (old_exec_file)
+		fput(old_exec_file);
+#endif
 
 	/* execve succeeded */
+
+	increment_exec_counter();
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	acct_update_integrals(current);
@@ -1840,6 +1951,14 @@ static int do_execveat_common(int fd, struct filename *filename,
 		put_files_struct(displaced);
 	return retval;
 
+out_fail:
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->signal->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
+
 out:
 	if (bprm->mm) {
 		acct_arg_size(bprm, 0);
@@ -2144,12 +2274,15 @@ void __used pax_track_stack(void)
 	if (sp < current->thread.lowest_stack &&
 	    sp >= (unsigned long)task_stack_page(current) + 2 * sizeof(unsigned long))
 		current->thread.lowest_stack = sp;
+	if (unlikely((sp & ~(THREAD_SIZE - 1)) < (THREAD_SIZE/16)))
+		BUG();
 }
 EXPORT_SYMBOL(pax_track_stack);
 #endif
 
 #ifdef CONFIG_PAX_SIZE_OVERFLOW
 static DEFINE_RATELIMIT_STATE(size_overflow_ratelimit, 15 * HZ, 3);
+extern bool pax_size_overflow_report_only;
 
 void __nocapture(1, 3, 4) __used report_size_overflow(const char *file, unsigned int line, const char *func, const char *ssa_name)
 {
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 350a2c8cfd28..9fb9bf7d2f96 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -103,6 +103,10 @@ void __f_setown(struct file *filp, struct pid *pid, enum pid_type type,
 		int force)
 {
 	security_file_set_fowner(filp);
+	if (gr_handle_chroot_fowner(pid, type))
+		return;
+	if (gr_check_protected_task_fowner(pid, type))
+		return;
 	f_modown(filp, pid, type, force);
 }
 EXPORT_SYMBOL(__f_setown);
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index fbb963244461..eaf1178d092d 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -1219,7 +1220,7 @@ static struct file_system_type hugetlbfs_fs_type = {
 	.kill_sb	= kill_litter_super,
 };
 
-static struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];
+struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];
 
 static int can_do_hugetlb_shm(void)
 {
diff --git a/fs/inode.c b/fs/inode.c
index 2d56f487c2a0..a112e53db224 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -855,6 +855,8 @@ unsigned int get_next_ino(void)
 	unsigned int *p = &get_cpu_var(last_ino);
 	unsigned int res = *p;
 
+start:
+
 #ifdef CONFIG_SMP
 	if (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {
 		static atomic_unchecked_t shared_last_ino;
@@ -864,10 +866,8 @@ unsigned int get_next_ino(void)
 	}
 #endif
 
-	res++;
-	/* get_next_ino should not provide a 0 inode number */
-	if (unlikely(!res))
-		res++;
+	if (unlikely(!++res))
+		goto start;	/* never zero */
 	*p = res;
 	put_cpu_var(last_ino);
 	return res;
diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c
index e2c01a951ab8..d21a2653f570 100644
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@ -1024,6 +1024,12 @@ static int kernfs_iop_mkdir(struct inode *dir, struct dentry *dentry,
 	ret = scops->mkdir(parent, dentry->d_name.name, mode);
 
 	kernfs_put_active(parent);
+
+	if (!ret) {
+		struct dentry *dentry_ret = kernfs_iop_lookup(dir, dentry, 0);
+		ret = PTR_ERR_OR_ZERO(dentry_ret);
+	}
+
 	return ret;
 }
 
diff --git a/fs/namei.c b/fs/namei.c
index cb3b5370ece0..32d72d14c9ad 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -565,6 +619,7 @@ static int __nd_alloc_stack(struct nameidata *nd)
 	}
 	memcpy(p, nd->internal, sizeof(nd->internal));
 	nd->stack = p;
+
 	return 0;
 }
 
@@ -1026,6 +1113,9 @@ const char *get_link(struct nameidata *nd)
 	if (unlikely(error))
 		return ERR_PTR(error);
 
+	if (gr_handle_follow_link(dentry, last->link.mnt))
+		return ERR_PTR(-EACCES);
+
 	nd->last_type = LAST_BIND;
 	res = inode->i_link;
 	if (!res) {
@@ -2272,6 +2383,14 @@ static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path
 	if (!err)
 		err = complete_walk(nd);
 
+	if (!err && !(nd->flags & LOOKUP_PARENT)) {
+		if (!gr_acl_handle_hidden_file(nd->path.dentry, nd->path.mnt))
+			err = -ENOENT;
+		if (!err)
+			err = gr_chroot_pathat(nd->dfd, nd->path.dentry,
+						nd->path.mnt, nd->flags);
+	}
+
 	if (!err && nd->flags & LOOKUP_DIRECTORY)
 		if (!d_can_lookup(nd->path.dentry))
 			err = -ENOTDIR;
@@ -2320,6 +2439,14 @@ static int path_parentat(struct nameidata *nd, unsigned flags,
 	err = link_path_walk(s, nd);
 	if (!err)
 		err = complete_walk(nd);
+
+	if (!err && gr_handle_nameidata_symlinkowner(nd, nd->inode))
+		err = -EACCES;
+
+	if (!err)
+		err = gr_chroot_pathat(nd->dfd, nd->path.dentry,
+					nd->path.mnt, nd->flags);
+
 	if (!err) {
 		*parent = nd->path;
 		nd->path.mnt = NULL;
@@ -2937,6 +3064,13 @@ static int may_open(struct path *path, int acc_mode, int flag)
 	if (flag & O_NOATIME && !inode_owner_or_capable(inode))
 		return -EPERM;
 
+	if (gr_handle_rofs_blockwrite(dentry, path->mnt, acc_mode))
+		return -EPERM;
+	if (gr_handle_rawio(inode))
+		return -EPERM;
+	if (!gr_acl_handle_open(dentry, path->mnt, acc_mode))
+		return -EACCES;
+
 	return 0;
 }
 
@@ -3176,6 +3310,20 @@ static int lookup_open(struct nameidata *nd, struct path *path,
 
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode && (open_flag & O_CREAT)) {
+		error = gr_chroot_pathat(nd->dfd, dentry, nd->path.mnt, nd->flags);
+		if (error)
+			goto out_dput;
+
+		if (gr_handle_nameidata_symlinkowner(nd, dir_inode)) {
+			error = -EACCES;
+			goto out_dput;
+		}
+
+		if (!gr_acl_handle_creat(dentry, dir, nd->path.mnt, op->open_flag, op->acc_mode, mode)) {
+			error = -EACCES;
+			goto out_dput;
+		}
+
 		*opened |= FILE_CREATED;
 		audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);
 		if (!dir_inode->i_op->create) {
@@ -3186,6 +3334,7 @@ static int lookup_open(struct nameidata *nd, struct path *path,
 						open_flag & O_EXCL);
 		if (error)
 			goto out_dput;
+		gr_handle_create(dentry, nd->path.mnt);
 		fsnotify_create(dir_inode, dentry);
 	}
 	if (unlikely(create_error) && !dentry->d_inode) {
@@ -3300,6 +3449,11 @@ static int do_last(struct nameidata *nd,
 		goto finish_open_created;
 	}
 
+	if (!gr_acl_handle_hidden_file(path.dentry, nd->path.mnt)) {
+		path_to_nameidata(&path, nd);
+		return -ENOENT;
+	}
+
 	/*
 	 * If atomic_open() acquired write access it is dropped now due to
 	 * possible mount and symlink following (this might be optimized away if
@@ -3319,6 +3473,13 @@ static int do_last(struct nameidata *nd,
 		return -ENOENT;
 	}
 
+	/* only check if O_CREAT is specified, all other checks need to go
+	   into may_open */
+	if (gr_handle_fifo(path.dentry, path.mnt, dir, open_flag, acc_mode)) {
+		path_to_nameidata(&path, nd);
+		return -EACCES;
+	}
+
 	/*
 	 * create/update audit record if it already exists.
 	 */
@@ -3347,6 +3508,21 @@ static int do_last(struct nameidata *nd,
 	error = complete_walk(nd);
 	if (error)
 		return error;
+
+	if (!gr_acl_handle_hidden_file(nd->path.dentry, nd->path.mnt)) {
+		error = -ENOENT;
+		goto out;
+	}
+
+	error = gr_chroot_pathat(nd->dfd, nd->path.dentry, nd->path.mnt, nd->flags);
+	if (error)
+		goto out;
+
+	if (gr_handle_nameidata_symlinkowner(nd, nd->inode)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	audit_inode(nd->name, nd->path.dentry, 0);
 	error = -EISDIR;
 	if ((open_flag & O_CREAT) && d_is_dir(nd->path.dentry))
@@ -3603,9 +3779,11 @@ static struct dentry *filename_create(int dfd, struct filename *name,
 		goto unlock;
 
 	error = -EEXIST;
-	if (d_is_positive(dentry))
+	if (d_is_positive(dentry)) {
+		if (!gr_acl_handle_hidden_file(dentry, path->mnt))
+			error = -ENOENT;
 		goto fail;
-
+	}
 	/*
 	 * Special case - lookup gave negative, but... we had foo/bar/
 	 * From the vfs_mknod() POV we just have a negative dentry -
@@ -3659,6 +3837,20 @@ inline struct dentry *user_path_create(int dfd, const char __user *pathname,
 }
 EXPORT_SYMBOL(user_path_create);
 
+static struct dentry *user_path_create_with_name(int dfd, const char __user *pathname, struct path *path, struct filename **to, unsigned int lookup_flags)
+{
+	struct filename *tmp = getname(pathname);
+	struct dentry *res;
+	if (IS_ERR(tmp))
+		return ERR_CAST(tmp);
+	res = kern_path_create(dfd, tmp->name, path, lookup_flags);
+	if (IS_ERR(res))
+		putname(tmp);
+	else
+		*to = tmp;
+	return res;
+}
+
 int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
 {
 	int error = may_create(dir, dentry);
@@ -3722,6 +3914,17 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
 
 	if (!IS_POSIXACL(path.dentry->d_inode))
 		mode &= ~current_umask();
+
+	if (gr_handle_chroot_mknod(dentry, path.mnt, mode)) {
+		error = -EPERM;
+		goto out;
+	}
+
+	if (!gr_acl_handle_mknod(dentry, path.dentry, path.mnt, mode)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	error = security_path_mknod(&path, dentry, mode, dev);
 	if (error)
 		goto out;
@@ -3739,6 +3942,8 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
 			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
+	if (!error)
+		gr_handle_create(dentry, path.mnt);
 out:
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
@@ -3793,9 +3998,16 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
 
 	if (!IS_POSIXACL(path.dentry->d_inode))
 		mode &= ~current_umask();
+	if (!gr_acl_handle_mkdir(dentry, path.dentry, path.mnt)) {
+		error = -EACCES;
+		goto out;
+	}
 	error = security_path_mkdir(&path, dentry, mode);
 	if (!error)
 		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
+	if (!error)
+		gr_handle_create(dentry, path.mnt);
+out:
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
 		lookup_flags |= LOOKUP_REVAL;
@@ -3856,6 +4068,8 @@ static long do_rmdir(int dfd, const char __user *pathname)
 	struct path path;
 	struct qstr last;
 	int type;
+	u64 saved_ino = 0;
+	dev_t saved_dev = 0;
 	unsigned int lookup_flags = 0;
 retry:
 	name = user_path_parent(dfd, pathname,
@@ -3888,10 +4102,20 @@ static long do_rmdir(int dfd, const char __user *pathname)
 		error = -ENOENT;
 		goto exit3;
 	}
+	saved_ino = gr_get_ino_from_dentry(dentry);
+	saved_dev = gr_get_dev_from_dentry(dentry);
+
+	if (!gr_acl_handle_rmdir(dentry, path.mnt)) {
+		error = -EACCES;
+		goto exit3;
+	}
+
 	error = security_path_rmdir(&path, dentry);
 	if (error)
 		goto exit3;
 	error = vfs_rmdir(path.dentry->d_inode, dentry);
+	if (!error && (saved_dev || saved_ino))
+		gr_handle_delete(saved_ino, saved_dev);
 exit3:
 	dput(dentry);
 exit2:
@@ -3986,6 +4210,8 @@ static long do_unlinkat(int dfd, const char __user *pathname)
 	int type;
 	struct inode *inode = NULL;
 	struct inode *delegated_inode = NULL;
+	u64 saved_ino = 0;
+	dev_t saved_dev = 0;
 	unsigned int lookup_flags = 0;
 retry:
 	name = user_path_parent(dfd, pathname,
@@ -4012,10 +4238,21 @@ static long do_unlinkat(int dfd, const char __user *pathname)
 		if (d_is_negative(dentry))
 			goto slashes;
 		ihold(inode);
+		if (inode->i_nlink <= 1) {
+			saved_ino = gr_get_ino_from_dentry(dentry);
+			saved_dev = gr_get_dev_from_dentry(dentry);
+		}
+		if (!gr_acl_handle_unlink(dentry, path.mnt)) {
+			error = -EACCES;
+			goto exit2;
+		}
+
 		error = security_path_unlink(&path, dentry);
 		if (error)
 			goto exit2;
 		error = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);
+		if (!error && (saved_ino || saved_dev))
+			gr_handle_delete(saved_ino, saved_dev);
 exit2:
 		dput(dentry);
 	}
@@ -4104,9 +4341,17 @@ SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
 	if (IS_ERR(dentry))
 		goto out_putname;
 
+	if (!gr_acl_handle_symlink(dentry, path.dentry, path.mnt, from)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	error = security_path_symlink(&path, dentry, from->name);
 	if (!error)
 		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
+	if (!error)
+		gr_handle_create(dentry, path.mnt);
+out:
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
 		lookup_flags |= LOOKUP_REVAL;
@@ -4217,6 +4462,7 @@ SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
 	struct dentry *new_dentry;
 	struct path old_path, new_path;
 	struct inode *delegated_inode = NULL;
+	struct filename *to = NULL;
 	int how = 0;
 	int error;
 
@@ -4240,7 +4486,7 @@ SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
 	if (error)
 		return error;
 
-	new_dentry = user_path_create(newdfd, newname, &new_path,
+	new_dentry = user_path_create_with_name(newdfd, newname, &new_path, &to,
 					(how & LOOKUP_REVAL));
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
@@ -4252,11 +4498,26 @@ SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
 	error = may_linkat(&old_path);
 	if (unlikely(error))
 		goto out_dput;
+
+	if (gr_handle_hardlink(old_path.dentry, old_path.mnt, to)) {
+		error = -EACCES;
+		goto out_dput;
+	}
+
+	if (!gr_acl_handle_link(new_dentry, new_path.dentry, new_path.mnt,
+				old_path.dentry, old_path.mnt, to)) {
+		error = -EACCES;
+		goto out_dput;
+	}
+
 	error = security_path_link(old_path.dentry, &new_path, new_dentry);
 	if (error)
 		goto out_dput;
 	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
+	if (!error)
+		gr_handle_create(new_dentry, new_path.mnt);
 out_dput:
+	putname(to);
 	done_path_create(&new_path, new_dentry);
 	if (delegated_inode) {
 		error = break_deleg_wait(&delegated_inode);
@@ -4566,6 +4827,20 @@ SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
 	if (new_dentry == trap)
 		goto exit5;
 
+	if (gr_bad_chroot_rename(old_dentry, old_path.mnt, new_dentry, new_path.mnt)) {
+		/* use EXDEV error to cause 'mv' to switch to an alternative
+		 * method for usability
+		 */
+		error = -EXDEV;
+		goto exit5;
+	}
+
+	error = gr_acl_handle_rename(new_dentry, new_path.dentry, new_path.mnt,
+				     old_dentry, d_backing_inode(old_path.dentry), old_path.mnt,
+				     to, flags);
+	if (error)
+		goto exit5;
+
 	error = security_path_rename(&old_path, old_dentry,
 				     &new_path, new_dentry, flags);
 	if (error)
@@ -4573,6 +4848,9 @@ SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
 	error = vfs_rename(old_path.dentry->d_inode, old_dentry,
 			   new_path.dentry->d_inode, new_dentry,
 			   &delegated_inode, flags);
+	if (!error)
+		gr_handle_rename(d_backing_inode(old_path.dentry), d_backing_inode(new_path.dentry), old_dentry,
+				 new_dentry, old_path.mnt, d_is_positive(new_dentry) ? 1 : 0, flags);
 exit5:
 	dput(new_dentry);
 exit4:
diff --git a/fs/namespace.c b/fs/namespace.c
index a1a42b87c0f5..ff2d4585d38a 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2796,6 +2802,16 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 		   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |
 		   MS_STRICTATIME | MS_NOREMOTELOCK | MS_SUBMOUNT);
 
+	if (gr_handle_rofs_mount(path.dentry, path.mnt, mnt_flags)) {
+		retval = -EPERM;
+		goto dput_out;
+	}
+
+	if (gr_handle_chroot_mount(path.dentry, path.mnt, dev_name)) {
+		retval = -EPERM;
+		goto dput_out;
+	}
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&path, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -3106,6 +3125,11 @@ SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,
 	if (error)
 		goto out2;
 
+	if (gr_handle_chroot_pivot()) {
+		error = -EPERM;
+		goto out2;
+	}
+
 	get_fs_root(current->fs, &root);
 	old_mp = lock_mount(&old);
 	error = PTR_ERR(old_mp);
diff --git a/fs/open.c b/fs/open.c
index d3ed8171e8e0..d6038021b72b 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -32,6 +32,8 @@
 #include <linux/dnotify.h>
 #include <linux/compat.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/fs.h>
 #include "internal.h"
 
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
@@ -446,6 +455,8 @@ SYSCALL_DEFINE1(chdir, const char __user *, filename)
 	if (error)
 		goto dput_and_out;
 
+	gr_log_chdir(path.dentry, path.mnt);
+
 	set_fs_pwd(current->fs, &path);
 
 dput_and_out:
@@ -475,6 +486,13 @@ SYSCALL_DEFINE1(fchdir, unsigned int, fd)
 		goto out_putf;
 
 	error = inode_permission(inode, MAY_EXEC | MAY_CHDIR);
+
+	if (!error && !gr_chroot_fchdir(f.file->f_path.dentry, f.file->f_path.mnt))
+		error = -EPERM;
+
+	if (!error)
+		gr_log_chdir(f.file->f_path.dentry, f.file->f_path.mnt);
+
 	if (!error)
 		set_fs_pwd(current->fs, &f.file->f_path);
 out_putf:
@@ -504,7 +522,13 @@ SYSCALL_DEFINE1(chroot, const char __user *, filename)
 	if (error)
 		goto dput_and_out;
 
+	if (gr_handle_chroot_chroot(path.dentry, path.mnt))
+		goto dput_and_out;
+
 	set_fs_root(current->fs, &path);
+
+	gr_handle_chroot_chdir(&path);
+
 	error = 0;
 dput_and_out:
 	path_put(&path);
@@ -528,6 +552,16 @@ static int chmod_common(const struct path *path, umode_t mode)
 		return error;
 retry_deleg:
 	inode_lock(inode);
+
+	if (!gr_acl_handle_chmod(path->dentry, path->mnt, &mode)) {
+		error = -EACCES;
+		goto out_unlock;
+	}
+	if (gr_handle_chroot_chmod(path->dentry, path->mnt, mode)) {
+		error = -EACCES;
+		goto out_unlock;
+	}
+
 	error = security_path_chmod(path, mode);
 	if (error)
 		goto out_unlock;
@@ -1057,6 +1094,7 @@ long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 		} else {
 			fsnotify_open(f);
 			fd_install(fd, f);
+			trace_do_sys_open(tmp->name, flags, mode);
 		}
 	}
 	putname(tmp);
diff --git a/fs/pipe.c b/fs/pipe.c
index 62af5deec3ef..50c72462b486 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -678,7 +678,7 @@ void free_pipe_info(struct pipe_inode_info *pipe)
 	kfree(pipe);
 }
 
-static struct vfsmount *pipe_mnt __read_mostly;
+struct vfsmount *pipe_mnt __read_mostly;
 
 /*
  * pipefs_dname() is called from d_path().
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 1dbfdcaa168c..aa676306b7f1 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -497,6 +515,19 @@ static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
 		gtime = task_gtime(task);
 	}
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (PAX_RAND_FLAGS(mm)) {
+		eip = 0;
+		esp = 0;
+		wchan = 0;
+	}
+#endif
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	wchan = 0;
+	eip =0;
+	esp =0;
+#endif
+
 	/* scale priority and nice values from timeslices to -20..20 */
 	/* to make it look like a "normal" Unix priority/nice value  */
 	priority = task_prio(task);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 4fb5a1bc4831..a4332371b62e 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -113,6 +113,14 @@ struct pid_entry {
 	union proc_op op;
 };
 
+struct getdents_callback {
+	struct linux_dirent __user * current_dir;
+	struct linux_dirent __user * previous;
+	struct file * file;
+	int count;
+	int error;
+};
+
 #define NOD(NAME, MODE, IOP, FOP, OP) {			\
 	.name = (NAME),					\
 	.len  = sizeof(NAME) - 1,			\
@@ -784,13 +834,24 @@ static const struct file_operations proc_single_file_operations = {
 };
 
 
-struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)
+struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode, u64 *ptracer_exec_id)
 {
 	struct task_struct *task = get_proc_task(inode);
 	struct mm_struct *mm = ERR_PTR(-ESRCH);
 
+	if (ptracer_exec_id)
+		*ptracer_exec_id = 0;
+
 	if (task) {
 		mm = mm_access(task, mode | PTRACE_MODE_FSCREDS);
+		if (!IS_ERR_OR_NULL(mm) && gr_acl_handle_procpidmem(task)) {
+			mmput(mm);
+			mm = ERR_PTR(-EPERM);
+		}
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+		if (ptracer_exec_id)
+			current_is_ptracer(task, ptracer_exec_id);
+#endif
 		put_task_struct(task);
 
 		if (!IS_ERR_OR_NULL(mm)) {
@@ -806,12 +867,17 @@ struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)
 
 static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)
 {
-	struct mm_struct *mm = proc_mem_open(inode, mode);
+	struct mm_struct *mm = proc_mem_open(inode, mode, NULL);
 
 	if (IS_ERR(mm))
 		return PTR_ERR(mm);
 
 	file->private_data = mm;
+
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	file->f_version = current->exec_id;
+#endif
+
 	return 0;
 }
 
@@ -834,6 +900,26 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 	char *page;
 	unsigned int flags;
 
+#ifdef CONFIG_GRKERNSEC
+	struct task_struct *task = get_proc_task(file_inode(file));
+	bool is_by_ptracer = false;
+
+	if (task) {
+		is_by_ptracer = current_is_ptracer(task, NULL);
+		put_task_struct(task);
+	}
+
+	if (write && !is_by_ptracer)
+		return -EPERM;
+
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (file->f_version != current->exec_id && !is_by_ptracer) {
+		gr_log_badprocpid("mem");
+		return 0;
+	}
+#endif
+#endif
+
 	if (!mm)
 		return 0;
 
@@ -2411,6 +2551,9 @@ static struct dentry *proc_pident_lookup(struct inode *dir,
 	if (!task)
 		goto out_no_task;
 
+	if (gr_pid_is_chrooted(task) || gr_check_hidden_task(task))
+		goto out;
+
 	/*
 	 * Yes, it does not scale. And it should not. Don't add
 	 * new entries into /proc/<tgid>/ without very good reasons.
@@ -2441,6 +2584,9 @@ static int proc_pident_readdir(struct file *file, struct dir_context *ctx,
 	if (!task)
 		return -ENOENT;
 
+	if (gr_pid_is_chrooted(task) || gr_check_hidden_task(task))
+		goto out;
+
 	if (!dir_emit_dots(file, ctx))
 		goto out;
 
@@ -2853,7 +2999,9 @@ static const struct inode_operations proc_task_inode_operations;
 static const struct pid_entry tgid_base_stuff[] = {
 	DIR("task",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),
 	DIR("fd",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),
+#ifndef CONFIG_GRKERNSEC
 	DIR("map_files",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),
+#endif
 	DIR("fdinfo",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),
 	DIR("ns",	  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),
 #ifdef CONFIG_NET
@@ -3104,7 +3262,11 @@ struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsign
 	if (!task)
 		goto out;
 
+	if (gr_pid_is_chrooted(task) || gr_check_hidden_task(task))
+		goto out_put_task;
+
 	result = proc_pid_instantiate(dir, dentry, task, NULL);
+out_put_task:
 	put_task_struct(task);
 out:
 	return ERR_PTR(result);
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 5f2dc2032c79..2ae27201c217 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -22,6 +22,7 @@
 #include <linux/bitops.h>
 #include <linux/spinlock.h>
 #include <linux/completion.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 
 #include "internal.h"
@@ -253,6 +254,15 @@ struct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,
 	return proc_lookup_de(PDE(dir), dir, dentry);
 }
 
+struct dentry *proc_lookup_restrict(struct inode *dir, struct dentry *dentry,
+		unsigned int flags)
+{
+	if (gr_proc_is_restricted())
+		return ERR_PTR(-EACCES);
+
+	return proc_lookup_de(PDE(dir), dir, dentry);
+}
+
 /*
  * This returns non-zero if at EOF, so that the /proc
  * root directory can use this and check if it should
@@ -310,6 +320,16 @@ int proc_readdir(struct file *file, struct dir_context *ctx)
 	return proc_readdir_de(PDE(inode), file, ctx);
 }
 
+int proc_readdir_restrict(struct file *file, struct dir_context *ctx)
+{
+	struct inode *inode = file_inode(file);
+
+	if (gr_proc_is_restricted())
+		return -EACCES;
+
+	return proc_readdir_de(PDE(inode), file, ctx);
+}
+
 /*
  * These are the generic /proc directory operations. They
  * use the in-memory "struct proc_dir_entry" tree to parse
@@ -321,6 +341,12 @@ static const struct file_operations proc_dir_operations = {
 	.iterate_shared		= proc_readdir,
 };
 
+static const struct file_operations proc_dir_restricted_operations = {
+	.llseek			= generic_file_llseek,
+	.read			= generic_read_dir,
+	.iterate		= proc_readdir_restrict,
+};
+
 /*
  * proc directories can do almost nothing..
  */
@@ -330,6 +356,12 @@ static const struct inode_operations proc_dir_inode_operations = {
 	.setattr	= proc_notify_change,
 };
 
+static const struct inode_operations proc_dir_restricted_inode_operations = {
+	.lookup		= proc_lookup_restrict,
+	.getattr	= proc_getattr,
+	.setattr	= proc_notify_change,
+};
+
 static int proc_register(struct proc_dir_entry * dir, struct proc_dir_entry * dp)
 {
 	int ret;
@@ -447,6 +479,31 @@ struct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,
 }
 EXPORT_SYMBOL_GPL(proc_mkdir_data);
 
+struct proc_dir_entry *proc_mkdir_data_restrict(const char *name, umode_t mode,
+		struct proc_dir_entry *parent, void *data)
+{
+	struct proc_dir_entry *ent;
+
+	if (mode == 0)
+		mode = S_IRUGO | S_IXUGO;
+
+	ent = __proc_create(&parent, name, S_IFDIR | mode, 2);
+	if (ent) {
+		ent->data = data;
+		ent->restricted = 1;
+		ent->proc_fops = &proc_dir_restricted_operations;
+		ent->proc_iops = &proc_dir_restricted_inode_operations;
+		parent->nlink++;
+		if (proc_register(parent, ent) < 0) {
+			kfree(ent);
+			parent->nlink--;
+			ent = NULL;
+		}
+	}
+	return ent;
+}
+EXPORT_SYMBOL_GPL(proc_mkdir_data_restrict);
+
 struct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,
 				       struct proc_dir_entry *parent)
 {
@@ -461,6 +518,13 @@ struct proc_dir_entry *proc_mkdir(const char *name,
 }
 EXPORT_SYMBOL(proc_mkdir);
 
+struct proc_dir_entry *proc_mkdir_restrict(const char *name,
+		struct proc_dir_entry *parent)
+{
+	return proc_mkdir_data_restrict(name, 0, parent, NULL);
+}
+EXPORT_SYMBOL(proc_mkdir_restrict);
+
 struct proc_dir_entry *proc_create_mount_point(const char *name)
 {
 	umode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;
diff --git a/fs/proc/inode.c b/fs/proc/inode.c
index e69ebe648a34..8a28d63a5304 100644
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@ -23,11 +23,17 @@
 #include <linux/slab.h>
 #include <linux/mount.h>
 #include <linux/magic.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
 #include "internal.h"
 
+#ifdef CONFIG_PROC_SYSCTL
+extern const struct inode_operations proc_sys_inode_operations;
+extern const struct inode_operations proc_sys_dir_operations;
+#endif
+
 static void proc_evict_inode(struct inode *inode)
 {
 	struct proc_dir_entry *de;
@@ -48,6 +54,13 @@ static void proc_evict_inode(struct inode *inode)
 		RCU_INIT_POINTER(PROC_I(inode)->sysctl, NULL);
 		sysctl_head_put(head);
 	}
+
+#ifdef CONFIG_PROC_SYSCTL
+	if (inode->i_op == &proc_sys_inode_operations ||
+	    inode->i_op == &proc_sys_dir_operations)
+		gr_handle_delete(inode->i_ino, inode->i_sb->s_dev);
+#endif
+
 }
 
 static struct kmem_cache * proc_inode_cachep;
@@ -430,7 +443,11 @@ struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+			inode->i_gid = grsec_proc_gid;
+#else
 			inode->i_gid = de->gid;
+#endif
 		}
 		if (de->size)
 			inode->i_size = de->size;
diff --git a/fs/proc/internal.h b/fs/proc/internal.h
index 5378441ec1b7..666c3505cfd2 100644
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@ -155,6 +156,10 @@ extern int proc_pid_status(struct seq_file *, struct pid_namespace *,
 			   struct pid *, struct task_struct *);
 extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,
 			  struct pid *, struct task_struct *);
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+extern int proc_pid_ipaddr(struct seq_file *, struct pid_namespace *,
+			  struct pid *, struct task_struct *);
+#endif
 
 /*
  * base.c
@@ -179,9 +184,11 @@ extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, i
  * generic.c
  */
 extern struct dentry *proc_lookup(struct inode *, struct dentry *, unsigned int);
+extern struct dentry *proc_lookup_restrict(struct inode *, struct dentry *, unsigned int);
 extern struct dentry *proc_lookup_de(struct proc_dir_entry *, struct inode *,
 				     struct dentry *);
 extern int proc_readdir(struct file *, struct dir_context *);
+extern int proc_readdir_restrict(struct file *, struct dir_context *);
 extern int proc_readdir_de(struct proc_dir_entry *, struct file *, struct dir_context *);
 
 static inline struct proc_dir_entry *pde_get(struct proc_dir_entry *pde)
@@ -286,9 +293,12 @@ struct proc_maps_private {
 #ifdef CONFIG_NUMA
 	struct mempolicy *task_mempolicy;
 #endif
-};
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	u64 ptracer_exec_id;
+#endif
+} __randomize_layout;
 
-struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode);
+struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode, u64 *ptracer_exec_id);
 
 extern const struct file_operations proc_pid_maps_operations;
 extern const struct file_operations proc_tid_maps_operations;
diff --git a/fs/proc/kcore.c b/fs/proc/kcore.c
index 535e0f7ec3f5..1749d06523e3 100644
--- a/fs/proc/kcore.c
+++ b/fs/proc/kcore.c
@@ -544,6 +544,9 @@ read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)
 
 static int open_kcore(struct inode *inode, struct file *filp)
 {
+#if defined(CONFIG_GRKERNSEC_PROC_ADD) || defined(CONFIG_GRKERNSEC_HIDESYM)
+	return -EPERM;
+#endif
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
diff --git a/fs/proc/proc_net.c b/fs/proc/proc_net.c
index 777fe92a70e9..cf23c946e2d1 100644
--- a/fs/proc/proc_net.c
+++ b/fs/proc/proc_net.c
@@ -24,9 +24,27 @@
 #include <linux/uidgid.h>
 #include <net/net_namespace.h>
 #include <linux/seq_file.h>
+#include <linux/grsecurity.h>
 
 #include "internal.h"
 
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+static struct seq_operations *ipv6_seq_ops_addr;
+
+void register_ipv6_seq_ops_addr(struct seq_operations *addr)
+{
+	ipv6_seq_ops_addr = addr;
+}
+
+void unregister_ipv6_seq_ops_addr(void)
+{
+	ipv6_seq_ops_addr = NULL;
+}
+
+EXPORT_SYMBOL_GPL(register_ipv6_seq_ops_addr);
+EXPORT_SYMBOL_GPL(unregister_ipv6_seq_ops_addr);
+#endif
+
 static inline struct net *PDE_NET(struct proc_dir_entry *pde)
 {
 	return pde->parent->data;
@@ -37,6 +55,8 @@ static struct net *get_proc_net(const struct inode *inode)
 	return maybe_get_net(PDE_NET(PDE(inode)));
 }
 
+extern const struct seq_operations dev_seq_ops;
+
 int seq_open_net(struct inode *ino, struct file *f,
 		 const struct seq_operations *ops, int size)
 {
@@ -45,6 +65,14 @@ int seq_open_net(struct inode *ino, struct file *f,
 
 	BUG_ON(size < sizeof(*p));
 
+	/* only permit access to /proc/net/dev */
+	if (
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	    ops != ipv6_seq_ops_addr && 
+#endif
+	    ops != &dev_seq_ops && gr_proc_is_restricted())
+		return -EACCES;
+
 	net = get_proc_net(ino);
 	if (net == NULL)
 		return -ENXIO;
@@ -67,6 +95,9 @@ int single_open_net(struct inode *inode, struct file *file,
 	int err;
 	struct net *net;
 
+	if (gr_proc_is_restricted())
+		return -EACCES;
+
 	err = -ENXIO;
 	net = get_proc_net(inode);
 	if (net == NULL)
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index df6a359455a1..5a409fc17907 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -11,13 +11,21 @@
 #include <linux/namei.h>
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/nsproxy.h>
+#ifdef CONFIG_GRKERNSEC
+#include <net/net_namespace.h>
+#endif
 #include "internal.h"
 
+extern int gr_handle_chroot_sysctl(const int op);
+extern int gr_handle_sysctl_mod(const char *dirname, const char *name,
+				const int op);
+
 static const struct dentry_operations proc_sys_dentry_operations;
 static const struct file_operations proc_sys_file_operations;
-static const struct inode_operations proc_sys_inode_operations;
+const struct inode_operations proc_sys_inode_operations;
 static const struct file_operations proc_sys_dir_file_operations;
-static const struct inode_operations proc_sys_dir_operations;
+const struct inode_operations proc_sys_dir_operations;
 
 /* Support for permanently empty directories */
 
@@ -513,6 +521,9 @@ static struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,
 
 	err = NULL;
 	d_set_d_op(dentry, &proc_sys_dentry_operations);
+
+	gr_handle_proc_create(dentry, inode);
+
 	d_add(dentry, inode);
 
 out:
@@ -528,6 +539,7 @@ static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,
 	struct inode *inode = file_inode(filp);
 	struct ctl_table_header *head = grab_header(inode);
 	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
+	int op = write ? MAY_WRITE : MAY_READ;
 	ssize_t error;
 	size_t res;
 
@@ -539,7 +551,7 @@ static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,
 	 * and won't be until we finish.
 	 */
 	error = -EPERM;
-	if (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))
+	if (sysctl_perm(head, table, op))
 		goto out;
 
 	/* if that can happen at all, it should be -EINVAL, not -EISDIR */
@@ -547,6 +559,27 @@ static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,
 	if (!table->proc_handler)
 		goto out;
 
+#ifdef CONFIG_GRKERNSEC
+	error = -EPERM;
+	if (gr_handle_chroot_sysctl(op))
+		goto out;
+	dget(filp->f_path.dentry);
+	if (gr_handle_sysctl_mod((const char *)filp->f_path.dentry->d_parent->d_name.name, table->procname, op)) {
+		dput(filp->f_path.dentry);
+		goto out;
+	}
+	dput(filp->f_path.dentry);
+	if (!gr_acl_handle_open(filp->f_path.dentry, filp->f_path.mnt, op))
+		goto out;
+	if (write) {
+		if (current->nsproxy->net_ns != table->extra2) {
+			if (!capable(CAP_SYS_ADMIN))
+				goto out;
+		} else if (!ns_capable(current->nsproxy->net_ns->user_ns, CAP_NET_ADMIN))
+			goto out;
+	}
+#endif
+
 	/* careful: calling conventions are nasty here */
 	res = count;
 	error = table->proc_handler(table, write, buf, &res, ppos);
@@ -648,6 +681,7 @@ static bool proc_sys_fill_cache(struct file *file,
 				return false;
 			}
 			d_set_d_op(child, &proc_sys_dentry_operations);
+			gr_handle_proc_create(child, inode);
 			d_add(child, inode);
 		}
 	}
@@ -688,6 +722,9 @@ static int scan(struct ctl_table_header *head, struct ctl_table *table,
 	if ((*pos)++ < ctx->pos)
 		return true;
 
+	if (!gr_acl_handle_hidden_file(file->f_path.dentry, file->f_path.mnt))
+		return 0;
+
 	if (unlikely(S_ISLNK(table->mode)))
 		res = proc_sys_link_fill_cache(file, ctx, head, table);
 	else
@@ -782,6 +819,9 @@ static int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct
 	if (IS_ERR(head))
 		return PTR_ERR(head);
 
+	if (table && !gr_acl_handle_hidden_file(dentry, mnt))
+		return -ENOENT;
+
 	generic_fillattr(inode, stat);
 	if (table)
 		stat->mode = (stat->mode & S_IFMT) | table->mode;
@@ -804,13 +844,13 @@ static const struct file_operations proc_sys_dir_file_operations = {
 	.llseek		= generic_file_llseek,
 };
 
-static const struct inode_operations proc_sys_inode_operations = {
+const struct inode_operations proc_sys_inode_operations = {
 	.permission	= proc_sys_permission,
 	.setattr	= proc_sys_setattr,
 	.getattr	= proc_sys_getattr,
 };
 
-static const struct inode_operations proc_sys_dir_operations = {
+const struct inode_operations proc_sys_dir_operations = {
 	.lookup		= proc_sys_lookup,
 	.permission	= proc_sys_permission,
 	.setattr	= proc_sys_setattr,
diff --git a/fs/proc/root.c b/fs/proc/root.c
index 8d3e484055a6..5fc5ce2693e2 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -143,7 +143,15 @@ void __init proc_root_init(void)
 	proc_create_mount_point("openprom");
 #endif
 	proc_tty_init();
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_mkdir_mode("bus", S_IRUSR | S_IXUSR, NULL);
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	proc_mkdir_mode("bus", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+#endif
+#else
 	proc_mkdir("bus", NULL);
+#endif
 	proc_sys_init();
 }
 
diff --git a/fs/proc/stat.c b/fs/proc/stat.c
index d700c42b3572..f711c8623acc 100644
--- a/fs/proc/stat.c
+++ b/fs/proc/stat.c
@@ -11,6 +11,7 @@
 #include <linux/irqnr.h>
 #include <linux/cputime.h>
 #include <linux/tick.h>
+#include <linux/grsecurity.h>
 
 #ifndef arch_irq_stat_cpu
 #define arch_irq_stat_cpu(cpu) 0
@@ -86,6 +87,18 @@ static int show_stat(struct seq_file *p, void *v)
 	u64 sum_softirq = 0;
 	unsigned int per_softirq_sums[NR_SOFTIRQS] = {0};
 	struct timespec64 boottime;
+	int unrestricted = 1;
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+		&& !in_group_p(grsec_proc_gid)
+#endif
+	)
+		unrestricted = 0;
+#endif
+#endif
 
 	user = nice = system = idle = iowait =
 		irq = softirq = steal = 0;
@@ -97,23 +110,25 @@ static int show_stat(struct seq_file *p, void *v)
 		nice += kcpustat_cpu(i).cpustat[CPUTIME_NICE];
 		system += kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];
 		idle += get_idle_time(i);
-		iowait += get_iowait_time(i);
-		irq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];
-		softirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];
-		steal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];
-		guest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];
-		guest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];
-		sum += kstat_cpu_irqs_sum(i);
-		sum += arch_irq_stat_cpu(i);
-
-		for (j = 0; j < NR_SOFTIRQS; j++) {
-			unsigned int softirq_stat = kstat_softirqs_cpu(j, i);
-
-			per_softirq_sums[j] += softirq_stat;
-			sum_softirq += softirq_stat;
+		if (unrestricted) {
+			iowait += get_iowait_time(i);
+			irq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];
+			softirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];
+			steal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];
+			guest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];
+			guest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];
+			sum += kstat_cpu_irqs_sum(i);
+			sum += arch_irq_stat_cpu(i);
+			for (j = 0; j < NR_SOFTIRQS; j++) {
+				unsigned int softirq_stat = kstat_softirqs_cpu(j, i);
+
+				per_softirq_sums[j] += softirq_stat;
+				sum_softirq += softirq_stat;
+			}
 		}
 	}
-	sum += arch_irq_stat();
+	if (unrestricted)
+		sum += arch_irq_stat();
 
 	seq_put_decimal_ull(p, "cpu  ", cputime64_to_clock_t(user));
 	seq_put_decimal_ull(p, " ", cputime64_to_clock_t(nice));
@@ -133,12 +148,14 @@ static int show_stat(struct seq_file *p, void *v)
 		nice = kcpustat_cpu(i).cpustat[CPUTIME_NICE];
 		system = kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];
 		idle = get_idle_time(i);
-		iowait = get_iowait_time(i);
-		irq = kcpustat_cpu(i).cpustat[CPUTIME_IRQ];
-		softirq = kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];
-		steal = kcpustat_cpu(i).cpustat[CPUTIME_STEAL];
-		guest = kcpustat_cpu(i).cpustat[CPUTIME_GUEST];
-		guest_nice = kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];
+		if (unrestricted) {
+			iowait = get_iowait_time(i);
+			irq = kcpustat_cpu(i).cpustat[CPUTIME_IRQ];
+			softirq = kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];
+			steal = kcpustat_cpu(i).cpustat[CPUTIME_STEAL];
+			guest = kcpustat_cpu(i).cpustat[CPUTIME_GUEST];
+			guest_nice = kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];
+		}
 		seq_printf(p, "cpu%d", i);
 		seq_put_decimal_ull(p, " ", cputime64_to_clock_t(user));
 		seq_put_decimal_ull(p, " ", cputime64_to_clock_t(nice));
@@ -156,7 +173,7 @@ static int show_stat(struct seq_file *p, void *v)
 
 	/* sum again ? it could be updated? */
 	for_each_irq_nr(j)
-		seq_put_decimal_ull(p, " ", kstat_irqs_usr(j));
+		seq_put_decimal_ull(p, " ", unrestricted ? kstat_irqs_usr(j) : 0ULL);
 
 	seq_printf(p,
 		"\nctxt %llu\n"
@@ -164,11 +181,11 @@ static int show_stat(struct seq_file *p, void *v)
 		"processes %lu\n"
 		"procs_running %lu\n"
 		"procs_blocked %lu\n",
-		nr_context_switches(),
+		unrestricted ? nr_context_switches() : 0ULL,
 		(unsigned long long)boottime.tv_sec,
-		total_forks,
-		nr_running(),
-		nr_iowait());
+		unrestricted ? total_forks : 0UL,
+		unrestricted ? nr_running() : 0UL,
+		unrestricted ? nr_iowait() : 0UL);
 
 	seq_put_decimal_ull(p, "softirq ", (unsigned long long)sum_softirq);
 
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 01a4c701864d..b1aa8042308f 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -15,12 +15,19 @@
 #include <linux/mmu_notifier.h>
 #include <linux/page_idle.h>
 #include <linux/shmem_fs.h>
+#include <linux/grsecurity.h>
 
 #include <asm/elf.h>
 #include <asm/uaccess.h>
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+#define PAX_RAND_FLAGS(_mm) (_mm != NULL && _mm != current->mm && \
+			     (_mm->pax_flags & MF_PAX_RANDMMAP || \
+			      _mm->pax_flags & MF_PAX_SEGMEXEC))
+#endif
+
 void task_mem(struct seq_file *m, struct mm_struct *mm)
 {
 	unsigned long text, lib, swap, ptes, pmds, anon, file, shmem;
@@ -87,7 +94,13 @@ void task_mem(struct seq_file *m, struct mm_struct *mm)
 		swap << (PAGE_SHIFT-10)
 
 #ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
-		, mm->context.user_cs_base, mm->context.user_cs_limit
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+		, PAX_RAND_FLAGS(mm) ? 0 : mm->context.user_cs_base
+		, PAX_RAND_FLAGS(mm) ? 0 : mm->context.user_cs_limit
+#else
+		, mm->context.user_cs_base
+		, mm->context.user_cs_limit
+#endif
 #endif
 
 	);
@@ -243,7 +256,11 @@ static int proc_maps_open(struct inode *inode, struct file *file,
 		return -ENOMEM;
 
 	priv->inode = inode;
-	priv->mm = proc_mem_open(inode, PTRACE_MODE_READ);
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	priv->mm = proc_mem_open(inode, PTRACE_MODE_READ, &priv->ptracer_exec_id);
+#else
+	priv->mm = proc_mem_open(inode, PTRACE_MODE_READ, NULL);
+#endif
 	if (IS_ERR(priv->mm)) {
 		int err = PTR_ERR(priv->mm);
 
@@ -290,7 +307,7 @@ static int is_stack(struct proc_maps_private *priv,
 }
 
 static void
-show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
+show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid, bool restrict)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct file *file = vma->vm_file;
@@ -309,26 +326,18 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
 	}
 
-	start = vma->vm_start;
-	end = vma->vm_end;
+	start = restrict ? 0UL : vma->vm_start;
+	end = restrict ? 0UL : vma->vm_end;
 
 	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu ",
 			start,
 			end,
-
-#if 0
-			flags & VM_MAYREAD ? flags & VM_READ ? 'R' : '+' : flags & VM_READ ? 'r' : '-',
-			flags & VM_MAYWRITE ? flags & VM_WRITE ? 'W' : '+' : flags & VM_WRITE ? 'w' : '-',
-			flags & VM_MAYEXEC ? flags & VM_EXEC ? 'X' : '+' : flags & VM_EXEC ? 'x' : '-',
-#else
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
-#endif
-
 			flags & VM_MAYSHARE ? 's' : 'p',
-			pgoff,
+			restrict ? 0UL : pgoff,
 			MAJOR(dev), MINOR(dev), ino);
 
 	/*
@@ -374,7 +383,20 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 
 static int show_map(struct seq_file *m, void *v, int is_pid)
 {
-	show_map_vma(m, v, is_pid);
+	bool restrict = false;
+
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	struct vm_area_struct *vma = (struct vm_area_struct *)v;
+	struct proc_maps_private *priv = m->private;
+	restrict = current->exec_id != priv->ptracer_exec_id;
+	if (current->exec_id != m->exec_id && restrict) {
+		gr_log_badprocpid("maps");
+		return 0;
+	}
+	if (restrict)
+		restrict = PAX_RAND_FLAGS(vma->vm_mm);
+#endif
+	show_map_vma(m, v, is_pid, restrict);
 	m_cache_vma(m, v);
 	return 0;
 }
@@ -746,7 +768,14 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 		.mm = vma->vm_mm,
 		.private = &mss,
 	};
+	bool restrict = false;
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (current->exec_id != m->exec_id) {
+		gr_log_badprocpid("smaps");
+		return 0;
+	}
+#endif
 	memset(&mss, 0, sizeof mss);
 
 #ifdef CONFIG_SHMEM
@@ -773,10 +802,15 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 	}
 #endif
 
-	/* mmap_sem is held in m_start */
-	walk_page_vma(vma, &smaps_walk);
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (PAX_RAND_FLAGS(vma->vm_mm))
+		restrict = true;
+	else
+#endif
+		/* mmap_sem is held in m_start */
+		walk_page_vma(vma, &smaps_walk);
 
-	show_map_vma(m, vma, is_pid);
+	show_map_vma(m, vma, is_pid, restrict);
 
 	seq_printf(m,
 		   "Size:           %8lu kB\n"
@@ -797,7 +831,7 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 		   "KernelPageSize: %8lu kB\n"
 		   "MMUPageSize:    %8lu kB\n"
 		   "Locked:         %8lu kB\n",
-		   (vma->vm_end - vma->vm_start) >> 10,
+		   restrict ? 0UL : (vma->vm_end - vma->vm_start) >> 10,
 		   mss.resident >> 10,
 		   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),
 		   mss.shared_clean  >> 10,
@@ -1461,7 +1495,7 @@ static int pagemap_open(struct inode *inode, struct file *file)
 {
 	struct mm_struct *mm;
 
-	mm = proc_mem_open(inode, PTRACE_MODE_READ);
+	mm = proc_mem_open(inode, PTRACE_MODE_READ, NULL);
 	if (IS_ERR(mm))
 		return PTR_ERR(mm);
 	file->private_data = mm;
@@ -1664,6 +1698,13 @@ static int show_numa_map(struct seq_file *m, void *v, int is_pid)
 	char buffer[64];
 	int nid;
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (current->exec_id != m->exec_id) {
+		gr_log_badprocpid("numa_maps");
+		return 0;
+	}
+#endif
+
 	if (!mm)
 		return 0;
 
@@ -1678,7 +1719,11 @@ static int show_numa_map(struct seq_file *m, void *v, int is_pid)
 		mpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);
 	}
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	seq_printf(m, "%08lx %s", PAX_RAND_FLAGS(vma->vm_mm) ? 0UL : vma->vm_start, buffer);
+#else
 	seq_printf(m, "%08lx %s", vma->vm_start, buffer);
+#endif
 
 	if (file) {
 		seq_puts(m, " file=");
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index 58d11ecbd556..b6237abf7972 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -280,7 +280,7 @@ static int maps_open(struct inode *inode, struct file *file,
 		return -ENOMEM;
 
 	priv->inode = inode;
-	priv->mm = proc_mem_open(inode, PTRACE_MODE_READ);
+	priv->mm = proc_mem_open(inode, PTRACE_MODE_READ, NULL);
 	if (IS_ERR(priv->mm)) {
 		int err = PTR_ERR(priv->mm);
 
diff --git a/fs/readdir.c b/fs/readdir.c
index 89998ea6b53f..da1afd12ced6 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -18,6 +18,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
+#include <linux/namei.h>
 
 #include <asm/uaccess.h>
 
@@ -84,6 +85,7 @@ struct old_linux_dirent {
 struct readdir_callback {
 	struct dir_context ctx;
 	struct old_linux_dirent __user * dirent;
+	struct file * file;
 	int result;
 };
 
@@ -102,6 +104,10 @@ static int fillonedir(struct dir_context *ctx, const char *name, int namlen,
 		buf->result = -EOVERFLOW;
 		return -EOVERFLOW;
 	}
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	buf->result++;
 	dirent = buf->dirent;
 	if (!access_ok(VERIFY_WRITE, dirent,
@@ -133,6 +139,7 @@ SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
@@ -158,6 +165,7 @@ struct getdents_callback {
 	struct dir_context ctx;
 	struct linux_dirent __user * current_dir;
 	struct linux_dirent __user * previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -180,6 +188,10 @@ static int filldir(struct dir_context *ctx, const char *name, int namlen,
 		buf->error = -EOVERFLOW;
 		return -EOVERFLOW;
 	}
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (signal_pending(current))
@@ -227,6 +239,7 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -245,6 +258,7 @@ struct getdents_callback64 {
 	struct dir_context ctx;
 	struct linux_dirent64 __user * current_dir;
 	struct linux_dirent64 __user * previous;
+	struct file *file;
 	int count;
 	int error;
 };
@@ -261,6 +275,10 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (signal_pending(current))
@@ -310,6 +328,7 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+	buf.file = f.file;
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index aca73dd73906..e3c558d1b78c 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -724,18 +724,18 @@ static void errcatch_print_vi(struct virtual_item *vi)
 }
 
 static struct item_operations errcatch_ops = {
-	errcatch_bytes_number,
-	errcatch_decrement_key,
-	errcatch_is_left_mergeable,
-	errcatch_print_item,
-	errcatch_check_item,
-
-	errcatch_create_vi,
-	errcatch_check_left,
-	errcatch_check_right,
-	errcatch_part_size,
-	errcatch_unit_num,
-	errcatch_print_vi
+	.bytes_number = errcatch_bytes_number,
+	.decrement_key = errcatch_decrement_key,
+	.is_left_mergeable = errcatch_is_left_mergeable,
+	.print_item = errcatch_print_item,
+	.check_item = errcatch_check_item,
+
+	.create_vi = errcatch_create_vi,
+	.check_left = errcatch_check_left,
+	.check_right = errcatch_check_right,
+	.part_size = errcatch_part_size,
+	.unit_num = errcatch_unit_num,
+	.print_vi = errcatch_print_vi
 };
 
 #if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)
diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c
index 0a6ad4e71e88..fbaf9b4cd281 100644
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@ -1887,6 +1887,10 @@ static int reiserfs_fill_super(struct super_block *s, void *data, int silent)
 	sbi->s_mount_opt |= (1 << REISERFS_SMALLTAIL);
 	sbi->s_mount_opt |= (1 << REISERFS_ERROR_RO);
 	sbi->s_mount_opt |= (1 << REISERFS_BARRIER_FLUSH);
+#ifdef CONFIG_REISERFS_FS_XATTR
+	/* turn on user xattrs by default */
+	sbi->s_mount_opt |= (1 << REISERFS_XATTRS_USER);
+#endif
 	/* no preallocation minimum, be smart in reiserfs_file_write instead */
 	sbi->s_alloc_options.preallocmin = 0;
 	/* Preallocate by 16 blocks (17-1) at once */
diff --git a/fs/select.c b/fs/select.c
index b9ed87b5f7cc..98af55774ced 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -20,6 +20,7 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
+#include <linux/security.h>
 #include <linux/personality.h> /* for STICKY_TIMEOUTS */
 #include <linux/file.h>
 #include <linux/fdtable.h>
@@ -894,6 +895,7 @@ int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,
  	struct poll_list *walk = head;
  	unsigned long todo = nfds;
 
+	gr_learn_resource(current, RLIMIT_NOFILE, nfds, 1);
 	if (nfds > rlimit(RLIMIT_NOFILE))
 		return -EINVAL;
 
diff --git a/fs/seq_file.c b/fs/seq_file.c
index 6cd7726dbbdf..5b43f3778284 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -14,6 +14,8 @@
 #include <linux/mm.h>
 #include <linux/printk.h>
 #include <linux/string_helpers.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -26,7 +28,7 @@ static void seq_set_overflow(struct seq_file *m)
 static void *seq_buf_alloc(unsigned long size)
 {
 	void *buf;
-	gfp_t gfp = GFP_KERNEL;
+	gfp_t gfp = GFP_KERNEL | GFP_USERCOPY;
 
 	/*
 	 * For high order allocations, use __GFP_NORETRY to avoid oom-killing -
@@ -38,7 +40,7 @@ static void *seq_buf_alloc(unsigned long size)
 		gfp |= __GFP_NORETRY | __GFP_NOWARN;
 	buf = kmalloc(size, gfp);
 	if (!buf && size > PAGE_SIZE)
-		buf = vmalloc(size);
+		buf = vmalloc_usercopy(size);
 	return buf;
 }
 
@@ -77,6 +79,10 @@ int seq_open(struct file *file, const struct seq_operations *op)
 	// to the lifetime of the file.
 	p->file = file;
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	p->exec_id = current->exec_id;
+#endif
+
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be
 	 * aware of this. If they set f_version themselves, they
@@ -98,6 +104,16 @@ int seq_open(struct file *file, const struct seq_operations *op)
 }
 EXPORT_SYMBOL(seq_open);
 
+
+int seq_open_restrict(struct file *file, const struct seq_operations *op)
+{
+	if (gr_proc_is_restricted())
+		return -EACCES;
+
+	return seq_open(file, op);
+}
+EXPORT_SYMBOL(seq_open_restrict);
+
 static int traverse(struct seq_file *m, loff_t offset)
 {
 	loff_t pos = 0, index;
@@ -602,6 +618,17 @@ int single_open_size(struct file *file, int (*show)(struct seq_file *, void *),
 }
 EXPORT_SYMBOL(single_open_size);
 
+int single_open_restrict(struct file *file, int (*show)(struct seq_file *, void *),
+		void *data)
+{
+	if (gr_proc_is_restricted())
+		return -EACCES;
+
+	return single_open(file, show, data);
+}
+EXPORT_SYMBOL(single_open_restrict);
+
+
 int single_release(struct inode *inode, struct file *file)
 {
 	const struct seq_operations *op = ((struct seq_file *)file->private_data)->op;
diff --git a/fs/stat.c b/fs/stat.c
index bc045c7994e1..68725c1426e1 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -28,8 +28,13 @@ void generic_fillattr(struct inode *inode, struct kstat *stat)
 	stat->gid = inode->i_gid;
 	stat->rdev = inode->i_rdev;
 	stat->size = i_size_read(inode);
-	stat->atime = inode->i_atime;
-	stat->mtime = inode->i_mtime;
+	if (is_sidechannel_device(inode) && !capable_nolog(CAP_MKNOD)) {
+		stat->atime = inode->i_ctime;
+		stat->mtime = inode->i_ctime;
+	} else {
+		stat->atime = inode->i_atime;
+		stat->mtime = inode->i_mtime;
+	}
 	stat->ctime = inode->i_ctime;
 	stat->blksize = (1 << inode->i_blkbits);
 	stat->blocks = inode->i_blocks;
@@ -52,9 +57,16 @@ EXPORT_SYMBOL(generic_fillattr);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat)
 {
 	struct inode *inode = d_backing_inode(path->dentry);
+	int retval;
 
-	if (inode->i_op->getattr)
-		return inode->i_op->getattr(path->mnt, path->dentry, stat);
+	if (inode->i_op->getattr) {
+		retval = inode->i_op->getattr(path->mnt, path->dentry, stat);
+		if (!retval && is_sidechannel_device(inode) && !capable_nolog(CAP_MKNOD)) {
+			stat->atime = stat->ctime;
+			stat->mtime = stat->ctime;
+		}
+		return retval;
+	}
 
 	generic_fillattr(inode, stat);
 	return 0;
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 2b67bda2021b..45acc9f129f1 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -33,6 +33,10 @@ void sysfs_warn_dup(struct kernfs_node *parent, const char *name)
 	kfree(buf);
 }
 
+#ifdef CONFIG_GRKERNSEC_SYSFS_RESTRICT
+extern int grsec_enable_sysfs_restrict;
+#endif
+
 /**
  * sysfs_create_dir_ns - create a directory for an object with a namespace tag
  * @kobj: object we're creating directory for
@@ -41,9 +45,16 @@ void sysfs_warn_dup(struct kernfs_node *parent, const char *name)
 int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 {
 	struct kernfs_node *parent, *kn;
+	const char *name;
+	umode_t mode = S_IRWXU | S_IRUGO | S_IXUGO;
+#ifdef CONFIG_GRKERNSEC_SYSFS_RESTRICT
+	const char *parent_name;
+#endif
 
 	BUG_ON(!kobj);
 
+	name = kobject_name(kobj);
+
 	if (kobj->parent)
 		parent = kobj->parent->sd;
 	else
@@ -52,11 +63,24 @@ int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 	if (!parent)
 		return -ENOENT;
 
-	kn = kernfs_create_dir_ns(parent, kobject_name(kobj),
-				  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns);
+#ifdef CONFIG_GRKERNSEC_SYSFS_RESTRICT
+	parent_name = parent->name;
+	mode = S_IRWXU;
+
+	if ((!strcmp(parent_name, "") && (!strcmp(name, "devices") || !strcmp(name, "fs"))) ||
+	    (!strcmp(parent_name, "devices") && !strcmp(name, "system")) ||
+	    (!strcmp(parent_name, "fs") && (!strcmp(name, "selinux") || !strcmp(name, "fuse") || !strcmp(name, "ecryptfs"))) ||
+	    (!strcmp(parent_name, "system") && !strcmp(name, "cpu")))
+		mode = S_IRWXU | S_IRUGO | S_IXUGO;
+	if (!grsec_enable_sysfs_restrict)
+		mode = S_IRWXU | S_IRUGO | S_IXUGO;
+#endif
+
+	kn = kernfs_create_dir_ns(parent, name,
+				  mode, kobj, ns);
 	if (IS_ERR(kn)) {
 		if (PTR_ERR(kn) == -EEXIST)
-			sysfs_warn_dup(parent, kobject_name(kobj));
+			sysfs_warn_dup(parent, name);
 		return PTR_ERR(kn);
 	}
 
diff --git a/fs/utimes.c b/fs/utimes.c
index 22307cdf7014..87b5f8665805 100644
--- a/fs/utimes.c
+++ b/fs/utimes.c
@@ -1,6 +1,7 @@
 #include <linux/compiler.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/security.h>
 #include <linux/linkage.h>
 #include <linux/mount.h>
 #include <linux/namei.h>
@@ -90,6 +91,12 @@ static int utimes_common(struct path *path, struct timespec *times)
 		newattrs.ia_valid |= ATTR_TOUCH;
 	}
 retry_deleg:
+
+	if (!gr_acl_handle_utime(path->dentry, path->mnt)) {
+		error = -EACCES;
+		goto mnt_drop_write_and_out;
+	}
+
 	inode_lock(inode);
 	error = notify_change(path->dentry, &newattrs, &delegated_inode);
 	inode_unlock(inode);
@@ -99,6 +106,7 @@ static int utimes_common(struct path *path, struct timespec *times)
 			goto retry_deleg;
 	}
 
+mnt_drop_write_and_out:
 	mnt_drop_write(path->mnt);
 out:
 	return error;
diff --git a/fs/xattr.c b/fs/xattr.c
index 9126b1baef65..c9348e414867 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -428,7 +428,7 @@ EXPORT_SYMBOL_GPL(vfs_removexattr);
  * Extended attribute SET operations
  */
 static long
-setxattr(struct dentry *d, const char __user *name, const void __user *value,
+setxattr(struct path *path, const char __user *name, const void __user *value,
 	 size_t size, int flags)
 {
 	int error;
@@ -462,7 +462,12 @@ setxattr(struct dentry *d, const char __user *name, const void __user *value,
 			posix_acl_fix_xattr_from_user(kvalue, size);
 	}
 
-	error = vfs_setxattr(d, kname, kvalue, size, flags);
+	if (!gr_acl_handle_setxattr(path->dentry, path->mnt)) {
+		error = -EACCES;
+		goto out;
+	}
+
+	error = vfs_setxattr(path->dentry, kname, kvalue, size, flags);
 out:
 	kvfree(kvalue);
 
@@ -481,7 +486,7 @@ static int path_setxattr(const char __user *pathname,
 		return error;
 	error = mnt_want_write(path.mnt);
 	if (!error) {
-		error = setxattr(path.dentry, name, value, size, flags);
+		error = setxattr(&path, name, value, size, flags);
 		mnt_drop_write(path.mnt);
 	}
 	path_put(&path);
@@ -517,7 +522,7 @@ SYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,
 	audit_file(f.file);
 	error = mnt_want_write_file(f.file);
 	if (!error) {
-		error = setxattr(f.file->f_path.dentry, name, value, size, flags);
+		error = setxattr(&f.file->f_path, name, value, size, flags);
 		mnt_drop_write_file(f.file);
 	}
 	fdput(f);
@@ -697,7 +702,7 @@ SYSCALL_DEFINE3(flistxattr, int, fd, char __user *, list, size_t, size)
  * Extended attribute REMOVE operations
  */
 static long
-removexattr(struct dentry *d, const char __user *name)
+removexattr(struct path *path, const char __user *name)
 {
 	int error;
 	char kname[XATTR_NAME_MAX + 1];
@@ -708,7 +713,10 @@ removexattr(struct dentry *d, const char __user *name)
 	if (error < 0)
 		return error;
 
-	return vfs_removexattr(d, kname);
+	if (!gr_acl_handle_removexattr(path->dentry, path->mnt))
+		return -EACCES;
+
+	return vfs_removexattr(path->dentry, kname);
 }
 
 static int path_removexattr(const char __user *pathname,
@@ -722,7 +730,7 @@ static int path_removexattr(const char __user *pathname,
 		return error;
 	error = mnt_want_write(path.mnt);
 	if (!error) {
-		error = removexattr(path.dentry, name);
+		error = removexattr(&path, name);
 		mnt_drop_write(path.mnt);
 	}
 	path_put(&path);
@@ -748,14 +756,16 @@ SYSCALL_DEFINE2(lremovexattr, const char __user *, pathname,
 SYSCALL_DEFINE2(fremovexattr, int, fd, const char __user *, name)
 {
 	struct fd f = fdget(fd);
+	struct path *path;
 	int error = -EBADF;
 
 	if (!f.file)
 		return error;
+	path = &f.file->f_path;
 	audit_file(f.file);
 	error = mnt_want_write_file(f.file);
 	if (!error) {
-		error = removexattr(f.file->f_path.dentry, name);
+		error = removexattr(path, name);
 		mnt_drop_write_file(f.file);
 	}
 	fdput(f);
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 64ed756202de..7474a848b05e 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1659,6 +1659,12 @@ xfs_ioc_swapext(
 		goto out_put_tmp_file;
 	}
 
+	if (f.file->f_op != &xfs_file_operations ||
+	    tmp.file->f_op != &xfs_file_operations) {
+		error = -EINVAL;
+		goto out_put_tmp_file;
+	}
+
 	ip = XFS_I(file_inode(f.file));
 	tip = XFS_I(file_inode(tmp.file));
 
diff --git a/grsecurity/Kconfig b/grsecurity/Kconfig
new file mode 100644
index 000000000000..f1c1ee2847c7
--- /dev/null
+++ b/grsecurity/Kconfig
@@ -0,0 +1,1206 @@
+#
+# grecurity configuration
+#
+menu "Memory Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_KMEM
+	bool "Deny reading/writing to /dev/kmem, /dev/mem, and /dev/port"
+	default y if GRKERNSEC_CONFIG_AUTO
+	select STRICT_DEVMEM if (X86 || ARM || TILE || S390)
+	help
+	  If you say Y here, /dev/kmem and /dev/mem won't be allowed to
+	  be written to or read from to modify or leak the contents of the running
+	  kernel.  /dev/port will also not be allowed to be opened, writing to
+	  /dev/cpu/*/msr will be prevented, and support for kexec will be removed.
+	  If you have module support disabled, enabling this will close up several
+	  ways that are currently used to insert malicious code into the running
+	  kernel.
+
+	  Even with this feature enabled, we still highly recommend that
+	  you use the RBAC system, as it is still possible for an attacker to
+	  modify the running kernel through other more obscure methods.
+
+	  Enabling this feature will prevent the "cpupower" and "powertop" tools
+	  from working and excludes debugfs from being compiled into the kernel.
+
+	  It is highly recommended that you say Y here if you meet all the
+	  conditions above.
+
+config GRKERNSEC_VM86
+	bool "Restrict VM86 mode"
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_SERVER)
+	depends on X86_32
+
+	help
+	  If you say Y here, only processes with CAP_SYS_RAWIO will be able to
+	  make use of a special execution mode on 32bit x86 processors called
+	  Virtual 8086 (VM86) mode.  XFree86 may need vm86 mode for certain
+	  video cards and will still work with this option enabled.  The purpose
+	  of the option is to prevent exploitation of emulation errors in
+	  virtualization of vm86 mode like the one discovered in VMWare in 2009.
+	  Nearly all users should be able to enable this option.
+
+config GRKERNSEC_IO
+	bool "Disable privileged I/O"
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_SERVER)
+	depends on X86
+	select RTC_CLASS
+	select RTC_INTF_DEV
+	select RTC_DRV_CMOS
+
+	help
+	  If you say Y here, all ioperm and iopl calls will return an error.
+	  Ioperm and iopl can be used to modify the running kernel.
+	  Unfortunately, some programs need this access to operate properly,
+	  the most notable of which are XFree86 and hwclock.  hwclock can be
+	  remedied by having RTC support in the kernel, so real-time 
+	  clock support is enabled if this option is enabled, to ensure 
+	  that hwclock operates correctly.  If hwclock still does not work,
+	  either update udev or symlink /dev/rtc to /dev/rtc0.
+
+	  If you're using XFree86 or a version of Xorg from 2012 or earlier,
+	  you may not be able to boot into a graphical environment with this
+	  option enabled.  In this case, you should use the RBAC system instead.
+
+config GRKERNSEC_BPF_HARDEN
+	bool "Harden BPF interpreter"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  Unlike previous versions of grsecurity that hardened both the BPF
+	  interpreted code against corruption at rest as well as the JIT code
+	  against JIT-spray attacks and attacker-controlled immediate values
+	  for ROP, this feature will enforce disabling of the new eBPF JIT engine
+	  and will ensure the interpreted code is read-only at rest.  This feature
+	  may be removed at a later time when eBPF stabilizes to entirely revert
+	  back to the more secure pre-3.16 BPF interpreter/JIT.
+
+	  If you're using KERNEXEC, it's recommended that you enable this option
+	  to supplement the hardening of the kernel.
+  
+config GRKERNSEC_PERF_HARDEN
+	bool "Disable unprivileged PERF_EVENTS usage by default"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on PERF_EVENTS
+	help
+	  If you say Y here, the range of acceptable values for the
+	  /proc/sys/kernel/perf_event_paranoid sysctl will be expanded to allow and
+	  default to a new value: 3.  When the sysctl is set to this value, no
+	  unprivileged use of the PERF_EVENTS syscall interface will be permitted.
+
+	  Though PERF_EVENTS can be used legitimately for performance monitoring
+	  and low-level application profiling, it is forced on regardless of
+	  configuration, has been at fault for several vulnerabilities, and
+	  creates new opportunities for side channels and other information leaks.
+
+	  This feature puts PERF_EVENTS into a secure default state and permits
+	  the administrator to change out of it temporarily if unprivileged
+	  application profiling is needed.
+
+config GRKERNSEC_RAND_THREADSTACK
+	bool "Insert random gaps between thread stacks"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on PAX_RANDMMAP && !PPC
+	help
+	  If you say Y here, a random-sized gap will be enforced between allocated
+	  thread stacks.  Glibc's NPTL and other threading libraries that
+	  pass MAP_STACK to the kernel for thread stack allocation are supported.
+	  The implementation currently provides 8 bits of entropy for the gap.
+
+	  Many distributions do not compile threaded remote services with the
+	  -fstack-check argument to GCC, causing the variable-sized stack-based
+	  allocator, alloca(), to not probe the stack on allocation.  This
+	  permits an unbounded alloca() to skip over any guard page and potentially
+	  modify another thread's stack reliably.  An enforced random gap
+	  reduces the reliability of such an attack and increases the chance
+	  that such a read/write to another thread's stack instead lands in
+	  an unmapped area, causing a crash and triggering grsecurity's
+	  anti-bruteforcing logic.
+
+config GRKERNSEC_PROC_MEMMAP
+	bool "Harden ASLR against information leaks and entropy reduction"
+	default y if (GRKERNSEC_CONFIG_AUTO || PAX_NOEXEC || PAX_ASLR)
+	depends on PAX_NOEXEC || PAX_ASLR
+	help
+	  If you say Y here, the /proc/<pid>/maps and /proc/<pid>/stat files will
+	  give no information about the addresses of its mappings if
+	  PaX features that rely on random addresses are enabled on the task.
+	  In addition to sanitizing this information and disabling other
+	  dangerous sources of information, this option causes reads of sensitive
+	  /proc/<pid> entries where the file descriptor was opened in a different
+	  task than the one performing the read.  Such attempts are logged.
+	  This option also limits argv/env strings for suid/sgid binaries
+	  to 512KB to prevent a complete exhaustion of the stack entropy provided
+	  by ASLR.  Finally, it places an 8MB stack resource limit on suid/sgid
+	  binaries to prevent alternative mmap layouts from being abused.
+
+	  If you use PaX it is essential that you say Y here as it closes up
+	  several holes that make full ASLR useless locally.
+
+
+config GRKERNSEC_KSTACKOVERFLOW
+	bool "Prevent kernel stack overflows"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on X86_64
+	help
+	  If you say Y here, the kernel's process stacks will be allocated
+	  with vmalloc instead of the kernel's default allocator.  This
+	  introduces guard pages that in combination with the alloca checking
+	  of the STACKLEAK feature and removal of thread_info from the kernel
+	  stack prevents all forms of kernel process stack overflow abuse.
+          Note that this is different from kernel stack buffer overflows.
+
+config GRKERNSEC_BRUTE
+	bool "Deter exploit bruteforcing"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, attempts to bruteforce exploits against forking
+	  daemons such as apache or sshd, as well as against suid/sgid binaries
+	  will be deterred.  When a child of a forking daemon is killed by PaX
+	  or crashes due to an illegal instruction or other suspicious signal,
+	  the parent process will be delayed 30 seconds upon every subsequent
+	  fork until the administrator is able to assess the situation and
+	  restart the daemon.
+	  In the suid/sgid case, the attempt is logged, the user has all their
+	  existing instances of the suid/sgid binary terminated and will
+	  be unable to execute any suid/sgid binaries for 15 minutes.
+
+	  It is recommended that you also enable signal logging in the auditing
+	  section so that logs are generated when a process triggers a suspicious
+	  signal.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "deter_bruteforce" is created.
+
+config GRKERNSEC_MODHARDEN
+	bool "Harden module auto-loading"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on MODULES
+	help
+	  If you say Y here, module auto-loading in response to use of some
+	  feature implemented by an unloaded module will be restricted to
+	  root users.  Enabling this option helps defend against attacks 
+	  by unprivileged users who abuse the auto-loading behavior to 
+	  cause a vulnerable module to load that is then exploited.
+
+	  If this option prevents a legitimate use of auto-loading for a 
+	  non-root user, the administrator can execute modprobe manually 
+	  with the exact name of the module mentioned in the alert log.
+	  Alternatively, the administrator can add the module to the list
+	  of modules loaded at boot by modifying init scripts.
+
+	  Modification of init scripts will most likely be needed on 
+	  Ubuntu servers with encrypted home directory support enabled,
+	  as the first non-root user logging in will cause the ecb(aes),
+	  ecb(aes)-all, cbc(aes), and cbc(aes)-all  modules to be loaded.
+
+config GRKERNSEC_HIDESYM
+	bool "Hide kernel symbols"
+	default y if GRKERNSEC_CONFIG_AUTO
+	select PAX_USERCOPY
+	help
+	  If you say Y here, getting information on loaded modules, and
+	  displaying all kernel symbols through a syscall will be restricted
+	  to users with CAP_SYS_MODULE.  For software compatibility reasons,
+	  /proc/kallsyms will be restricted to the root user.  The RBAC
+	  system can hide that entry even from root.
+
+	  This option also prevents leaking of kernel addresses through
+	  several /proc entries.
+
+	  Note that this option is only effective provided the following
+	  conditions are met:
+	  1) The kernel using grsecurity is not precompiled by some distribution
+	  2) You have also enabled GRKERNSEC_DMESG
+	  3) You are using the RBAC system and hiding other files such as your
+	     kernel image and System.map.  Alternatively, enabling this option
+	     causes the permissions on /boot, /lib/modules, and the kernel
+	     source directory to change at compile time to prevent 
+	     reading by non-root users.
+	  If the above conditions are met, this option will aid in providing a
+	  useful protection against local kernel exploitation of overflows
+	  and arbitrary read/write vulnerabilities.
+
+	  It is highly recommended that you enable GRKERNSEC_PERF_HARDEN
+	  in addition to this feature.
+
+config GRKERNSEC_RANDSTRUCT
+	bool "Randomize layout of sensitive kernel structures"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GCC_PLUGINS
+	select GRKERNSEC_HIDESYM
+	select MODVERSIONS if MODULES
+	help
+	  If you say Y here, the layouts of a number of sensitive kernel
+	  structures (task, fs, cred, etc) and all structures composed entirely
+	  of function pointers (aka "ops" structs) will be randomized at compile-time.
+	  This can introduce the requirement of an additional infoleak
+	  vulnerability for exploits targeting these structure types.
+
+	  Enabling this feature will introduce some performance impact, slightly
+	  increase memory usage, and prevent the use of forensic tools like
+	  Volatility against the system (unless the kernel source tree isn't
+	  cleaned after kernel installation).
+
+	  The seed used for compilation is located at tools/gcc/randomize_layout_seed.h.
+	  It remains after a make clean to allow for external modules to be compiled
+	  with the existing seed and will be removed by a make mrproper or
+	  make distclean.
+
+          Note that the implementation requires gcc 4.6.4. or newer.  You may need
+	  to install the supporting headers explicitly in addition to the normal
+	  gcc package.
+
+config GRKERNSEC_RANDSTRUCT_PERFORMANCE
+	bool "Use cacheline-aware structure randomization"
+	depends on GRKERNSEC_RANDSTRUCT
+	default y if GRKERNSEC_CONFIG_PRIORITY_PERF
+	help
+	  If you say Y here, the RANDSTRUCT randomization will make a best effort
+	  at restricting randomization to cacheline-sized groups of elements.  It
+	  will further not randomize bitfields in structures.  This reduces the
+	  performance hit of RANDSTRUCT at the cost of weakened randomization.
+
+config GRKERNSEC_KERN_LOCKOUT
+	bool "Active kernel exploit response"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on X86 || ARM || PPC || SPARC
+	help
+	  If you say Y here, when a PaX alert is triggered due to suspicious
+	  activity in the kernel (from KERNEXEC/UDEREF/USERCOPY)
+	  or an OOPS occurs due to bad memory accesses, instead of just
+	  terminating the offending process (and potentially allowing
+	  a subsequent exploit from the same user), we will take one of two
+	  actions:
+	   If the user was root, we will panic the system
+	   If the user was non-root, we will log the attempt, terminate
+	   all processes owned by the user, then prevent them from creating
+	   any new processes until the system is restarted
+	  This deters repeated kernel exploitation/bruteforcing attempts
+	  and is useful for later forensics.
+
+config GRKERNSEC_OLD_ARM_USERLAND
+	bool "Old ARM userland compatibility"
+	depends on ARM && (CPU_V6 || CPU_V6K || CPU_V7)
+	help
+	  If you say Y here, stubs of executable code to perform such operations
+	  as "compare-exchange" will be placed at fixed locations in the ARM vector
+	  table.  This is unfortunately needed for old ARM userland meant to run
+	  across a wide range of processors.  Without this option enabled,
+	  the get_tls and data memory barrier stubs will be emulated by the kernel,
+	  which is enough for Linaro userlands or other userlands designed for v6
+	  and newer ARM CPUs.  It's recommended that you try without this option enabled
+	  first, and only enable it if your userland does not boot (it will likely fail
+	  at init time).
+
+endmenu
+menu "Role Based Access Control Options"
+depends on GRKERNSEC
+
+config GRKERNSEC_RBAC_DEBUG
+	bool
+
+config GRKERNSEC_NO_RBAC
+	bool "Disable RBAC system"
+	help
+	  If you say Y here, the /dev/grsec device will be removed from the kernel,
+	  preventing the RBAC system from being enabled.  You should only say Y
+	  here if you have no intention of using the RBAC system, so as to prevent
+	  an attacker with root access from misusing the RBAC system to hide files
+	  and processes when loadable module support and /dev/[k]mem have been
+	  locked down.
+
+config GRKERNSEC_ACL_HIDEKERN
+	bool "Hide kernel processes"
+	help
+	  If you say Y here, all kernel threads will be hidden to all
+	  processes but those whose subject has the "view hidden processes"
+	  flag.
+
+config GRKERNSEC_ACL_MAXTRIES
+	int "Maximum tries before password lockout"
+	default 3
+	help
+	  This option enforces the maximum number of times a user can attempt
+	  to authorize themselves with the grsecurity RBAC system before being
+	  denied the ability to attempt authorization again for a specified time.
+	  The lower the number, the harder it will be to brute-force a password.
+
+config GRKERNSEC_ACL_TIMEOUT
+	int "Time to wait after max password tries, in seconds"
+	default 30
+	help
+	  This option specifies the time the user must wait after attempting to
+	  authorize to the RBAC system with the maximum number of invalid
+	  passwords.  The higher the number, the harder it will be to brute-force
+	  a password.
+
+endmenu
+menu "Filesystem Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_PROC
+	bool "Proc restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, the permissions of the /proc filesystem
+	  will be altered to enhance system security and privacy.  You MUST
+  	  choose either a user only restriction or a user and group restriction.
+	  Depending upon the option you choose, you can either restrict users to
+	  see only the processes they themselves run, or choose a group that can
+	  view all processes and files normally restricted to root if you choose
+	  the "restrict to user only" option.  NOTE: If you're running identd or
+	  ntpd as a non-root user, you will have to run it as the group you
+	  specify here.
+
+config GRKERNSEC_PROC_USER
+	bool "Restrict /proc to user only"
+	depends on GRKERNSEC_PROC
+	help
+	  If you say Y here, non-root users will only be able to view their own
+	  processes, and restricts them from viewing network-related information,
+	  and viewing kernel symbol and module information.
+
+config GRKERNSEC_PROC_USERGROUP
+	bool "Allow special group"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_PROC && !GRKERNSEC_PROC_USER
+	help
+	  If you say Y here, you will be able to select a group that will be
+	  able to view all processes and network-related information.  If you've
+	  enabled GRKERNSEC_HIDESYM, kernel and symbol information may still
+	  remain hidden.  This option is useful if you want to run identd as
+	  a non-root user.  The group you select may also be chosen at boot time
+	  via "grsec_proc_gid=" on the kernel commandline.
+
+config GRKERNSEC_PROC_GID
+	int "GID for special group"
+	depends on GRKERNSEC_PROC_USERGROUP
+	default 1001
+
+config GRKERNSEC_PROC_ADD
+	bool "Additional restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_PROC_USER || GRKERNSEC_PROC_USERGROUP
+	help
+	  If you say Y here, additional restrictions will be placed on
+	  /proc that keep normal users from viewing device information and 
+	  slabinfo information that could be useful for exploits.
+
+config GRKERNSEC_LINK
+	bool "Linking restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, /tmp race exploits will be prevented, since users
+	  will no longer be able to follow symlinks owned by other users in
+	  world-writable +t directories (e.g. /tmp), unless the owner of the
+	  symlink is the owner of the directory. users will also not be
+	  able to hardlink to files they do not own.  If the sysctl option is
+	  enabled, a sysctl option with name "linking_restrictions" is created.
+
+config GRKERNSEC_SYMLINKOWN
+	bool "Kernel-enforced SymlinksIfOwnerMatch"
+	default y if GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_SERVER
+	help
+	  Apache's SymlinksIfOwnerMatch option has an inherent race condition
+	  that prevents it from being used as a security feature.  As Apache
+	  verifies the symlink by performing a stat() against the target of
+	  the symlink before it is followed, an attacker can setup a symlink
+	  to point to a same-owned file, then replace the symlink with one
+	  that targets another user's file just after Apache "validates" the
+	  symlink -- a classic TOCTOU race.  If you say Y here, a complete,
+	  race-free replacement for Apache's "SymlinksIfOwnerMatch" option
+	  will be in place for the group you specify. If the sysctl option
+	  is enabled, a sysctl option with name "enforce_symlinksifowner" is
+	  created.
+
+config GRKERNSEC_SYMLINKOWN_GID
+	int "GID for users with kernel-enforced SymlinksIfOwnerMatch"
+	depends on GRKERNSEC_SYMLINKOWN
+	default 1006
+	help
+	  Setting this GID determines what group kernel-enforced
+	  SymlinksIfOwnerMatch will be enabled for.  If the sysctl option
+	  is enabled, a sysctl option with name "symlinkown_gid" is created.
+
+config GRKERNSEC_FIFO
+	bool "FIFO restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, users will not be able to write to FIFOs they don't
+	  own in world-writable +t directories (e.g. /tmp), unless the owner of
+	  the FIFO is the same owner of the directory it's held in.  If the sysctl
+	  option is enabled, a sysctl option with name "fifo_restrictions" is
+	  created.
+
+config GRKERNSEC_SYSFS_RESTRICT
+	bool "Sysfs/debugfs restriction"
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_SERVER)
+	depends on SYSFS
+	help
+	  If you say Y here, sysfs (the pseudo-filesystem mounted at /sys) and
+	  any filesystem normally mounted under it (e.g. debugfs) will be
+	  mostly accessible only by root.  These filesystems generally provide access
+	  to hardware and debug information that isn't appropriate for unprivileged
+	  users of the system.  Sysfs and debugfs have also become a large source
+	  of new vulnerabilities, ranging from infoleaks to local compromise.
+	  There has been very little oversight with an eye toward security involved
+	  in adding new exporters of information to these filesystems, so their
+	  use is discouraged.
+	  For reasons of compatibility, a few directories have been whitelisted
+	  for access by non-root users:
+	  /sys/fs/selinux
+	  /sys/fs/fuse
+	  /sys/devices/system/cpu
+
+config GRKERNSEC_ROFS
+	bool "Runtime read-only mount protection"
+	depends on SYSCTL
+	help
+	  If you say Y here, a sysctl option with name "romount_protect" will
+	  be created.  By setting this option to 1 at runtime, filesystems
+	  will be protected in the following ways:
+	  * No new writable mounts will be allowed
+	  * Existing read-only mounts won't be able to be remounted read/write
+	  * Write operations will be denied on all block devices
+	  This option acts independently of grsec_lock: once it is set to 1,
+	  it cannot be turned off.  Therefore, please be mindful of the resulting
+	  behavior if this option is enabled in an init script on a read-only
+	  filesystem.
+	  Also be aware that as with other root-focused features, GRKERNSEC_KMEM
+	  and GRKERNSEC_IO should be enabled and module loading disabled via
+	  config or at runtime.
+	  This feature is mainly intended for secure embedded systems.
+	  
+
+config GRKERNSEC_DEVICE_SIDECHANNEL
+	bool "Eliminate stat/notify-based device sidechannels"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, timing analyses on block or character
+	  devices like /dev/ptmx using stat or inotify/dnotify/fanotify
+	  will be thwarted for unprivileged users.  If a process without
+	  CAP_MKNOD stats such a device, the last access and last modify times
+	  will match the device's create time.  No access or modify events
+	  will be triggered through inotify/dnotify/fanotify for such devices.
+	  This feature will prevent attacks that may at a minimum
+	  allow an attacker to determine the administrator's password length.
+
+config GRKERNSEC_CHROOT
+	bool "Chroot jail restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, you will be able to choose several options that will
+	  make breaking out of a chrooted jail much more difficult.  If you
+	  encounter no software incompatibilities with the following options, it
+	  is recommended that you enable each one.
+
+	  Note that the chroot restrictions are not intended to apply to "chroots"
+	  to directories that are simple bind mounts of the global root filesystem.
+	  For several other reasons, a user shouldn't expect any significant
+	  security by performing such a chroot.
+
+config GRKERNSEC_CHROOT_MOUNT
+	bool "Deny mounts"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  mount or remount filesystems.  If the sysctl option is enabled, a
+	  sysctl option with name "chroot_deny_mount" is created.
+
+config GRKERNSEC_CHROOT_DOUBLE
+	bool "Deny double-chroots"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to chroot
+	  again outside the chroot.  This is a widely used method of breaking
+	  out of a chroot jail and should not be allowed.  If the sysctl 
+	  option is enabled, a sysctl option with name 
+	  "chroot_deny_chroot" is created.
+
+config GRKERNSEC_CHROOT_PIVOT
+	bool "Deny pivot_root in chroot"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to use
+	  a function called pivot_root() that was introduced in Linux 2.3.41.  It
+	  works similar to chroot in that it changes the root filesystem.  This
+	  function could be misused in a chrooted process to attempt to break out
+	  of the chroot, and therefore should not be allowed.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_deny_pivot" is
+	  created.
+
+config GRKERNSEC_CHROOT_CHDIR
+	bool "Enforce chdir(\"/\") on all chroots"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, the current working directory of all newly-chrooted
+	  applications will be set to the the root directory of the chroot.
+	  The man page on chroot(2) states:
+	  Note that this call does not change  the  current  working
+	  directory,  so  that `.' can be outside the tree rooted at
+	  `/'.  In particular, the  super-user  can  escape  from  a
+	  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.
+
+	  It is recommended that you say Y here, since it's not known to break
+	  any software.  If the sysctl option is enabled, a sysctl option with
+	  name "chroot_enforce_chdir" is created.
+
+config GRKERNSEC_CHROOT_CHMOD
+	bool "Deny (f)chmod +s"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to chmod
+	  or fchmod files to make them have suid or sgid bits.  This protects
+	  against another published method of breaking a chroot.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+	  created.
+
+config GRKERNSEC_CHROOT_FCHDIR
+	bool "Deny fchdir and fhandle out of chroot"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, a well-known method of breaking chroots by fchdir'ing
+	  to a file descriptor of the chrooting process that points to a directory
+	  outside the filesystem will be stopped.  This option also prevents use of
+	  the recently-created syscall for opening files by a guessable "file handle"
+	  inside a chroot, as well as accessing relative paths outside of a
+	  directory passed in via file descriptor with openat and similar syscalls.
+	  If the sysctl option is enabled, a sysctl option with name "chroot_deny_fchdir"
+	  is created.
+
+config GRKERNSEC_CHROOT_MKNOD
+	bool "Deny mknod"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be allowed to
+	  mknod.  The problem with using mknod inside a chroot is that it
+	  would allow an attacker to create a device entry that is the same
+	  as one on the physical root of your system, which could range from
+	  anything from the console device to a device for your harddrive (which
+	  they could then use to wipe the drive or steal data).  It is recommended
+	  that you say Y here, unless you run into software incompatibilities.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_mknod" is created.
+
+config GRKERNSEC_CHROOT_SHMAT
+	bool "Deny shmat() out of chroot"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to attach
+	  to shared memory segments that were created outside of the chroot jail.
+	  It is recommended that you say Y here.  If the sysctl option is enabled,
+	  a sysctl option with name "chroot_deny_shmat" is created.
+
+config GRKERNSEC_CHROOT_UNIX
+	bool "Deny access to abstract AF_UNIX sockets out of chroot"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  connect to abstract (meaning not belonging to a filesystem) Unix
+	  domain sockets that were bound outside of a chroot.  It is recommended
+	  that you say Y here.  If the sysctl option is enabled, a sysctl option
+	  with name "chroot_deny_unix" is created.
+
+config GRKERNSEC_CHROOT_FINDTASK
+	bool "Protect outside processes"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  kill, send signals with fcntl, ptrace, capget, getpgid, setpgid, 
+	  getsid, or view any process outside of the chroot.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_findtask" is
+	  created.
+
+config GRKERNSEC_CHROOT_NICE
+	bool "Restrict priority changes"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to raise
+	  the priority of processes in the chroot, or alter the priority of
+	  processes outside the chroot.  This provides more security than simply
+	  removing CAP_SYS_NICE from the process' capability set.  If the
+	  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+	  is created.
+
+config GRKERNSEC_CHROOT_SYSCTL
+	bool "Deny sysctl writes"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, an attacker in a chroot will not be able to
+	  write to sysctl entries, either by sysctl(2) or through a /proc
+	  interface.  It is strongly recommended that you say Y here. If the
+	  sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_sysctl" is created.
+
+config GRKERNSEC_CHROOT_RENAME
+	bool "Deny bad renames"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, an attacker in a chroot will not be able to
+	  abuse the ability to create double chroots to break out of the
+	  chroot by exploiting a race condition between a rename of a directory
+	  within a chroot against an open of a symlink with relative path
+	  components.  This feature will likewise prevent an accomplice outside
+	  a chroot from enabling a user inside the chroot to break out and make
+	  use of their credentials on the global filesystem.  Enabling this
+	  feature is essential to prevent root users from breaking out of a
+	  chroot. If the sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_bad_rename" is created.
+
+config GRKERNSEC_CHROOT_CAPS
+	bool "Capability restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, the capabilities on all processes within a
+	  chroot jail will be lowered to stop module insertion, raw i/o,
+	  system and net admin tasks, rebooting the system, modifying immutable
+	  files, modifying IPC owned by another, and changing the system time.
+	  This is left an option because it can break some apps.  Disable this
+	  if your chrooted apps are having problems performing those kinds of
+	  tasks.  If the sysctl option is enabled, a sysctl option with
+	  name "chroot_caps" is created.
+
+config GRKERNSEC_CHROOT_INITRD
+	bool "Exempt initrd tasks from restrictions"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT && BLK_DEV_INITRD
+	help
+	  If you say Y here, tasks started prior to init will be exempted from
+	  grsecurity's chroot restrictions.  This option is mainly meant to
+	  resolve Plymouth's performing privileged operations unnecessarily
+	  in a chroot.
+
+endmenu
+menu "Kernel Auditing"
+depends on GRKERNSEC
+
+config GRKERNSEC_AUDIT_GROUP
+	bool "Single group for auditing"
+	help
+	  If you say Y here, the exec and chdir logging features will only operate
+	  on a group you specify.  This option is recommended if you only want to
+	  watch certain users instead of having a large amount of logs from the
+	  entire system.  If the sysctl option is enabled, a sysctl option with
+	  name "audit_group" is created.
+
+config GRKERNSEC_AUDIT_GID
+	int "GID for auditing"
+	depends on GRKERNSEC_AUDIT_GROUP
+	default 1007
+
+config GRKERNSEC_EXECLOG
+	bool "Exec logging"
+	help
+	  If you say Y here, all execve() calls will be logged (since the
+	  other exec*() calls are frontends to execve(), all execution
+	  will be logged).  Useful for shell-servers that like to keep track
+	  of their users.  If the sysctl option is enabled, a sysctl option with
+	  name "exec_logging" is created.
+	  WARNING: This option when enabled will produce a LOT of logs, especially
+	  on an active system.
+
+config GRKERNSEC_RESLOG
+	bool "Resource logging"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, all attempts to overstep resource limits will
+	  be logged with the resource name, the requested size, and the current
+	  limit.  It is highly recommended that you say Y here.  If the sysctl
+	  option is enabled, a sysctl option with name "resource_logging" is
+	  created.  If the RBAC system is enabled, the sysctl value is ignored.
+
+config GRKERNSEC_CHROOT_EXECLOG
+	bool "Log execs within chroot"
+	help
+	  If you say Y here, all executions inside a chroot jail will be logged
+	  to syslog.  This can cause a large amount of logs if certain
+	  applications (eg. djb's daemontools) are installed on the system, and
+	  is therefore left as an option.  If the sysctl option is enabled, a
+	  sysctl option with name "chroot_execlog" is created.
+
+config GRKERNSEC_AUDIT_PTRACE
+	bool "Ptrace logging"
+	help
+	  If you say Y here, all attempts to attach to a process via ptrace
+	  will be logged.  If the sysctl option is enabled, a sysctl option
+	  with name "audit_ptrace" is created.
+
+config GRKERNSEC_AUDIT_CHDIR
+	bool "Chdir logging"
+	help
+	  If you say Y here, all chdir() calls will be logged.  If the sysctl
+ 	  option is enabled, a sysctl option with name "audit_chdir" is created.
+
+config GRKERNSEC_AUDIT_MOUNT
+	bool "(Un)Mount logging"
+	help
+	  If you say Y here, all mounts and unmounts will be logged.  If the
+	  sysctl option is enabled, a sysctl option with name "audit_mount" is
+	  created.
+
+config GRKERNSEC_SIGNAL
+	bool "Signal logging"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, certain important signals will be logged, such as
+	  SIGSEGV, which will as a result inform you of when a error in a program
+	  occurred, which in some cases could mean a possible exploit attempt.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "signal_logging" is created.
+
+config GRKERNSEC_FORKFAIL
+	bool "Fork failure logging"
+	help
+	  If you say Y here, all failed fork() attempts will be logged.
+	  This could suggest a fork bomb, or someone attempting to overstep
+	  their process limit.  If the sysctl option is enabled, a sysctl option
+	  with name "forkfail_logging" is created.
+
+config GRKERNSEC_TIME
+	bool "Time change logging"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, any changes of the system clock will be logged.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "timechange_logging" is created.
+
+config GRKERNSEC_PROC_IPADDR
+	bool "/proc/<pid>/ipaddr support"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, a new entry will be added to each /proc/<pid>
+	  directory that contains the IP address of the person using the task.
+	  The IP is carried across local TCP and AF_UNIX stream sockets.
+	  This information can be useful for IDS/IPSes to perform remote response
+	  to a local attack.  The entry is readable by only the owner of the
+	  process (and root if he has CAP_DAC_OVERRIDE, which can be removed via
+	  the RBAC system), and thus does not create privacy concerns.
+
+config GRKERNSEC_RWXMAP_LOG
+	bool 'Denied RWX mmap/mprotect logging'
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on PAX_MPROTECT && !PAX_EMUPLT && !PAX_EMUSIGRT
+	help
+	  If you say Y here, calls to mmap() and mprotect() with explicit
+	  usage of PROT_WRITE and PROT_EXEC together will be logged when
+	  denied by the PAX_MPROTECT feature.  This feature will also
+	  log other problematic scenarios that can occur when PAX_MPROTECT
+	  is enabled on a binary, like textrels and PT_GNU_STACK.  If the 
+          sysctl option is enabled, a sysctl option with name "rwxmap_logging"
+	  is created.
+
+endmenu
+
+menu "Executable Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_DMESG
+	bool "Dmesg(8) restriction"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, non-root users will not be able to use dmesg(8)
+	  to view the contents of the kernel's circular log buffer.
+	  The kernel's log buffer often contains kernel addresses and other
+	  identifying information useful to an attacker in fingerprinting a
+	  system for a targeted exploit.
+	  If the sysctl option is enabled, a sysctl option with name "dmesg" is
+	  created.
+
+config GRKERNSEC_HARDEN_PTRACE
+	bool "Deter ptrace-based process snooping"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, TTY sniffers and other malicious monitoring
+	  programs implemented through ptrace will be defeated.  If you
+	  have been using the RBAC system, this option has already been
+	  enabled for several years for all users, with the ability to make
+	  fine-grained exceptions.
+
+	  This option only affects the ability of non-root users to ptrace
+	  processes that are not a descendent of the ptracing process.
+	  This means that strace ./binary and gdb ./binary will still work,
+	  but attaching to arbitrary processes will not.  If the sysctl
+	  option is enabled, a sysctl option with name "harden_ptrace" is
+	  created.
+
+config GRKERNSEC_PTRACE_READEXEC
+	bool "Require read access to ptrace sensitive binaries"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, unprivileged users will not be able to ptrace unreadable
+	  binaries.  This option is useful in environments that
+	  remove the read bits (e.g. file mode 4711) from suid binaries to
+	  prevent infoleaking of their contents.  This option adds
+	  consistency to the use of that file mode, as the binary could normally
+	  be read out when run without privileges while ptracing.
+
+	  If the sysctl option is enabled, a sysctl option with name "ptrace_readexec"
+	  is created.
+
+config GRKERNSEC_SETXID
+	bool "Enforce consistent multithreaded privileges"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on (X86 || SPARC64 || PPC || ARM || MIPS)
+	help
+	  If you say Y here, a change from a root uid to a non-root uid
+	  in a multithreaded application will cause the resulting uids,
+	  gids, supplementary groups, and capabilities in that thread
+	  to be propagated to the other threads of the process.  In most
+	  cases this is unnecessary, as glibc will emulate this behavior
+	  on behalf of the application.  Other libcs do not act in the
+	  same way, allowing the other threads of the process to continue
+	  running with root privileges.  If the sysctl option is enabled,
+	  a sysctl option with name "consistent_setxid" is created.
+
+config GRKERNSEC_HARDEN_IPC
+	bool "Disallow access to overly-permissive IPC objects"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on SYSVIPC
+	help
+	  If you say Y here, access to overly-permissive IPC objects (shared
+	  memory, message queues, and semaphores) will be denied for processes
+	  given the following criteria beyond normal permission checks:
+	  1) If the IPC object is world-accessible and the euid doesn't match
+	     that of the creator or current uid for the IPC object
+	  2) If the IPC object is group-accessible and the egid doesn't
+	     match that of the creator or current gid for the IPC object
+	  It's a common error to grant too much permission to these objects,
+	  with impact ranging from denial of service and information leaking to
+	  privilege escalation.  This feature was developed in response to
+	  research by Tim Brown:
+	  http://labs.portcullis.co.uk/whitepapers/memory-squatting-attacks-on-system-v-shared-memory/
+	  who found hundreds of such insecure usages.  Processes with
+	  CAP_IPC_OWNER are still permitted to access these IPC objects.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "harden_ipc" is created.
+
+config GRKERNSEC_HARDEN_TTY
+	bool "Disallow unprivileged use of command injection"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, the ability to use the TIOCSTI ioctl for
+	  terminal command injection will be denied for unprivileged users.
+	  There are very few legitimate uses for this functionality and it
+	  has made vulnerabilities in several 'su'-like programs possible in
+	  the past.  Even without these vulnerabilities, it provides an
+	  attacker with an easy mechanism to move laterally among other
+	  processes within the same user's compromised session.
+	  By default, Linux allows unprivileged use of command injection as
+	  long as the injection is being performed into the same tty session.
+	  This feature makes that case the same as attempting to inject into
+	  another session, making any TIOCSTI use require CAP_SYS_ADMIN.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "harden_tty" is created.
+
+config GRKERNSEC_TPE
+	bool "Trusted Path Execution (TPE)"
+	default y if GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_SERVER
+	help
+	  If you say Y here, you will be able to choose a gid to add to the
+	  supplementary groups of users you want to mark as "untrusted."
+	  These users will not be able to execute any files that are not in
+	  root-owned directories writable only by root.  If the sysctl option
+	  is enabled, a sysctl option with name "tpe" is created.
+
+config GRKERNSEC_TPE_ALL
+	bool "Partially restrict all non-root users"
+	depends on GRKERNSEC_TPE
+	help
+	  If you say Y here, all non-root users will be covered under
+	  a weaker TPE restriction.  This is separate from, and in addition to,
+	  the main TPE options that you have selected elsewhere.  Thus, if a
+	  "trusted" GID is chosen, this restriction applies to even that GID.
+	  Under this restriction, all non-root users will only be allowed to
+	  execute files in directories they own that are not group or
+	  world-writable, or in directories owned by root and writable only by
+	  root.  If the sysctl option is enabled, a sysctl option with name
+	  "tpe_restrict_all" is created.
+
+config GRKERNSEC_TPE_INVERT
+	bool "Invert GID option"
+	depends on GRKERNSEC_TPE
+	help
+	  If you say Y here, the group you specify in the TPE configuration will
+	  decide what group TPE restrictions will be *disabled* for.  This
+	  option is useful if you want TPE restrictions to be applied to most
+	  users on the system.  If the sysctl option is enabled, a sysctl option
+	  with name "tpe_invert" is created.  Unlike other sysctl options, this
+	  entry will default to on for backward-compatibility.
+
+config GRKERNSEC_TPE_GID
+	int
+	default GRKERNSEC_TPE_UNTRUSTED_GID if (GRKERNSEC_TPE && !GRKERNSEC_TPE_INVERT)
+	default GRKERNSEC_TPE_TRUSTED_GID if (GRKERNSEC_TPE && GRKERNSEC_TPE_INVERT)
+	
+config GRKERNSEC_TPE_UNTRUSTED_GID
+	int "GID for TPE-untrusted users"
+	depends on GRKERNSEC_TPE && !GRKERNSEC_TPE_INVERT
+	default 1005
+	help
+	  Setting this GID determines what group TPE restrictions will be
+	  *enabled* for.  If the sysctl option is enabled, a sysctl option
+	  with name "tpe_gid" is created.
+
+config GRKERNSEC_TPE_TRUSTED_GID
+	int "GID for TPE-trusted users"
+	depends on GRKERNSEC_TPE && GRKERNSEC_TPE_INVERT
+	default 1005
+	help
+	  Setting this GID determines what group TPE restrictions will be
+	  *disabled* for.  If the sysctl option is enabled, a sysctl option
+	  with name "tpe_gid" is created.
+
+endmenu
+menu "Network Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_BLACKHOLE
+	bool "TCP/UDP blackhole and LAST_ACK DoS prevention"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on NET
+	help
+	  If you say Y here, neither TCP resets nor ICMP
+	  destination-unreachable packets will be sent in response to packets
+	  sent to ports for which no associated listening process exists.
+	  It will also prevent the sending of ICMP protocol unreachable packets
+	  in response to packets with unknown protocols.
+	  This feature supports both IPV4 and IPV6 and exempts the 
+	  loopback interface from blackholing.  Enabling this feature 
+	  makes a host more resilient to DoS attacks and reduces network
+	  visibility against scanners.
+
+	  The blackhole feature as-implemented is equivalent to the FreeBSD
+	  blackhole feature, as it prevents RST responses to all packets, not
+	  just SYNs.  Under most application behavior this causes no
+	  problems, but applications (like haproxy) may not close certain
+	  connections in a way that cleanly terminates them on the remote
+	  end, leaving the remote host in LAST_ACK state.  Because of this
+	  side-effect and to prevent intentional LAST_ACK DoSes, this
+	  feature also adds automatic mitigation against such attacks.
+	  The mitigation drastically reduces the amount of time a socket
+	  can spend in LAST_ACK state.  If you're using haproxy and not
+	  all servers it connects to have this option enabled, consider
+	  disabling this feature on the haproxy host.
+
+	  If the sysctl option is enabled, two sysctl options with names
+	  "ip_blackhole" and "lastack_retries" will be created.
+	  While "ip_blackhole" takes the standard zero/non-zero on/off
+	  toggle, "lastack_retries" uses the same kinds of values as
+	  "tcp_retries1" and "tcp_retries2".  The default value of 4
+	  prevents a socket from lasting more than 45 seconds in LAST_ACK
+	  state.
+
+config GRKERNSEC_NO_SIMULT_CONNECT
+	bool "Disable TCP Simultaneous Connect"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on NET
+	help
+	  If you say Y here, a feature by Willy Tarreau will be enabled that
+	  removes a weakness in Linux's strict implementation of TCP that
+	  allows two clients to connect to each other without either entering
+	  a listening state.  The weakness allows an attacker to easily prevent
+	  a client from connecting to a known server provided the source port
+	  for the connection is guessed correctly.
+
+	  As the weakness could be used to prevent an antivirus or IPS from
+	  fetching updates, or prevent an SSL gateway from fetching a CRL,
+	  it should be eliminated by enabling this option.  Though Linux is
+	  one of few operating systems supporting simultaneous connect, it
+	  has no legitimate use in practice and is rarely supported by firewalls.
+	
+config GRKERNSEC_SOCKET
+	bool "Socket restrictions"
+	depends on NET
+	help
+	  If you say Y here, you will be able to choose from several options.
+	  If you assign a GID on your system and add it to the supplementary
+	  groups of users you want to restrict socket access to, this patch
+	  will perform up to three things, based on the option(s) you choose.
+
+config GRKERNSEC_SOCKET_ALL
+	bool "Deny any sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to connect to other hosts from your machine or run server
+	  applications from your machine.  If the sysctl option is enabled, a
+	  sysctl option with name "socket_all" is created.
+
+config GRKERNSEC_SOCKET_ALL_GID
+	int "GID to deny all sockets for"
+	depends on GRKERNSEC_SOCKET_ALL
+	default 1004
+	help
+	  Here you can choose the GID to disable socket access for. Remember to
+	  add the users you want socket access disabled for to the GID
+	  specified here.  If the sysctl option is enabled, a sysctl option
+	  with name "socket_all_gid" is created.
+
+config GRKERNSEC_SOCKET_CLIENT
+	bool "Deny client sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to connect to other hosts from your machine, but will be
+	  able to run servers.  If this option is enabled, all users in the group
+	  you specify will have to use passive mode when initiating ftp transfers
+	  from the shell on your machine.  If the sysctl option is enabled, a
+	  sysctl option with name "socket_client" is created.
+
+config GRKERNSEC_SOCKET_CLIENT_GID
+	int "GID to deny client sockets for"
+	depends on GRKERNSEC_SOCKET_CLIENT
+	default 1003
+	help
+	  Here you can choose the GID to disable client socket access for.
+	  Remember to add the users you want client socket access disabled for to
+	  the GID specified here.  If the sysctl option is enabled, a sysctl
+	  option with name "socket_client_gid" is created.
+
+config GRKERNSEC_SOCKET_SERVER
+	bool "Deny server sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to run server applications from your machine.  If the sysctl
+	  option is enabled, a sysctl option with name "socket_server" is created.
+
+config GRKERNSEC_SOCKET_SERVER_GID
+	int "GID to deny server sockets for"
+	depends on GRKERNSEC_SOCKET_SERVER
+	default 1002
+	help
+	  Here you can choose the GID to disable server socket access for.
+	  Remember to add the users you want server socket access disabled for to
+	  the GID specified here.  If the sysctl option is enabled, a sysctl
+	  option with name "socket_server_gid" is created.
+
+endmenu
+
+menu "Physical Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_DENYUSB
+	bool "Deny new USB connections after toggle"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on SYSCTL && USB_SUPPORT
+	help
+	  If you say Y here, a new sysctl option with name "deny_new_usb"
+	  will be created.  Setting its value to 1 will prevent any new
+	  USB devices from being recognized by the OS.  Any attempted USB
+	  device insertion will be logged.  This option is intended to be
+	  used against custom USB devices designed to exploit vulnerabilities
+	  in various USB device drivers.
+
+	  For greatest effectiveness, this sysctl should be set after any
+	  relevant init scripts.  This option is safe to enable in distros
+	  as each user can choose whether or not to toggle the sysctl.
+
+config GRKERNSEC_DENYUSB_FORCE
+	bool "Reject all USB devices not connected at boot"
+	select USB
+	depends on GRKERNSEC_DENYUSB
+	help
+	  If you say Y here, a variant of GRKERNSEC_DENYUSB will be enabled
+	  that doesn't involve a sysctl entry.  This option should only be
+	  enabled if you're sure you want to deny all new USB connections
+	  at runtime and don't want to modify init scripts.  This should not
+	  be enabled by distros.  It forces the core USB code to be built
+	  into the kernel image so that all devices connected at boot time
+	  can be recognized and new USB device connections can be prevented
+	  prior to init running.
+
+endmenu
+
+menu "Sysctl Support"
+depends on GRKERNSEC && SYSCTL
+
+config GRKERNSEC_SYSCTL
+	bool "Sysctl support"
+	default y if GRKERNSEC_CONFIG_AUTO
+	help
+	  If you say Y here, you will be able to change the options that
+	  grsecurity runs with at bootup, without having to recompile your
+	  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+	  to enable (1) or disable (0) various features.  All the sysctl entries
+	  are mutable until the "grsec_lock" entry is set to a non-zero value.
+	  All features enabled in the kernel configuration are disabled at boot
+	  if you do not say Y to the "Turn on features by default" option.
+	  All options should be set at startup, and the grsec_lock entry should
+	  be set to a non-zero value after all the options are set.
+	  *THIS IS EXTREMELY IMPORTANT*
+
+config GRKERNSEC_SYSCTL_DISTRO
+	bool "Extra sysctl support for distro makers (READ HELP)"
+	depends on GRKERNSEC_SYSCTL && GRKERNSEC_IO
+	help
+	  If you say Y here, additional sysctl options will be created
+	  for features that affect processes running as root.  Therefore,
+	  it is critical when using this option that the grsec_lock entry be
+	  enabled after boot.  Only distros with prebuilt kernel packages
+	  with this option enabled that can ensure grsec_lock is enabled
+	  after boot should use this option.
+	  *Failure to set grsec_lock after boot makes all grsec features
+	  this option covers useless*
+
+	  Currently this option creates the following sysctl entries:
+	  "Disable Privileged I/O": "disable_priv_io"	
+
+config GRKERNSEC_SYSCTL_ON
+	bool "Turn on features by default"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_SYSCTL
+	help
+	  If you say Y here, instead of having all features enabled in the
+	  kernel configuration disabled at boot time, the features will be
+	  enabled at boot time.  It is recommended you say Y here unless
+	  there is some reason you would want all sysctl-tunable features to
+	  be disabled by default.  As mentioned elsewhere, it is important
+	  to enable the grsec_lock entry once you have finished modifying
+	  the sysctl entries.
+
+endmenu
+menu "Logging Options"
+depends on GRKERNSEC
+
+config GRKERNSEC_FLOODTIME
+	int "Seconds in between log messages (minimum)"
+	default 10
+	help
+	  This option allows you to enforce the number of seconds between
+	  grsecurity log messages.  The default should be suitable for most
+	  people, however, if you choose to change it, choose a value small enough
+	  to allow informative logs to be produced, but large enough to
+	  prevent flooding.
+
+	  Setting both this value and GRKERNSEC_FLOODBURST to 0 will disable
+	  any rate limiting on grsecurity log messages.
+
+config GRKERNSEC_FLOODBURST
+	int "Number of messages in a burst (maximum)"
+	default 6
+	help
+	  This option allows you to choose the maximum number of messages allowed
+	  within the flood time interval you chose in a separate option.  The
+	  default should be suitable for most people, however if you find that
+	  many of your logs are being interpreted as flooding, you may want to
+	  raise this value.
+
+	  Setting both this value and GRKERNSEC_FLOODTIME to 0 will disable
+	  any rate limiting on grsecurity log messages.
+
+endmenu
diff --git a/grsecurity/Makefile b/grsecurity/Makefile
new file mode 100644
index 000000000000..e136e5fd7b5b
--- /dev/null
+++ b/grsecurity/Makefile
@@ -0,0 +1,54 @@
+# grsecurity - access control and security hardening for Linux
+# All code in this directory and various hooks located throughout the Linux kernel are
+# Copyright (C) 2001-2014 Bradley Spengler, Open Source Security, Inc.
+# http://www.grsecurity.net spender@grsecurity.net
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License version 2
+# as published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+KBUILD_CFLAGS += -Werror
+
+obj-y = grsec_chdir.o grsec_chroot.o grsec_exec.o grsec_fifo.o grsec_fork.o \
+	grsec_mount.o grsec_sig.o grsec_sysctl.o \
+	grsec_time.o grsec_tpe.o grsec_link.o grsec_pax.o grsec_ptrace.o \
+	grsec_usb.o grsec_ipc.o grsec_proc.o grsec_tty.o
+
+obj-$(CONFIG_GRKERNSEC) += grsec_init.o grsum.o gracl.o gracl_segv.o \
+	gracl_cap.o gracl_alloc.o gracl_shm.o grsec_mem.o gracl_fs.o \
+	gracl_learn.o grsec_log.o gracl_policy.o
+ifdef CONFIG_COMPAT
+obj-$(CONFIG_GRKERNSEC) += gracl_compat.o
+endif
+
+obj-$(CONFIG_GRKERNSEC_RESLOG) += gracl_res.o
+
+ifdef CONFIG_NET
+obj-y += grsec_sock.o
+obj-$(CONFIG_GRKERNSEC) += gracl_ip.o
+endif
+
+ifndef CONFIG_GRKERNSEC
+obj-y += grsec_disabled.o
+endif
+
+ifdef CONFIG_GRKERNSEC_HIDESYM
+extra-y := grsec_hidesym.o
+$(obj)/grsec_hidesym.o:
+	@-chmod -f 500 /boot
+	@-chmod -f 500 /lib/modules
+	@-chmod -f 500 /lib64/modules
+	@-chmod -f 500 /lib32/modules
+	@-chmod -f 700 .
+	@-chmod -f 700 $(objtree)
+	@echo '  grsec: protected kernel image paths'
+endif
diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
new file mode 100644
index 000000000000..fa03095d6b94
--- /dev/null
+++ b/grsecurity/gracl.c
@@ -0,0 +1,2773 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/tty.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/sysctl.h>
+#include <linux/netdevice.h>
+#include <linux/ptrace.h>
+#include <linux/gracl.h>
+#include <linux/gralloc.h>
+#include <linux/security.h>
+#include <linux/grinternal.h>
+#include <linux/pid_namespace.h>
+#include <linux/stop_machine.h>
+#include <linux/fdtable.h>
+#include <linux/percpu.h>
+#include <linux/hugetlb.h>
+#include <linux/posix-timers.h>
+#include <linux/prefetch.h>
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+#include <linux/magic.h>
+#include <linux/pagemap.h>
+#include "../fs/btrfs/async-thread.h"
+#include "../fs/btrfs/ctree.h"
+#include "../fs/btrfs/btrfs_inode.h"
+#endif
+#include "../fs/mount.h"
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+
+#define FOR_EACH_ROLE_START(role) \
+	role = running_polstate.role_list; \
+	while (role) {
+
+#define FOR_EACH_ROLE_END(role) \
+		role = role->prev; \
+	}
+
+extern struct path gr_real_root;
+
+static struct gr_policy_state running_polstate;
+struct gr_policy_state *polstate = &running_polstate;
+extern struct gr_alloc_state *current_alloc_state;
+
+extern char *gr_shared_page[4];
+DEFINE_RWLOCK(gr_inode_lock);
+
+static unsigned int gr_status __read_only = GR_STATUS_INIT;
+
+#ifdef CONFIG_NET
+extern struct vfsmount *sock_mnt;
+#endif
+
+extern struct vfsmount *pipe_mnt;
+extern struct vfsmount *shm_mnt;
+
+#ifdef CONFIG_HUGETLBFS
+extern struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];
+#endif
+
+extern u16 acl_sp_role_value;
+extern struct acl_object_label *fakefs_obj_rw;
+extern struct acl_object_label *fakefs_obj_rwx;
+
+int gr_acl_is_enabled(void)
+{
+	return (gr_status & GR_READY);
+}
+
+void gr_enable_rbac_system(void)
+{
+	pax_open_kernel();
+	gr_status |= GR_READY;
+	pax_close_kernel();
+}
+
+int gr_rbac_disable(void *unused)
+{
+	pax_open_kernel();
+	gr_status &= ~GR_READY;
+	pax_close_kernel();
+
+	return 0;
+}
+
+static inline dev_t __get_dev(const struct dentry *dentry)
+{
+	struct dentry *ldentry = d_backing_dentry((struct dentry *)dentry);
+
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+	if (ldentry->d_sb->s_magic == BTRFS_SUPER_MAGIC)
+		return BTRFS_I(d_inode(ldentry))->root->anon_dev;
+	else
+#endif
+		return d_inode(ldentry)->i_sb->s_dev;
+}
+
+static inline u64 __get_ino(const struct dentry *dentry)
+{
+	struct dentry *ldentry = d_backing_dentry((struct dentry *)dentry);
+
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+	if (ldentry->d_sb->s_magic == BTRFS_SUPER_MAGIC)
+		return btrfs_ino(d_inode(dentry));
+	else
+#endif
+		return d_inode(ldentry)->i_ino;
+}
+
+dev_t gr_get_dev_from_dentry(struct dentry *dentry)
+{
+	return __get_dev(dentry);
+}
+
+u64 gr_get_ino_from_dentry(struct dentry *dentry)
+{
+	return __get_ino(dentry);
+}
+
+static char gr_task_roletype_to_char(struct task_struct *task)
+{
+	switch (task->role->roletype &
+		(GR_ROLE_DEFAULT | GR_ROLE_USER | GR_ROLE_GROUP |
+		 GR_ROLE_SPECIAL)) {
+	case GR_ROLE_DEFAULT:
+		return 'D';
+	case GR_ROLE_USER:
+		return 'U';
+	case GR_ROLE_GROUP:
+		return 'G';
+	case GR_ROLE_SPECIAL:
+		return 'S';
+	}
+
+	return 'X';
+}
+
+char gr_roletype_to_char(void)
+{
+	return gr_task_roletype_to_char(current);
+}
+
+int
+gr_acl_tpe_check(void)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+	if (current->role->roletype & GR_ROLE_TPE)
+		return 1;
+	else
+		return 0;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (inode && (S_ISBLK(inode->i_mode) || (S_ISCHR(inode->i_mode) && imajor(inode) == RAW_MAJOR)) &&
+	    grsec_enable_chroot_caps && proc_is_chrooted(current) &&
+	    !capable(CAP_SYS_RAWIO))
+		return 1;
+#endif
+	return 0;
+}
+
+int
+gr_streq(const char *a, const char *b, const unsigned int lena, const unsigned int lenb)
+{
+	if (likely(lena != lenb))
+		return 0;
+
+	return !memcmp(a, b, lena);
+}
+
+static int prepend(char **buffer, int *buflen, const char *str, int namelen)
+{
+	*buflen -= namelen;
+	if (*buflen < 0)
+		return -ENAMETOOLONG;
+	*buffer -= namelen;
+	memcpy(*buffer, str, namelen);
+	return 0;
+}
+
+static int prepend_name(char **buffer, int *buflen, struct qstr *name)
+{
+	return prepend(buffer, buflen, (const char *)name->name, name->len);
+}
+
+static int prepend_path(const struct path *path, struct path *root,
+			char **buffer, int *buflen)
+{
+	struct dentry *dentry = path->dentry;
+	struct vfsmount *vfsmnt = path->mnt;
+	struct mount *mnt = real_mount(vfsmnt);
+	bool slash = false;
+	int error = 0;
+
+	while (dentry != root->dentry || vfsmnt != root->mnt) {
+		struct dentry * parent;
+
+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			/* Global root? */
+			if (!mnt_has_parent(mnt)) {
+				goto out;
+			}
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			vfsmnt = &mnt->mnt;
+			continue;
+		}
+		parent = dentry->d_parent;
+		prefetch(parent);
+		spin_lock(&dentry->d_lock);
+		error = prepend_name(buffer, buflen, &dentry->d_name);
+		spin_unlock(&dentry->d_lock);
+		if (!error)
+			error = prepend(buffer, buflen, "/", 1);
+		if (error)
+			break;
+
+		slash = true;
+		dentry = parent;
+	}
+
+out:
+	if (!error && !slash)
+		error = prepend(buffer, buflen, "/", 1);
+
+	return error;
+}
+
+/* this must be called with mount_lock and rename_lock held */
+
+static char *__our_d_path(const struct path *path, struct path *root,
+			char *buf, int buflen)
+{
+	char *res = buf + buflen;
+	int error;
+
+	prepend(&res, &buflen, "\0", 1);
+	error = prepend_path(path, root, &res, &buflen);
+	if (error)
+		return ERR_PTR(error);
+
+	return res;
+}
+
+static char *
+gen_full_path(struct path *path, struct path *root, char *buf, int buflen)
+{
+	char *retval;
+
+	retval = __our_d_path(path, root, buf, buflen);
+	if (unlikely(IS_ERR(retval)))
+		retval = strcpy(buf, "<path too long>");
+	else if (unlikely(retval[1] == '/' && retval[2] == '\0'))
+		retval[1] = '\0';
+
+	return retval;
+}
+
+static char *
+__d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+		char *buf, int buflen)
+{
+	struct path path;
+	char *res;
+
+	path.dentry = (struct dentry *)dentry;
+	path.mnt = (struct vfsmount *)vfsmnt;
+
+	/* we can use gr_real_root.dentry, gr_real_root.mnt, because this is only called
+	   by the RBAC system */
+	res = gen_full_path(&path, &gr_real_root, buf, buflen);
+
+	return res;
+}
+
+static char *
+d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+	    char *buf, int buflen)
+{
+	char *res;
+	struct path path;
+	struct path root;
+	struct task_struct *reaper = init_pid_ns.child_reaper;
+
+	path.dentry = (struct dentry *)dentry;
+	path.mnt = (struct vfsmount *)vfsmnt;
+
+	/* we can't use gr_real_root.dentry, gr_real_root.mnt, because they belong only to the RBAC system */
+	get_fs_root(reaper->fs, &root);
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+	res = gen_full_path(&path, &root, buf, buflen);
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+
+	path_put(&root);
+	return res;
+}
+
+char *
+gr_to_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	char *ret;
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+	ret = __d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0],smp_processor_id()),
+			     PAGE_SIZE);
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+	return ret;
+}
+
+static char *
+gr_to_proc_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	char *ret;
+	char *buf;
+	int buflen;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+	buf = per_cpu_ptr(gr_shared_page[0], smp_processor_id());
+	ret = __d_real_path(dentry, mnt, buf, PAGE_SIZE - 6);
+	buflen = (int)(ret - buf);
+	if (buflen >= 5)
+		prepend(&ret, &buflen, "/proc", 5);
+	else
+		ret = strcpy(buf, "<path too long>");
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+	return ret;
+}
+
+char *
+gr_to_filename_nolock(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return __d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0],smp_processor_id()),
+			     PAGE_SIZE);
+}
+
+char *
+gr_to_filename(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename1(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[1], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename2(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[2], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename3(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[3], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+__u32
+to_gr_audit(const __u32 reqmode)
+{
+	/* masks off auditable permission flags, then shifts them to create
+	   auditing flags, and adds the special case of append auditing if
+	   we're requesting write */
+	return (((reqmode & ~GR_AUDITS) << 10) | ((reqmode & GR_WRITE) ? GR_AUDIT_APPEND : 0));
+}
+
+struct acl_role_label *
+__lookup_acl_role_label(const struct gr_policy_state *state, const struct task_struct *task, const uid_t uid,
+		      const gid_t gid)
+{
+	unsigned int index = gr_rhash(uid, GR_ROLE_USER, state->acl_role_set.r_size);
+	struct acl_role_label *match;
+	struct role_allowed_ip *ipp;
+	unsigned int x;
+	u32 curr_ip = task->signal->saved_ip;
+
+	match = state->acl_role_set.r_hash[index];
+
+	while (match) {
+		if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_USER)) == (GR_ROLE_DOMAIN | GR_ROLE_USER)) {
+			for (x = 0; x < match->domain_child_num; x++) {
+				if (match->domain_children[x] == uid)
+					goto found;
+			}
+		} else if (match->uidgid == uid && match->roletype & GR_ROLE_USER)
+			break;
+		match = match->next;
+	}
+found:
+	if (match == NULL) {
+	      try_group:
+		index = gr_rhash(gid, GR_ROLE_GROUP, state->acl_role_set.r_size);
+		match = state->acl_role_set.r_hash[index];
+
+		while (match) {
+			if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) == (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) {
+				for (x = 0; x < match->domain_child_num; x++) {
+					if (match->domain_children[x] == gid)
+						goto found2;
+				}
+			} else if (match->uidgid == gid && match->roletype & GR_ROLE_GROUP)
+				break;
+			match = match->next;
+		}
+found2:
+		if (match == NULL)
+			match = state->default_role;
+		if (match->allowed_ips == NULL)
+			return match;
+		else {
+			for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+				if (likely
+				    ((ntohl(curr_ip) & ipp->netmask) ==
+				     (ntohl(ipp->addr) & ipp->netmask)))
+					return match;
+			}
+			match = state->default_role;
+		}
+	} else if (match->allowed_ips == NULL) {
+		return match;
+	} else {
+		for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+			if (likely
+			    ((ntohl(curr_ip) & ipp->netmask) ==
+			     (ntohl(ipp->addr) & ipp->netmask)))
+				return match;
+		}
+		goto try_group;
+	}
+
+	return match;
+}
+
+static struct acl_role_label *
+lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
+		      const gid_t gid)
+{
+	return __lookup_acl_role_label(&running_polstate, task, uid, gid);
+}
+
+struct acl_subject_label *
+lookup_acl_subj_label(const u64 ino, const dev_t dev,
+		      const struct acl_role_label *role)
+{
+	unsigned int index = gr_fhash(ino, dev, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+struct acl_subject_label *
+lookup_acl_subj_label_deleted(const u64 ino, const dev_t dev,
+			  const struct acl_role_label *role)
+{
+	unsigned int index = gr_fhash(ino, dev, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       !(match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && (match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label(const u64 ino, const dev_t dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = gr_fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label_create(const u64 ino, const dev_t dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = gr_fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       !(match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && (match->mode & GR_DELETED))
+		return match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+struct name_entry *
+__lookup_name_entry(const struct gr_policy_state *state, const char *name)
+{
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(NULL, (const unsigned char *)name, len);
+	unsigned int index = key % state->name_set.n_size;
+	struct name_entry *match;
+
+	match = state->name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len)))
+		match = match->next;
+
+	return match;
+}
+
+static struct name_entry *
+lookup_name_entry(const char *name)
+{
+	return __lookup_name_entry(&running_polstate, name);
+}
+
+static struct name_entry *
+lookup_name_entry_create(const char *name)
+{
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(NULL, (const unsigned char *)name, len);
+	unsigned int index = key % running_polstate.name_set.n_size;
+	struct name_entry *match;
+
+	match = running_polstate.name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len) ||
+			 !match->deleted))
+		match = match->next;
+
+	if (match && match->deleted)
+		return match;
+
+	match = running_polstate.name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len) ||
+			 match->deleted))
+		match = match->next;
+
+	if (match && !match->deleted)
+		return match;
+	else
+		return NULL;
+}
+
+static struct inodev_entry *
+lookup_inodev_entry(const u64 ino, const dev_t dev)
+{
+	unsigned int index = gr_fhash(ino, dev, running_polstate.inodev_set.i_size);
+	struct inodev_entry *match;
+
+	match = running_polstate.inodev_set.i_hash[index];
+
+	while (match && (match->nentry->inode != ino || match->nentry->device != dev))
+		match = match->next;
+
+	return match;
+}
+
+void
+__insert_inodev_entry(const struct gr_policy_state *state, struct inodev_entry *entry)
+{
+	unsigned int index = gr_fhash(entry->nentry->inode, entry->nentry->device,
+				    state->inodev_set.i_size);
+	struct inodev_entry **curr;
+
+	entry->prev = NULL;
+
+	curr = &state->inodev_set.i_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = entry;
+	
+	entry->next = *curr;
+	*curr = entry;
+
+	return;
+}
+
+static void
+insert_inodev_entry(struct inodev_entry *entry)
+{
+	__insert_inodev_entry(&running_polstate, entry);
+}
+
+void
+insert_acl_obj_label(struct acl_object_label *obj,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index =
+	    gr_fhash(obj->inode, obj->device, subj->obj_hash_size);
+	struct acl_object_label **curr;
+
+	obj->prev = NULL;
+
+	curr = &subj->obj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+void
+insert_acl_subj_label(struct acl_subject_label *obj,
+		      struct acl_role_label *role)
+{
+	unsigned int index = gr_fhash(obj->inode, obj->device, role->subj_hash_size);
+	struct acl_subject_label **curr;
+
+	obj->prev = NULL;
+
+	curr = &role->subj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+/* derived from glibc fnmatch() 0: match, 1: no match*/
+
+static int
+glob_match(const char *p, const char *n)
+{
+	char c;
+
+	while ((c = *p++) != '\0') {
+	switch (c) {
+		case '?':
+			if (*n == '\0')
+				return 1;
+			else if (*n == '/')
+				return 1;
+			break;
+		case '\\':
+			if (*n != c)
+				return 1;
+			break;
+		case '*':
+			for (c = *p++; c == '?' || c == '*'; c = *p++) {
+				if (*n == '/')
+					return 1;
+				else if (c == '?') {
+					if (*n == '\0')
+						return 1;
+					else
+						++n;
+				}
+			}
+			if (c == '\0') {
+				return 0;
+			} else {
+				const char *endp;
+
+				if ((endp = strchr(n, '/')) == NULL)
+					endp = n + strlen(n);
+
+				if (c == '[') {
+					for (--p; n < endp; ++n)
+						if (!glob_match(p, n))
+							return 0;
+				} else if (c == '/') {
+					while (*n != '\0' && *n != '/')
+						++n;
+					if (*n == '/' && !glob_match(p, n + 1))
+						return 0;
+				} else {
+					for (--p; n < endp; ++n)
+						if (*n == c && !glob_match(p, n))
+							return 0;
+				}
+
+				return 1;
+			}
+		case '[':
+			{
+			int not;
+			char cold;
+
+			if (*n == '\0' || *n == '/')
+				return 1;
+
+			not = (*p == '!' || *p == '^');
+			if (not)
+				++p;
+
+			c = *p++;
+			for (;;) {
+				unsigned char fn = (unsigned char)*n;
+
+				if (c == '\0')
+					return 1;
+				else {
+					if (c == fn)
+						goto matched;
+					cold = c;
+					c = *p++;
+
+					if (c == '-' && *p != ']') {
+						unsigned char cend = *p++;
+
+						if (cend == '\0')
+							return 1;
+
+						if (cold <= fn && fn <= cend)
+							goto matched;
+
+						c = *p++;
+					}
+				}
+
+				if (c == ']')
+					break;
+			}
+			if (!not)
+				return 1;
+			break;
+		matched:
+			while (c != ']') {
+				if (c == '\0')
+					return 1;
+
+				c = *p++;
+			}
+			if (not)
+				return 1;
+		}
+		break;
+	default:
+		if (c != *n)
+			return 1;
+	}
+
+	++n;
+	}
+
+	if (*n == '\0')
+		return 0;
+
+	if (*n == '/')
+		return 0;
+
+	return 1;
+}
+
+static struct acl_object_label *
+chk_glob_label(struct acl_object_label *globbed,
+	const struct dentry *dentry, const struct vfsmount *mnt, char **path)
+{
+	struct acl_object_label *tmp;
+
+	if (*path == NULL)
+		*path = gr_to_filename_nolock(dentry, mnt);
+
+	tmp = globbed;
+
+	while (tmp) {
+		if (!glob_match(tmp->filename, *path))
+			return tmp;
+		tmp = tmp->next;
+	}
+
+	return NULL;
+}
+
+static struct acl_object_label *
+__full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    const u64 curr_ino, const dev_t curr_dev,
+	    const struct acl_subject_label *subj, char **path, const int checkglob)
+{
+	struct acl_subject_label *tmpsubj;
+	struct acl_object_label *retval;
+	struct acl_object_label *retval2;
+
+	tmpsubj = (struct acl_subject_label *) subj;
+	read_lock(&gr_inode_lock);
+	do {
+		retval = lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
+		if (retval) {
+			if (checkglob && retval->globbed) {
+				retval2 = chk_glob_label(retval->globbed, orig_dentry, orig_mnt, path);
+				if (retval2)
+					retval = retval2;
+			}
+			break;
+		}
+	} while ((tmpsubj = tmpsubj->parent_subject));
+	read_unlock(&gr_inode_lock);
+
+	return retval;
+}
+
+static struct acl_object_label *
+full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    struct dentry *curr_dentry,
+	    const struct acl_subject_label *subj, char **path, const int checkglob)
+{
+	int newglob = checkglob;
+	u64 inode;
+	dev_t device;
+
+	/* if we aren't checking a subdirectory of the original path yet, don't do glob checking
+	   as we don't want a / * rule to match instead of the / object
+	   don't do this for create lookups that call this function though, since they're looking up
+	   on the parent and thus need globbing checks on all paths
+	*/
+	if (orig_dentry == curr_dentry && newglob != GR_CREATE_GLOB)
+		newglob = GR_NO_GLOB;
+
+	spin_lock(&curr_dentry->d_lock);
+	inode = __get_ino(curr_dentry);
+	device = __get_dev(curr_dentry);
+	spin_unlock(&curr_dentry->d_lock);
+
+	return __full_lookup(orig_dentry, orig_mnt, inode, device, subj, path, newglob);
+}
+
+#ifdef CONFIG_HUGETLBFS
+static inline bool
+is_hugetlbfs_mnt(const struct vfsmount *mnt)
+{
+	int i;
+	for (i = 0; i < HUGE_MAX_HSTATE; i++) {
+		if (unlikely(hugetlbfs_vfsmount[i] == mnt))
+			return true;
+	}
+
+	return false;
+}
+#endif
+
+static struct acl_object_label *
+__chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj, char *path, const int checkglob)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct inode * inode = d_backing_inode(dentry);
+	struct mount *real_mnt = real_mount(mnt);
+	struct acl_object_label *retval;
+	struct dentry *parent;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	if (unlikely((mnt == shm_mnt && inode->i_nlink == 0) || mnt == pipe_mnt ||
+#ifdef CONFIG_NET
+	    mnt == sock_mnt ||
+#endif
+#ifdef CONFIG_HUGETLBFS
+	    (is_hugetlbfs_mnt(mnt) && inode->i_nlink == 0) ||
+#endif
+		/* ignore Eric Biederman */
+	    IS_PRIVATE(inode))) {
+		retval = (subj->mode & GR_SHMEXEC) ? fakefs_obj_rwx : fakefs_obj_rw;
+		goto out;
+	}
+
+	for (;;) {
+		if (dentry == gr_real_root.dentry && mnt == gr_real_root.mnt)
+			break;
+
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (!mnt_has_parent(real_mnt))
+				break;
+
+			retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+			if (retval != NULL)
+				goto out;
+
+			dentry = real_mnt->mnt_mountpoint;
+			real_mnt = real_mnt->mnt_parent;
+			mnt = &real_mnt->mnt;
+			continue;
+		}
+
+		parent = dentry->d_parent;
+		retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+		if (retval != NULL)
+			goto out;
+
+		dentry = parent;
+	}
+
+	retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+
+	/* gr_real_root is pinned so we don't have to hold a reference */
+	if (retval == NULL)
+		retval = full_lookup(l_dentry, l_mnt, gr_real_root.dentry, subj, &path, checkglob);
+out:
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+
+	BUG_ON(retval == NULL);
+
+	return retval;
+}
+
+static struct acl_object_label *
+chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj)
+{
+	char *path = NULL;
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, GR_REG_GLOB);
+}
+
+static struct acl_object_label *
+chk_obj_label_noglob(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj)
+{
+	char *path = NULL;
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, GR_NO_GLOB);
+}
+
+static struct acl_object_label *
+chk_obj_create_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+		     const struct acl_subject_label *subj, char *path)
+{
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, GR_CREATE_GLOB);
+}
+
+struct acl_subject_label *
+chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	       const struct acl_role_label *role)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct mount *real_mnt = real_mount(mnt);
+	struct acl_subject_label *retval;
+	struct dentry *parent;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	for (;;) {
+		if (dentry == gr_real_root.dentry && mnt == gr_real_root.mnt)
+			break;
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (!mnt_has_parent(real_mnt))
+				break;
+
+			spin_lock(&dentry->d_lock);
+			read_lock(&gr_inode_lock);
+			retval =
+				lookup_acl_subj_label(__get_ino(dentry),
+						__get_dev(dentry), role);
+			read_unlock(&gr_inode_lock);
+			spin_unlock(&dentry->d_lock);
+			if (retval != NULL)
+				goto out;
+
+			dentry = real_mnt->mnt_mountpoint;
+			real_mnt = real_mnt->mnt_parent;
+			mnt = &real_mnt->mnt;
+			continue;
+		}
+
+		spin_lock(&dentry->d_lock);
+		read_lock(&gr_inode_lock);
+		retval = lookup_acl_subj_label(__get_ino(dentry),
+					  __get_dev(dentry), role);
+		read_unlock(&gr_inode_lock);
+		parent = dentry->d_parent;
+		spin_unlock(&dentry->d_lock);
+
+		if (retval != NULL)
+			goto out;
+
+		dentry = parent;
+	}
+
+	spin_lock(&dentry->d_lock);
+	read_lock(&gr_inode_lock);
+	retval = lookup_acl_subj_label(__get_ino(dentry),
+				  __get_dev(dentry), role);
+	read_unlock(&gr_inode_lock);
+	spin_unlock(&dentry->d_lock);
+
+	if (unlikely(retval == NULL)) {
+		/* gr_real_root is pinned, we don't need to hold a reference */
+		read_lock(&gr_inode_lock);
+		retval = lookup_acl_subj_label(__get_ino(gr_real_root.dentry),
+					  __get_dev(gr_real_root.dentry), role);
+		read_unlock(&gr_inode_lock);
+	}
+out:
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+
+	BUG_ON(retval == NULL);
+
+	return retval;
+}
+
+void
+assign_special_role(const char *rolename)
+{
+	struct acl_object_label *obj;
+	struct acl_role_label *r;
+	struct acl_role_label *assigned = NULL;
+	struct task_struct *tsk;
+	struct file *filp;
+
+	FOR_EACH_ROLE_START(r)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL)) {
+			assigned = r;
+			break;
+		}
+	FOR_EACH_ROLE_END(r)
+
+	if (!assigned)
+		return;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+
+	tsk = current->real_parent;
+	if (tsk == NULL)
+		goto out_unlock;
+
+	filp = tsk->exec_file;
+	if (filp == NULL)
+		goto out_unlock;
+
+	tsk->is_writable = 0;
+	tsk->inherited = 0;
+
+	tsk->acl_sp_role = 1;
+	tsk->acl_role_id = ++acl_sp_role_value;
+	tsk->role = assigned;
+	tsk->acl = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, tsk->role);
+
+	/* ignore additional mmap checks for processes that are writable
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, running_polstate.default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, tsk->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "Assigning special role:%s subject:%s to process (%s:%d)\n", tsk->role->rolename,
+			tsk->acl->filename, tsk->comm, task_pid_nr(tsk));
+#endif
+
+out_unlock:
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	return;
+}
+
+
+static void
+gr_log_learn(const struct dentry *dentry, const struct vfsmount *mnt, const __u32 mode)
+{
+	struct task_struct *task = current;
+	const struct cred *cred = current_cred();
+
+	security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename, task->role->roletype,
+		       GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), task->exec_file ? gr_to_filename1(task->exec_file->f_path.dentry,
+		       task->exec_file->f_path.mnt) : task->acl->filename, task->acl->filename,
+		       1UL, 1UL, gr_to_filename(dentry, mnt), (unsigned long) mode, &task->signal->saved_ip);
+
+	return;
+}
+
+static void
+gr_log_learn_uid_change(const kuid_t real, const kuid_t effective, const kuid_t fs)
+{
+	struct task_struct *task = current;
+	const struct cred *cred = current_cred();
+
+	security_learn(GR_ID_LEARN_MSG, task->role->rolename, task->role->roletype,
+		       GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), task->exec_file ? gr_to_filename1(task->exec_file->f_path.dentry,
+		       task->exec_file->f_path.mnt) : task->acl->filename, task->acl->filename,
+		       'u', GR_GLOBAL_UID(real), GR_GLOBAL_UID(effective), GR_GLOBAL_UID(fs), &task->signal->saved_ip);
+
+	return;
+}
+
+static void
+gr_log_learn_gid_change(const kgid_t real, const kgid_t effective, const kgid_t fs)
+{
+	struct task_struct *task = current;
+	const struct cred *cred = current_cred();
+
+	security_learn(GR_ID_LEARN_MSG, task->role->rolename, task->role->roletype,
+		       GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), task->exec_file ? gr_to_filename1(task->exec_file->f_path.dentry,
+		       task->exec_file->f_path.mnt) : task->acl->filename, task->acl->filename,
+		       'g', GR_GLOBAL_GID(real), GR_GLOBAL_GID(effective), GR_GLOBAL_GID(fs), &task->signal->saved_ip);
+
+	return;
+}
+
+static void
+gr_set_proc_res(struct task_struct *task)
+{
+	struct acl_subject_label *proc;
+	unsigned short i;
+
+	proc = task->acl;
+
+	if (proc->mode & (GR_LEARN | GR_INHERITLEARN))
+		return;
+
+	for (i = 0; i < RLIM_NLIMITS; i++) {
+		unsigned long rlim_cur, rlim_max;
+
+		if (!(proc->resmask & (1U << i)))
+			continue;
+
+		rlim_cur = proc->res[i].rlim_cur;
+		rlim_max = proc->res[i].rlim_max;
+
+		if (i == RLIMIT_NOFILE) {
+			unsigned long saved_sysctl_nr_open = sysctl_nr_open;
+			if (rlim_cur > saved_sysctl_nr_open)
+				rlim_cur = saved_sysctl_nr_open;
+			if (rlim_max > saved_sysctl_nr_open)
+				rlim_max = saved_sysctl_nr_open;
+		}
+
+		task->signal->rlim[i].rlim_cur = rlim_cur;
+		task->signal->rlim[i].rlim_max = rlim_max;
+
+		if (i == RLIMIT_CPU)
+			update_rlimit_cpu(task, rlim_cur);
+	}
+
+	return;
+}
+
+/* both of the below must be called with
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+   except in the case of gr_set_role_label() (for __gr_get_subject_for_task)
+*/
+
+struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename, int fallback)
+{
+	char *tmpname;
+	struct acl_subject_label *tmpsubj;
+	struct file *filp;
+	struct name_entry *nmatch;
+
+	filp = task->exec_file;
+	if (filp == NULL)
+		return NULL;
+
+	/* the following is to apply the correct subject
+	   on binaries running when the RBAC system
+	   is enabled, when the binaries have been
+	   replaced or deleted since their execution
+	   -----
+	   when the RBAC system starts, the inode/dev
+	   from exec_file will be one the RBAC system
+	   is unaware of.  It only knows the inode/dev
+	   of the present file on disk, or the absence
+	   of it.
+	*/
+
+	if (filename)
+		nmatch = __lookup_name_entry(state, filename);
+	else {
+		preempt_disable();
+		tmpname = gr_to_filename_rbac(filp->f_path.dentry, filp->f_path.mnt);
+
+		nmatch = __lookup_name_entry(state, tmpname);
+		preempt_enable();
+	}
+	tmpsubj = NULL;
+	if (nmatch) {
+		if (nmatch->deleted)
+			tmpsubj = lookup_acl_subj_label_deleted(nmatch->inode, nmatch->device, task->role);
+		else
+			tmpsubj = lookup_acl_subj_label(nmatch->inode, nmatch->device, task->role);
+	}
+	/* this also works for the reload case -- if we don't match a potentially inherited subject
+	   then we fall back to a normal lookup based on the binary's ino/dev
+	*/
+	if (tmpsubj == NULL && fallback)
+		tmpsubj = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, task->role);
+
+	return tmpsubj;
+}
+
+static struct acl_subject_label *gr_get_subject_for_task(struct task_struct *task, const char *filename, int fallback)
+{
+	return __gr_get_subject_for_task(&running_polstate, task, filename, fallback);
+}
+
+void __gr_apply_subject_to_task(const struct gr_policy_state *state, struct task_struct *task, struct acl_subject_label *subj)
+{
+	struct acl_object_label *obj;
+	struct file *filp;
+
+	filp = task->exec_file;
+
+	task->acl = subj;
+	task->is_writable = 0;
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, state->default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+	gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "gr_set_acls for (%s:%d): role:%s, subject:%s\n", task->comm, task_pid_nr(task), task->role->rolename, task->acl->filename);
+#endif
+}
+
+static void gr_apply_subject_to_task(struct task_struct *task, struct acl_subject_label *subj)
+{
+	__gr_apply_subject_to_task(&running_polstate, task, subj);
+}
+
+__u32
+gr_search_file(const struct dentry * dentry, const __u32 mode,
+	       const struct vfsmount * mnt)
+{
+	__u32 retval = mode;
+	struct acl_subject_label *curracl;
+	struct acl_object_label *currobj;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	curracl = current->acl;
+
+	currobj = chk_obj_label(dentry, mnt, curracl);
+	retval = currobj->mode & mode;
+
+	/* if we're opening a specified transfer file for writing
+	   (e.g. /dev/initctl), then transfer our role to init
+	*/
+	if (unlikely(currobj->mode & GR_INIT_TRANSFER && retval & GR_WRITE &&
+		     current->role->roletype & GR_ROLE_PERSIST)) {
+		struct task_struct *task = init_pid_ns.child_reaper;
+
+		if (task->role != current->role) {
+			struct acl_subject_label *subj;
+
+			task->acl_sp_role = 0;
+			task->acl_role_id = current->acl_role_id;
+			task->role = current->role;
+			rcu_read_lock();
+			read_lock(&grsec_exec_file_lock);
+			subj = gr_get_subject_for_task(task, NULL, 1);
+			gr_apply_subject_to_task(task, subj);
+			read_unlock(&grsec_exec_file_lock);
+			rcu_read_unlock();
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_INIT_TRANSFER_MSG);
+		}
+	}
+
+	if (unlikely
+	    ((curracl->mode & (GR_LEARN | GR_INHERITLEARN)) && !(mode & GR_NOPTRACE)
+	     && (retval != (mode & ~(GR_AUDITS | GR_SUPPRESS))))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		retval = new_mode;
+
+		if (new_mode & GR_EXEC && curracl->mode & GR_INHERITLEARN)
+			new_mode |= GR_INHERIT;
+
+		if (!(mode & GR_NOLEARN))
+			gr_log_learn(dentry, mnt, new_mode);
+	}
+
+	return retval;
+}
+
+struct acl_object_label *gr_get_create_object(const struct dentry *new_dentry,
+					      const struct dentry *parent,
+					      const struct vfsmount *mnt)
+{
+	struct name_entry *match;
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *curracl;
+	char *path;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return NULL;
+
+	preempt_disable();
+	path = gr_to_filename_rbac(new_dentry, mnt);
+	match = lookup_name_entry_create(path);
+
+	curracl = current->acl;
+
+	if (match) {
+		read_lock(&gr_inode_lock);
+		matchpo = lookup_acl_obj_label_create(match->inode, match->device, curracl);
+		read_unlock(&gr_inode_lock);
+
+		if (matchpo) {
+			preempt_enable();
+			return matchpo;
+		}
+	}
+
+	// lookup parent
+
+	matchpo = chk_obj_create_label(parent, mnt, curracl, path);
+
+	preempt_enable();
+	return matchpo;
+}
+
+__u32
+gr_check_create(const struct dentry * new_dentry, const struct dentry * parent,
+		const struct vfsmount * mnt, const __u32 mode)
+{
+	struct acl_object_label *matchpo;
+	__u32 retval;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	matchpo = gr_get_create_object(new_dentry, parent, mnt);
+
+	retval = matchpo->mode & mode;
+
+	if ((retval != (mode & ~(GR_AUDITS | GR_SUPPRESS)))
+	    && (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		gr_log_learn(new_dentry, mnt, new_mode);
+		return new_mode;
+	}
+
+	return retval;
+}
+
+__u32
+gr_check_link(const struct dentry * new_dentry,
+	      const struct dentry * parent_dentry,
+	      const struct vfsmount * parent_mnt,
+	      const struct dentry * old_dentry, const struct vfsmount * old_mnt)
+{
+	struct acl_object_label *obj;
+	__u32 oldmode, newmode;
+	__u32 needmode;
+	__u32 checkmodes = GR_FIND | GR_APPEND | GR_WRITE | GR_EXEC | GR_SETID | GR_READ |
+			   GR_DELETE | GR_INHERIT;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (GR_CREATE | GR_LINK);
+
+	obj = chk_obj_label(old_dentry, old_mnt, current->acl);
+	oldmode = obj->mode;
+
+	obj = gr_get_create_object(new_dentry, parent_dentry, parent_mnt);
+	newmode = obj->mode;
+
+	needmode = newmode & checkmodes;
+
+	// old name for hardlink must have at least the permissions of the new name
+	if ((oldmode & needmode) != needmode)
+		goto bad;
+
+	// if old name had restrictions/auditing, make sure the new name does as well
+	needmode = oldmode & (GR_NOPTRACE | GR_PTRACERD | GR_INHERIT | GR_AUDITS);
+
+	// don't allow hardlinking of suid/sgid/fcapped files without permission
+	if (is_privileged_binary(old_dentry))
+		needmode |= GR_SETID;
+
+	if ((newmode & needmode) != needmode)
+		goto bad;
+
+	// enforce minimum permissions
+	if ((newmode & (GR_CREATE | GR_LINK)) == (GR_CREATE | GR_LINK))
+		return newmode;
+bad:
+	needmode = oldmode;
+	if (is_privileged_binary(old_dentry))
+		needmode |= GR_SETID;
+	
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		gr_log_learn(old_dentry, old_mnt, needmode | GR_CREATE | GR_LINK);
+		return (GR_CREATE | GR_LINK);
+	} else if (newmode & GR_SUPPRESS)
+		return GR_SUPPRESS;
+	else
+		return 0;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (!(task->acl->mode & GR_PROCFIND) && !(current->acl->mode & GR_VIEW))
+		return 1;
+
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY) || !task))
+		return 0;
+
+	if ((task->acl->mode & GR_PROTECTED) && !(current->acl->mode & GR_KILL) &&
+	    task->acl != current->acl)
+		return 1;
+
+	return 0;
+}
+
+int
+gr_check_protected_task_fowner(struct pid *pid, enum pid_type type)
+{
+	struct task_struct *p;
+	int ret = 0;
+
+	if (unlikely(!(gr_status & GR_READY) || !pid))
+		return ret;
+
+	read_lock(&tasklist_lock);
+	do_each_pid_task(pid, type, p) {
+		if ((p->acl->mode & GR_PROTECTED) && !(current->acl->mode & GR_KILL) &&
+		    p->acl != current->acl) {
+			ret = 1;
+			goto out;
+		}
+	} while_each_pid_task(pid, type, p);
+out:
+	read_unlock(&tasklist_lock);
+
+	return ret;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	struct task_struct *p = current;
+
+	tsk->inherited = p->inherited;
+	tsk->acl_sp_role = 0;
+	tsk->acl_role_id = p->acl_role_id;
+	tsk->acl = p->acl;
+	tsk->role = p->role;
+	tsk->signal->used_accept = 0;
+	tsk->signal->curr_ip = p->signal->curr_ip;
+	tsk->signal->saved_ip = p->signal->saved_ip;
+	if (p->exec_file)
+		get_file(p->exec_file);
+	tsk->exec_file = p->exec_file;
+	tsk->is_writable = p->is_writable;
+	if (unlikely(p->signal->used_accept)) {
+		p->signal->curr_ip = 0;
+		p->signal->saved_ip = 0;
+	}
+
+	return;
+}
+
+extern int gr_process_kernel_setuid_ban(struct user_struct *user);
+
+int
+gr_check_user_change(kuid_t real, kuid_t effective, kuid_t fs)
+{
+	unsigned int i;
+	__u16 num;
+	uid_t *uidlist;
+	uid_t curuid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+	uid_t globalreal, globaleffective, globalfs;
+
+#if defined(CONFIG_GRKERNSEC_KERN_LOCKOUT)
+	struct user_struct *user;
+
+	if (!uid_valid(real))
+		goto skipit;
+
+	/* find user based on global namespace */
+
+	globalreal = GR_GLOBAL_UID(real);
+
+	user = find_user(make_kuid(&init_user_ns, globalreal));
+	if (user == NULL)
+		goto skipit;
+
+	if (gr_process_kernel_setuid_ban(user)) {
+		/* for find_user */
+		free_uid(user);
+		return 1;
+	}
+
+	/* for find_user */
+	free_uid(user);
+
+skipit:
+#endif
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_uid_change(real, effective, fs);
+
+	num = current->acl->user_trans_num;
+	uidlist = current->acl->user_transitions;
+
+	if (uidlist == NULL)
+		return 0;
+
+	if (!uid_valid(real)) {
+		realok = 1;
+		globalreal = (uid_t)-1;		
+	} else {
+		globalreal = GR_GLOBAL_UID(real);		
+	}
+	if (!uid_valid(effective)) {
+		effectiveok = 1;
+		globaleffective = (uid_t)-1;
+	} else {
+		globaleffective = GR_GLOBAL_UID(effective);
+	}
+	if (!uid_valid(fs)) {
+		fsok = 1;
+		globalfs = (uid_t)-1;
+	} else {
+		globalfs = GR_GLOBAL_UID(fs);
+	}
+
+	if (current->acl->user_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curuid = uidlist[i];
+			if (globalreal == curuid)
+				realok = 1;
+			if (globaleffective == curuid)
+				effectiveok = 1;
+			if (globalfs == curuid)
+				fsok = 1;
+		}
+	} else if (current->acl->user_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curuid = uidlist[i];
+			if (globalreal == curuid)
+				break;
+			if (globaleffective == curuid)
+				break;
+			if (globalfs == curuid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_USRCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : globalfs) : globaleffective) : globalreal);
+		return 1;
+	}
+}
+
+int
+gr_check_group_change(kgid_t real, kgid_t effective, kgid_t fs)
+{
+	unsigned int i;
+	__u16 num;
+	gid_t *gidlist;
+	gid_t curgid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+	gid_t globalreal, globaleffective, globalfs;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_gid_change(real, effective, fs);
+
+	num = current->acl->group_trans_num;
+	gidlist = current->acl->group_transitions;
+
+	if (gidlist == NULL)
+		return 0;
+
+	if (!gid_valid(real)) {
+		realok = 1;
+		globalreal = (gid_t)-1;		
+	} else {
+		globalreal = GR_GLOBAL_GID(real);
+	}
+	if (!gid_valid(effective)) {
+		effectiveok = 1;
+		globaleffective = (gid_t)-1;		
+	} else {
+		globaleffective = GR_GLOBAL_GID(effective);
+	}
+	if (!gid_valid(fs)) {
+		fsok = 1;
+		globalfs = (gid_t)-1;		
+	} else {
+		globalfs = GR_GLOBAL_GID(fs);
+	}
+
+	if (current->acl->group_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curgid = gidlist[i];
+			if (globalreal == curgid)
+				realok = 1;
+			if (globaleffective == curgid)
+				effectiveok = 1;
+			if (globalfs == curgid)
+				fsok = 1;
+		}
+	} else if (current->acl->group_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curgid = gidlist[i];
+			if (globalreal == curgid)
+				break;
+			if (globaleffective == curgid)
+				break;
+			if (globalfs == curgid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_GRPCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : globalfs) : globaleffective) : globalreal);
+		return 1;
+	}
+}
+
+extern int gr_acl_is_capable(const int cap);
+
+void
+gr_set_role_label(struct task_struct *task, const kuid_t kuid, const kgid_t kgid)
+{
+	struct acl_role_label *role = task->role;
+	struct acl_role_label *origrole = role;
+	struct acl_subject_label *subj = NULL;
+	struct acl_object_label *obj;
+	struct file *filp;
+	uid_t uid;
+	gid_t gid;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	uid = GR_GLOBAL_UID(kuid);
+	gid = GR_GLOBAL_GID(kgid);
+
+	filp = task->exec_file;
+
+	/* kernel process, we'll give them the kernel role */
+	if (unlikely(!filp)) {
+		task->role = running_polstate.kernel_role;
+		task->acl = running_polstate.kernel_role->root_label;
+		return;
+	} else if (!task->role || !(task->role->roletype & GR_ROLE_SPECIAL)) {
+		/* save the current ip at time of role lookup so that the proper
+		   IP will be learned for role_allowed_ip */
+		task->signal->saved_ip = task->signal->curr_ip;
+		role = lookup_acl_role_label(task, uid, gid);
+	}
+
+	/* don't change the role if we're not a privileged process */
+	if (role && task->role != role &&
+	    (((role->roletype & GR_ROLE_USER) && !gr_acl_is_capable(CAP_SETUID)) ||
+	     ((role->roletype & GR_ROLE_GROUP) && !gr_acl_is_capable(CAP_SETGID))))
+		return;
+
+	task->role = role;
+
+	if (task->inherited) {
+		/* if we reached our subject through inheritance, then first see
+		   if there's a subject of the same name in the new role that has
+		   an object that would result in the same inherited subject
+		*/
+		subj = gr_get_subject_for_task(task, task->acl->filename, 0);
+		if (subj) {
+			obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, subj);
+			if (!(obj->mode & GR_INHERIT))
+				subj = NULL;
+		}
+		
+	}
+	if (subj == NULL) {
+		/* otherwise:
+		   perform subject lookup in possibly new role
+		   we can use this result below in the case where role == task->role
+		*/
+		subj = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, role);
+	}
+
+	/* if we changed uid/gid, but result in the same role
+	   and are using inheritance, don't lose the inherited subject
+	   if current subject is other than what normal lookup
+	   would result in, we arrived via inheritance, don't
+	   lose subject
+	*/
+	if (role != origrole || (!(task->acl->mode & GR_INHERITLEARN) &&
+				   (subj == task->acl)))
+		task->acl = subj;
+
+	/* leave task->inherited unaffected */
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, running_polstate.default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "Set role label for (%s:%d): role:%s, subject:%s\n", task->comm, task_pid_nr(task), task->role->rolename, task->acl->filename);
+#endif
+
+	gr_set_proc_res(task);
+
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
+		  const int unsafe_flags)
+{
+	struct task_struct *task = current;
+	struct acl_subject_label *newacl;
+	struct acl_object_label *obj;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	newacl = chk_subj_label(dentry, mnt, task->role);
+
+	/* special handling for if we did an strace -f -p <pid> from an admin role, where pid then
+	   did an exec
+	*/
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	if (task->ptrace && task->parent && ((task->parent->role->roletype & GR_ROLE_GOD) ||
+	    (task->parent->acl->mode & GR_POVERRIDE))) {
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+		goto skip_check;
+	}
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	if (unsafe_flags && !(task->acl->mode & GR_POVERRIDE) && (task->acl != newacl) &&
+	     !(task->role->roletype & GR_ROLE_GOD) &&
+	     !gr_search_file(dentry, GR_PTRACERD, mnt) &&
+	     !(task->acl->mode & (GR_LEARN | GR_INHERITLEARN))) {
+		if (unsafe_flags & LSM_UNSAFE_SHARE)
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_UNSAFESHARE_EXEC_ACL_MSG, dentry, mnt);
+		else if (unsafe_flags & (LSM_UNSAFE_PTRACE_CAP | LSM_UNSAFE_PTRACE))
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_PTRACE_EXEC_ACL_MSG, dentry, mnt);
+		else
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_NNP_EXEC_ACL_MSG, dentry, mnt);
+		return -EACCES;
+	}
+
+skip_check:
+
+	obj = chk_obj_label(dentry, mnt, task->acl);
+	retmode = obj->mode & (GR_INHERIT | GR_AUDIT_INHERIT);
+
+	if (!(task->acl->mode & GR_INHERITLEARN) &&
+	    ((newacl->mode & GR_LEARN) || !(retmode & GR_INHERIT))) {
+		if (obj->nested)
+			task->acl = obj->nested;
+		else
+			task->acl = newacl;
+		task->inherited = 0;
+	} else {
+		task->inherited = 1;
+		if (retmode & GR_INHERIT && retmode & GR_AUDIT_INHERIT)
+			gr_log_str_fs(GR_DO_AUDIT, GR_INHERIT_ACL_MSG, task->acl->filename, dentry, mnt);
+	}
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(dentry, mnt, running_polstate.default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(dentry, mnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+	gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "Set subject label for (%s:%d): role:%s, subject:%s\n", task->comm, task_pid_nr(task), task->role->rolename, task->acl->filename);
+#endif
+	return 0;
+}
+
+/* always called with valid inodev ptr */
+static void
+do_handle_delete(struct inodev_entry *inodev, const u64 ino, const dev_t dev)
+{
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *matchps;
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int x;
+
+	FOR_EACH_ROLE_START(role)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			if ((matchpo = lookup_acl_obj_label(ino, dev, subj)) != NULL)
+				matchpo->mode |= GR_DELETED;
+		FOR_EACH_SUBJECT_END(subj,x)
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			/* nested subjects aren't in the role's subj_hash table */
+			if ((matchpo = lookup_acl_obj_label(ino, dev, subj)) != NULL)
+				matchpo->mode |= GR_DELETED;
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		if ((matchps = lookup_acl_subj_label(ino, dev, role)) != NULL)
+			matchps->mode |= GR_DELETED;
+	FOR_EACH_ROLE_END(role)
+
+	inodev->nentry->deleted = 1;
+
+	return;
+}
+
+void
+gr_handle_delete(const u64 ino, const dev_t dev)
+{
+	struct inodev_entry *inodev;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	write_lock(&gr_inode_lock);
+	inodev = lookup_inodev_entry(ino, dev);
+	if (inodev != NULL)
+		do_handle_delete(inodev, ino, dev);
+	write_unlock(&gr_inode_lock);
+
+	return;
+}
+
+static void
+update_acl_obj_label(const u64 oldinode, const dev_t olddevice,
+		     const u64 newinode, const dev_t newdevice,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index = gr_fhash(oldinode, olddevice, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			subj->obj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_obj_label(match, subj);
+	}
+
+	return;
+}
+
+static void
+update_acl_subj_label(const u64 oldinode, const dev_t olddevice,
+		      const u64 newinode, const dev_t newdevice,
+		      struct acl_role_label *role)
+{
+	unsigned int index = gr_fhash(oldinode, olddevice, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			role->subj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_subj_label(match, role);
+	}
+
+	return;
+}
+
+static void
+update_inodev_entry(const u64 oldinode, const dev_t olddevice,
+		    const u64 newinode, const dev_t newdevice)
+{
+	unsigned int index = gr_fhash(oldinode, olddevice, running_polstate.inodev_set.i_size);
+	struct inodev_entry *match;
+
+	match = running_polstate.inodev_set.i_hash[index];
+
+	while (match && (match->nentry->inode != oldinode ||
+	       match->nentry->device != olddevice || !match->nentry->deleted))
+		match = match->next;
+
+	if (match && (match->nentry->inode == oldinode)
+	    && (match->nentry->device == olddevice) &&
+	    match->nentry->deleted) {
+		if (match->prev == NULL) {
+			running_polstate.inodev_set.i_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->nentry->inode = newinode;
+		match->nentry->device = newdevice;
+		match->nentry->deleted = 0;
+
+		insert_inodev_entry(match);
+	}
+
+	return;
+}
+
+static void
+__do_handle_create(const struct name_entry *matchn, u64 ino, dev_t dev)
+{
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int x;
+
+	FOR_EACH_ROLE_START(role)
+		update_acl_subj_label(matchn->inode, matchn->device, ino, dev, role);
+
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			if ((subj->inode == ino) && (subj->device == dev)) {
+				subj->inode = ino;
+				subj->device = dev;
+			}
+			/* nested subjects aren't in the role's subj_hash table */
+			update_acl_obj_label(matchn->inode, matchn->device,
+					     ino, dev, subj);
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			update_acl_obj_label(matchn->inode, matchn->device,
+					     ino, dev, subj);
+		FOR_EACH_SUBJECT_END(subj,x)
+	FOR_EACH_ROLE_END(role)
+
+	update_inodev_entry(matchn->inode, matchn->device, ino, dev);
+
+	return;
+}
+
+static void
+do_handle_create(const struct name_entry *matchn, const struct dentry *dentry,
+		 const struct vfsmount *mnt)
+{
+	u64 ino = __get_ino(dentry);
+	dev_t dev = __get_dev(dentry);
+
+	__do_handle_create(matchn, ino, dev);	
+
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	struct name_entry *matchn;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	preempt_disable();
+	matchn = lookup_name_entry(gr_to_filename_rbac(dentry, mnt));
+
+	if (unlikely((unsigned long)matchn)) {
+		write_lock(&gr_inode_lock);
+		do_handle_create(matchn, dentry, mnt);
+		write_unlock(&gr_inode_lock);
+	}
+	preempt_enable();
+
+	return;
+}
+
+void
+gr_handle_proc_create(const struct dentry *dentry, const struct inode *inode)
+{
+	struct name_entry *matchn;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	preempt_disable();
+	matchn = lookup_name_entry(gr_to_proc_filename_rbac(dentry, init_pid_ns.proc_mnt));
+
+	if (unlikely((unsigned long)matchn)) {
+		write_lock(&gr_inode_lock);
+		__do_handle_create(matchn, inode->i_ino, inode->i_sb->s_dev);
+		write_unlock(&gr_inode_lock);
+	}
+	preempt_enable();
+
+	return;
+}
+
+void
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace, unsigned int flags)
+{
+	struct name_entry *matchn;
+	struct name_entry *matchn2 = NULL;
+	struct inodev_entry *inodev;
+	struct inode *inode = d_backing_inode(new_dentry);
+	struct inode *old_inode = d_backing_inode(old_dentry);
+	u64 old_ino = __get_ino(old_dentry);
+	dev_t old_dev = __get_dev(old_dentry);
+	unsigned int exchange = flags & RENAME_EXCHANGE;
+
+	/* vfs_rename swaps the name and parent link for old_dentry and
+	   new_dentry
+	   at this point, old_dentry has the new name, parent link, and inode
+	   for the renamed file
+	   if a file is being replaced by a rename, new_dentry has the inode
+	   and name for the replaced file
+	*/
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	preempt_disable();
+	matchn = lookup_name_entry(gr_to_filename_rbac(old_dentry, mnt));
+
+	/* exchange cases:
+	   a filename exists for the source, but not dest
+		do a recreate on source
+	   a filename exists for the dest, but not source
+		do a recreate on dest
+	   a filename exists for both source and dest
+		delete source and dest, then create source and dest
+	   a filename exists for neither source nor dest
+		no updates needed
+
+	   the name entry lookups get us the old inode/dev associated with
+	   each name, so do the deletes first (if possible) so that when
+	   we do the create, we pick up on the right entries
+	*/
+
+	if (exchange)
+		matchn2 = lookup_name_entry(gr_to_filename_rbac(new_dentry, mnt));
+
+	/* we wouldn't have to check d_inode if it weren't for
+	   NFS silly-renaming
+	 */
+
+	write_lock(&gr_inode_lock);
+	if (unlikely((replace || exchange) && inode)) {
+		u64 new_ino = __get_ino(new_dentry);
+		dev_t new_dev = __get_dev(new_dentry);
+
+		inodev = lookup_inodev_entry(new_ino, new_dev);
+		if (inodev != NULL && ((inode->i_nlink <= 1) || d_is_dir(new_dentry)))
+			do_handle_delete(inodev, new_ino, new_dev);
+	}
+
+	inodev = lookup_inodev_entry(old_ino, old_dev);
+	if (inodev != NULL && ((old_inode->i_nlink <= 1) || d_is_dir(old_dentry)))
+		do_handle_delete(inodev, old_ino, old_dev);
+
+	if (unlikely(matchn != NULL))
+		do_handle_create(matchn, old_dentry, mnt);
+
+	if (unlikely(matchn2 != NULL))
+		do_handle_create(matchn2, new_dentry, mnt);
+
+	write_unlock(&gr_inode_lock);
+	preempt_enable();
+
+	return;
+}
+
+#if defined(CONFIG_GRKERNSEC_RESLOG) || !defined(CONFIG_GRKERNSEC_NO_RBAC)
+static const unsigned long res_learn_bumps[GR_NLIMITS] = {
+	[RLIMIT_CPU] = GR_RLIM_CPU_BUMP,
+	[RLIMIT_FSIZE] = GR_RLIM_FSIZE_BUMP,
+	[RLIMIT_DATA] = GR_RLIM_DATA_BUMP,
+	[RLIMIT_STACK] = GR_RLIM_STACK_BUMP,
+	[RLIMIT_CORE] = GR_RLIM_CORE_BUMP,
+	[RLIMIT_RSS] = GR_RLIM_RSS_BUMP,
+	[RLIMIT_NPROC] = GR_RLIM_NPROC_BUMP,
+	[RLIMIT_NOFILE] = GR_RLIM_NOFILE_BUMP,
+	[RLIMIT_MEMLOCK] = GR_RLIM_MEMLOCK_BUMP,
+	[RLIMIT_AS] = GR_RLIM_AS_BUMP,
+	[RLIMIT_LOCKS] = GR_RLIM_LOCKS_BUMP,
+	[RLIMIT_SIGPENDING] = GR_RLIM_SIGPENDING_BUMP,
+	[RLIMIT_MSGQUEUE] = GR_RLIM_MSGQUEUE_BUMP,
+	[RLIMIT_NICE] = GR_RLIM_NICE_BUMP,
+	[RLIMIT_RTPRIO] = GR_RLIM_RTPRIO_BUMP,
+	[RLIMIT_RTTIME] = GR_RLIM_RTTIME_BUMP
+};
+
+void
+gr_learn_resource(const struct task_struct *task,
+		  const int res, const unsigned long wanted, const int gt)
+{
+	struct acl_subject_label *acl;
+	const struct cred *cred;
+
+	if (unlikely((gr_status & GR_READY) &&
+		     task->acl && (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))))
+		goto skip_reslog;
+
+	gr_log_resource(task, res, wanted, gt);
+skip_reslog:
+
+	if (unlikely(!(gr_status & GR_READY) || !wanted || res >= GR_NLIMITS))
+		return;
+
+	acl = task->acl;
+
+	if (likely(!acl || !(acl->mode & (GR_LEARN | GR_INHERITLEARN)) ||
+		   !(acl->resmask & (1U << (unsigned short) res))))
+		return;
+
+	if (wanted >= acl->res[res].rlim_cur) {
+		unsigned long res_add;
+
+		res_add = wanted + res_learn_bumps[res];
+
+		acl->res[res].rlim_cur = res_add;
+
+		if (wanted > acl->res[res].rlim_max)
+			acl->res[res].rlim_max = res_add;
+
+		/* only log the subject filename, since resource logging is supported for
+		   single-subject learning only */
+		rcu_read_lock();
+		cred = __task_cred(task);
+		security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), acl->filename,
+			       acl->filename, acl->res[res].rlim_cur, acl->res[res].rlim_max,
+			       "", (unsigned long) res, &task->signal->saved_ip);
+		rcu_read_unlock();
+	}
+
+	return;
+}
+EXPORT_SYMBOL_GPL(gr_learn_resource);
+#endif
+
+#if defined(CONFIG_PAX_HAVE_ACL_FLAGS) && (defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR))
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	struct task_struct *task = current;
+        struct acl_subject_label *proc;
+	unsigned long flags;
+
+        if (unlikely(!(gr_status & GR_READY)))
+                return;
+
+	flags = pax_get_flags(task);
+
+        proc = task->acl;
+
+	if (proc->pax_flags & GR_PAX_DISABLE_PAGEEXEC)
+		flags &= ~MF_PAX_PAGEEXEC;
+	if (proc->pax_flags & GR_PAX_DISABLE_SEGMEXEC)
+		flags &= ~MF_PAX_SEGMEXEC;
+	if (proc->pax_flags & GR_PAX_DISABLE_RANDMMAP)
+		flags &= ~MF_PAX_RANDMMAP;
+	if (proc->pax_flags & GR_PAX_DISABLE_EMUTRAMP)
+		flags &= ~MF_PAX_EMUTRAMP;
+	if (proc->pax_flags & GR_PAX_DISABLE_MPROTECT)
+		flags &= ~MF_PAX_MPROTECT;
+
+	if (proc->pax_flags & GR_PAX_ENABLE_PAGEEXEC)
+		flags |= MF_PAX_PAGEEXEC;
+	if (proc->pax_flags & GR_PAX_ENABLE_SEGMEXEC)
+		flags |= MF_PAX_SEGMEXEC;
+	if (proc->pax_flags & GR_PAX_ENABLE_RANDMMAP)
+		flags |= MF_PAX_RANDMMAP;
+	if (proc->pax_flags & GR_PAX_ENABLE_EMUTRAMP)
+		flags |= MF_PAX_EMUTRAMP;
+	if (proc->pax_flags & GR_PAX_ENABLE_MPROTECT)
+		flags |= MF_PAX_MPROTECT;
+
+	pax_set_flags(task, flags);
+
+        return;
+}
+#endif
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	struct file *filp;
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+#ifndef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+#endif
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	filp = task->exec_file;
+
+	while (task_pid_nr(tmp) > 0) {
+		if (tmp == curtemp)
+			break;
+		tmp = tmp->real_parent;
+	}
+
+	if (!filp || (task_pid_nr(tmp) == 0 && ((grsec_enable_harden_ptrace && gr_is_global_nonroot(current_uid()) && !(gr_status & GR_READY)) ||
+				((gr_status & GR_READY)	&& !(current->acl->mode & GR_RELAXPTRACE))))) {
+		read_unlock(&grsec_exec_file_lock);
+		read_unlock(&tasklist_lock);
+		return 1;
+	}
+
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (!(gr_status & GR_READY)) {
+		read_unlock(&grsec_exec_file_lock);
+		read_unlock(&tasklist_lock);
+		return 0;
+	}
+#endif
+
+	retmode = gr_search_file(filp->f_path.dentry, GR_NOPTRACE, filp->f_path.mnt);
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+
+	if (retmode & GR_NOPTRACE)
+		return 1;
+
+	if (!(current->acl->mode & GR_POVERRIDE) && !(current->role->roletype & GR_ROLE_GOD)
+	    && (current->acl != task->acl || (current->acl != current->role->root_label
+	    && task_pid_nr(current) != task_pid_nr(task))))
+		return 1;
+
+	return 0;
+}
+
+void task_grsec_rbac(struct seq_file *m, struct task_struct *p)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	if (!(current->role->roletype & GR_ROLE_GOD))
+		return;
+
+	seq_printf(m, "RBAC:\t%.64s:%c:%.950s\n",
+			p->role->rolename, gr_task_roletype_to_char(p),
+			p->acl->filename);
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+#ifndef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+#endif
+	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
+		read_lock(&tasklist_lock);
+		while (task_pid_nr(tmp) > 0) {
+			if (tmp == curtemp)
+				break;
+			tmp = tmp->real_parent;
+		}
+
+		if (task_pid_nr(tmp) == 0 && ((grsec_enable_harden_ptrace && gr_is_global_nonroot(current_uid()) && !(gr_status & GR_READY)) ||
+					((gr_status & GR_READY)	&& !(current->acl->mode & GR_RELAXPTRACE)))) {
+			read_unlock(&tasklist_lock);
+			gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+			return 1;
+		}
+		read_unlock(&tasklist_lock);
+	}
+
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (!(gr_status & GR_READY))
+		return 0;
+#endif
+
+	read_lock(&grsec_exec_file_lock);
+	if (unlikely(!task->exec_file)) {
+		read_unlock(&grsec_exec_file_lock);
+		return 0;
+	}
+
+	retmode = gr_search_file(task->exec_file->f_path.dentry, GR_PTRACERD | GR_NOPTRACE, task->exec_file->f_path.mnt);
+	read_unlock(&grsec_exec_file_lock);
+
+	if (retmode & GR_NOPTRACE) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+		
+	if (retmode & GR_PTRACERD) {
+		switch (request) {
+		case PTRACE_SEIZE:
+		case PTRACE_POKETEXT:
+		case PTRACE_POKEDATA:
+		case PTRACE_POKEUSR:
+#if !defined(CONFIG_PPC32) && !defined(CONFIG_PPC64) && !defined(CONFIG_PARISC) && !defined(CONFIG_ALPHA) && !defined(CONFIG_IA64) && !defined(CONFIG_ARM64)
+		case PTRACE_SETREGS:
+		case PTRACE_SETFPREGS:
+#endif
+#ifdef CONFIG_COMPAT
+#ifdef CONFIG_ARM64
+		case COMPAT_PTRACE_SETREGS:
+		case COMPAT_PTRACE_SETVFPREGS:
+#ifdef CONFIG_HAVE_HW_BREAKPOINT
+		case COMPAT_PTRACE_SETHBPREGS:
+#endif
+#endif
+#endif
+#ifdef CONFIG_X86
+		case PTRACE_SETFPXREGS:
+#endif
+#ifdef CONFIG_ALTIVEC
+		case PTRACE_SETVRREGS:
+#endif
+#ifdef CONFIG_ARM
+		case PTRACE_SET_SYSCALL:
+		case PTRACE_SETVFPREGS:
+#ifdef CONFIG_HAVE_HW_BREAKPOINT
+		case PTRACE_SETHBPREGS:
+#endif
+#endif
+			return 1;
+		default:
+			return 0;
+		}
+	} else if (!(current->acl->mode & GR_POVERRIDE) &&
+		   !(current->role->roletype & GR_ROLE_GOD) &&
+		   (current->acl != task->acl)) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int is_writable_mmap(const struct file *filp)
+{
+	struct task_struct *task = current;
+	struct acl_object_label *obj, *obj2;
+	struct dentry *dentry = filp->f_path.dentry;
+	struct vfsmount *mnt = filp->f_path.mnt;
+	struct inode *inode = d_backing_inode(dentry);
+
+	if (gr_status & GR_READY && !(task->acl->mode & GR_OVERRIDE) &&
+	    !task->is_writable && d_is_reg(dentry) && (mnt != shm_mnt || (inode->i_nlink > 0))) {
+		obj = chk_obj_label(dentry, mnt, running_polstate.default_role->root_label);
+		obj2 = chk_obj_label(dentry, mnt, task->role->root_label);
+		if (unlikely((obj->mode & GR_WRITE) || (obj2->mode & GR_WRITE))) {
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_WRITLIB_ACL_MSG, dentry, mnt);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_path.dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_path.mnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MMAP_ACL_MSG, file->f_path.dentry, file->f_path.mnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MMAP_ACL_MSG, file->f_path.dentry, file->f_path.mnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_path.dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_path.mnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MPROTECT_ACL_MSG, file->f_path.dentry, file->f_path.mnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MPROTECT_ACL_MSG, file->f_path.dentry, file->f_path.mnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	unsigned long runtime, cputime;
+	cputime_t utime, stime;
+	unsigned int wday, cday;
+	__u8 whr, chr;
+	__u8 wmin, cmin;
+	__u8 wsec, csec;
+	struct timespec curtime, starttime;
+
+	if (unlikely(!(gr_status & GR_READY) || !task->acl ||
+		     !(task->acl->mode & GR_PROCACCT)))
+		return;
+	
+	curtime = ns_to_timespec(ktime_get_ns());
+	starttime = ns_to_timespec(task->start_time);
+	runtime = curtime.tv_sec - starttime.tv_sec;
+	wday = runtime / (60 * 60 * 24);
+	runtime -= wday * (60 * 60 * 24);
+	whr = runtime / (60 * 60);
+	runtime -= whr * (60 * 60);
+	wmin = runtime / 60;
+	runtime -= wmin * 60;
+	wsec = runtime;
+
+	task_cputime(task, &utime, &stime);
+	cputime = cputime_to_secs(utime + stime);
+	cday = cputime / (60 * 60 * 24);
+	cputime -= cday * (60 * 60 * 24);
+	chr = cputime / (60 * 60);
+	cputime -= chr * (60 * 60);
+	cmin = cputime / 60;
+	cputime -= cmin * 60;
+	csec = cputime;
+
+	gr_log_procacct(GR_DO_AUDIT, GR_ACL_PROCACCT_MSG, task, wday, whr, wmin, wsec, cday, chr, cmin, csec, code);
+
+	return;
+}
+
+#ifdef CONFIG_TASKSTATS
+int gr_is_taskstats_denied(int pid)
+{
+	struct task_struct *task;
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	const struct cred *cred;
+#endif
+	int ret = 0;
+
+	/* restrict taskstats viewing to un-chrooted root users
+	   who have the 'view' subject flag if the RBAC system is enabled
+	*/
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	task = find_task_by_vpid(pid);
+	if (task) {
+#ifdef CONFIG_GRKERNSEC_CHROOT
+		if (proc_is_chrooted(task))
+			ret = -EACCES;
+#endif
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+		cred = __task_cred(task);
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+		if (gr_is_global_nonroot(cred->uid))
+			ret = -EACCES;
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+		if (gr_is_global_nonroot(cred->uid) && !groups_search(cred->group_info, grsec_proc_gid))
+			ret = -EACCES;
+#endif
+#endif
+		if (gr_status & GR_READY) {
+			if (!(task->acl->mode & GR_VIEW))
+				ret = -EACCES;
+		}
+	} else
+		ret = -ENOENT;
+
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	return ret;
+}
+#endif
+
+/* AUXV entries are filled via a descendant of search_binary_handler
+   after we've already applied the subject for the target
+*/
+int gr_acl_enable_at_secure(void)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & GR_ATSECURE)
+		return 1;
+
+	return 0;
+}
+	
+int gr_acl_handle_filldir(const struct file *file, const char *name, const unsigned int namelen, const u64 ino)
+{
+	struct task_struct *task = current;
+	struct dentry *dentry = file->f_path.dentry;
+	struct vfsmount *mnt = file->f_path.mnt;
+	struct acl_object_label *obj, *tmp;
+	struct acl_subject_label *subj;
+	unsigned int bufsize;
+	int is_not_root;
+	char *path;
+	dev_t dev = __get_dev(dentry);
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 1;
+
+	if (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		return 1;
+
+	/* ignore Eric Biederman */
+	if (IS_PRIVATE(d_backing_inode(dentry)))
+		return 1;
+
+	subj = task->acl;
+	read_lock(&gr_inode_lock);
+	do {
+		obj = lookup_acl_obj_label(ino, dev, subj);
+		if (obj != NULL) {
+			read_unlock(&gr_inode_lock);
+			return (obj->mode & GR_FIND) ? 1 : 0;
+		}
+	} while ((subj = subj->parent_subject));
+	read_unlock(&gr_inode_lock);
+	
+	/* this is purely an optimization since we're looking for an object
+	   for the directory we're doing a readdir on
+	   if it's possible for any globbed object to match the entry we're
+	   filling into the directory, then the object we find here will be
+	   an anchor point with attached globbed objects
+	*/
+	obj = chk_obj_label_noglob(dentry, mnt, task->acl);
+	if (obj->globbed == NULL)
+		return (obj->mode & GR_FIND) ? 1 : 0;
+
+	is_not_root = ((obj->filename[0] == '/') &&
+		   (obj->filename[1] == '\0')) ? 0 : 1;
+	bufsize = PAGE_SIZE - namelen - is_not_root;
+
+	/* check bufsize > PAGE_SIZE || bufsize == 0 */
+	if (unlikely((bufsize - 1) > (PAGE_SIZE - 1)))
+		return 1;
+
+	preempt_disable();
+	path = d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0], smp_processor_id()),
+			   bufsize);
+
+	bufsize = strlen(path);
+
+	/* if base is "/", don't append an additional slash */
+	if (is_not_root)
+		*(path + bufsize) = '/';
+	memcpy(path + bufsize + is_not_root, name, namelen);
+	*(path + bufsize + namelen + is_not_root) = '\0';
+
+	tmp = obj->globbed;
+	while (tmp) {
+		if (!glob_match(tmp->filename, path)) {
+			preempt_enable();
+			return (tmp->mode & GR_FIND) ? 1 : 0;
+		}
+		tmp = tmp->next;
+	}
+	preempt_enable();
+	return (obj->mode & GR_FIND) ? 1 : 0;
+}
+
+void gr_put_exec_file(struct task_struct *task)
+{
+	struct file *filp;  
+
+	write_lock(&grsec_exec_file_lock);
+	filp = task->exec_file;   
+	task->exec_file = NULL;
+	write_unlock(&grsec_exec_file_lock);
+
+	if (filp)
+		fput(filp);
+
+	return;
+}
+
+
+#ifdef CONFIG_NETFILTER_XT_MATCH_GRADM_MODULE
+EXPORT_SYMBOL_GPL(gr_acl_is_enabled);
+#endif
+#ifdef CONFIG_SECURITY
+EXPORT_SYMBOL_GPL(gr_check_user_change);
+EXPORT_SYMBOL_GPL(gr_check_group_change);
+#endif
+
diff --git a/grsecurity/gracl_alloc.c b/grsecurity/gracl_alloc.c
new file mode 100644
index 000000000000..9adc75c94817
--- /dev/null
+++ b/grsecurity/gracl_alloc.c
@@ -0,0 +1,105 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+
+static struct gr_alloc_state __current_alloc_state = { 1, 1, NULL };
+struct gr_alloc_state *current_alloc_state = &__current_alloc_state;
+
+static int
+alloc_pop(void)
+{
+	if (current_alloc_state->alloc_stack_next == 1)
+		return 0;
+
+	kfree(current_alloc_state->alloc_stack[current_alloc_state->alloc_stack_next - 2]);
+
+	current_alloc_state->alloc_stack_next--;
+
+	return 1;
+}
+
+static int
+alloc_push(void *buf)
+{
+	if (current_alloc_state->alloc_stack_next >= current_alloc_state->alloc_stack_size)
+		return 1;
+
+	current_alloc_state->alloc_stack[current_alloc_state->alloc_stack_next - 1] = buf;
+
+	current_alloc_state->alloc_stack_next++;
+
+	return 0;
+}
+
+void *
+acl_alloc(unsigned long len)
+{
+	void *ret = NULL;
+
+	if (!len || len > PAGE_SIZE)
+		goto out;
+
+	ret = kmalloc(len, GFP_KERNEL);
+
+	if (ret) {
+		if (alloc_push(ret)) {
+			kfree(ret);
+			ret = NULL;
+		}
+	}
+
+out:
+	return ret;
+}
+
+void *
+acl_alloc_num(unsigned long num, unsigned long len)
+{
+	if (!len || (num > (PAGE_SIZE / len)))
+		return NULL;
+
+	return acl_alloc(num * len);
+}
+
+void
+acl_free_all(void)
+{
+	if (!current_alloc_state->alloc_stack)
+		return;
+
+	while (alloc_pop()) ;
+
+	if (current_alloc_state->alloc_stack) {
+		if ((current_alloc_state->alloc_stack_size * sizeof (void *)) <= PAGE_SIZE)
+			kfree(current_alloc_state->alloc_stack);
+		else
+			vfree(current_alloc_state->alloc_stack);
+	}
+
+	current_alloc_state->alloc_stack = NULL;
+	current_alloc_state->alloc_stack_size = 1;
+	current_alloc_state->alloc_stack_next = 1;
+
+	return;
+}
+
+int
+acl_alloc_stack_init(unsigned long size)
+{
+	if ((size * sizeof (void *)) <= PAGE_SIZE)
+		current_alloc_state->alloc_stack =
+		    (void **) kmalloc(size * sizeof (void *), GFP_KERNEL);
+	else
+		current_alloc_state->alloc_stack = (void **) vmalloc(size * sizeof (void *));
+
+	current_alloc_state->alloc_stack_size = size;
+	current_alloc_state->alloc_stack_next = 1;
+
+	if (!current_alloc_state->alloc_stack)
+		return 0;
+	else
+		return 1;
+}
diff --git a/grsecurity/gracl_cap.c b/grsecurity/gracl_cap.c
new file mode 100644
index 000000000000..8747091f68d6
--- /dev/null
+++ b/grsecurity/gracl_cap.c
@@ -0,0 +1,96 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+extern const char *captab_log[];
+extern int captab_log_entries;
+
+int gr_learn_cap(const struct task_struct *task, const struct cred *cred, const int cap, bool log)
+{
+	struct acl_subject_label *curracl;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	curracl = task->acl;
+
+	if (curracl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		if (log)
+			security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, GR_GLOBAL_UID(cred->uid),
+			       GR_GLOBAL_GID(cred->gid), task->exec_file ?
+			       gr_to_filename(task->exec_file->f_path.dentry,
+			       task->exec_file->f_path.mnt) : curracl->filename,
+			       curracl->filename, 0UL,
+			       0UL, "", (unsigned long) cap, &task->signal->saved_ip);
+		return 1;
+	}
+
+	return 0;
+}
+
+int gr_task_acl_is_capable(const struct task_struct *task, const struct cred *cred, const int cap, bool log)
+{
+	struct acl_subject_label *curracl;
+	kernel_cap_t cap_drop = __cap_empty_set, cap_mask = __cap_empty_set;
+	kernel_cap_t cap_audit = __cap_empty_set;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	curracl = task->acl;
+
+	cap_drop = curracl->cap_lower;
+	cap_mask = curracl->cap_mask;
+	cap_audit = curracl->cap_invert_audit;
+
+	while ((curracl = curracl->parent_subject)) {
+		/* if the cap isn't specified in the current computed mask but is specified in the
+		   current level subject, and is lowered in the current level subject, then add
+		   it to the set of dropped capabilities
+		   otherwise, add the current level subject's mask to the current computed mask
+		 */
+		if (!cap_raised(cap_mask, cap) && cap_raised(curracl->cap_mask, cap)) {
+			cap_raise(cap_mask, cap);
+			if (cap_raised(curracl->cap_lower, cap))
+				cap_raise(cap_drop, cap);
+			if (cap_raised(curracl->cap_invert_audit, cap))
+				cap_raise(cap_audit, cap);
+		}
+	}
+
+	if (!cap_raised(cap_drop, cap)) {
+		if (log && cap_raised(cap_audit, cap))
+			gr_log_cap(GR_DO_AUDIT, GR_CAP_ACL_MSG2, task, captab_log[cap]);
+		return 1;
+	}
+
+	/* only learn the capability use if the process has the capability in the
+	   general case, the two uses in sys.c of gr_learn_cap are an exception
+	   to this rule to ensure any role transition involves what the full-learned
+	   policy believes in a privileged process
+	*/
+	if (cap_raised(cred->cap_effective, cap) && gr_learn_cap(task, cred, cap, log))
+		return 1;
+
+	if (log && (cap >= 0) && (cap < captab_log_entries) && cap_raised(cred->cap_effective, cap) && !cap_raised(cap_audit, cap))
+		gr_log_cap(GR_DONT_AUDIT, GR_CAP_ACL_MSG, task, captab_log[cap]);
+
+	return 0;
+}
+
+int
+gr_acl_is_capable(const int cap)
+{
+	return gr_task_acl_is_capable(current, current_cred(), cap, true);
+}
+
+int
+gr_acl_is_capable_nolog(const int cap)
+{
+	return gr_task_acl_is_capable(current, current_cred(), cap, false);
+}
+
diff --git a/grsecurity/gracl_compat.c b/grsecurity/gracl_compat.c
new file mode 100644
index 000000000000..a43dd06a2747
--- /dev/null
+++ b/grsecurity/gracl_compat.c
@@ -0,0 +1,269 @@
+#include <linux/kernel.h>
+#include <linux/gracl.h>
+#include <linux/compat.h>
+#include <linux/gracl_compat.h>
+
+#include <asm/uaccess.h>
+
+int copy_gr_arg_wrapper_compat(const char *buf, struct gr_arg_wrapper *uwrap)
+{
+	struct gr_arg_wrapper_compat uwrapcompat;
+
+        if (copy_from_user(&uwrapcompat, buf, sizeof(uwrapcompat)))
+                return -EFAULT;
+
+        if ((uwrapcompat.version != GRSECURITY_VERSION) ||
+	    (uwrapcompat.size != sizeof(struct gr_arg_compat)))  
+                return -EINVAL;
+
+	uwrap->arg = compat_ptr(uwrapcompat.arg);
+	uwrap->version = uwrapcompat.version;
+	uwrap->size = sizeof(struct gr_arg);
+
+        return 0;
+}
+
+int copy_gr_arg_compat(const struct gr_arg __user *buf, struct gr_arg *arg)
+{
+	struct gr_arg_compat argcompat;
+
+        if (copy_from_user(&argcompat, buf, sizeof(argcompat)))
+                return -EFAULT;
+
+	arg->role_db.r_table = compat_ptr(argcompat.role_db.r_table);
+	arg->role_db.num_pointers = argcompat.role_db.num_pointers;
+	arg->role_db.num_roles = argcompat.role_db.num_roles;
+	arg->role_db.num_domain_children = argcompat.role_db.num_domain_children;
+	arg->role_db.num_subjects = argcompat.role_db.num_subjects;
+	arg->role_db.num_objects = argcompat.role_db.num_objects;
+
+	memcpy(&arg->pw, &argcompat.pw, sizeof(arg->pw));
+	memcpy(&arg->salt, &argcompat.salt, sizeof(arg->salt));
+	memcpy(&arg->sum, &argcompat.sum, sizeof(arg->sum));
+	memcpy(&arg->sp_role, &argcompat.sp_role, sizeof(arg->sp_role));
+	arg->sprole_pws = compat_ptr(argcompat.sprole_pws);
+	arg->segv_device = argcompat.segv_device;
+	arg->segv_inode = argcompat.segv_inode;
+	arg->segv_uid = argcompat.segv_uid;
+	arg->num_sprole_pws = argcompat.num_sprole_pws;
+	arg->mode = argcompat.mode;
+
+	return 0;
+}
+
+int copy_acl_object_label_compat(struct acl_object_label *obj, const struct acl_object_label *userp)
+{
+	struct acl_object_label_compat objcompat;
+
+	if (copy_from_user(&objcompat, userp, sizeof(objcompat)))
+                return -EFAULT;
+
+	obj->filename = compat_ptr(objcompat.filename);
+	obj->inode = objcompat.inode;
+	obj->device = objcompat.device;
+	obj->mode = objcompat.mode;
+
+	obj->nested = compat_ptr(objcompat.nested);
+	obj->globbed = compat_ptr(objcompat.globbed);
+
+	obj->prev = compat_ptr(objcompat.prev);
+	obj->next = compat_ptr(objcompat.next);
+
+	return 0;
+}
+
+int copy_acl_subject_label_compat(struct acl_subject_label *subj, const struct acl_subject_label *userp)
+{
+	unsigned int i;
+	struct acl_subject_label_compat subjcompat;
+
+	if (copy_from_user(&subjcompat, userp, sizeof(subjcompat)))
+                return -EFAULT;
+
+	subj->filename = compat_ptr(subjcompat.filename);
+	subj->inode = subjcompat.inode;
+	subj->device = subjcompat.device;
+	subj->mode = subjcompat.mode;
+	subj->cap_mask = subjcompat.cap_mask;
+	subj->cap_lower = subjcompat.cap_lower;
+	subj->cap_invert_audit = subjcompat.cap_invert_audit;
+
+	for (i = 0; i < GR_NLIMITS; i++) {
+		if (subjcompat.res[i].rlim_cur == COMPAT_RLIM_INFINITY)
+			subj->res[i].rlim_cur = RLIM_INFINITY;
+		else
+			subj->res[i].rlim_cur = subjcompat.res[i].rlim_cur;
+		if (subjcompat.res[i].rlim_max == COMPAT_RLIM_INFINITY)
+			subj->res[i].rlim_max = RLIM_INFINITY;
+		else
+			subj->res[i].rlim_max = subjcompat.res[i].rlim_max;
+	}
+	subj->resmask = subjcompat.resmask;
+
+	subj->user_trans_type = subjcompat.user_trans_type;
+	subj->group_trans_type = subjcompat.group_trans_type;
+	subj->user_transitions = compat_ptr(subjcompat.user_transitions);
+	subj->group_transitions = compat_ptr(subjcompat.group_transitions);
+	subj->user_trans_num = subjcompat.user_trans_num;
+	subj->group_trans_num = subjcompat.group_trans_num;
+
+	memcpy(&subj->sock_families, &subjcompat.sock_families, sizeof(subj->sock_families));
+	memcpy(&subj->ip_proto, &subjcompat.ip_proto, sizeof(subj->ip_proto));
+	subj->ip_type = subjcompat.ip_type;
+	subj->ips = compat_ptr(subjcompat.ips);
+	subj->ip_num = subjcompat.ip_num;
+	subj->inaddr_any_override = subjcompat.inaddr_any_override;
+
+	subj->crashes = subjcompat.crashes;
+	subj->expires = subjcompat.expires;
+
+	subj->parent_subject = compat_ptr(subjcompat.parent_subject);
+	subj->hash = compat_ptr(subjcompat.hash);
+	subj->prev = compat_ptr(subjcompat.prev);
+	subj->next = compat_ptr(subjcompat.next);
+
+	subj->obj_hash = compat_ptr(subjcompat.obj_hash);
+	subj->obj_hash_size = subjcompat.obj_hash_size;
+	subj->pax_flags = subjcompat.pax_flags;
+
+	return 0;
+}
+
+int copy_acl_role_label_compat(struct acl_role_label *role, const struct acl_role_label *userp)
+{
+	struct acl_role_label_compat rolecompat;
+
+	if (copy_from_user(&rolecompat, userp, sizeof(rolecompat)))
+                return -EFAULT;
+
+	role->rolename = compat_ptr(rolecompat.rolename);
+	role->uidgid = rolecompat.uidgid;
+	role->roletype = rolecompat.roletype;
+
+	role->auth_attempts = rolecompat.auth_attempts;
+	role->expires = rolecompat.expires;
+
+	role->root_label = compat_ptr(rolecompat.root_label);
+	role->hash = compat_ptr(rolecompat.hash);
+
+	role->prev = compat_ptr(rolecompat.prev);
+	role->next = compat_ptr(rolecompat.next);
+
+	role->transitions = compat_ptr(rolecompat.transitions);
+	role->allowed_ips = compat_ptr(rolecompat.allowed_ips);
+	role->domain_children = compat_ptr(rolecompat.domain_children);
+	role->domain_child_num = rolecompat.domain_child_num;
+
+	role->umask = rolecompat.umask;
+
+	role->subj_hash = compat_ptr(rolecompat.subj_hash);
+	role->subj_hash_size = rolecompat.subj_hash_size;
+
+	return 0;
+}
+
+int copy_role_allowed_ip_compat(struct role_allowed_ip *roleip, const struct role_allowed_ip *userp)
+{
+	struct role_allowed_ip_compat roleip_compat;
+
+	if (copy_from_user(&roleip_compat, userp, sizeof(roleip_compat)))
+                return -EFAULT;
+
+	roleip->addr = roleip_compat.addr;
+	roleip->netmask = roleip_compat.netmask;
+
+	roleip->prev = compat_ptr(roleip_compat.prev);
+	roleip->next = compat_ptr(roleip_compat.next);
+
+	return 0;
+}
+
+int copy_role_transition_compat(struct role_transition *trans, const struct role_transition *userp)
+{
+	struct role_transition_compat trans_compat;
+
+	if (copy_from_user(&trans_compat, userp, sizeof(trans_compat)))
+                return -EFAULT;
+
+	trans->rolename = compat_ptr(trans_compat.rolename);
+
+	trans->prev = compat_ptr(trans_compat.prev);
+	trans->next = compat_ptr(trans_compat.next);
+
+	return 0;
+
+}
+
+int copy_gr_hash_struct_compat(struct gr_hash_struct *hash, const struct gr_hash_struct *userp)
+{
+	struct gr_hash_struct_compat hash_compat;
+
+	if (copy_from_user(&hash_compat, userp, sizeof(hash_compat)))
+                return -EFAULT;
+
+	hash->table = compat_ptr(hash_compat.table);
+	hash->nametable = compat_ptr(hash_compat.nametable);
+	hash->first = compat_ptr(hash_compat.first);
+
+	hash->table_size = hash_compat.table_size;
+	hash->used_size = hash_compat.used_size;
+
+	hash->type = hash_compat.type;
+
+	return 0;
+}
+
+int copy_pointer_from_array_compat(void *ptr, unsigned long idx, const void *userp)
+{
+	compat_uptr_t ptrcompat;
+
+	if (copy_from_user(&ptrcompat, userp + (idx * sizeof(ptrcompat)), sizeof(ptrcompat)))
+                return -EFAULT;
+
+	*(void **)ptr = compat_ptr(ptrcompat);
+
+	return 0;
+}
+
+int copy_acl_ip_label_compat(struct acl_ip_label *ip, const struct acl_ip_label *userp)
+{
+	struct acl_ip_label_compat ip_compat;
+
+	if (copy_from_user(&ip_compat, userp, sizeof(ip_compat)))
+                return -EFAULT;
+
+	ip->iface = compat_ptr(ip_compat.iface);
+	ip->addr = ip_compat.addr;
+	ip->netmask = ip_compat.netmask;
+	ip->low = ip_compat.low;
+	ip->high = ip_compat.high;
+	ip->mode = ip_compat.mode;
+	ip->type = ip_compat.type;
+
+	memcpy(&ip->proto, &ip_compat.proto, sizeof(ip->proto));
+
+	ip->prev = compat_ptr(ip_compat.prev);
+	ip->next = compat_ptr(ip_compat.next);
+
+	return 0;
+}
+
+int copy_sprole_pw_compat(struct sprole_pw *pw, unsigned long idx, const struct sprole_pw *userp)
+{
+	struct sprole_pw_compat pw_compat;
+
+	if (copy_from_user(&pw_compat, (const void *)userp + (sizeof(pw_compat) * idx), sizeof(pw_compat)))
+                return -EFAULT;
+
+	pw->rolename = compat_ptr(pw_compat.rolename);
+	memcpy(&pw->salt, pw_compat.salt, sizeof(pw->salt));
+	memcpy(&pw->sum, pw_compat.sum, sizeof(pw->sum));
+
+	return 0;
+}
+
+size_t get_gr_arg_wrapper_size_compat(void)
+{
+	return sizeof(struct gr_arg_wrapper_compat);
+}
+
diff --git a/grsecurity/gracl_fs.c b/grsecurity/gracl_fs.c
new file mode 100644
index 000000000000..fce7f71fb055
--- /dev/null
+++ b/grsecurity/gracl_fs.c
@@ -0,0 +1,448 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+umode_t
+gr_acl_umask(void)
+{
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	return current->role->umask;
+}
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	__u32 mode;
+
+	if (unlikely(d_is_negative(dentry)))
+		return GR_FIND;
+
+	mode =
+	    gr_search_file(dentry, GR_FIND | GR_AUDIT_FIND | GR_SUPPRESS, mnt);
+
+	if (unlikely(mode & GR_FIND && mode & GR_AUDIT_FIND)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return mode;
+	} else if (unlikely(!(mode & GR_FIND) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_FIND)))
+		return 0;
+
+	return GR_FIND;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   int acc_mode)
+{
+	__u32 reqmode = GR_FIND;
+	__u32 mode;
+
+	if (unlikely(d_is_negative(dentry)))
+		return reqmode;
+
+	if (acc_mode & MAY_APPEND)
+		reqmode |= GR_APPEND;
+	else if (acc_mode & MAY_WRITE)
+		reqmode |= GR_WRITE;
+	if ((acc_mode & MAY_READ) && !d_is_dir(dentry))
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, int open_flags, int acc_mode,
+		    const int imode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	if (acc_mode & MAY_APPEND)
+		reqmode |= GR_APPEND;
+	// if a directory was required or the directory already exists, then
+	// don't count this open as a read
+	if ((acc_mode & MAY_READ) &&
+	    !((open_flags & O_DIRECTORY) || d_is_dir(dentry)))
+		reqmode |= GR_READ;
+	if ((open_flags & O_CREAT) &&
+	    ((imode & S_ISUID) || ((imode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))))
+		reqmode |= GR_SETID;
+
+	mode =
+	    gr_check_create(dentry, p_dentry, p_mnt,
+			    reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry, const struct vfsmount * mnt,
+		     const int fmode)
+{
+	__u32 mode, reqmode = GR_FIND;
+
+	if ((fmode & S_IXOTH) && !d_is_dir(dentry))
+		reqmode |= GR_EXEC;
+	if (fmode & S_IWOTH)
+		reqmode |= GR_WRITE;
+	if (fmode & S_IROTH)
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode3(GR_DO_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode3(GR_DONT_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+static __u32 generic_fs_handler(const struct dentry *dentry, const struct vfsmount *mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS, mnt);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, dentry, mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, dentry, mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_RMDIR_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_UNLINK_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_TRUNCATE_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_ATIME_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry *dentry, const struct vfsmount *mnt,
+		     umode_t *modeptr)
+{
+	umode_t mode;
+	struct inode *inode = d_backing_inode(dentry);
+
+	*modeptr &= ~gr_acl_umask();
+	mode = *modeptr;
+
+	if (unlikely(inode && S_ISSOCK(inode->i_mode)))
+		return 1;
+
+	if (unlikely(!d_is_dir(dentry) &&
+		     ((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))))) {
+		return generic_fs_handler(dentry, mnt, GR_WRITE | GR_SETID,
+				   GR_CHMOD_ACL_MSG);
+	} else {
+		return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHMOD_ACL_MSG);
+	}
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHOWN_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_setxattr(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_SETXATTR_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_removexattr(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_REMOVEXATTR_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_EXEC, GR_EXEC_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_READ | GR_WRITE,
+			   GR_UNIXCONNECT_ACL_MSG);
+}
+
+/* hardlinks require at minimum create and link permission,
+   any additional privilege required is based on the
+   privilege of the file being linked to
+*/
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const struct filename *to)
+{
+	__u32 mode;
+	__u32 needmode = GR_CREATE | GR_LINK;
+	__u32 needaudit = GR_AUDIT_CREATE | GR_AUDIT_LINK;
+
+	mode =
+	    gr_check_link(new_dentry, parent_dentry, parent_mnt, old_dentry,
+			  old_mnt);
+
+	if (unlikely(((mode & needmode) == needmode) && (mode & needaudit))) {
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to->name);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to->name);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const struct filename *from)
+{
+	__u32 needmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	mode =
+	    gr_check_create(new_dentry, parent_dentry, parent_mnt,
+			    GR_CREATE | GR_AUDIT_CREATE |
+			    GR_WRITE | GR_AUDIT_WRITE | GR_SUPPRESS);
+
+	if (unlikely(mode & GR_WRITE && mode & GR_AUDITS)) {
+		gr_log_fs_str_rbac(GR_DO_AUDIT, GR_SYMLINK_ACL_MSG, from->name, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_str_rbac(GR_DONT_AUDIT, GR_SYMLINK_ACL_MSG, from->name, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return (GR_WRITE | GR_CREATE);
+}
+
+static __u32 generic_fs_create_handler(const struct dentry *new_dentry, const struct dentry *parent_dentry, const struct vfsmount *parent_mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_check_create(new_dentry, parent_dentry, parent_mnt, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	if (unlikely((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))))
+		reqmode |= GR_SETID;
+
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  reqmode, GR_MKNOD_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry *new_dentry,
+		    const struct dentry *parent_dentry,
+		    const struct vfsmount *parent_mnt)
+{
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  GR_WRITE | GR_CREATE, GR_MKDIR_ACL_MSG);
+}
+
+#define RENAME_CHECK_SUCCESS(old, new) \
+	(((old & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)) && \
+	 ((new & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)))
+
+int
+gr_acl_handle_rename(struct dentry *new_dentry,
+		     struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     struct dentry *old_dentry,
+		     struct inode *old_parent_inode,
+		     struct vfsmount *old_mnt, const struct filename *newname, unsigned int flags)
+{
+	__u32 comp1, comp2;
+	int error = 0;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	if (flags & RENAME_EXCHANGE) {
+		comp1 = gr_search_file(new_dentry, GR_READ | GR_WRITE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, parent_mnt);
+		comp2 =
+		    gr_search_file(old_dentry,
+				   GR_READ | GR_WRITE | GR_AUDIT_READ |
+				   GR_AUDIT_WRITE | GR_SUPPRESS, old_mnt);
+	} else if (d_is_negative(new_dentry)) {
+		comp1 = gr_check_create(new_dentry, parent_dentry, parent_mnt,
+					GR_READ | GR_WRITE | GR_CREATE | GR_AUDIT_READ |
+					GR_AUDIT_WRITE | GR_AUDIT_CREATE | GR_SUPPRESS);
+		comp2 = gr_search_file(old_dentry, GR_READ | GR_WRITE |
+				       GR_DELETE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, old_mnt);
+	} else {
+		comp1 = gr_search_file(new_dentry, GR_READ | GR_WRITE |
+				       GR_CREATE | GR_DELETE |
+				       GR_AUDIT_CREATE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, parent_mnt);
+		comp2 =
+		    gr_search_file(old_dentry,
+				   GR_READ | GR_WRITE | GR_AUDIT_READ |
+				   GR_DELETE | GR_AUDIT_DELETE |
+				   GR_AUDIT_WRITE | GR_SUPPRESS, old_mnt);
+	}
+
+	if (RENAME_CHECK_SUCCESS(comp1, comp2) &&
+	    ((comp1 & GR_AUDITS) || (comp2 & GR_AUDITS)))
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname->name);
+	else if (!RENAME_CHECK_SUCCESS(comp1, comp2) && !(comp1 & GR_SUPPRESS)
+		 && !(comp2 & GR_SUPPRESS)) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname->name);
+		error = -EACCES;
+	} else if (unlikely(!RENAME_CHECK_SUCCESS(comp1, comp2)))
+		error = -EACCES;
+
+	return error;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	u16 id;
+	char *rolename;
+
+	if (unlikely(current->acl_sp_role && gr_acl_is_enabled() &&
+	    !(current->role->roletype & GR_ROLE_PERSIST))) {
+		id = current->acl_role_id;
+		rolename = current->role->rolename;
+		gr_set_acls(1);
+		gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLEL_ACL_MSG, rolename, id);
+	}
+
+	gr_put_exec_file(current);
+	return;
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	if (task != current && (task->acl->mode & GR_PROTPROCFD) &&
+	    !(current->acl->mode & GR_POVERRIDE) &&
+	    !(current->role->roletype & GR_ROLE_GOD))
+		return -EACCES;
+
+	return 0;
+}
diff --git a/grsecurity/gracl_ip.c b/grsecurity/gracl_ip.c
new file mode 100644
index 000000000000..d877c3879fa6
--- /dev/null
+++ b/grsecurity/gracl_ip.c
@@ -0,0 +1,387 @@
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+#define GR_BIND			0x01
+#define GR_CONNECT		0x02
+#define GR_INVERT		0x04
+#define GR_BINDOVERRIDE		0x08
+#define GR_CONNECTOVERRIDE	0x10
+#define GR_SOCK_FAMILY		0x20
+
+static const char * gr_protocols[IPPROTO_MAX] = {
+	"ip", "icmp", "igmp", "ggp", "ipencap", "st", "tcp", "cbt",
+	"egp", "igp", "bbn-rcc", "nvp", "pup", "argus", "emcon", "xnet",
+	"chaos", "udp", "mux", "dcn", "hmp", "prm", "xns-idp", "trunk-1",
+	"trunk-2", "leaf-1", "leaf-2", "rdp", "irtp", "iso-tp4", "netblt", "mfe-nsp",
+	"merit-inp", "sep", "3pc", "idpr", "xtp", "ddp", "idpr-cmtp", "tp++",
+	"il", "ipv6", "sdrp", "ipv6-route", "ipv6-frag", "idrp", "rsvp", "gre",
+	"mhrp", "bna", "ipv6-crypt", "ipv6-auth", "i-nlsp", "swipe", "narp", "mobile",
+	"tlsp", "skip", "ipv6-icmp", "ipv6-nonxt", "ipv6-opts", "unknown:61", "cftp", "unknown:63",
+	"sat-expak", "kryptolan", "rvd", "ippc", "unknown:68", "sat-mon", "visa", "ipcv",
+	"cpnx", "cphb", "wsn", "pvp", "br-sat-mon", "sun-nd", "wb-mon", "wb-expak", 
+	"iso-ip", "vmtp", "secure-vmtp", "vines", "ttp", "nfsnet-igp", "dgp", "tcf", 
+	"eigrp", "ospf", "sprite-rpc", "larp", "mtp", "ax.25", "ipip", "micp",
+	"scc-sp", "etherip", "encap", "unknown:99", "gmtp", "ifmp", "pnni", "pim",
+	"aris", "scps", "qnx", "a/n", "ipcomp", "snp", "compaq-peer", "ipx-in-ip",
+	"vrrp", "pgm", "unknown:114", "l2tp", "ddx", "iatp", "stp", "srp",
+	"uti", "smp", "sm", "ptp", "isis", "fire", "crtp", "crdup",
+	"sscopmce", "iplt", "sps", "pipe", "sctp", "fc", "unkown:134", "unknown:135",
+	"unknown:136", "unknown:137", "unknown:138", "unknown:139", "unknown:140", "unknown:141", "unknown:142", "unknown:143",
+	"unknown:144", "unknown:145", "unknown:146", "unknown:147", "unknown:148", "unknown:149", "unknown:150", "unknown:151",
+	"unknown:152", "unknown:153", "unknown:154", "unknown:155", "unknown:156", "unknown:157", "unknown:158", "unknown:159",
+	"unknown:160", "unknown:161", "unknown:162", "unknown:163", "unknown:164", "unknown:165", "unknown:166", "unknown:167",
+	"unknown:168", "unknown:169", "unknown:170", "unknown:171", "unknown:172", "unknown:173", "unknown:174", "unknown:175",
+	"unknown:176", "unknown:177", "unknown:178", "unknown:179", "unknown:180", "unknown:181", "unknown:182", "unknown:183",
+	"unknown:184", "unknown:185", "unknown:186", "unknown:187", "unknown:188", "unknown:189", "unknown:190", "unknown:191",
+	"unknown:192", "unknown:193", "unknown:194", "unknown:195", "unknown:196", "unknown:197", "unknown:198", "unknown:199",
+	"unknown:200", "unknown:201", "unknown:202", "unknown:203", "unknown:204", "unknown:205", "unknown:206", "unknown:207",
+	"unknown:208", "unknown:209", "unknown:210", "unknown:211", "unknown:212", "unknown:213", "unknown:214", "unknown:215",
+	"unknown:216", "unknown:217", "unknown:218", "unknown:219", "unknown:220", "unknown:221", "unknown:222", "unknown:223",
+	"unknown:224", "unknown:225", "unknown:226", "unknown:227", "unknown:228", "unknown:229", "unknown:230", "unknown:231",
+	"unknown:232", "unknown:233", "unknown:234", "unknown:235", "unknown:236", "unknown:237", "unknown:238", "unknown:239",
+	"unknown:240", "unknown:241", "unknown:242", "unknown:243", "unknown:244", "unknown:245", "unknown:246", "unknown:247",
+	"unknown:248", "unknown:249", "unknown:250", "unknown:251", "unknown:252", "unknown:253", "unknown:254", "unknown:255",
+	};
+
+static const char * gr_socktypes[SOCK_MAX] = {
+	"unknown:0", "stream", "dgram", "raw", "rdm", "seqpacket", "unknown:6", 
+	"unknown:7", "unknown:8", "unknown:9", "packet"
+	};
+
+static const char * gr_sockfamilies[AF_MAX] = {
+	"unspec", "unix", "inet", "ax25", "ipx", "appletalk", "netrom", "bridge", "atmpvc", "x25",
+	"inet6", "rose", "decnet", "netbeui", "security", "key", "netlink", "packet", "ash",
+	"econet", "atmsvc", "rds", "sna", "irda", "ppox", "wanpipe", "llc", "ib", "mpls", "can",
+	"tipc", "bluetooth", "iucv", "rxrpc", "isdn", "phonet", "ieee802154", "ciaf", "alg",
+	"nfc", "vsock", "kcm", "qipcrtr"
+	};
+
+const char *
+gr_proto_to_name(unsigned char proto)
+{
+	return gr_protocols[proto];
+}
+
+const char *
+gr_socktype_to_name(unsigned char type)
+{
+	return gr_socktypes[type];
+}
+
+const char *
+gr_sockfamily_to_name(unsigned char family)
+{
+	return gr_sockfamilies[family];
+}
+
+extern const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;
+
+int
+gr_search_socket(const int domain, const int type, const int protocol)
+{
+	struct acl_subject_label *curr;
+	const struct cred *cred = current_cred();
+
+	if (unlikely(!gr_acl_is_enabled()))
+		goto exit;
+
+	if ((domain < 0) || (type < 0) || (protocol < 0) ||
+	    (domain >= AF_MAX) || (type >= SOCK_MAX) || (protocol >= IPPROTO_MAX))
+		goto exit;	// let the kernel handle it
+
+	curr = current->acl;
+
+	if (curr->sock_families[domain / 32] & (1U << (domain % 32))) {
+		/* the family is allowed, if this is PF_INET allow it only if
+		   the extra sock type/protocol checks pass */
+		if (domain == PF_INET)
+			goto inet_check;
+		goto exit;
+	} else {
+		if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, GR_GLOBAL_UID(cred->uid),
+				       GR_GLOBAL_GID(cred->gid), current->exec_file ?
+				       gr_to_filename(current->exec_file->f_path.dentry,
+				       current->exec_file->f_path.mnt) :
+				       curr->filename, curr->filename,
+				       &fakeip, domain, 0, 0, GR_SOCK_FAMILY,
+				       &current->signal->saved_ip);
+			goto exit;
+		}
+		goto exit_fail;
+	}
+
+inet_check:
+	/* the rest of this checking is for IPv4 only */
+	if (!curr->ips)
+		goto exit;
+
+	if ((curr->ip_type & (1U << type)) &&
+	    (curr->ip_proto[protocol / 32] & (1U << (protocol % 32))))
+		goto exit;
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		/* we don't place acls on raw sockets , and sometimes
+		   dgram/ip sockets are opened for ioctl and not
+		   bind/connect, so we'll fake a bind learn log */
+		if (type == SOCK_RAW || type == SOCK_PACKET) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, GR_GLOBAL_UID(cred->uid),
+				       GR_GLOBAL_GID(cred->gid), current->exec_file ?
+				       gr_to_filename(current->exec_file->f_path.dentry,
+				       current->exec_file->f_path.mnt) :
+				       curr->filename, curr->filename,
+				       &fakeip, 0, type,
+				       protocol, GR_CONNECT, &current->signal->saved_ip);
+		} else if ((type == SOCK_DGRAM) && (protocol == IPPROTO_IP)) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, GR_GLOBAL_UID(cred->uid),
+				       GR_GLOBAL_GID(cred->gid), current->exec_file ?
+				       gr_to_filename(current->exec_file->f_path.dentry,
+				       current->exec_file->f_path.mnt) :
+				       curr->filename, curr->filename,
+				       &fakeip, 0, type,
+				       protocol, GR_BIND, &current->signal->saved_ip);
+		}
+		/* we'll log when they use connect or bind */
+		goto exit;
+	}
+
+exit_fail:
+	if (domain == PF_INET)
+		gr_log_str3(GR_DONT_AUDIT, GR_SOCK_MSG, gr_sockfamily_to_name(domain), 
+			    gr_socktype_to_name(type), gr_proto_to_name(protocol));
+	else if (rcu_access_pointer(net_families[domain]) != NULL)
+		gr_log_str2_int(GR_DONT_AUDIT, GR_SOCK_NOINET_MSG, gr_sockfamily_to_name(domain), 
+			    gr_socktype_to_name(type), protocol);
+
+	return 0;
+exit:
+	return 1;
+}
+
+int check_ip_policy(struct acl_ip_label *ip, __u32 ip_addr, __u16 ip_port, __u8 protocol, const int mode, const int type, __u32 our_addr, __u32 our_netmask)
+{
+	if ((ip->mode & mode) &&
+	    (ip_port >= ip->low) &&
+	    (ip_port <= ip->high) &&
+	    ((ntohl(ip_addr) & our_netmask) ==
+	     (ntohl(our_addr) & our_netmask))
+	    && (ip->proto[protocol / 32] & (1U << (protocol % 32)))
+	    && (ip->type & (1U << type))) {
+		if (ip->mode & GR_INVERT)
+			return 2; // specifically denied
+		else
+			return 1; // allowed
+	}
+
+	return 0; // not specifically allowed, may continue parsing
+}
+
+static int
+gr_search_connectbind(const int full_mode, struct sock *sk,
+		      struct sockaddr_in *addr, const int type)
+{
+	char iface[IFNAMSIZ] = {0};
+	struct acl_subject_label *curr;
+	struct acl_ip_label *ip;
+	struct inet_sock *isk;
+	struct net_device *dev;
+	struct in_device *idev;
+	unsigned long i;
+	int ret;
+	int mode = full_mode & (GR_BIND | GR_CONNECT);
+	__u32 ip_addr = 0;
+	__u32 our_addr;
+	__u32 our_netmask;
+	char *p;
+	__u16 ip_port = 0;
+	const struct cred *cred = current_cred();
+
+	if (unlikely(!gr_acl_is_enabled() || sk->sk_family != PF_INET))
+		return 0;
+
+	curr = current->acl;
+	isk = inet_sk(sk);
+
+	/* INADDR_ANY overriding for binds, inaddr_any_override is already in network order */
+	if ((full_mode & GR_BINDOVERRIDE) && addr->sin_addr.s_addr == htonl(INADDR_ANY) && curr->inaddr_any_override != 0)
+		addr->sin_addr.s_addr = curr->inaddr_any_override;
+	if ((full_mode & GR_CONNECT) && isk->inet_saddr == htonl(INADDR_ANY) && curr->inaddr_any_override != 0) {
+		struct sockaddr_in saddr;
+		int err;
+
+		saddr.sin_family = AF_INET;
+		saddr.sin_addr.s_addr = curr->inaddr_any_override;
+		saddr.sin_port = isk->inet_sport;
+
+		err = security_socket_bind(sk->sk_socket, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in));
+		if (err)
+			return err;
+
+		err = sk->sk_socket->ops->bind(sk->sk_socket, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in));
+		if (err)
+			return err;
+	}
+
+	if (!curr->ips)
+		return 0;
+
+	ip_addr = addr->sin_addr.s_addr;
+	ip_port = ntohs(addr->sin_port);
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+			       current->role->roletype, GR_GLOBAL_UID(cred->uid),
+			       GR_GLOBAL_GID(cred->gid), current->exec_file ?
+			       gr_to_filename(current->exec_file->f_path.dentry,
+			       current->exec_file->f_path.mnt) :
+			       curr->filename, curr->filename,
+			       &ip_addr, ip_port, type,
+			       sk->sk_protocol, mode, &current->signal->saved_ip);
+		return 0;
+	}
+
+	for (i = 0; i < curr->ip_num; i++) {
+		ip = *(curr->ips + i);
+		if (ip->iface != NULL) {
+			strncpy(iface, ip->iface, IFNAMSIZ - 1);
+			p = strchr(iface, ':');
+			if (p != NULL)
+				*p = '\0';
+			dev = dev_get_by_name(sock_net(sk), iface);
+			if (dev == NULL)
+				continue;
+			idev = in_dev_get(dev);
+			if (idev == NULL) {
+				dev_put(dev);
+				continue;
+			}
+			rcu_read_lock();
+			for_ifa(idev) {
+				if (!strcmp(ip->iface, ifa->ifa_label)) {
+					our_addr = ifa->ifa_address;
+					our_netmask = 0xffffffff;
+					ret = check_ip_policy(ip, ip_addr, ip_port, sk->sk_protocol, mode, type, our_addr, our_netmask);
+					if (ret == 1) {
+						rcu_read_unlock();
+						in_dev_put(idev);
+						dev_put(dev);
+						return 0;
+					} else if (ret == 2) {
+						rcu_read_unlock();
+						in_dev_put(idev);
+						dev_put(dev);
+						goto denied;
+					}
+				}
+			} endfor_ifa(idev);
+			rcu_read_unlock();
+			in_dev_put(idev);
+			dev_put(dev);
+		} else {
+			our_addr = ip->addr;
+			our_netmask = ip->netmask;
+			ret = check_ip_policy(ip, ip_addr, ip_port, sk->sk_protocol, mode, type, our_addr, our_netmask);
+			if (ret == 1)
+				return 0;
+			else if (ret == 2)
+				goto denied;
+		}
+	}
+
+denied:
+	if (mode == GR_BIND)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_BIND_ACL_MSG, &ip_addr, ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->sk_protocol));
+	else if (mode == GR_CONNECT)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_CONNECT_ACL_MSG, &ip_addr, ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->sk_protocol));
+
+	return -EACCES;
+}
+
+int
+gr_search_connect(struct socket *sock, struct sockaddr_in *addr)
+{
+	/* always allow disconnection of dgram sockets with connect */
+	if (addr->sin_family == AF_UNSPEC)
+		return 0;
+	return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sock->sk, addr, sock->type);
+}
+
+int
+gr_search_bind(struct socket *sock, struct sockaddr_in *addr)
+{
+	return gr_search_connectbind(GR_BIND | GR_BINDOVERRIDE, sock->sk, addr, sock->type);
+}
+
+int gr_search_listen(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = inet_sk(sk)->inet_saddr;
+	addr.sin_port = inet_sk(sk)->inet_sport;
+
+	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
+}
+
+int gr_search_accept(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = inet_sk(sk)->inet_saddr;
+	addr.sin_port = inet_sk(sk)->inet_sport;
+
+	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
+}
+
+int
+gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr)
+{
+	if (addr)
+		return gr_search_connectbind(GR_CONNECT, sk, addr, SOCK_DGRAM);
+	else {
+		struct sockaddr_in sin;
+		const struct inet_sock *inet = inet_sk(sk);
+
+		sin.sin_addr.s_addr = inet->inet_daddr;
+		sin.sin_port = inet->inet_dport;
+
+		return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, &sin, SOCK_DGRAM);
+	}
+}
+
+int
+gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb)
+{
+	struct sockaddr_in sin;
+
+	if (unlikely(skb->len < sizeof (struct udphdr)))
+		return 0;	// skip this packet
+
+	sin.sin_addr.s_addr = ip_hdr(skb)->saddr;
+	sin.sin_port = udp_hdr(skb)->source;
+
+	return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, &sin, SOCK_DGRAM);
+}
diff --git a/grsecurity/gracl_learn.c b/grsecurity/gracl_learn.c
new file mode 100644
index 000000000000..c5abda5c83e3
--- /dev/null
+++ b/grsecurity/gracl_learn.c
@@ -0,0 +1,209 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/string.h>
+#include <linux/file.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/grinternal.h>
+
+extern ssize_t write_grsec_handler(struct file * file, const char __user * buf,
+				   size_t count, loff_t *ppos);
+extern int gr_acl_is_enabled(void);
+
+static DECLARE_WAIT_QUEUE_HEAD(learn_wait);
+static int gr_learn_attached;
+
+/* use a 512k buffer */
+#define LEARN_BUFFER_SIZE (512 * 1024)
+
+static DEFINE_SPINLOCK(gr_learn_lock);
+static DEFINE_MUTEX(gr_learn_user_mutex);
+
+/* we need to maintain two buffers, so that the kernel context of grlearn
+   uses a semaphore around the userspace copying, and the other kernel contexts
+   use a spinlock when copying into the buffer, since they cannot sleep
+*/
+static char *learn_buffer;
+static char *learn_buffer_user;
+static int learn_buffer_len;
+static int learn_buffer_user_len;
+
+static ssize_t
+read_learn(struct file *file, char __user * buf, size_t count, loff_t * ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t retval = 0;
+
+	add_wait_queue(&learn_wait, &wait);
+	do {
+		mutex_lock(&gr_learn_user_mutex);
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock(&gr_learn_lock);
+		if (learn_buffer_len) {
+			set_current_state(TASK_RUNNING);
+			break;
+		}
+		spin_unlock(&gr_learn_lock);
+		mutex_unlock(&gr_learn_user_mutex);
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			goto out;
+		}
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			goto out;
+		}
+
+		schedule();
+	} while (1);
+
+	memcpy(learn_buffer_user, learn_buffer, learn_buffer_len);
+	learn_buffer_user_len = learn_buffer_len;
+	retval = learn_buffer_len;
+	learn_buffer_len = 0;
+
+	spin_unlock(&gr_learn_lock);
+
+	if (copy_to_user(buf, learn_buffer_user, learn_buffer_user_len))
+		retval = -EFAULT;
+
+	mutex_unlock(&gr_learn_user_mutex);
+out:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&learn_wait, &wait);
+	return retval;
+}
+
+static unsigned int
+poll_learn(struct file * file, poll_table * wait)
+{
+	poll_wait(file, &learn_wait, wait);
+
+	if (learn_buffer_len)
+		return (POLLIN | POLLRDNORM);
+
+	return 0;
+}
+
+void
+gr_clear_learn_entries(void)
+{
+	char *tmp;
+
+	mutex_lock(&gr_learn_user_mutex);
+	spin_lock(&gr_learn_lock);
+	tmp = learn_buffer;
+	learn_buffer = NULL;
+	spin_unlock(&gr_learn_lock);
+	if (tmp)
+		vfree(tmp);
+	if (learn_buffer_user != NULL) {
+		vfree(learn_buffer_user);
+		learn_buffer_user = NULL;
+	}
+	learn_buffer_len = 0;
+	mutex_unlock(&gr_learn_user_mutex);
+
+	return;
+}
+
+void
+gr_add_learn_entry(const char *fmt, ...)
+{
+	va_list args;
+	unsigned int len;
+
+	if (!gr_learn_attached)
+		return;
+
+	spin_lock(&gr_learn_lock);
+
+	/* leave a gap at the end so we know when it's "full" but don't have to
+	   compute the exact length of the string we're trying to append
+	*/
+	if (learn_buffer_len > LEARN_BUFFER_SIZE - 16384) {
+		spin_unlock(&gr_learn_lock);
+		wake_up_interruptible(&learn_wait);
+		return;
+	}
+	if (learn_buffer == NULL) {
+		spin_unlock(&gr_learn_lock);
+		return;
+	}
+
+	va_start(args, fmt);
+	len = vsnprintf(learn_buffer + learn_buffer_len, LEARN_BUFFER_SIZE - learn_buffer_len, fmt, args);
+	va_end(args);
+
+	learn_buffer_len += len + 1;
+
+	spin_unlock(&gr_learn_lock);
+	wake_up_interruptible(&learn_wait);
+
+	return;
+}
+
+static int
+open_learn(struct inode *inode, struct file *file)
+{
+	if (file->f_mode & FMODE_READ && gr_learn_attached)
+		return -EBUSY;
+	if (file->f_mode & FMODE_READ) {
+		int retval = 0;
+		mutex_lock(&gr_learn_user_mutex);
+		if (learn_buffer == NULL)
+			learn_buffer = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer_user == NULL)
+			learn_buffer_user = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer == NULL) {
+			retval = -ENOMEM;
+			goto out_error;
+		}
+		if (learn_buffer_user == NULL) {
+			retval = -ENOMEM;
+			goto out_error;
+		}
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 1;
+out_error:
+		mutex_unlock(&gr_learn_user_mutex);
+		return retval;
+	}
+	return 0;
+}
+
+static int
+close_learn(struct inode *inode, struct file *file)
+{
+	if (file->f_mode & FMODE_READ) {
+		char *tmp = NULL;
+		mutex_lock(&gr_learn_user_mutex);
+		spin_lock(&gr_learn_lock);
+		tmp = learn_buffer;
+		learn_buffer = NULL;
+		spin_unlock(&gr_learn_lock);
+		if (tmp)
+			vfree(tmp);
+		if (learn_buffer_user != NULL) {
+			vfree(learn_buffer_user);
+			learn_buffer_user = NULL;
+		}
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 0;
+		mutex_unlock(&gr_learn_user_mutex);
+	}
+
+	return 0;
+}
+		
+const struct file_operations grsec_fops = {
+	.read		= read_learn,
+	.write		= write_grsec_handler,
+	.open		= open_learn,
+	.release	= close_learn,
+	.poll		= poll_learn,
+};
diff --git a/grsecurity/gracl_policy.c b/grsecurity/gracl_policy.c
new file mode 100644
index 000000000000..7c42102d6593
--- /dev/null
+++ b/grsecurity/gracl_policy.c
@@ -0,0 +1,1782 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/tty.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/sysctl.h>
+#include <linux/netdevice.h>
+#include <linux/ptrace.h>
+#include <linux/gracl.h>
+#include <linux/gralloc.h>
+#include <linux/security.h>
+#include <linux/grinternal.h>
+#include <linux/pid_namespace.h>
+#include <linux/stop_machine.h>
+#include <linux/fdtable.h>
+#include <linux/percpu.h>
+#include <linux/hugetlb.h>
+#include <linux/posix-timers.h>
+#include "../fs/mount.h"
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+
+extern struct gr_policy_state *polstate;
+
+#define FOR_EACH_ROLE_START(role) \
+	role = polstate->role_list; \
+	while (role) {
+
+#define FOR_EACH_ROLE_END(role) \
+		role = role->prev; \
+	}
+
+struct path gr_real_root;
+
+extern struct gr_alloc_state *current_alloc_state;
+
+u16 acl_sp_role_value;
+
+static DEFINE_MUTEX(gr_dev_mutex);
+
+extern int chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum);
+extern void gr_clear_learn_entries(void);
+
+struct gr_arg *gr_usermode __read_only;
+unsigned char *gr_system_salt __read_only;
+unsigned char *gr_system_sum __read_only;
+
+static unsigned int gr_auth_attempts = 0;
+static unsigned long gr_auth_expires = 0UL;
+
+struct acl_object_label *fakefs_obj_rw;
+struct acl_object_label *fakefs_obj_rwx;
+
+extern int gr_init_uidset(void);
+extern void gr_free_uidset(void);
+extern int gr_find_and_remove_uid(uid_t uid);
+
+extern struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename, int fallback);
+extern void __gr_apply_subject_to_task(const struct gr_policy_state *state, struct task_struct *task, struct acl_subject_label *subj);
+extern int gr_streq(const char *a, const char *b, const unsigned int lena, const unsigned int lenb);
+extern void __insert_inodev_entry(const struct gr_policy_state *state, struct inodev_entry *entry);
+extern struct acl_role_label *__lookup_acl_role_label(const struct gr_policy_state *state, const struct task_struct *task, const uid_t uid, const gid_t gid);
+extern void insert_acl_obj_label(struct acl_object_label *obj, struct acl_subject_label *subj);
+extern void insert_acl_subj_label(struct acl_subject_label *obj, struct acl_role_label *role);
+extern struct name_entry * __lookup_name_entry(const struct gr_policy_state *state, const char *name);
+extern char *gr_to_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt);
+extern struct acl_subject_label *lookup_acl_subj_label(const u64 ino, const dev_t dev, const struct acl_role_label *role);
+extern struct acl_subject_label *lookup_acl_subj_label_deleted(const u64 ino, const dev_t dev, const struct acl_role_label *role);
+extern void assign_special_role(const char *rolename);
+extern struct acl_subject_label *chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt, const struct acl_role_label *role);
+extern int gr_rbac_disable(void *unused);
+extern void gr_enable_rbac_system(void);
+
+static int copy_acl_object_label_normal(struct acl_object_label *obj, const struct acl_object_label *userp)
+{
+	if (copy_from_user(obj, userp, sizeof(struct acl_object_label)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_acl_ip_label_normal(struct acl_ip_label *ip, const struct acl_ip_label *userp)
+{
+	if (copy_from_user(ip, userp, sizeof(struct acl_ip_label)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_acl_subject_label_normal(struct acl_subject_label *subj, const struct acl_subject_label *userp)
+{
+	if (copy_from_user(subj, userp, sizeof(struct acl_subject_label)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_acl_role_label_normal(struct acl_role_label *role, const struct acl_role_label *userp)
+{
+	if (copy_from_user(role, userp, sizeof(struct acl_role_label)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_role_allowed_ip_normal(struct role_allowed_ip *roleip, const struct role_allowed_ip *userp)
+{
+	if (copy_from_user(roleip, userp, sizeof(struct role_allowed_ip)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_sprole_pw_normal(struct sprole_pw *pw, unsigned long idx, const struct sprole_pw *userp)
+{
+	if (copy_from_user(pw, userp + idx, sizeof(struct sprole_pw)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_gr_hash_struct_normal(struct gr_hash_struct *hash, const struct gr_hash_struct *userp)
+{
+	if (copy_from_user(hash, userp, sizeof(struct gr_hash_struct)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_role_transition_normal(struct role_transition *trans, const struct role_transition *userp)
+{
+	if (copy_from_user(trans, userp, sizeof(struct role_transition)))
+		return -EFAULT;
+
+	return 0;
+}
+
+int copy_pointer_from_array_normal(void *ptr, unsigned long idx, const void *userp)
+{
+	if (copy_from_user(ptr, userp + (idx * sizeof(void *)), sizeof(void *)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int copy_gr_arg_wrapper_normal(const char __user *buf, struct gr_arg_wrapper *uwrap)
+{
+	if (copy_from_user(uwrap, buf, sizeof (struct gr_arg_wrapper)))
+		return -EFAULT;
+
+	if ((uwrap->version != GRSECURITY_VERSION) ||
+	    (uwrap->size != sizeof(struct gr_arg)))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int copy_gr_arg_normal(const struct gr_arg __user *buf, struct gr_arg *arg)
+{
+	if (copy_from_user(arg, buf, sizeof (struct gr_arg)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static size_t get_gr_arg_wrapper_size_normal(void)
+{
+	return sizeof(struct gr_arg_wrapper);
+}
+
+#ifdef CONFIG_COMPAT
+extern int copy_gr_arg_wrapper_compat(const char *buf, struct gr_arg_wrapper *uwrap);
+extern int copy_gr_arg_compat(const struct gr_arg __user *buf, struct gr_arg *arg);
+extern int copy_acl_object_label_compat(struct acl_object_label *obj, const struct acl_object_label *userp);
+extern int copy_acl_subject_label_compat(struct acl_subject_label *subj, const struct acl_subject_label *userp);
+extern int copy_acl_role_label_compat(struct acl_role_label *role, const struct acl_role_label *userp);
+extern int copy_role_allowed_ip_compat(struct role_allowed_ip *roleip, const struct role_allowed_ip *userp);
+extern int copy_role_transition_compat(struct role_transition *trans, const struct role_transition *userp);
+extern int copy_gr_hash_struct_compat(struct gr_hash_struct *hash, const struct gr_hash_struct *userp);
+extern int copy_pointer_from_array_compat(void *ptr, unsigned long idx, const void *userp);
+extern int copy_acl_ip_label_compat(struct acl_ip_label *ip, const struct acl_ip_label *userp);
+extern int copy_sprole_pw_compat(struct sprole_pw *pw, unsigned long idx, const struct sprole_pw *userp);
+extern size_t get_gr_arg_wrapper_size_compat(void);
+
+int (* copy_gr_arg_wrapper)(const char *buf, struct gr_arg_wrapper *uwrap) __read_only;
+int (* copy_gr_arg)(const struct gr_arg *buf, struct gr_arg *arg) __read_only;
+int (* copy_acl_object_label)(struct acl_object_label *obj, const struct acl_object_label *userp) __read_only;
+int (* copy_acl_subject_label)(struct acl_subject_label *subj, const struct acl_subject_label *userp) __read_only;
+int (* copy_acl_role_label)(struct acl_role_label *role, const struct acl_role_label *userp) __read_only;
+int (* copy_acl_ip_label)(struct acl_ip_label *ip, const struct acl_ip_label *userp) __read_only;
+int (* copy_pointer_from_array)(void *ptr, unsigned long idx, const void *userp) __read_only;
+int (* copy_sprole_pw)(struct sprole_pw *pw, unsigned long idx, const struct sprole_pw *userp) __read_only;
+int (* copy_gr_hash_struct)(struct gr_hash_struct *hash, const struct gr_hash_struct *userp) __read_only;
+int (* copy_role_transition)(struct role_transition *trans, const struct role_transition *userp) __read_only;
+int (* copy_role_allowed_ip)(struct role_allowed_ip *roleip, const struct role_allowed_ip *userp) __read_only;
+size_t (* get_gr_arg_wrapper_size)(void) __read_only;
+
+#else
+#define copy_gr_arg_wrapper copy_gr_arg_wrapper_normal
+#define copy_gr_arg copy_gr_arg_normal
+#define copy_gr_hash_struct copy_gr_hash_struct_normal
+#define copy_acl_object_label copy_acl_object_label_normal
+#define copy_acl_subject_label copy_acl_subject_label_normal
+#define copy_acl_role_label copy_acl_role_label_normal
+#define copy_acl_ip_label copy_acl_ip_label_normal
+#define copy_pointer_from_array copy_pointer_from_array_normal
+#define copy_sprole_pw copy_sprole_pw_normal
+#define copy_role_transition copy_role_transition_normal
+#define copy_role_allowed_ip copy_role_allowed_ip_normal
+#define get_gr_arg_wrapper_size get_gr_arg_wrapper_size_normal
+#endif
+
+static struct acl_subject_label *
+lookup_subject_map(const struct acl_subject_label *userp)
+{
+	unsigned int index = gr_shash(userp, polstate->subj_map_set.s_size);
+	struct subject_map *match;
+
+	match = polstate->subj_map_set.s_hash[index];
+
+	while (match && match->user != userp)
+		match = match->next;
+
+	if (match != NULL)
+		return match->kernel;
+	else
+		return NULL;
+}
+
+static void
+insert_subj_map_entry(struct subject_map *subjmap)
+{
+	unsigned int index = gr_shash(subjmap->user, polstate->subj_map_set.s_size);
+	struct subject_map **curr;
+
+	subjmap->prev = NULL;
+
+	curr = &polstate->subj_map_set.s_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = subjmap;
+
+	subjmap->next = *curr;
+	*curr = subjmap;
+
+	return;
+}
+
+static void
+__insert_acl_role_label(struct acl_role_label *role, uid_t uidgid)
+{
+	unsigned int index =
+	    gr_rhash(uidgid, role->roletype & (GR_ROLE_USER | GR_ROLE_GROUP), polstate->acl_role_set.r_size);
+	struct acl_role_label **curr;
+	struct acl_role_label *tmp, *tmp2;
+
+	curr = &polstate->acl_role_set.r_hash[index];
+
+	/* simple case, slot is empty, just set it to our role */
+	if (*curr == NULL) {
+		*curr = role;
+	} else {
+		/* example:
+		   1 -> 2 -> 3 (adding 2 -> 3 to here)
+		   2 -> 3
+		*/
+		/* first check to see if we can already be reached via this slot */
+		tmp = *curr;
+		while (tmp && tmp != role)
+			tmp = tmp->next;
+		if (tmp == role) {
+			/* we don't need to add ourselves to this slot's chain */
+			return;
+		}
+		/* we need to add ourselves to this chain, two cases */
+		if (role->next == NULL) {
+			/* simple case, append the current chain to our role */
+			role->next = *curr;
+			*curr = role;
+		} else {
+			/* 1 -> 2 -> 3 -> 4
+			   2 -> 3 -> 4
+			   3 -> 4 (adding 1 -> 2 -> 3 -> 4 to here)
+			*/			   
+			/* trickier case: walk our role's chain until we find
+			   the role for the start of the current slot's chain */
+			tmp = role;
+			tmp2 = *curr;
+			while (tmp->next && tmp->next != tmp2)
+				tmp = tmp->next;
+			if (tmp->next == tmp2) {
+				/* from example above, we found 3, so just
+				   replace this slot's chain with ours */
+				*curr = role;
+			} else {
+				/* we didn't find a subset of our role's chain
+				   in the current slot's chain, so append their
+				   chain to ours, and set us as the first role in
+				   the slot's chain
+
+				   we could fold this case with the case above,
+				   but making it explicit for clarity
+				*/
+				tmp->next = tmp2;
+				*curr = role;
+			}
+		}
+	}
+
+	return;
+}
+
+static void
+insert_acl_role_label(struct acl_role_label *role)
+{
+	int i;
+
+	if (polstate->role_list == NULL) {
+		polstate->role_list = role;
+		role->prev = NULL;
+	} else {
+		role->prev = polstate->role_list;
+		polstate->role_list = role;
+	}
+	
+	/* used for hash chains */
+	role->next = NULL;
+
+	if (role->roletype & GR_ROLE_DOMAIN) {
+		for (i = 0; i < role->domain_child_num; i++)
+			__insert_acl_role_label(role, role->domain_children[i]);
+	} else
+		__insert_acl_role_label(role, role->uidgid);
+}
+					
+static int
+insert_name_entry(char *name, const u64 inode, const dev_t device, __u8 deleted)
+{
+	struct name_entry **curr, *nentry;
+	struct inodev_entry *ientry;
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(NULL, (const unsigned char *)name, len);
+	unsigned int index = key % polstate->name_set.n_size;
+
+	curr = &polstate->name_set.n_hash[index];
+
+	while (*curr && ((*curr)->key != key || !gr_streq((*curr)->name, name, (*curr)->len, len)))
+		curr = &((*curr)->next);
+
+	if (*curr != NULL)
+		return 1;
+
+	nentry = acl_alloc(sizeof (struct name_entry));
+	if (nentry == NULL)
+		return 0;
+	ientry = acl_alloc(sizeof (struct inodev_entry));
+	if (ientry == NULL)
+		return 0;
+	ientry->nentry = nentry;
+
+	nentry->key = key;
+	nentry->name = name;
+	nentry->inode = inode;
+	nentry->device = device;
+	nentry->len = len;
+	nentry->deleted = deleted;
+
+	nentry->prev = NULL;
+	curr = &polstate->name_set.n_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = nentry;
+	nentry->next = *curr;
+	*curr = nentry;
+
+	/* insert us into the table searchable by inode/dev */
+	__insert_inodev_entry(polstate, ientry);
+
+	return 1;
+}
+
+/* allocating chained hash tables, so optimal size is where lambda ~ 1 */
+
+static void *
+create_table(__u32 * len, int elementsize)
+{
+	unsigned int table_sizes[] = {
+		7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
+		32749, 65521, 131071, 262139, 524287, 1048573, 2097143,
+		4194301, 8388593, 16777213, 33554393, 67108859
+	};
+	void *newtable = NULL;
+	unsigned int pwr = 0;
+
+	while ((pwr < ((sizeof (table_sizes) / sizeof (table_sizes[0])) - 1)) &&
+	       table_sizes[pwr] <= *len)
+		pwr++;
+
+	if (table_sizes[pwr] <= *len || (table_sizes[pwr] > ULONG_MAX / elementsize))
+		return newtable;
+
+	if ((table_sizes[pwr] * elementsize) <= PAGE_SIZE)
+		newtable =
+		    kmalloc(table_sizes[pwr] * elementsize, GFP_KERNEL);
+	else
+		newtable = vmalloc(table_sizes[pwr] * elementsize);
+
+	*len = table_sizes[pwr];
+
+	return newtable;
+}
+
+static int
+init_variables(const struct gr_arg *arg, bool reload)
+{
+	struct task_struct *reaper = init_pid_ns.child_reaper;
+	unsigned int stacksize;
+
+	polstate->subj_map_set.s_size = arg->role_db.num_subjects;
+	polstate->acl_role_set.r_size = arg->role_db.num_roles + arg->role_db.num_domain_children;
+	polstate->name_set.n_size = arg->role_db.num_objects;
+	polstate->inodev_set.i_size = arg->role_db.num_objects;
+
+	if (!polstate->subj_map_set.s_size || !polstate->acl_role_set.r_size ||
+	    !polstate->name_set.n_size || !polstate->inodev_set.i_size)
+		return 1;
+
+	if (!reload) {
+		if (!gr_init_uidset())
+			return 1;
+	}
+
+	/* set up the stack that holds allocation info */
+
+	stacksize = arg->role_db.num_pointers + 5;
+
+	if (!acl_alloc_stack_init(stacksize))
+		return 1;
+
+	if (!reload) {
+		/* grab reference for the real root dentry and vfsmount */
+		get_fs_root(reaper->fs, &gr_real_root);
+	
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "Obtained real root device=%d, inode=%lu\n", gr_get_dev_from_dentry(gr_real_root.dentry), gr_get_ino_from_dentry(gr_real_root.dentry));
+#endif
+
+		fakefs_obj_rw = kzalloc(sizeof(struct acl_object_label), GFP_KERNEL);
+		if (fakefs_obj_rw == NULL)
+			return 1;
+		fakefs_obj_rw->mode = GR_FIND | GR_READ | GR_WRITE;
+	
+		fakefs_obj_rwx = kzalloc(sizeof(struct acl_object_label), GFP_KERNEL);
+		if (fakefs_obj_rwx == NULL)
+			return 1;
+		fakefs_obj_rwx->mode = GR_FIND | GR_READ | GR_WRITE | GR_EXEC;
+	}
+
+	polstate->subj_map_set.s_hash =
+	    (struct subject_map **) create_table(&polstate->subj_map_set.s_size, sizeof(void *));
+	polstate->acl_role_set.r_hash =
+	    (struct acl_role_label **) create_table(&polstate->acl_role_set.r_size, sizeof(void *));
+	polstate->name_set.n_hash = (struct name_entry **) create_table(&polstate->name_set.n_size, sizeof(void *));
+	polstate->inodev_set.i_hash =
+	    (struct inodev_entry **) create_table(&polstate->inodev_set.i_size, sizeof(void *));
+
+	if (!polstate->subj_map_set.s_hash || !polstate->acl_role_set.r_hash ||
+	    !polstate->name_set.n_hash || !polstate->inodev_set.i_hash)
+		return 1;
+
+	memset(polstate->subj_map_set.s_hash, 0,
+	       sizeof(struct subject_map *) * polstate->subj_map_set.s_size);
+	memset(polstate->acl_role_set.r_hash, 0,
+	       sizeof (struct acl_role_label *) * polstate->acl_role_set.r_size);
+	memset(polstate->name_set.n_hash, 0,
+	       sizeof (struct name_entry *) * polstate->name_set.n_size);
+	memset(polstate->inodev_set.i_hash, 0,
+	       sizeof (struct inodev_entry *) * polstate->inodev_set.i_size);
+
+	return 0;
+}
+
+/* free information not needed after startup
+   currently contains user->kernel pointer mappings for subjects
+*/
+
+static void
+free_init_variables(void)
+{
+	__u32 i;
+
+	if (polstate->subj_map_set.s_hash) {
+		for (i = 0; i < polstate->subj_map_set.s_size; i++) {
+			if (polstate->subj_map_set.s_hash[i]) {
+				kfree(polstate->subj_map_set.s_hash[i]);
+				polstate->subj_map_set.s_hash[i] = NULL;
+			}
+		}
+
+		if ((polstate->subj_map_set.s_size * sizeof (struct subject_map *)) <=
+		    PAGE_SIZE)
+			kfree(polstate->subj_map_set.s_hash);
+		else
+			vfree(polstate->subj_map_set.s_hash);
+	}
+
+	return;
+}
+
+static void
+free_variables(bool reload)
+{
+	struct acl_subject_label *s;
+	struct acl_role_label *r;
+	struct task_struct *task, *task2;
+	unsigned int x;
+
+	if (!reload) {
+		gr_clear_learn_entries();
+
+		read_lock(&tasklist_lock);
+		do_each_thread(task2, task) {
+			task->acl_sp_role = 0;
+			task->acl_role_id = 0;
+			task->inherited = 0;
+			task->acl = NULL;
+			task->role = NULL;
+		} while_each_thread(task2, task);
+		read_unlock(&tasklist_lock);
+
+		kfree(fakefs_obj_rw);
+		fakefs_obj_rw = NULL;
+		kfree(fakefs_obj_rwx);
+		fakefs_obj_rwx = NULL;
+
+		/* release the reference to the real root dentry and vfsmount */
+		path_put(&gr_real_root);
+		memset(&gr_real_root, 0, sizeof(gr_real_root));
+	}
+
+	/* free all object hash tables */
+
+	FOR_EACH_ROLE_START(r)
+		if (r->subj_hash == NULL)
+			goto next_role;
+		FOR_EACH_SUBJECT_START(r, s, x)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_SUBJECT_END(s, x)
+		FOR_EACH_NESTED_SUBJECT_START(r, s)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_NESTED_SUBJECT_END(s)
+		if ((r->subj_hash_size * sizeof (struct acl_subject_label *)) <= PAGE_SIZE)
+			kfree(r->subj_hash);
+		else
+			vfree(r->subj_hash);
+		r->subj_hash = NULL;
+next_role:
+	FOR_EACH_ROLE_END(r)
+
+	acl_free_all();
+
+	if (polstate->acl_role_set.r_hash) {
+		if ((polstate->acl_role_set.r_size * sizeof (struct acl_role_label *)) <=
+		    PAGE_SIZE)
+			kfree(polstate->acl_role_set.r_hash);
+		else
+			vfree(polstate->acl_role_set.r_hash);
+	}
+	if (polstate->name_set.n_hash) {
+		if ((polstate->name_set.n_size * sizeof (struct name_entry *)) <=
+		    PAGE_SIZE)
+			kfree(polstate->name_set.n_hash);
+		else
+			vfree(polstate->name_set.n_hash);
+	}
+
+	if (polstate->inodev_set.i_hash) {
+		if ((polstate->inodev_set.i_size * sizeof (struct inodev_entry *)) <=
+		    PAGE_SIZE)
+			kfree(polstate->inodev_set.i_hash);
+		else
+			vfree(polstate->inodev_set.i_hash);
+	}
+
+	if (!reload)
+		gr_free_uidset();
+
+	memset(&polstate->name_set, 0, sizeof (struct name_db));
+	memset(&polstate->inodev_set, 0, sizeof (struct inodev_db));
+	memset(&polstate->acl_role_set, 0, sizeof (struct acl_role_db));
+	memset(&polstate->subj_map_set, 0, sizeof (struct acl_subj_map_db));
+
+	polstate->default_role = NULL;
+	polstate->kernel_role = NULL;
+	polstate->role_list = NULL;
+
+	return;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role, int *already_copied);
+
+static int alloc_and_copy_string(char **name, unsigned int maxlen)
+{
+	unsigned int len = strnlen_user(*name, maxlen);
+	char *tmp;
+
+	if (!len || len >= maxlen)
+		return -EINVAL;
+
+	if ((tmp = (char *) acl_alloc(len)) == NULL)
+		return -ENOMEM;
+
+	if (copy_from_user(tmp, *name, len))
+		return -EFAULT;
+
+	tmp[len-1] = '\0';
+	*name = tmp;
+
+	return 0;
+}
+
+static int
+copy_user_glob(struct acl_object_label *obj)
+{
+	struct acl_object_label *g_tmp, **guser;
+	int error;
+
+	if (obj->globbed == NULL)
+		return 0;
+
+	guser = &obj->globbed;
+	while (*guser) {
+		g_tmp = (struct acl_object_label *)
+			acl_alloc(sizeof (struct acl_object_label));
+		if (g_tmp == NULL)
+			return -ENOMEM;
+
+		if (copy_acl_object_label(g_tmp, *guser))
+			return -EFAULT;
+
+		error = alloc_and_copy_string(&g_tmp->filename, PATH_MAX);
+		if (error)
+			return error;
+
+		*guser = g_tmp;
+		guser = &(g_tmp->next);
+	}
+
+	return 0;
+}
+
+static int
+copy_user_objs(struct acl_object_label *userp, struct acl_subject_label *subj,
+	       struct acl_role_label *role)
+{
+	struct acl_object_label *o_tmp;
+	int ret;
+
+	while (userp) {
+		if ((o_tmp = (struct acl_object_label *)
+		     acl_alloc(sizeof (struct acl_object_label))) == NULL)
+			return -ENOMEM;
+
+		if (copy_acl_object_label(o_tmp, userp))
+			return -EFAULT;
+
+		userp = o_tmp->prev;
+
+		ret = alloc_and_copy_string(&o_tmp->filename, PATH_MAX);
+		if (ret)
+			return ret;
+
+		insert_acl_obj_label(o_tmp, subj);
+		if (!insert_name_entry(o_tmp->filename, o_tmp->inode,
+				       o_tmp->device, (o_tmp->mode & GR_DELETED) ? 1 : 0))
+			return -ENOMEM;
+
+		ret = copy_user_glob(o_tmp);
+		if (ret)
+			return ret;
+
+		if (o_tmp->nested) {
+			int already_copied;
+
+			o_tmp->nested = do_copy_user_subj(o_tmp->nested, role, &already_copied);
+			if (IS_ERR(o_tmp->nested))
+				return PTR_ERR(o_tmp->nested);
+
+			/* insert into nested subject list if we haven't copied this one yet
+			   to prevent duplicate entries */
+			if (!already_copied) {
+				o_tmp->nested->next = role->hash->first;
+				role->hash->first = o_tmp->nested;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static __u32
+count_user_subjs(struct acl_subject_label *userp)
+{
+	struct acl_subject_label s_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_acl_subject_label(&s_tmp, userp))
+			break;
+
+		userp = s_tmp.prev;
+	}
+
+	return num;
+}
+
+static int
+copy_user_allowedips(struct acl_role_label *rolep)
+{
+	struct role_allowed_ip *ruserip, *rtmp = NULL, *rlast;
+
+	ruserip = rolep->allowed_ips;
+
+	while (ruserip) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_allowed_ip *)
+		     acl_alloc(sizeof (struct role_allowed_ip))) == NULL)
+			return -ENOMEM;
+
+		if (copy_role_allowed_ip(rtmp, ruserip))
+			return -EFAULT;
+
+		ruserip = rtmp->prev;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->allowed_ips = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!ruserip)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_transitions(struct acl_role_label *rolep)
+{
+	struct role_transition *rusertp, *rtmp = NULL, *rlast;
+	int error;
+
+	rusertp = rolep->transitions;
+
+	while (rusertp) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_transition *)
+		     acl_alloc(sizeof (struct role_transition))) == NULL)
+			return -ENOMEM;
+
+		if (copy_role_transition(rtmp, rusertp))
+			return -EFAULT;
+
+		rusertp = rtmp->prev;
+
+		error = alloc_and_copy_string(&rtmp->rolename, GR_SPROLE_LEN);
+		if (error)
+			return error;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->transitions = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!rusertp)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static __u32 count_user_objs(const struct acl_object_label __user *userp)
+{
+	struct acl_object_label o_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_acl_object_label(&o_tmp, userp))
+			break;
+
+		userp = o_tmp.prev;
+		num++;
+	}
+
+	return num;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role, int *already_copied)
+{
+	struct acl_subject_label *s_tmp = NULL, *s_tmp2;
+	__u32 num_objs;
+	struct acl_ip_label **i_tmp, *i_utmp2;
+	struct gr_hash_struct ghash;
+	struct subject_map *subjmap;
+	unsigned int i_num;
+	int err;
+
+	if (already_copied != NULL)
+		*already_copied = 0;
+
+	s_tmp = lookup_subject_map(userp);
+
+	/* we've already copied this subject into the kernel, just return
+	   the reference to it, and don't copy it over again
+	*/
+	if (s_tmp) {
+		if (already_copied != NULL)
+			*already_copied = 1;
+		return(s_tmp);
+	}
+
+	if ((s_tmp = (struct acl_subject_label *)
+	    acl_alloc(sizeof (struct acl_subject_label))) == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap = (struct subject_map *)kmalloc(sizeof (struct subject_map), GFP_KERNEL);
+	if (subjmap == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap->user = userp;
+	subjmap->kernel = s_tmp;
+	insert_subj_map_entry(subjmap);
+
+	if (copy_acl_subject_label(s_tmp, userp))
+		return ERR_PTR(-EFAULT);
+
+	err = alloc_and_copy_string(&s_tmp->filename, PATH_MAX);
+	if (err)
+		return ERR_PTR(err);
+
+	if (!strcmp(s_tmp->filename, "/"))
+		role->root_label = s_tmp;
+
+	if (copy_gr_hash_struct(&ghash, s_tmp->hash))
+		return ERR_PTR(-EFAULT);
+
+	/* copy user and group transition tables */
+
+	if (s_tmp->user_trans_num) {
+		uid_t *uidlist;
+
+		uidlist = (uid_t *)acl_alloc_num(s_tmp->user_trans_num, sizeof(uid_t));
+		if (uidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(uidlist, s_tmp->user_transitions, s_tmp->user_trans_num * sizeof(uid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->user_transitions = uidlist;
+	}
+
+	if (s_tmp->group_trans_num) {
+		gid_t *gidlist;
+
+		gidlist = (gid_t *)acl_alloc_num(s_tmp->group_trans_num, sizeof(gid_t));
+		if (gidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(gidlist, s_tmp->group_transitions, s_tmp->group_trans_num * sizeof(gid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->group_transitions = gidlist;
+	}
+
+	/* set up object hash table */
+	num_objs = count_user_objs(ghash.first);
+
+	s_tmp->obj_hash_size = num_objs;
+	s_tmp->obj_hash =
+	    (struct acl_object_label **)
+	    create_table(&(s_tmp->obj_hash_size), sizeof(void *));
+
+	if (!s_tmp->obj_hash)
+		return ERR_PTR(-ENOMEM);
+
+	memset(s_tmp->obj_hash, 0,
+	       s_tmp->obj_hash_size *
+	       sizeof (struct acl_object_label *));
+
+	/* add in objects */
+	err = copy_user_objs(ghash.first, s_tmp, role);
+
+	if (err)
+		return ERR_PTR(err);
+
+	/* set pointer for parent subject */
+	if (s_tmp->parent_subject) {
+		s_tmp2 = do_copy_user_subj(s_tmp->parent_subject, role, NULL);
+
+		if (IS_ERR(s_tmp2))
+			return s_tmp2;
+
+		s_tmp->parent_subject = s_tmp2;
+	}
+
+	/* add in ip acls */
+
+	if (!s_tmp->ip_num) {
+		s_tmp->ips = NULL;
+		goto insert;
+	}
+
+	i_tmp =
+	    (struct acl_ip_label **) acl_alloc_num(s_tmp->ip_num,
+					       sizeof (struct acl_ip_label *));
+
+	if (!i_tmp)
+		return ERR_PTR(-ENOMEM);
+
+	for (i_num = 0; i_num < s_tmp->ip_num; i_num++) {
+		*(i_tmp + i_num) =
+		    (struct acl_ip_label *)
+		    acl_alloc(sizeof (struct acl_ip_label));
+		if (!*(i_tmp + i_num))
+			return ERR_PTR(-ENOMEM);
+
+		if (copy_pointer_from_array(&i_utmp2, i_num, s_tmp->ips))
+			return ERR_PTR(-EFAULT);
+
+		if (copy_acl_ip_label(*(i_tmp + i_num), i_utmp2))
+			return ERR_PTR(-EFAULT);
+		
+		if ((*(i_tmp + i_num))->iface == NULL)
+			continue;
+
+		err = alloc_and_copy_string(&(*(i_tmp + i_num))->iface, IFNAMSIZ);
+		if (err)
+			return ERR_PTR(err);
+	}
+
+	s_tmp->ips = i_tmp;
+
+insert:
+	if (!insert_name_entry(s_tmp->filename, s_tmp->inode,
+			       s_tmp->device, (s_tmp->mode & GR_DELETED) ? 1 : 0))
+		return ERR_PTR(-ENOMEM);
+
+	return s_tmp;
+}
+
+static int
+copy_user_subjs(struct acl_subject_label *userp, struct acl_role_label *role)
+{
+	struct acl_subject_label s_pre;
+	struct acl_subject_label * ret;
+	int err;
+
+	while (userp) {
+		if (copy_acl_subject_label(&s_pre, userp))
+			return -EFAULT;
+		
+		ret = do_copy_user_subj(userp, role, NULL);
+
+		err = PTR_ERR(ret);
+		if (IS_ERR(ret))
+			return err;
+
+		insert_acl_subj_label(ret, role);
+
+		userp = s_pre.prev;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_acl(struct gr_arg *arg)
+{
+	struct acl_role_label *r_tmp = NULL, **r_utmp, *r_utmp2;
+	struct acl_subject_label *subj_list;
+	struct sprole_pw *sptmp;
+	struct gr_hash_struct *ghash;
+	uid_t *domainlist;
+	unsigned int r_num;
+	int err = 0;
+	__u16 i;
+	__u32 num_subjs;
+
+	/* we need a default and kernel role */
+	if (arg->role_db.num_roles < 2)
+		return -EINVAL;
+
+	/* copy special role authentication info from userspace */
+
+	polstate->num_sprole_pws = arg->num_sprole_pws;
+	polstate->acl_special_roles = (struct sprole_pw **) acl_alloc_num(polstate->num_sprole_pws, sizeof(struct sprole_pw *));
+
+	if (!polstate->acl_special_roles && polstate->num_sprole_pws)
+		return -ENOMEM;
+
+	for (i = 0; i < polstate->num_sprole_pws; i++) {
+		sptmp = (struct sprole_pw *) acl_alloc(sizeof(struct sprole_pw));
+		if (!sptmp)
+			return -ENOMEM;
+		if (copy_sprole_pw(sptmp, i, arg->sprole_pws))
+			return -EFAULT;
+
+		err = alloc_and_copy_string((char **)&sptmp->rolename, GR_SPROLE_LEN);
+		if (err)
+			return err;
+
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+		printk(KERN_ALERT "Copying special role %s\n", sptmp->rolename);
+#endif
+
+		polstate->acl_special_roles[i] = sptmp;
+	}
+
+	r_utmp = (struct acl_role_label **) arg->role_db.r_table;
+
+	for (r_num = 0; r_num < arg->role_db.num_roles; r_num++) {
+		r_tmp = acl_alloc(sizeof (struct acl_role_label));
+
+		if (!r_tmp)
+			return -ENOMEM;
+
+		if (copy_pointer_from_array(&r_utmp2, r_num, r_utmp))
+			return -EFAULT;
+
+		if (copy_acl_role_label(r_tmp, r_utmp2))
+			return -EFAULT;
+
+		err = alloc_and_copy_string(&r_tmp->rolename, GR_SPROLE_LEN);
+		if (err)
+			return err;
+
+		if (!strcmp(r_tmp->rolename, "default")
+		    && (r_tmp->roletype & GR_ROLE_DEFAULT)) {
+			polstate->default_role = r_tmp;
+		} else if (!strcmp(r_tmp->rolename, ":::kernel:::")) {
+			polstate->kernel_role = r_tmp;
+		}
+
+		if ((ghash = (struct gr_hash_struct *) acl_alloc(sizeof(struct gr_hash_struct))) == NULL)
+			return -ENOMEM;
+
+		if (copy_gr_hash_struct(ghash, r_tmp->hash))
+			return -EFAULT;
+
+		r_tmp->hash = ghash;
+
+		num_subjs = count_user_subjs(r_tmp->hash->first);
+
+		r_tmp->subj_hash_size = num_subjs;
+		r_tmp->subj_hash =
+		    (struct acl_subject_label **)
+		    create_table(&(r_tmp->subj_hash_size), sizeof(void *));
+
+		if (!r_tmp->subj_hash)
+			return -ENOMEM;
+
+		err = copy_user_allowedips(r_tmp);
+		if (err)
+			return err;
+
+		/* copy domain info */
+		if (r_tmp->domain_children != NULL) {
+			domainlist = acl_alloc_num(r_tmp->domain_child_num, sizeof(uid_t));
+			if (domainlist == NULL)
+				return -ENOMEM;
+
+			if (copy_from_user(domainlist, r_tmp->domain_children, r_tmp->domain_child_num * sizeof(uid_t)))
+				return -EFAULT;
+
+			r_tmp->domain_children = domainlist;
+		}
+
+		err = copy_user_transitions(r_tmp);
+		if (err)
+			return err;
+
+		memset(r_tmp->subj_hash, 0,
+		       r_tmp->subj_hash_size *
+		       sizeof (struct acl_subject_label *));
+
+		/* acquire the list of subjects, then NULL out
+		   the list prior to parsing the subjects for this role,
+		   as during this parsing the list is replaced with a list
+		   of *nested* subjects for the role
+		*/
+		subj_list = r_tmp->hash->first;
+
+		/* set nested subject list to null */
+		r_tmp->hash->first = NULL;
+
+		err = copy_user_subjs(subj_list, r_tmp);
+
+		if (err)
+			return err;
+
+		insert_acl_role_label(r_tmp);
+	}
+
+	if (polstate->default_role == NULL || polstate->kernel_role == NULL)
+		return -EINVAL;
+
+	return err;
+}
+
+static int gracl_reload_apply_policies(void *reload)
+{
+	struct gr_reload_state *reload_state = (struct gr_reload_state *)reload;
+	struct task_struct *task, *task2;
+	struct acl_role_label *role, *rtmp;
+	struct acl_subject_label *subj;
+	const struct cred *cred;
+	int role_applied;
+	int ret = 0;
+
+	memcpy(&reload_state->oldpolicy, reload_state->oldpolicy_ptr, sizeof(struct gr_policy_state));
+	memcpy(&reload_state->oldalloc, reload_state->oldalloc_ptr, sizeof(struct gr_alloc_state));
+
+	/* first make sure we'll be able to apply the new policy cleanly */
+	do_each_thread(task2, task) {
+		if (task->exec_file == NULL)
+			continue;
+		role_applied = 0;
+		if (!reload_state->oldmode && task->role->roletype & GR_ROLE_SPECIAL) {
+			/* preserve special roles */
+			FOR_EACH_ROLE_START(role)
+				if ((role->roletype & GR_ROLE_SPECIAL) && !strcmp(task->role->rolename, role->rolename)) {
+					rtmp = task->role;
+					task->role = role;
+					role_applied = 1;
+					break;
+				}
+			FOR_EACH_ROLE_END(role)
+		}
+		if (!role_applied) {
+			cred = __task_cred(task);
+			rtmp = task->role;
+			task->role = __lookup_acl_role_label(polstate, task, GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid));
+		}
+		/* this handles non-nested inherited subjects, nested subjects will still
+		   be dropped currently */
+		subj = __gr_get_subject_for_task(polstate, task, task->acl->filename, 1);
+		task->tmpacl = __gr_get_subject_for_task(polstate, task, NULL, 1);
+		/* change the role back so that we've made no modifications to the policy */
+		task->role = rtmp;
+
+		if (subj == NULL || task->tmpacl == NULL) {
+			ret = -EINVAL;
+			goto out;
+		}
+	} while_each_thread(task2, task);
+
+	/* now actually apply the policy */
+
+	do_each_thread(task2, task) {
+		if (task->exec_file) {
+			role_applied = 0;
+			if (!reload_state->oldmode && task->role->roletype & GR_ROLE_SPECIAL) {
+				/* preserve special roles */
+				FOR_EACH_ROLE_START(role)
+					if ((role->roletype & GR_ROLE_SPECIAL) && !strcmp(task->role->rolename, role->rolename)) {
+						task->role = role;
+						role_applied = 1;
+						break;
+					}
+				FOR_EACH_ROLE_END(role)
+			}
+			if (!role_applied) {
+				cred = __task_cred(task);
+				task->role = __lookup_acl_role_label(polstate, task, GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid));
+			}
+			/* this handles non-nested inherited subjects, nested subjects will still
+			   be dropped currently */
+			if (!reload_state->oldmode && task->inherited)
+				subj = __gr_get_subject_for_task(polstate, task, task->acl->filename, 1);
+			else {
+				/* looked up and tagged to the task previously */
+				subj = task->tmpacl;
+			}
+			/* subj will be non-null */
+			__gr_apply_subject_to_task(polstate, task, subj);
+			if (reload_state->oldmode) {
+				task->acl_role_id = 0;
+				task->acl_sp_role = 0;
+				task->inherited = 0;
+			}
+		} else {
+			// it's a kernel process
+			task->role = polstate->kernel_role;
+			task->acl = polstate->kernel_role->root_label;
+#ifdef CONFIG_GRKERNSEC_ACL_HIDEKERN
+			task->acl->mode &= ~GR_PROCFIND;
+#endif
+		}
+	} while_each_thread(task2, task);
+
+	memcpy(reload_state->oldpolicy_ptr, &reload_state->newpolicy, sizeof(struct gr_policy_state));
+	memcpy(reload_state->oldalloc_ptr, &reload_state->newalloc, sizeof(struct gr_alloc_state));
+
+out:
+
+	return ret;
+}
+
+static int gracl_reload(struct gr_arg *args, unsigned char oldmode)
+{
+	struct gr_reload_state new_reload_state = { };
+	int err;
+
+	new_reload_state.oldpolicy_ptr = polstate;
+	new_reload_state.oldalloc_ptr = current_alloc_state;
+	new_reload_state.oldmode = oldmode;
+
+	current_alloc_state = &new_reload_state.newalloc;
+	polstate = &new_reload_state.newpolicy;
+
+	/* everything relevant is now saved off, copy in the new policy */
+	if (init_variables(args, true)) {
+		gr_log_str(GR_DONT_AUDIT_GOOD, GR_INITF_ACL_MSG, GR_VERSION);
+		err = -ENOMEM;
+		goto error;
+	}
+
+	err = copy_user_acl(args);
+	free_init_variables();
+	if (err)
+		goto error;
+	/* the new policy is copied in, with the old policy available via saved_state
+	   first go through applying roles, making sure to preserve special roles
+	   then apply new subjects, making sure to preserve inherited and nested subjects,
+	   though currently only inherited subjects will be preserved
+	*/
+	err = stop_machine(gracl_reload_apply_policies, &new_reload_state, NULL);
+	if (err)
+		goto error;
+
+	/* we've now applied the new policy, so restore the old policy state to free it */
+	polstate = &new_reload_state.oldpolicy;
+	current_alloc_state = &new_reload_state.oldalloc;
+	free_variables(true);
+
+	/* oldpolicy/oldalloc_ptr point to the new policy/alloc states as they were copied
+	   to running_polstate/current_alloc_state inside stop_machine
+	*/
+	err = 0;
+	goto out;
+error:
+	/* on error of loading the new policy, we'll just keep the previous
+	   policy set around
+	*/
+	free_variables(true);
+
+	/* doesn't affect runtime, but maintains consistent state */
+out:
+	polstate = new_reload_state.oldpolicy_ptr;
+	current_alloc_state = new_reload_state.oldalloc_ptr;
+
+	return err;
+}
+
+static int
+gracl_init(struct gr_arg *args)
+{
+	int error = 0;
+
+	memcpy(gr_system_salt, args->salt, GR_SALT_LEN);
+	memcpy(gr_system_sum, args->sum, GR_SHA_LEN);
+
+	if (init_variables(args, false)) {
+		gr_log_str(GR_DONT_AUDIT_GOOD, GR_INITF_ACL_MSG, GR_VERSION);
+		error = -ENOMEM;
+		goto out;
+	}
+
+	error = copy_user_acl(args);
+	free_init_variables();
+	if (error)
+		goto out;
+
+	error = gr_set_acls(0);
+	if (error)
+		goto out;
+
+	gr_enable_rbac_system();
+
+	return 0;
+
+out:
+	free_variables(false);
+	return error;
+}
+
+static int
+lookup_special_role_auth(__u16 mode, const char *rolename, unsigned char **salt,
+			 unsigned char **sum)
+{
+	struct acl_role_label *r;
+	struct role_allowed_ip *ipp;
+	struct role_transition *trans;
+	unsigned int i;
+	int found = 0;
+	u32 curr_ip = current->signal->curr_ip;
+
+	current->signal->saved_ip = curr_ip;
+
+	/* check transition table */
+
+	for (trans = current->role->transitions; trans; trans = trans->next) {
+		if (!strcmp(rolename, trans->rolename)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return 0;
+
+	/* handle special roles that do not require authentication
+	   and check ip */
+
+	FOR_EACH_ROLE_START(r)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL)) {
+			found = 0;
+			if (r->allowed_ips != NULL) {
+				for (ipp = r->allowed_ips; ipp; ipp = ipp->next) {
+					if ((ntohl(curr_ip) & ipp->netmask) ==
+					     (ntohl(ipp->addr) & ipp->netmask))
+						found = 1;
+				}
+			} else
+				found = 2;
+			if (!found)
+				return 0;
+
+			if (((mode == GR_SPROLE) && (r->roletype & GR_ROLE_NOPW)) ||
+			    ((mode == GR_SPROLEPAM) && (r->roletype & GR_ROLE_PAM))) {
+				*salt = NULL;
+				*sum = NULL;
+				return 1;
+			}
+		}
+	FOR_EACH_ROLE_END(r)
+
+	for (i = 0; i < polstate->num_sprole_pws; i++) {
+		if (!strcmp(rolename, (const char *)polstate->acl_special_roles[i]->rolename)) {
+			*salt = polstate->acl_special_roles[i]->salt;
+			*sum = polstate->acl_special_roles[i]->sum;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int gr_check_secure_terminal(struct task_struct *task)
+{
+	struct task_struct *p, *p2, *p3;
+	struct files_struct *files;
+	struct fdtable *fdt;
+	struct file *our_file = NULL, *file;
+	struct inode *our_inode = NULL;
+	int i;
+
+	if (task->signal->tty == NULL)
+		return 1;
+
+	files = get_files_struct(task);
+	if (files != NULL) {
+		rcu_read_lock();
+		fdt = files_fdtable(files);
+		for (i=0; i < fdt->max_fds; i++) {
+			file = fcheck_files(files, i);
+			if (file && (our_file == NULL) && (file->private_data == task->signal->tty)) {
+				get_file(file);
+				our_file = file;
+			}
+		}
+		rcu_read_unlock();
+		put_files_struct(files);
+	}
+
+	if (our_file == NULL)
+		return 1;
+
+	our_inode = d_backing_inode(our_file->f_path.dentry);
+
+	read_lock(&tasklist_lock);
+	do_each_thread(p2, p) {
+		files = get_files_struct(p);
+		if (files == NULL ||
+		    (p->signal && p->signal->tty == task->signal->tty)) {
+			if (files != NULL)
+				put_files_struct(files);
+			continue;
+		}
+		rcu_read_lock();
+		fdt = files_fdtable(files);
+		for (i=0; i < fdt->max_fds; i++) {
+			struct inode *inode = NULL;
+			file = fcheck_files(files, i);
+			if (file)
+				inode = d_backing_inode(file->f_path.dentry);
+			if (inode && S_ISCHR(inode->i_mode) && inode->i_rdev == our_inode->i_rdev) {
+				p3 = task;
+				while (task_pid_nr(p3) > 0) {
+					if (p3 == p)
+						break;
+					p3 = p3->real_parent;
+				}
+				if (p3 == p)
+					break;
+				gr_log_ttysniff(GR_DONT_AUDIT_GOOD, GR_TTYSNIFF_ACL_MSG, p);
+				gr_handle_alertkill(p);
+				rcu_read_unlock();
+				put_files_struct(files);
+				read_unlock(&tasklist_lock);
+				fput(our_file);
+				return 0;
+			}
+		}
+		rcu_read_unlock();
+		put_files_struct(files);
+	} while_each_thread(p2, p);
+	read_unlock(&tasklist_lock);
+
+	fput(our_file);
+	return 1;
+}
+
+ssize_t
+write_grsec_handler(struct file *file, const char __user * buf, size_t count, loff_t *ppos)
+{
+	struct gr_arg_wrapper uwrap;
+	unsigned char *sprole_salt = NULL;
+	unsigned char *sprole_sum = NULL;
+	int error = 0;
+	int error2 = 0;
+	size_t req_count = 0;
+	unsigned char oldmode = 0;
+
+	mutex_lock(&gr_dev_mutex);
+
+	if (gr_acl_is_enabled() && !(current->acl->mode & GR_KERNELAUTH)) {
+		error = -EPERM;
+		goto out;
+	}
+
+#ifdef CONFIG_COMPAT
+	pax_open_kernel();
+	if (in_compat_syscall()) {
+		copy_gr_arg_wrapper = &copy_gr_arg_wrapper_compat;
+		copy_gr_arg = &copy_gr_arg_compat;
+		copy_acl_object_label = &copy_acl_object_label_compat;
+		copy_acl_subject_label = &copy_acl_subject_label_compat;
+		copy_acl_role_label = &copy_acl_role_label_compat;
+		copy_acl_ip_label = &copy_acl_ip_label_compat;
+		copy_role_allowed_ip = &copy_role_allowed_ip_compat;
+		copy_role_transition = &copy_role_transition_compat;
+		copy_sprole_pw = &copy_sprole_pw_compat;
+		copy_gr_hash_struct = &copy_gr_hash_struct_compat;
+		copy_pointer_from_array = &copy_pointer_from_array_compat;
+		get_gr_arg_wrapper_size = &get_gr_arg_wrapper_size_compat;
+	} else {
+		copy_gr_arg_wrapper = &copy_gr_arg_wrapper_normal;
+		copy_gr_arg = &copy_gr_arg_normal;
+		copy_acl_object_label = &copy_acl_object_label_normal;
+		copy_acl_subject_label = &copy_acl_subject_label_normal;
+		copy_acl_role_label = &copy_acl_role_label_normal;
+		copy_acl_ip_label = &copy_acl_ip_label_normal;
+		copy_role_allowed_ip = &copy_role_allowed_ip_normal;
+		copy_role_transition = &copy_role_transition_normal;
+		copy_sprole_pw = &copy_sprole_pw_normal;
+		copy_gr_hash_struct = &copy_gr_hash_struct_normal;
+		copy_pointer_from_array = &copy_pointer_from_array_normal;
+		get_gr_arg_wrapper_size = &get_gr_arg_wrapper_size_normal;
+	}
+	pax_close_kernel();
+#endif
+
+	req_count = get_gr_arg_wrapper_size();
+
+	if (count != req_count) {
+		gr_log_int_int(GR_DONT_AUDIT_GOOD, GR_DEV_ACL_MSG, (int)count, (int)req_count);
+		error = -EINVAL;
+		goto out;
+	}
+
+	
+	if (gr_auth_expires && time_after_eq(get_seconds(), gr_auth_expires)) {
+		gr_auth_expires = 0;
+		gr_auth_attempts = 0;
+	}
+
+	error = copy_gr_arg_wrapper(buf, &uwrap);
+	if (error)
+		goto out;
+
+	error = copy_gr_arg(uwrap.arg, gr_usermode);
+	if (error)
+		goto out;
+
+	if (gr_usermode->mode != GR_SPROLE && gr_usermode->mode != GR_SPROLEPAM &&
+	    gr_auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+	    time_after(gr_auth_expires, get_seconds())) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	/* if non-root trying to do anything other than use a special role,
+	   do not attempt authentication, do not count towards authentication
+	   locking
+	 */
+
+	if (gr_usermode->mode != GR_SPROLE && gr_usermode->mode != GR_STATUS &&
+	    gr_usermode->mode != GR_UNSPROLE && gr_usermode->mode != GR_SPROLEPAM &&
+	    gr_is_global_nonroot(current_uid())) {
+		error = -EPERM;
+		goto out;
+	}
+
+	/* ensure pw and special role name are null terminated */
+
+	gr_usermode->pw[GR_PW_LEN - 1] = '\0';
+	gr_usermode->sp_role[GR_SPROLE_LEN - 1] = '\0';
+
+	/* Okay. 
+	 * We have our enough of the argument structure..(we have yet
+	 * to copy_from_user the tables themselves) . Copy the tables
+	 * only if we need them, i.e. for loading operations. */
+
+	switch (gr_usermode->mode) {
+	case GR_STATUS:
+			if (gr_acl_is_enabled()) {
+				error = 1;
+				if (!gr_check_secure_terminal(current))
+					error = 3;
+			} else
+				error = 2;
+			goto out;
+	case GR_SHUTDOWN:
+		if (gr_acl_is_enabled() && !(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			stop_machine(gr_rbac_disable, NULL, NULL);
+			free_variables(false);
+			memset(gr_usermode, 0, sizeof(struct gr_arg));
+			memset(gr_system_salt, 0, GR_SALT_LEN);
+			memset(gr_system_sum, 0, GR_SHA_LEN);
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTS_ACL_MSG);
+		} else if (gr_acl_is_enabled()) {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHUTF_ACL_MSG);
+			error = -EPERM;
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTI_ACL_MSG);
+			error = -EAGAIN;
+		}
+		break;
+	case GR_ENABLE:
+		if (!gr_acl_is_enabled() && !(error2 = gracl_init(gr_usermode)))
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_ENABLE_ACL_MSG, GR_VERSION);
+		else {
+			if (gr_acl_is_enabled())
+				error = -EAGAIN;
+			else
+				error = error2;
+			gr_log_str(GR_DONT_AUDIT, GR_ENABLEF_ACL_MSG, GR_VERSION);
+		}
+		break;
+	case GR_OLDRELOAD:
+		oldmode = 1;
+	case GR_RELOAD:
+		if (!gr_acl_is_enabled()) {
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOADI_ACL_MSG, GR_VERSION);
+			error = -EAGAIN;
+		} else if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			error2 = gracl_reload(gr_usermode, oldmode);
+			if (!error2)
+				gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOAD_ACL_MSG, GR_VERSION);
+			else {
+				gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+				error = error2;
+			}
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+			error = -EPERM;
+		}
+		break;
+	case GR_SEGVMOD:
+		if (unlikely(!gr_acl_is_enabled())) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODS_ACL_MSG);
+			if (gr_usermode->segv_device && gr_usermode->segv_inode) {
+				struct acl_subject_label *segvacl;
+				segvacl =
+				    lookup_acl_subj_label(gr_usermode->segv_inode,
+							  gr_usermode->segv_device,
+							  current->role);
+				if (segvacl) {
+					segvacl->crashes = 0;
+					segvacl->expires = 0;
+				}
+			} else
+				gr_find_and_remove_uid(gr_usermode->segv_uid);
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SEGVMODF_ACL_MSG);
+			error = -EPERM;
+		}
+		break;
+	case GR_SPROLE:
+	case GR_SPROLEPAM:
+		if (unlikely(!gr_acl_is_enabled())) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->expires && time_after_eq(get_seconds(), current->role->expires)) {
+			current->role->expires = 0;
+			current->role->auth_attempts = 0;
+		}
+
+		if (current->role->auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+		    time_after(current->role->expires, get_seconds())) {
+			error = -EBUSY;
+			goto out;
+		}
+
+		if (lookup_special_role_auth
+		    (gr_usermode->mode, (const char *)gr_usermode->sp_role, &sprole_salt, &sprole_sum)
+		    && ((!sprole_salt && !sprole_sum)
+			|| !(chkpw(gr_usermode, sprole_salt, sprole_sum)))) {
+			char *p = "";
+			assign_special_role((const char *)gr_usermode->sp_role);
+			read_lock(&tasklist_lock);
+			if (current->real_parent)
+				p = current->real_parent->role->rolename;
+			read_unlock(&tasklist_lock);
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLES_ACL_MSG,
+					p, acl_sp_role_value);
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_SPROLEF_ACL_MSG, gr_usermode->sp_role);
+			error = -EPERM;
+			if(!(current->role->auth_attempts++))
+				current->role->expires = get_seconds() + CONFIG_GRKERNSEC_ACL_TIMEOUT;
+
+			goto out;
+		}
+		break;
+	case GR_UNSPROLE:
+		if (unlikely(!gr_acl_is_enabled())) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_UNSPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->roletype & GR_ROLE_SPECIAL) {
+			char *p = "";
+			int i = 0;
+
+			read_lock(&tasklist_lock);
+			if (current->real_parent) {
+				p = current->real_parent->role->rolename;
+				i = current->real_parent->acl_role_id;
+			}
+			read_unlock(&tasklist_lock);
+
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_UNSPROLES_ACL_MSG, p, i);
+			gr_set_acls(1);
+		} else {
+			error = -EPERM;
+			goto out;
+		}
+		break;
+	default:
+		gr_log_int(GR_DONT_AUDIT, GR_INVMODE_ACL_MSG, gr_usermode->mode);
+		error = -EINVAL;
+		break;
+	}
+
+	if (error != -EPERM)
+		goto out;
+
+	if(!(gr_auth_attempts++))
+		gr_auth_expires = get_seconds() + CONFIG_GRKERNSEC_ACL_TIMEOUT;
+
+      out:
+	mutex_unlock(&gr_dev_mutex);
+
+	if (!error)
+		error = req_count;
+
+	return error;
+}
+
+int
+gr_set_acls(const int type)
+{
+	struct task_struct *task, *task2;
+	struct acl_role_label *role = current->role;
+	struct acl_subject_label *subj;
+	__u16 acl_role_id = current->acl_role_id;
+	const struct cred *cred;
+	int ret;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	do_each_thread(task2, task) {
+		/* check to see if we're called from the exit handler,
+		   if so, only replace ACLs that have inherited the admin
+		   ACL */
+
+		if (type && (task->role != role ||
+			     task->acl_role_id != acl_role_id))
+			continue;
+
+		task->acl_role_id = 0;
+		task->acl_sp_role = 0;
+		task->inherited = 0;
+
+		if (task->exec_file) {
+			cred = __task_cred(task);
+			task->role = __lookup_acl_role_label(polstate, task, GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid));
+			subj = __gr_get_subject_for_task(polstate, task, NULL, 1);
+			if (subj == NULL) {
+				ret = -EINVAL;
+				read_unlock(&grsec_exec_file_lock);
+				read_unlock(&tasklist_lock);
+				rcu_read_unlock();
+				gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_DEFACL_MSG, task->comm, task_pid_nr(task));
+				return ret;
+			}
+			__gr_apply_subject_to_task(polstate, task, subj);
+		} else {
+			// it's a kernel process
+			task->role = polstate->kernel_role;
+			task->acl = polstate->kernel_role->root_label;
+#ifdef CONFIG_GRKERNSEC_ACL_HIDEKERN
+			task->acl->mode &= ~GR_PROCFIND;
+#endif
+		}
+	} while_each_thread(task2, task);
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	return 0;
+}
diff --git a/grsecurity/gracl_res.c b/grsecurity/gracl_res.c
new file mode 100644
index 000000000000..dfba8fd4ba9a
--- /dev/null
+++ b/grsecurity/gracl_res.c
@@ -0,0 +1,74 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grinternal.h>
+
+static const char *restab_log[] = {
+	[RLIMIT_CPU] = "RLIMIT_CPU",
+	[RLIMIT_FSIZE] = "RLIMIT_FSIZE",
+	[RLIMIT_DATA] = "RLIMIT_DATA",
+	[RLIMIT_STACK] = "RLIMIT_STACK",
+	[RLIMIT_CORE] = "RLIMIT_CORE",
+	[RLIMIT_RSS] = "RLIMIT_RSS",
+	[RLIMIT_NPROC] = "RLIMIT_NPROC",
+	[RLIMIT_NOFILE] = "RLIMIT_NOFILE",
+	[RLIMIT_MEMLOCK] = "RLIMIT_MEMLOCK",
+	[RLIMIT_AS] = "RLIMIT_AS",
+	[RLIMIT_LOCKS] = "RLIMIT_LOCKS",
+	[RLIMIT_SIGPENDING] = "RLIMIT_SIGPENDING",
+	[RLIMIT_MSGQUEUE] = "RLIMIT_MSGQUEUE",
+	[RLIMIT_NICE] = "RLIMIT_NICE",
+	[RLIMIT_RTPRIO] = "RLIMIT_RTPRIO",
+	[RLIMIT_RTTIME] = "RLIMIT_RTTIME",
+	[GR_CRASH_RES] = "RLIMIT_CRASH"
+};
+
+void
+gr_log_resource(const struct task_struct *task,
+		const int res, const unsigned long wanted, const int gt)
+{
+	const struct cred *cred;
+	unsigned long rlim;
+
+	if (!gr_acl_is_enabled() && !grsec_resource_logging)
+		return;
+
+	// not yet supported resource
+	if (unlikely(!restab_log[res]))
+		return;
+
+	/*
+	 * not really security relevant, too much userland code shared
+	 * from pulseaudio that blindly attempts to violate limits in a loop,
+	 * resulting in log spam
+	 */
+	if (res == RLIMIT_NICE)
+		return;
+
+	if (res == RLIMIT_CPU || res == RLIMIT_RTTIME)
+		rlim = task_rlimit_max(task, res);
+	else
+		rlim = task_rlimit(task, res);
+
+	if (likely((rlim == RLIM_INFINITY) || (gt && wanted <= rlim) || (!gt && wanted < rlim)))
+		return;
+
+	rcu_read_lock();
+	cred = __task_cred(task);
+
+	if (res == RLIMIT_NPROC && 
+	    (cap_raised(cred->cap_effective, CAP_SYS_ADMIN) || 
+	     cap_raised(cred->cap_effective, CAP_SYS_RESOURCE)))
+		goto out_rcu_unlock;
+	else if (res == RLIMIT_MEMLOCK &&
+		 cap_raised(cred->cap_effective, CAP_IPC_LOCK))
+		goto out_rcu_unlock;
+	rcu_read_unlock();
+
+	gr_log_res_ulong2_str(GR_DONT_AUDIT, GR_RESOURCE_MSG, task, wanted, restab_log[res], rlim);
+
+	return;
+out_rcu_unlock:
+	rcu_read_unlock();
+	return;
+}
diff --git a/grsecurity/gracl_segv.c b/grsecurity/gracl_segv.c
new file mode 100644
index 000000000000..02c5a2bb9c15
--- /dev/null
+++ b/grsecurity/gracl_segv.c
@@ -0,0 +1,306 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+#include <linux/magic.h>
+#include <linux/pagemap.h>
+#include "../fs/btrfs/async-thread.h"
+#include "../fs/btrfs/ctree.h"
+#include "../fs/btrfs/btrfs_inode.h"
+#endif
+
+static struct crash_uid *uid_set;
+static unsigned short uid_used;
+static DEFINE_SPINLOCK(gr_uid_lock);
+extern rwlock_t gr_inode_lock;
+extern struct acl_subject_label *
+	lookup_acl_subj_label(const u64 inode, const dev_t dev,
+			      const struct acl_role_label *role);
+
+int
+gr_init_uidset(void)
+{
+	uid_set =
+	    kmalloc(GR_UIDTABLE_MAX * sizeof (struct crash_uid), GFP_KERNEL);
+	uid_used = 0;
+
+	return uid_set ? 1 : 0;
+}
+
+void
+gr_free_uidset(void)
+{
+	if (uid_set) {
+		struct crash_uid *tmpset;
+		spin_lock(&gr_uid_lock);
+		tmpset = uid_set;
+		uid_set = NULL;
+		uid_used = 0;
+		spin_unlock(&gr_uid_lock);
+		if (tmpset)
+			kfree(tmpset);
+	}
+
+	return;
+}
+
+int
+gr_find_uid(const uid_t uid)
+{
+	struct crash_uid *tmp = uid_set;
+	uid_t buid;
+	int low = 0, high = uid_used - 1, mid;
+
+	while (high >= low) {
+		mid = (low + high) >> 1;
+		buid = tmp[mid].uid;
+		if (buid == uid)
+			return mid;
+		if (buid > uid)
+			high = mid - 1;
+		if (buid < uid)
+			low = mid + 1;
+	}
+
+	return -1;
+}
+
+static void
+gr_insertsort(void)
+{
+	unsigned short i, j;
+	struct crash_uid index;
+
+	for (i = 1; i < uid_used; i++) {
+		index = uid_set[i];
+		j = i;
+		while ((j > 0) && uid_set[j - 1].uid > index.uid) {
+			uid_set[j] = uid_set[j - 1];
+			j--;
+		}
+		uid_set[j] = index;
+	}
+
+	return;
+}
+
+static void
+gr_insert_uid(const kuid_t kuid, const unsigned long expires)
+{
+	int loc;
+	uid_t uid = GR_GLOBAL_UID(kuid);
+
+	if (uid_used == GR_UIDTABLE_MAX)
+		return;
+
+	loc = gr_find_uid(uid);
+
+	if (loc >= 0) {
+		uid_set[loc].expires = expires;
+		return;
+	}
+
+	uid_set[uid_used].uid = uid;
+	uid_set[uid_used].expires = expires;
+	uid_used++;
+
+	gr_insertsort();
+
+	return;
+}
+
+void
+gr_remove_uid(const unsigned short loc)
+{
+	unsigned short i;
+
+	for (i = loc + 1; i < uid_used; i++)
+		uid_set[i - 1] = uid_set[i];
+
+	uid_used--;
+
+	return;
+}
+
+int gr_find_and_remove_uid(uid_t uid)
+{
+	int loc;
+
+	spin_lock(&gr_uid_lock);
+	loc = gr_find_uid(uid);
+	if (loc >= 0)
+		gr_remove_uid(loc);
+	spin_unlock(&gr_uid_lock);
+
+	return loc >= 0 ? 1 : 0;
+}
+
+int
+gr_check_crash_uid(const kuid_t kuid)
+{
+	int loc;
+	int ret = 0;
+	uid_t uid;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	uid = GR_GLOBAL_UID(kuid);
+
+	spin_lock(&gr_uid_lock);
+	loc = gr_find_uid(uid);
+
+	if (loc < 0)
+		goto out_unlock;
+
+	if (time_before_eq(uid_set[loc].expires, get_seconds()))
+		gr_remove_uid(loc);
+	else
+		ret = 1;
+
+out_unlock:
+	spin_unlock(&gr_uid_lock);
+	return ret;
+}
+
+extern int gr_fake_force_sig(int sig, struct task_struct *t);
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	struct acl_subject_label *curr;
+	struct task_struct *tsk, *tsk2;
+	const struct cred *cred;
+	const struct cred *cred2;
+
+	if (sig != SIGSEGV && sig != SIGKILL && sig != SIGBUS && sig != SIGILL)
+		return;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curr = task->acl;
+
+	if (!(curr->resmask & (1U << GR_CRASH_RES)))
+		return;
+
+	if (time_before_eq(curr->expires, get_seconds())) {
+		curr->expires = 0;
+		curr->crashes = 0;
+	}
+
+	curr->crashes++;
+
+	if (!curr->expires)
+		curr->expires = get_seconds() + curr->res[GR_CRASH_RES].rlim_max;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, get_seconds())) {
+		int is_priv = is_privileged_binary(task->mm->exe_file->f_path.dentry);
+
+		rcu_read_lock();
+		cred = __task_cred(task);
+		if (gr_is_global_nonroot(cred->uid) && is_priv) {
+			gr_log_crash1(GR_DONT_AUDIT, GR_SEGVSTART_ACL_MSG, task, curr->res[GR_CRASH_RES].rlim_max);
+			spin_lock(&gr_uid_lock);
+			gr_insert_uid(cred->uid, curr->expires);
+			spin_unlock(&gr_uid_lock);
+			curr->expires = 0;
+			curr->crashes = 0;
+			read_lock(&tasklist_lock);
+			do_each_thread(tsk2, tsk) {
+				cred2 = __task_cred(tsk);
+				if (tsk != task && uid_eq(cred2->uid, cred->uid))
+					gr_fake_force_sig(SIGKILL, tsk);
+			} while_each_thread(tsk2, tsk);
+			read_unlock(&tasklist_lock);
+		} else {
+			gr_log_crash2(GR_DONT_AUDIT, GR_SEGVNOSUID_ACL_MSG, task, curr->res[GR_CRASH_RES].rlim_max);
+			read_lock(&tasklist_lock);
+			read_lock(&grsec_exec_file_lock);
+			do_each_thread(tsk2, tsk) {
+				if (likely(tsk != task)) {
+					// if this thread has the same subject as the one that triggered
+					// RES_CRASH and it's the same binary, kill it
+					if (tsk->acl == task->acl && gr_is_same_file(tsk->exec_file, task->exec_file))
+						gr_fake_force_sig(SIGKILL, tsk);
+				}
+			} while_each_thread(tsk2, tsk);
+			read_unlock(&grsec_exec_file_lock);
+			read_unlock(&tasklist_lock);
+		}
+		rcu_read_unlock();
+	}
+
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	struct acl_subject_label *curr;
+	struct dentry *dentry;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	read_lock(&gr_inode_lock);
+	dentry = filp->f_path.dentry;
+	curr = lookup_acl_subj_label(gr_get_ino_from_dentry(dentry), gr_get_dev_from_dentry(dentry),
+				     current->role);
+	read_unlock(&gr_inode_lock);
+
+	if (!curr || !(curr->resmask & (1U << GR_CRASH_RES)) ||
+	    (!curr->crashes && !curr->expires))
+		return 0;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, get_seconds()))
+		return 1;
+	else if (time_before_eq(curr->expires, get_seconds())) {
+		curr->crashes = 0;
+		curr->expires = 0;
+	}
+
+	return 0;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	struct acl_subject_label *curracl;
+	__u32 curr_ip;
+	struct task_struct *p, *p2;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curracl = task->acl;
+	curr_ip = task->signal->curr_ip;
+
+	if ((curracl->mode & GR_KILLIPPROC) && curr_ip) {
+		read_lock(&tasklist_lock);
+		do_each_thread(p2, p) {
+			if (p->signal->curr_ip == curr_ip)
+				gr_fake_force_sig(SIGKILL, p);
+		} while_each_thread(p2, p);
+		read_unlock(&tasklist_lock);
+	} else if (curracl->mode & GR_KILLPROC)
+		gr_fake_force_sig(SIGKILL, task);
+
+	return;
+}
diff --git a/grsecurity/gracl_shm.c b/grsecurity/gracl_shm.c
new file mode 100644
index 000000000000..6b0c9cc644ff
--- /dev/null
+++ b/grsecurity/gracl_shm.c
@@ -0,0 +1,40 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/ipc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const u64 shm_createtime, const kuid_t cuid, const int shmid)
+{
+	struct task_struct *task;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+
+	task = find_task_by_vpid(shm_cprid);
+
+	if (unlikely(!task))
+		task = find_task_by_vpid(shm_lapid);
+
+	if (unlikely(task && (time_before_eq64(task->start_time, shm_createtime) ||
+			      (task_pid_nr(task) == shm_lapid)) &&
+		     (task->acl->mode & GR_PROTSHM) &&
+		     (task->acl != current->acl))) {
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+		gr_log_int3(GR_DONT_AUDIT, GR_SHMAT_ACL_MSG, GR_GLOBAL_UID(cuid), shm_cprid, shmid);
+		return 0;
+	}
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	return 1;
+}
diff --git a/grsecurity/grsec_chdir.c b/grsecurity/grsec_chdir.c
new file mode 100644
index 000000000000..bc0be01b02a0
--- /dev/null
+++ b/grsecurity/grsec_chdir.c
@@ -0,0 +1,19 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_chdir(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	if ((grsec_enable_chdir && grsec_enable_group &&
+	     in_group_p(grsec_audit_gid)) || (grsec_enable_chdir &&
+					      !grsec_enable_group)) {
+		gr_log_fs_generic(GR_DO_AUDIT, GR_CHDIR_AUDIT_MSG, dentry, mnt);
+	}
+#endif
+	return;
+}
diff --git a/grsecurity/grsec_chroot.c b/grsecurity/grsec_chroot.c
new file mode 100644
index 000000000000..1964ab1c888e
--- /dev/null
+++ b/grsecurity/grsec_chroot.c
@@ -0,0 +1,506 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/types.h>
+#include <linux/namei.h>
+#include "../fs/mount.h"
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+#ifdef CONFIG_GRKERNSEC_CHROOT_INITRD
+int gr_init_ran;
+#endif
+
+void gr_inc_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *tmpd = dentry;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	while (tmpd != mnt->mnt_root) {
+		atomic_inc(&tmpd->chroot_refcnt);
+		tmpd = tmpd->d_parent;
+	}
+	atomic_inc(&tmpd->chroot_refcnt);
+
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+#endif
+}
+
+void gr_dec_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *tmpd = dentry;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	while (tmpd != mnt->mnt_root) {
+		atomic_dec(&tmpd->chroot_refcnt);
+		tmpd = tmpd->d_parent;
+	}
+	atomic_dec(&tmpd->chroot_refcnt);
+
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+#endif
+}
+
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+static struct dentry *get_closest_chroot(struct dentry *dentry)
+{
+	write_seqlock(&rename_lock);
+	do {
+		if (atomic_read(&dentry->chroot_refcnt)) {
+			write_sequnlock(&rename_lock);
+			return dentry;
+		}
+		dentry = dentry->d_parent;
+	} while (!IS_ROOT(dentry));
+	write_sequnlock(&rename_lock);
+	return NULL;
+}
+#endif
+
+int gr_bad_chroot_rename(struct dentry *olddentry, struct vfsmount *oldmnt,
+			 struct dentry *newdentry, struct vfsmount *newmnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *chroot;
+
+	if (unlikely(!grsec_enable_chroot_rename))
+		return 0;
+
+	if (likely(!proc_is_chrooted(current) && gr_is_global_root(current_uid())))
+		return 0;
+
+	chroot = get_closest_chroot(olddentry);
+
+	if (chroot == NULL)
+		return 0;
+
+	if (is_subdir(newdentry, chroot))
+		return 0;
+
+	gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_RENAME_MSG, olddentry, oldmnt);
+
+	return 1;
+#else
+	return 0;
+#endif
+}
+
+void gr_set_chroot_entries(struct task_struct *task, const struct path *path)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (task_pid_nr(task) > 1 && path->dentry != init_task.fs->root.dentry &&
+	    		     path->dentry != task->nsproxy->mnt_ns->root->mnt.mnt_root
+#ifdef CONFIG_GRKERNSEC_CHROOT_INITRD
+			     && gr_init_ran
+#endif
+	   )
+		task->gr_is_chrooted = 1;
+	else {
+#ifdef CONFIG_GRKERNSEC_CHROOT_INITRD
+		if (task_pid_nr(task) == 1 && !gr_init_ran)
+			gr_init_ran = 1;
+#endif
+		task->gr_is_chrooted = 0;
+	}
+
+	task->gr_chroot_dentry = path->dentry;
+#endif
+	return;
+}
+
+void gr_clear_chroot_entries(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC
+	task->gr_is_chrooted = 0;
+	task->gr_chroot_dentry = NULL;
+#endif
+	return;
+}	
+
+int
+gr_handle_chroot_unix(const pid_t pid)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	struct task_struct *p;
+
+	if (unlikely(!grsec_enable_chroot_unix))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	p = find_task_by_vpid_unrestricted(pid);
+	if (unlikely(p && !have_same_root(current, p))) {
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+		gr_log_noargs(GR_DONT_AUDIT, GR_UNIX_CHROOT_MSG);
+		return 0;
+	}
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+#endif
+	return 1;
+}
+
+int
+gr_handle_chroot_nice(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_NICE_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_setpriority(struct task_struct *p, const int niceval)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && (niceval < task_nice(p))
+			&& proc_is_chrooted(current)) {
+		gr_log_str_int(GR_DONT_AUDIT, GR_PRIORITY_CHROOT_MSG, p->comm, task_pid_nr(p));
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_fowner(struct pid *pid, enum pid_type type)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	struct task_struct *p;
+	int ret = 0;
+	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || !pid)
+		return ret;
+
+	read_lock(&tasklist_lock);
+	do_each_pid_task(pid, type, p) {
+		if (!have_same_root(current, p)) {
+			ret = 1;
+			goto out;
+		}
+	} while_each_pid_task(pid, type, p);
+out:
+	read_unlock(&tasklist_lock);
+	return ret;
+#endif
+	return 0;
+}
+
+int
+gr_pid_is_chrooted(struct task_struct *p)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || p == NULL)
+		return 0;
+
+	if ((p->exit_state & (EXIT_ZOMBIE | EXIT_DEAD)) ||
+	    !have_same_root(current, p)) {
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(gr_pid_is_chrooted);
+
+#if defined(CONFIG_GRKERNSEC_CHROOT_DOUBLE) || defined(CONFIG_GRKERNSEC_CHROOT_FCHDIR)
+int gr_is_outside_chroot(const struct dentry *u_dentry, const struct vfsmount *u_mnt)
+{
+	struct path path, currentroot;
+	int ret = 0;
+
+	path.dentry = (struct dentry *)u_dentry;
+	path.mnt = (struct vfsmount *)u_mnt;
+	get_fs_root(current->fs, &currentroot);
+	if (path_is_under(&path, &currentroot))
+		ret = 1;
+	path_put(&currentroot);
+
+	return ret;
+}
+#endif
+
+int
+gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	if (!grsec_enable_chroot_fchdir)
+		return 1;
+
+	if (!proc_is_chrooted(current))
+		return 1;
+	else if (!gr_is_outside_chroot(u_dentry, u_mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_FCHDIR_MSG, u_dentry, u_mnt);
+		return 0;
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_pathat(int dfd, struct dentry *u_dentry, struct vfsmount *u_mnt, unsigned flags)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	struct fd f;
+	struct path fd_path;
+	struct path file_path;
+
+	if (!grsec_enable_chroot_fchdir)
+		return 0;
+
+	if (!proc_is_chrooted(current) || dfd == -1 || dfd == AT_FDCWD)
+		return 0;
+
+	if (flags & LOOKUP_RCU)
+		return -ECHILD;
+
+	f = fdget_raw(dfd);
+	if (!f.file)
+		return 0;
+
+	fd_path = f.file->f_path;
+	path_get(&fd_path);
+	fdput(f);
+
+	file_path.dentry = u_dentry;
+	file_path.mnt = u_mnt;
+
+	if (!gr_is_outside_chroot(u_dentry, u_mnt) && !path_is_under(&file_path, &fd_path)) {
+		path_put(&fd_path);
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_PATHAT_MSG, u_dentry, u_mnt);
+		return -ENOENT;
+	}
+	path_put(&fd_path);
+#endif
+	return 0;
+}
+
+int
+gr_chroot_fhandle(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	if (!grsec_enable_chroot_fchdir)
+		return 1;
+
+	if (!proc_is_chrooted(current))
+		return 1;
+	else {
+		gr_log_noargs(GR_DONT_AUDIT, GR_CHROOT_FHANDLE_MSG);
+		return 0;
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const u64 shm_createtime)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	struct task_struct *p;
+
+	if (unlikely(!grsec_enable_chroot_shmat))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+
+	if ((p = find_task_by_vpid_unrestricted(shm_cprid))) {
+		if (time_before_eq64(p->start_time, shm_createtime)) {
+			if (have_same_root(current, p)) {
+				goto allow;
+			} else {
+				read_unlock(&tasklist_lock);
+				rcu_read_unlock();
+				gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+				return 0;
+			}
+		}
+		/* creator exited, pid reuse, fall through to next check */
+	}
+	if ((p = find_task_by_vpid_unrestricted(shm_lapid))) {
+		if (unlikely(!have_same_root(current, p))) {
+			read_unlock(&tasklist_lock);
+			rcu_read_unlock();
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+			return 0;
+		}
+	}
+
+allow:
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+#endif
+	return 1;
+}
+
+void
+gr_log_chroot_exec(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	if (grsec_enable_chroot_execlog && proc_is_chrooted(current))
+		gr_log_fs_generic(GR_DO_AUDIT, GR_EXEC_CHROOT_MSG, dentry, mnt);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_mknod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && !S_ISREG(mode) && 
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_MKNOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_mount(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const char *dev_name)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+		gr_log_str_fs(GR_DONT_AUDIT, GR_MOUNT_CHROOT_MSG, dev_name ? dev_name : "none", dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_pivot(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_PIVOT_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_chroot(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	if (grsec_enable_chroot_double && proc_is_chrooted(current) &&
+	    !gr_is_outside_chroot(dentry, mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+extern const char *captab_log[];
+extern int captab_log_entries;
+
+int
+gr_task_chroot_is_capable(const struct task_struct *task, const struct cred *cred, const int cap)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+		kernel_cap_t chroot_caps = GR_CHROOT_CAPS;
+		if (cap_raised(chroot_caps, cap)) {
+			if (cap_raised(cred->cap_effective, cap) && cap < captab_log_entries) {
+				gr_log_cap(GR_DONT_AUDIT, GR_CAP_CHROOT_MSG, task, captab_log[cap]);
+			}
+			return 0;
+		}
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_is_capable(const int cap)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	return gr_task_chroot_is_capable(current, current_cred(), cap);
+#endif
+	return 1;
+}
+
+int
+gr_task_chroot_is_capable_nolog(const struct task_struct *task, const int cap)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+		kernel_cap_t chroot_caps = GR_CHROOT_CAPS;
+		if (cap_raised(chroot_caps, cap)) {
+			return 0;
+		}
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_is_capable_nolog(const int cap)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	return gr_task_chroot_is_capable_nolog(current, cap);
+#endif
+	return 1;
+}
+
+int
+gr_handle_chroot_sysctl(const int op)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	if (grsec_enable_chroot_sysctl && (op & MAY_WRITE) &&
+	    proc_is_chrooted(current))
+		return -EACCES;
+#endif
+	return 0;
+}
+
+void
+gr_handle_chroot_chdir(const struct path *path)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	if (grsec_enable_chroot_chdir)
+		set_fs_pwd(current->fs, path);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_chmod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	/* allow chmod +s on directories, but not files */
+	if (grsec_enable_chroot_chmod && !d_is_dir(dentry) &&
+	    ((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))) &&
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHMOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_disabled.c b/grsecurity/grsec_disabled.c
new file mode 100644
index 000000000000..ba8d9971ed37
--- /dev/null
+++ b/grsecurity/grsec_disabled.c
@@ -0,0 +1,445 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kdev_t.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/sysctl.h>
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+__u32
+gr_handle_sysctl(const struct ctl_table * table, const int op)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TASKSTATS
+int gr_is_taskstats_denied(int pid)
+{
+	return 0;
+}
+#endif
+
+int
+gr_acl_is_enabled(void)
+{
+	return 0;
+}
+
+int
+gr_learn_cap(const struct task_struct *task, const struct cred *cred, const int cap, bool log)
+{
+	return 0;
+}
+
+void
+gr_handle_proc_create(const struct dentry *dentry, const struct inode *inode) 
+{
+	return;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+	return 0;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	return;
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	return 0;
+}
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	return 0;
+}
+
+int
+gr_set_acls(const int type)
+{
+	return 0;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *tsk)
+{
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	return 0;
+}
+
+int
+gr_check_protected_task_fowner(struct pid *pid, enum pid_type type)
+{
+	return 0;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	return;
+}
+
+void
+gr_set_pax_flags(struct task_struct *task)
+{
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
+		  const int unsafe_share)
+{
+	return 0;
+}
+
+void
+gr_handle_delete(const u64 ino, const dev_t dev)
+{
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return;
+}
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	return 0;
+}
+
+int
+gr_check_crash_uid(const kuid_t uid)
+{
+	return 0;
+}
+
+void
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace, unsigned int flags)
+{
+	return;
+}
+
+int
+gr_search_socket(const int family, const int type, const int protocol)
+{
+	return 1;
+}
+
+int
+gr_search_connectbind(const int mode, const struct socket *sock,
+		      const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	return;
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   int acc_mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot,
+		   unsigned int *vm_flags)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry * dentry,
+		       const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry,
+		     const struct vfsmount * mnt, const int fmode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry * dentry, const struct vfsmount * mnt,
+		    umode_t *mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_setxattr(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_removexattr(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+void
+grsecurity_init(void)
+{
+	return;
+}
+
+umode_t gr_acl_umask(void)
+{
+	return 0;
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const struct filename *from)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const struct filename *to)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_rename(const struct dentry *new_dentry,
+		     const struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     const struct dentry *old_dentry,
+		     const struct inode *old_parent_inode,
+		     const struct vfsmount *old_mnt, const struct filename *newname,
+		     unsigned int flags)
+{
+	return 0;
+}
+
+int
+gr_acl_handle_filldir(const struct file *file, const char *name,
+		      const int namelen, const u64 ino)
+{
+	return 1;
+}
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const u64 shm_createtime, const kuid_t cuid, const int shmid)
+{
+	return 1;
+}
+
+int
+gr_search_bind(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+int
+gr_search_accept(const struct socket *sock)
+{
+	return 0;
+}
+
+int
+gr_search_listen(const struct socket *sock)
+{
+	return 0;
+}
+
+int
+gr_search_connect(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, int open_flags, int acc_mode,
+		    const int imode)
+{
+	return 1;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	return;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	return 1;
+}
+
+void
+gr_set_role_label(const kuid_t uid, const kgid_t gid)
+{
+	return;
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	return 0;
+}
+
+int
+gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb)
+{
+	return 0;
+}
+
+int
+gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+int
+gr_check_user_change(kuid_t real, kuid_t effective, kuid_t fs)
+{
+	return 0;
+}
+
+int
+gr_check_group_change(kgid_t real, kgid_t effective, kgid_t fs)
+{
+	return 0;
+}
+
+int gr_acl_enable_at_secure(void)
+{
+	return 0;
+}
+
+dev_t gr_get_dev_from_dentry(struct dentry *dentry)
+{
+	return d_backing_inode(dentry)->i_sb->s_dev;
+}
+
+u64 gr_get_ino_from_dentry(struct dentry *dentry)
+{
+	return d_backing_inode(dentry)->i_ino;
+}
+
+void gr_put_exec_file(struct task_struct *task)
+{
+	return;
+}
+
+#ifdef CONFIG_SECURITY
+EXPORT_SYMBOL_GPL(gr_check_user_change);
+EXPORT_SYMBOL_GPL(gr_check_group_change);
+#endif
diff --git a/grsecurity/grsec_exec.c b/grsecurity/grsec_exec.c
new file mode 100644
index 000000000000..808006ec242c
--- /dev/null
+++ b/grsecurity/grsec_exec.c
@@ -0,0 +1,188 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/binfmts.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/grdefs.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/capability.h>
+#include <linux/module.h>
+#include <linux/compat.h>
+
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+static char gr_exec_arg_buf[132];
+static DEFINE_MUTEX(gr_exec_arg_mutex);
+#endif
+
+struct user_arg_ptr {
+#ifdef CONFIG_COMPAT
+	bool is_compat;
+#endif
+	union {
+		const char __user *const __user *native;
+#ifdef CONFIG_COMPAT
+		const compat_uptr_t __user *compat;
+#endif
+	} ptr;
+};
+
+extern const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr);
+
+void
+gr_handle_exec_args(struct linux_binprm *bprm, struct user_arg_ptr argv)
+{
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	char *grarg = gr_exec_arg_buf;
+	unsigned int i, x, execlen = 0;
+	char c;
+
+	if (!((grsec_enable_execlog && grsec_enable_group &&
+	       in_group_p(grsec_audit_gid))
+	      || (grsec_enable_execlog && !grsec_enable_group)))
+		return;
+
+	mutex_lock(&gr_exec_arg_mutex);
+	memset(grarg, 0, sizeof(gr_exec_arg_buf));
+
+	for (i = 0; i < bprm->argc && execlen < 128; i++) {
+		const char __user *p;
+		unsigned int len;
+
+		p = get_user_arg_ptr(argv, i);
+		if (IS_ERR(p))
+			goto log;
+
+		len = strnlen_user(p, 128 - execlen);
+		if (len > 128 - execlen)
+			len = 128 - execlen;
+		else if (len > 0)
+			len--;
+		if (copy_from_user(grarg + execlen, p, len))
+			goto log;
+
+		/* rewrite unprintable characters */
+		for (x = 0; x < len; x++) {
+			c = *(grarg + execlen + x);
+			if (c < 32 || c > 126)
+				*(grarg + execlen + x) = ' ';
+		}
+
+		execlen += len;
+		*(grarg + execlen) = ' ';
+		*(grarg + execlen + 1) = '\0';
+		execlen++;
+	}
+
+      log:
+	gr_log_fs_str(GR_DO_AUDIT, GR_EXEC_AUDIT_MSG, bprm->file->f_path.dentry,
+			bprm->file->f_path.mnt, grarg);
+	mutex_unlock(&gr_exec_arg_mutex);
+#endif
+	return;
+}
+
+#ifdef CONFIG_GRKERNSEC
+extern int gr_acl_is_capable(const int cap);
+extern int gr_acl_is_capable_nolog(const int cap);
+extern int gr_task_acl_is_capable(const struct task_struct *task, const struct cred *cred, const int cap, bool log);
+extern int gr_chroot_is_capable(const int cap);
+extern int gr_chroot_is_capable_nolog(const int cap);
+extern int gr_task_chroot_is_capable(const struct task_struct *task, const struct cred *cred, const int cap);
+extern int gr_task_chroot_is_capable_nolog(const struct task_struct *task, const int cap);
+#endif
+
+const char *captab_log[] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",
+	"CAP_LEASE",
+	"CAP_AUDIT_WRITE",
+	"CAP_AUDIT_CONTROL",
+	"CAP_SETFCAP",
+	"CAP_MAC_OVERRIDE",
+	"CAP_MAC_ADMIN",
+	"CAP_SYSLOG",
+	"CAP_WAKE_ALARM",
+	"CAP_BLOCK_SUSPEND",
+	"CAP_AUDIT_READ"
+};
+
+int captab_log_entries = sizeof(captab_log)/sizeof(captab_log[0]);
+
+int gr_is_capable(const int cap)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (gr_acl_is_capable(cap) && gr_chroot_is_capable(cap))
+		return 1;
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+int gr_task_is_capable(const struct task_struct *task, const struct cred *cred, const int cap)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (gr_task_acl_is_capable(task, cred, cap, true) && gr_task_chroot_is_capable(task, cred, cap))
+		return 1;
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+int gr_is_capable_nolog(const int cap)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (gr_acl_is_capable_nolog(cap) && gr_chroot_is_capable_nolog(cap))
+		return 1;
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+int gr_task_is_capable_nolog(const struct task_struct *task, const struct cred *cred, const int cap)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (gr_task_acl_is_capable(task, cred, cap, false) && gr_task_chroot_is_capable_nolog(task, cap))
+		return 1;
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+EXPORT_SYMBOL_GPL(gr_is_capable);
+EXPORT_SYMBOL_GPL(gr_is_capable_nolog);
+EXPORT_SYMBOL_GPL(gr_task_is_capable);
+EXPORT_SYMBOL_GPL(gr_task_is_capable_nolog);
diff --git a/grsecurity/grsec_fifo.c b/grsecurity/grsec_fifo.c
new file mode 100644
index 000000000000..cdec49b4f5da
--- /dev/null
+++ b/grsecurity/grsec_fifo.c
@@ -0,0 +1,26 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_fifo(const struct dentry *dentry, const struct vfsmount *mnt,
+	       const struct dentry *dir, const int flag, const int acc_mode)
+{
+#ifdef CONFIG_GRKERNSEC_FIFO
+	const struct cred *cred = current_cred();
+	struct inode *inode = d_backing_inode(dentry);
+	struct inode *dir_inode = d_backing_inode(dir);
+
+	if (grsec_enable_fifo && S_ISFIFO(inode->i_mode) &&
+	    !(flag & O_EXCL) && (dir_inode->i_mode & S_ISVTX) &&
+	    !uid_eq(inode->i_uid, dir_inode->i_uid) &&
+	    !uid_eq(cred->fsuid, inode->i_uid)) {
+		if (!inode_permission(inode, acc_mode))
+			gr_log_fs_int2(GR_DONT_AUDIT, GR_FIFO_MSG, dentry, mnt, GR_GLOBAL_UID(inode->i_uid), GR_GLOBAL_GID(inode->i_gid));
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_fork.c b/grsecurity/grsec_fork.c
new file mode 100644
index 000000000000..8ca18bfafe1c
--- /dev/null
+++ b/grsecurity/grsec_fork.c
@@ -0,0 +1,23 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/errno.h>
+
+void
+gr_log_forkfail(const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	if (grsec_enable_forkfail && (retval == -EAGAIN || retval == -ENOMEM)) {
+		switch (retval) {
+			case -EAGAIN:
+				gr_log_str(GR_DONT_AUDIT, GR_FAILFORK_MSG, "EAGAIN");
+				break;
+			case -ENOMEM:
+				gr_log_str(GR_DONT_AUDIT, GR_FAILFORK_MSG, "ENOMEM");
+				break;
+		}
+	}
+#endif
+	return;
+}
diff --git a/grsecurity/grsec_init.c b/grsecurity/grsec_init.c
new file mode 100644
index 000000000000..68222080fd42
--- /dev/null
+++ b/grsecurity/grsec_init.c
@@ -0,0 +1,294 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/gracl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/percpu.h>
+#include <linux/module.h>
+
+int grsec_enable_ptrace_readexec __read_only;
+int grsec_enable_setxid __read_only;
+int grsec_enable_symlinkown __read_only;
+kgid_t grsec_symlinkown_gid __read_only;
+int grsec_enable_brute __read_only;
+int grsec_enable_link __read_only;
+int grsec_enable_dmesg __read_only;
+int grsec_enable_harden_ptrace __read_only;
+int grsec_enable_harden_ipc __read_only;
+int grsec_enable_fifo __read_only;
+int grsec_enable_execlog __read_only;
+int grsec_enable_signal __read_only;
+int grsec_enable_forkfail __read_only;
+int grsec_enable_audit_ptrace __read_only;
+int grsec_enable_time __read_only;
+int grsec_enable_group __read_only;
+kgid_t grsec_audit_gid __read_only;
+int grsec_enable_chdir __read_only;
+int grsec_enable_mount __read_only;
+int grsec_enable_rofs __read_only;
+int grsec_deny_new_usb __read_only;
+int grsec_enable_chroot_findtask __read_only;
+int grsec_enable_chroot_mount __read_only;
+int grsec_enable_chroot_shmat __read_only;
+int grsec_enable_chroot_fchdir __read_only;
+int grsec_enable_chroot_double __read_only;
+int grsec_enable_chroot_pivot __read_only;
+int grsec_enable_chroot_chdir __read_only;
+int grsec_enable_chroot_chmod __read_only;
+int grsec_enable_chroot_mknod __read_only;
+int grsec_enable_chroot_nice __read_only;
+int grsec_enable_chroot_execlog __read_only;
+int grsec_enable_chroot_caps __read_only;
+int grsec_enable_chroot_rename __read_only;
+int grsec_enable_chroot_sysctl __read_only;
+int grsec_enable_chroot_unix __read_only;
+int grsec_enable_tpe __read_only;
+kgid_t grsec_tpe_gid __read_only;
+int grsec_enable_blackhole __read_only;
+#ifdef CONFIG_IPV6_MODULE
+EXPORT_SYMBOL_GPL(grsec_enable_blackhole);
+#endif
+int grsec_lastack_retries __read_only;
+int grsec_enable_tpe_all __read_only;
+int grsec_enable_tpe_invert __read_only;
+int grsec_enable_socket_all __read_only;
+kgid_t grsec_socket_all_gid __read_only;
+int grsec_enable_socket_client __read_only;
+kgid_t grsec_socket_client_gid __read_only;
+int grsec_enable_socket_server __read_only;
+kgid_t grsec_socket_server_gid __read_only;
+int grsec_resource_logging __read_only;
+int grsec_disable_privio __read_only;
+int grsec_enable_log_rwxmaps __read_only;
+int grsec_enable_harden_tty __read_only;
+int grsec_lock __read_only;
+
+DEFINE_SPINLOCK(grsec_alert_lock);
+unsigned long grsec_alert_wtime = 0;
+unsigned long grsec_alert_fyet = 0;
+
+DEFINE_SPINLOCK(grsec_audit_lock);
+
+DEFINE_RWLOCK(grsec_exec_file_lock);
+
+char *gr_shared_page[4];
+
+char *gr_alert_log_fmt;
+char *gr_audit_log_fmt;
+char *gr_alert_log_buf;
+char *gr_audit_log_buf;
+
+extern struct gr_arg *gr_usermode;
+extern unsigned char *gr_system_salt;
+extern unsigned char *gr_system_sum;
+
+void __init
+grsecurity_init(void)
+{
+	int j;
+	/* create the per-cpu shared pages */
+
+#ifdef CONFIG_X86
+	memset((char *)(0x41a + PAGE_OFFSET), 0, 36);
+#endif
+
+	for (j = 0; j < 4; j++) {
+		gr_shared_page[j] = (char *)__alloc_percpu(PAGE_SIZE, __alignof__(unsigned long long));
+		if (gr_shared_page[j] == NULL) {
+			panic("Unable to allocate grsecurity shared page");
+			return;
+		}
+	}
+
+	/* allocate log buffers */
+	gr_alert_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_alert_log_fmt) {
+		panic("Unable to allocate grsecurity alert log format buffer");
+		return;
+	}
+	gr_audit_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_audit_log_fmt) {
+		panic("Unable to allocate grsecurity audit log format buffer");
+		return;
+	}
+	gr_alert_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_alert_log_buf) {
+		panic("Unable to allocate grsecurity alert log buffer");
+		return;
+	}
+	gr_audit_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_audit_log_buf) {
+		panic("Unable to allocate grsecurity audit log buffer");
+		return;
+	}
+
+	/* allocate memory for authentication structure */
+	gr_usermode = kmalloc(sizeof(struct gr_arg), GFP_KERNEL);
+	gr_system_salt = kmalloc(GR_SALT_LEN, GFP_KERNEL);
+	gr_system_sum = kmalloc(GR_SHA_LEN, GFP_KERNEL);
+
+	if (!gr_usermode || !gr_system_salt || !gr_system_sum) {
+		panic("Unable to allocate grsecurity authentication structure");
+		return;
+	}
+
+#ifdef CONFIG_GRKERNSEC_IO
+#if !defined(CONFIG_GRKERNSEC_SYSCTL_DISTRO)
+	grsec_disable_privio = 1;
+#elif defined(CONFIG_GRKERNSEC_SYSCTL_ON)
+	grsec_disable_privio = 1;
+#else
+	grsec_disable_privio = 0;
+#endif
+#endif
+
+#ifdef CONFIG_GRKERNSEC_TPE_INVERT
+	/* for backward compatibility, tpe_invert always defaults to on if
+	   enabled in the kernel
+	*/
+	grsec_enable_tpe_invert = 1;
+#endif
+
+#if !defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_SYSCTL_ON)
+#ifndef CONFIG_GRKERNSEC_SYSCTL
+	grsec_lock = 1;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	grsec_enable_log_rwxmaps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	grsec_enable_group = 1;
+	grsec_audit_gid = KGIDT_INIT(CONFIG_GRKERNSEC_AUDIT_GID);
+#endif
+#ifdef CONFIG_GRKERNSEC_PTRACE_READEXEC
+	grsec_enable_ptrace_readexec = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	grsec_enable_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	grsec_enable_harden_ptrace = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_IPC
+	grsec_enable_harden_ipc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_TTY
+	grsec_enable_harden_tty = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	grsec_enable_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+	grsec_enable_link = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	grsec_enable_brute = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	grsec_enable_dmesg = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	grsec_enable_blackhole = 1;
+	grsec_lastack_retries = 4;
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	grsec_enable_fifo = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	grsec_enable_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SETXID
+	grsec_enable_setxid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	grsec_enable_signal = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	grsec_enable_forkfail = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	grsec_enable_time = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RESLOG
+	grsec_resource_logging = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	grsec_enable_chroot_findtask = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	grsec_enable_chroot_unix = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	grsec_enable_chroot_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	grsec_enable_chroot_fchdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	grsec_enable_chroot_shmat = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_PTRACE
+	grsec_enable_audit_ptrace = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	grsec_enable_chroot_double = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	grsec_enable_chroot_pivot = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	grsec_enable_chroot_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	grsec_enable_chroot_chmod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	grsec_enable_chroot_mknod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	grsec_enable_chroot_nice = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	grsec_enable_chroot_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	grsec_enable_chroot_caps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	grsec_enable_chroot_rename = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	grsec_enable_chroot_sysctl = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SYMLINKOWN
+	grsec_enable_symlinkown = 1;
+	grsec_symlinkown_gid = KGIDT_INIT(CONFIG_GRKERNSEC_SYMLINKOWN_GID);
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	grsec_enable_tpe = 1;
+	grsec_tpe_gid = KGIDT_INIT(CONFIG_GRKERNSEC_TPE_GID);
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	grsec_enable_tpe_all = 1;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	grsec_enable_socket_all = 1;
+	grsec_socket_all_gid = KGIDT_INIT(CONFIG_GRKERNSEC_SOCKET_ALL_GID);
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	grsec_enable_socket_client = 1;
+	grsec_socket_client_gid = KGIDT_INIT(CONFIG_GRKERNSEC_SOCKET_CLIENT_GID);
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	grsec_enable_socket_server = 1;
+	grsec_socket_server_gid = KGIDT_INIT(CONFIG_GRKERNSEC_SOCKET_SERVER_GID);
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_DENYUSB_FORCE
+	grsec_deny_new_usb = 1;
+#endif
+
+	return;
+}
diff --git a/grsecurity/grsec_ipc.c b/grsecurity/grsec_ipc.c
new file mode 100644
index 000000000000..6a8ed69052f8
--- /dev/null
+++ b/grsecurity/grsec_ipc.c
@@ -0,0 +1,48 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/ipc.h>
+#include <linux/ipc_namespace.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_ipc_permitted(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, int requested_mode, int granted_mode)
+{
+#ifdef CONFIG_GRKERNSEC_HARDEN_IPC
+	int write;
+	int orig_granted_mode;
+	kuid_t euid;
+	kgid_t egid;
+
+	if (!grsec_enable_harden_ipc)
+		return 1;
+
+	euid = current_euid();
+	egid = current_egid();
+
+	write = requested_mode & 00002;
+	orig_granted_mode = ipcp->mode;
+
+	if (uid_eq(euid, ipcp->cuid) || uid_eq(euid, ipcp->uid))
+		orig_granted_mode >>= 6;
+	else {
+		/* if likely wrong permissions, lock to user */
+		if (orig_granted_mode & 0007)
+			orig_granted_mode = 0;
+		/* otherwise do a egid-only check */
+		else if (gid_eq(egid, ipcp->cgid) || gid_eq(egid, ipcp->gid))
+			orig_granted_mode >>= 3;
+		/* otherwise, no access */
+		else
+			orig_granted_mode = 0;
+	}
+	if (!(requested_mode & ~granted_mode & 0007) && (requested_mode & ~orig_granted_mode & 0007) &&
+	    !ns_capable_noaudit(ns->user_ns, CAP_IPC_OWNER)) {
+		gr_log_str_int(GR_DONT_AUDIT, GR_IPC_DENIED_MSG, write ? "write" : "read", GR_GLOBAL_UID(ipcp->cuid));
+		return 0;
+	}
+#endif
+	return 1;
+}
diff --git a/grsecurity/grsec_link.c b/grsecurity/grsec_link.c
new file mode 100644
index 000000000000..84c44a03caa9
--- /dev/null
+++ b/grsecurity/grsec_link.c
@@ -0,0 +1,65 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int gr_get_symlinkown_enabled(void)
+{
+#ifdef CONFIG_GRKERNSEC_SYMLINKOWN
+	if (grsec_enable_symlinkown && in_group_p(grsec_symlinkown_gid))
+		return 1;
+#endif
+	return 0;
+}
+
+int gr_handle_symlink_owner(const struct path *link, const struct inode *target)
+{
+#ifdef CONFIG_GRKERNSEC_SYMLINKOWN
+	const struct inode *link_inode = d_backing_inode(link->dentry);
+
+	if (target && !uid_eq(link_inode->i_uid, target->i_uid)) {
+		gr_log_fs_int2(GR_DONT_AUDIT, GR_SYMLINKOWNER_MSG, link->dentry, link->mnt, GR_GLOBAL_UID(link_inode->i_uid), GR_GLOBAL_UID(target->i_uid));
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_follow_link(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	struct inode *inode = d_backing_inode(dentry);
+	struct inode *parent = d_backing_inode(dentry->d_parent);
+	const struct cred *cred = current_cred();
+
+	if (grsec_enable_link && d_is_symlink(dentry) &&
+	    (parent->i_mode & S_ISVTX) && !uid_eq(parent->i_uid, inode->i_uid) &&
+	    (parent->i_mode & S_IWOTH) && !uid_eq(cred->fsuid, inode->i_uid)) {
+		gr_log_fs_int2(GR_DONT_AUDIT, GR_SYMLINK_MSG, dentry, mnt, GR_GLOBAL_UID(inode->i_uid), GR_GLOBAL_GID(inode->i_gid));
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_hardlink(const struct dentry *dentry,
+		   const struct vfsmount *mnt,
+		   const struct filename *to)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	struct inode *inode = d_backing_inode(dentry);
+	const struct cred *cred = current_cred();
+
+	if (grsec_enable_link && !uid_eq(cred->fsuid, inode->i_uid) &&
+	    (!d_is_reg(dentry) || is_privileged_binary(dentry) || 
+	     (inode_permission(inode, MAY_READ | MAY_WRITE))) &&
+	    !capable(CAP_FOWNER) && gr_is_global_nonroot(cred->uid)) {
+		gr_log_fs_int2_str(GR_DONT_AUDIT, GR_HARDLINK_MSG, dentry, mnt, GR_GLOBAL_UID(inode->i_uid), GR_GLOBAL_GID(inode->i_gid), to->name);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_log.c b/grsecurity/grsec_log.c
new file mode 100644
index 000000000000..a24b3385dcbb
--- /dev/null
+++ b/grsecurity/grsec_log.c
@@ -0,0 +1,340 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/tty.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/grinternal.h>
+
+#ifdef CONFIG_TREE_PREEMPT_RCU
+#define DISABLE_PREEMPT() preempt_disable()
+#define ENABLE_PREEMPT() preempt_enable()
+#else
+#define DISABLE_PREEMPT()
+#define ENABLE_PREEMPT()
+#endif
+
+#define BEGIN_LOCKS(x) \
+	DISABLE_PREEMPT(); \
+	rcu_read_lock(); \
+	read_lock(&tasklist_lock); \
+	read_lock(&grsec_exec_file_lock); \
+	if (x != GR_DO_AUDIT) \
+		spin_lock(&grsec_alert_lock); \
+	else \
+		spin_lock(&grsec_audit_lock)
+
+#define END_LOCKS(x) \
+	if (x != GR_DO_AUDIT) \
+		spin_unlock(&grsec_alert_lock); \
+	else \
+		spin_unlock(&grsec_audit_lock); \
+	read_unlock(&grsec_exec_file_lock); \
+	read_unlock(&tasklist_lock); \
+	rcu_read_unlock(); \
+	ENABLE_PREEMPT(); \
+	if (x == GR_DONT_AUDIT) \
+		gr_handle_alertkill(current)
+
+enum {
+	FLOODING,
+	NO_FLOODING
+};
+
+extern char *gr_alert_log_fmt;
+extern char *gr_audit_log_fmt;
+extern char *gr_alert_log_buf;
+extern char *gr_audit_log_buf;
+
+static int gr_log_start(int audit)
+{
+	char *loglevel = (audit == GR_DO_AUDIT) ? KERN_INFO : KERN_ALERT;
+	char *fmt = (audit == GR_DO_AUDIT) ? gr_audit_log_fmt : gr_alert_log_fmt;
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+#if (CONFIG_GRKERNSEC_FLOODTIME > 0 && CONFIG_GRKERNSEC_FLOODBURST > 0)
+	unsigned long curr_secs = get_seconds();
+
+	if (audit == GR_DO_AUDIT)
+		goto set_fmt;
+
+	if (!grsec_alert_wtime || time_after(curr_secs, grsec_alert_wtime + CONFIG_GRKERNSEC_FLOODTIME)) {
+		grsec_alert_wtime = curr_secs;
+		grsec_alert_fyet = 0;
+	} else if (time_before_eq(curr_secs, grsec_alert_wtime + CONFIG_GRKERNSEC_FLOODTIME)
+		    && (grsec_alert_fyet < CONFIG_GRKERNSEC_FLOODBURST)) {
+		grsec_alert_fyet++;
+	} else if (grsec_alert_fyet == CONFIG_GRKERNSEC_FLOODBURST) {
+		grsec_alert_wtime = curr_secs;
+		grsec_alert_fyet++;
+		printk(KERN_ALERT "grsec: more alerts, logging disabled for %d seconds\n", CONFIG_GRKERNSEC_FLOODTIME);
+		return FLOODING;
+	}
+	else return FLOODING;
+
+set_fmt:
+#endif
+	memset(buf, 0, PAGE_SIZE);
+	if (current->signal->curr_ip && gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %pI4: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, &current->signal->curr_ip, current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else if (current->signal->curr_ip) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %pI4: ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, &current->signal->curr_ip);
+	} else if (gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else {
+		sprintf(fmt, "%s%s", loglevel, "grsec: ");
+		strcpy(buf, fmt);
+	}
+
+	return NO_FLOODING;
+}
+
+static void gr_log_middle(int audit, const char *msg, va_list ap)
+	__attribute__ ((format (printf, 2, 0)));
+
+static void gr_log_middle(int audit, const char *msg, va_list ap)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+
+	return;
+}
+
+static void gr_log_middle_varargs(int audit, const char *msg, ...)
+	__attribute__ ((format (printf, 2, 3)));
+
+static void gr_log_middle_varargs(int audit, const char *msg, ...)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+	va_list ap;
+
+	va_start(ap, msg);
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+	va_end(ap);
+
+	return;
+}
+
+static void gr_log_end(int audit, int append_default)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	if (append_default) {
+		struct task_struct *task = current;
+		struct task_struct *parent = task->real_parent;
+		const struct cred *cred = __task_cred(task);
+		const struct cred *pcred = __task_cred(parent);
+		unsigned int len = strlen(buf);
+
+		snprintf(buf + len, PAGE_SIZE - len - 1, DEFAULTSECMSG, gr_task_fullpath(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath(task), parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid));
+	}
+
+	printk("%s\n", buf);
+
+	return;
+}
+
+void gr_log_varargs(int audit, const char *msg, int argtypes, ...)
+{
+	int logtype;
+	char *result = (audit == GR_DO_AUDIT) ? "successful" : "denied";
+	char *str1 = NULL, *str2 = NULL, *str3 = NULL;
+	void *voidptr = NULL;
+	int num1 = 0, num2 = 0;
+	unsigned long ulong1 = 0, ulong2 = 0;
+	struct dentry *dentry = NULL;
+	struct vfsmount *mnt = NULL;
+	struct file *file = NULL;
+	struct task_struct *task = NULL;
+	struct vm_area_struct *vma = NULL;
+	const struct cred *cred, *pcred;
+	va_list ap;
+
+	BEGIN_LOCKS(audit);
+	logtype = gr_log_start(audit);
+	if (logtype == FLOODING) {
+		END_LOCKS(audit);
+		return;
+	}
+	va_start(ap, argtypes);
+	switch (argtypes) {
+	case GR_TTYSNIFF:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, &task->signal->curr_ip, gr_task_fullpath0(task), task->comm, task_pid_nr(task), gr_parent_task_fullpath0(task), task->real_parent->comm, task_pid_nr(task->real_parent));
+		break;
+	case GR_SYSCTL_HIDDEN:
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, str1);
+		break;
+	case GR_RBAC:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_STR_RBAC:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_MODE2:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2);
+		break;
+	case GR_RBAC_MODE3:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		str3 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2, str3);
+		break;
+	case GR_FILENAME:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt));
+		break;
+	case GR_STR_FILENAME:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_FILENAME_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_FILENAME_TWO_INT:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2);
+		break;
+	case GR_FILENAME_TWO_INT_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2, str1);
+		break;
+	case GR_TEXTREL:
+		str1 = va_arg(ap, char *);
+		file = va_arg(ap, struct file *);
+		ulong1 = va_arg(ap, unsigned long);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, str1, file ? gr_to_filename(file->f_path.dentry, file->f_path.mnt) : "<anonymous mapping>", ulong1, ulong2);
+		break;
+	case GR_PTRACE:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, task->exec_file ? gr_to_filename(task->exec_file->f_path.dentry, task->exec_file->f_path.mnt) : "(none)", task->comm, task_pid_nr(task));
+		break;
+	case GR_RESOURCE:
+		task = va_arg(ap, struct task_struct *);
+		cred = __task_cred(task);
+		pcred = __task_cred(task->real_parent);
+		ulong1 = va_arg(ap, unsigned long);
+		str1 = va_arg(ap, char *);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, ulong1, str1, ulong2, gr_task_fullpath(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath(task), task->real_parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid));
+		break;
+	case GR_CAP:
+		task = va_arg(ap, struct task_struct *);
+		cred = __task_cred(task);
+		pcred = __task_cred(task->real_parent);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, str1, gr_task_fullpath(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath(task), task->real_parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid));
+		break;
+	case GR_SIG:
+		str1 = va_arg(ap, char *);
+		voidptr = va_arg(ap, void *);
+		gr_log_middle_varargs(audit, msg, str1, voidptr);
+		break;
+	case GR_SIG2:
+		task = va_arg(ap, struct task_struct *);
+		cred = __task_cred(task);
+		pcred = __task_cred(task->real_parent);
+		num1 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, num1, gr_task_fullpath0(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath0(task), task->real_parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid));
+		break;
+	case GR_CRASH1:
+		task = va_arg(ap, struct task_struct *);
+		cred = __task_cred(task);
+		pcred = __task_cred(task->real_parent);
+		ulong1 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath(task), task->real_parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid), GR_GLOBAL_UID(cred->uid), ulong1);
+		break;
+	case GR_CRASH2:
+		task = va_arg(ap, struct task_struct *);
+		cred = __task_cred(task);
+		pcred = __task_cred(task->real_parent);
+		ulong1 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task_pid_nr(task), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), gr_parent_task_fullpath(task), task->real_parent->comm, task_pid_nr(task->real_parent), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid), ulong1);
+		break;
+	case GR_RWXMAP:
+		file = va_arg(ap, struct file *);
+		gr_log_middle_varargs(audit, msg, file ? gr_to_filename(file->f_path.dentry, file->f_path.mnt) : "<anonymous mapping>");
+		break;
+	case GR_RWXMAPVMA:
+		vma = va_arg(ap, struct vm_area_struct *);
+		if (vma->vm_file)
+			str1 = gr_to_filename(vma->vm_file->f_path.dentry, vma->vm_file->f_path.mnt);
+		else if (vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP))
+			str1 = "<stack>";
+		else if (vma->vm_start <= current->mm->brk &&
+			 vma->vm_end >= current->mm->start_brk)
+			str1 = "<heap>";
+		else
+			str1 = "<anonymous mapping>";
+		gr_log_middle_varargs(audit, msg, str1);
+		break;
+	case GR_PSACCT:
+		{
+			unsigned int wday, cday;
+			__u8 whr, chr;
+			__u8 wmin, cmin;
+			__u8 wsec, csec;
+
+			task = va_arg(ap, struct task_struct *);
+			wday = va_arg(ap, unsigned int);
+			cday = va_arg(ap, unsigned int);
+			whr = va_arg(ap, int);
+			chr = va_arg(ap, int);
+			wmin = va_arg(ap, int);
+			cmin = va_arg(ap, int);
+			wsec = va_arg(ap, int);
+			csec = va_arg(ap, int);
+			ulong1 = va_arg(ap, unsigned long);
+			cred = __task_cred(task);
+			pcred = __task_cred(task->real_parent);
+
+			gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task_pid_nr(task), &task->signal->curr_ip, tty_name(task->signal->tty), GR_GLOBAL_UID(cred->uid), GR_GLOBAL_UID(cred->euid), GR_GLOBAL_GID(cred->gid), GR_GLOBAL_GID(cred->egid), wday, whr, wmin, wsec, cday, chr, cmin, csec, (task->flags & PF_SIGNALED) ? "killed by signal" : "exited", ulong1, gr_parent_task_fullpath(task), task->real_parent->comm, task_pid_nr(task->real_parent), &task->real_parent->signal->curr_ip, tty_name(task->real_parent->signal->tty), GR_GLOBAL_UID(pcred->uid), GR_GLOBAL_UID(pcred->euid), GR_GLOBAL_GID(pcred->gid), GR_GLOBAL_GID(pcred->egid));
+		}
+		break;
+	default:
+		gr_log_middle(audit, msg, ap);
+	}
+	va_end(ap);
+	// these don't need DEFAULTSECARGS printed on the end
+	if (argtypes == GR_CRASH1 || argtypes == GR_CRASH2)
+		gr_log_end(audit, 0);
+	else
+		gr_log_end(audit, 1);
+	END_LOCKS(audit);
+}
diff --git a/grsecurity/grsec_mem.c b/grsecurity/grsec_mem.c
new file mode 100644
index 000000000000..0e39d8c703dc
--- /dev/null
+++ b/grsecurity/grsec_mem.c
@@ -0,0 +1,48 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/grinternal.h>
+
+void gr_handle_msr_write(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_MSRWRITE_MSG);
+	return;
+}
+EXPORT_SYMBOL_GPL(gr_handle_msr_write);
+
+void
+gr_handle_ioperm(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPERM_MSG);
+	return;
+}
+
+void
+gr_handle_iopl(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPL_MSG);
+	return;
+}
+
+void
+gr_handle_mem_readwrite(u64 from, u64 to)
+{
+	gr_log_two_u64(GR_DONT_AUDIT, GR_MEM_READWRITE_MSG, from, to);
+	return;
+}
+
+void
+gr_handle_vm86(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_VM86_MSG);
+	return;
+}
+
+void
+gr_log_badprocpid(const char *entry)
+{
+	gr_log_str(GR_DONT_AUDIT, GR_BADPROCPID_MSG, entry);
+	return;
+}
diff --git a/grsecurity/grsec_mount.c b/grsecurity/grsec_mount.c
new file mode 100644
index 000000000000..fe02bf495ba5
--- /dev/null
+++ b/grsecurity/grsec_mount.c
@@ -0,0 +1,65 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mount.h>
+#include <linux/major.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_remount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_REMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_unmount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_UNMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_mount(const char *from, struct path *to, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str_fs(GR_DO_AUDIT, GR_MOUNT_AUDIT_MSG, from ? from : "none", to->dentry, to->mnt);
+#endif
+	return;
+}
+
+int
+gr_handle_rofs_mount(struct dentry *dentry, struct vfsmount *mnt, int mnt_flags)
+{
+#ifdef CONFIG_GRKERNSEC_ROFS
+	if (grsec_enable_rofs && !(mnt_flags & MNT_READONLY)) {
+		gr_log_fs_generic(GR_DO_AUDIT, GR_ROFS_MOUNT_MSG, dentry, mnt);
+		return -EPERM;
+	} else
+		return 0;
+#endif
+	return 0;
+}
+
+int
+gr_handle_rofs_blockwrite(struct dentry *dentry, struct vfsmount *mnt, int acc_mode)
+{
+#ifdef CONFIG_GRKERNSEC_ROFS
+	struct inode *inode = d_backing_inode(dentry);
+
+	if (grsec_enable_rofs && (acc_mode & MAY_WRITE) &&
+	    inode && (S_ISBLK(inode->i_mode) || (S_ISCHR(inode->i_mode) && imajor(inode) == RAW_MAJOR))) {
+		gr_log_fs_generic(GR_DO_AUDIT, GR_ROFS_BLOCKWRITE_MSG, dentry, mnt);
+		return -EPERM;
+	} else
+		return 0;
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_pax.c b/grsecurity/grsec_pax.c
new file mode 100644
index 000000000000..2ad7b964a20b
--- /dev/null
+++ b/grsecurity/grsec_pax.c
@@ -0,0 +1,47 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+#include <linux/grsecurity.h>
+
+void
+gr_log_textrel(struct vm_area_struct * vma, bool is_textrel_rw)
+{
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	if (grsec_enable_log_rwxmaps)
+		gr_log_textrel_ulong_ulong(GR_DONT_AUDIT, GR_TEXTREL_AUDIT_MSG,
+			is_textrel_rw ? "executable to writable" : "writable to executable",
+			vma->vm_file, vma->vm_start, vma->vm_pgoff);
+#endif
+	return;
+}
+
+void gr_log_ptgnustack(struct file *file)
+{
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	if (grsec_enable_log_rwxmaps)
+		gr_log_rwxmap(GR_DONT_AUDIT, GR_PTGNUSTACK_MSG, file);
+#endif
+	return;
+}
+
+void
+gr_log_rwxmmap(struct file *file)
+{
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	if (grsec_enable_log_rwxmaps)
+		gr_log_rwxmap(GR_DONT_AUDIT, GR_RWXMMAP_MSG, file);
+#endif
+	return;
+}
+
+void
+gr_log_rwxmprotect(struct vm_area_struct *vma)
+{
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	if (grsec_enable_log_rwxmaps)
+		gr_log_rwxmap_vma(GR_DONT_AUDIT, GR_RWXMPROTECT_MSG, vma);
+#endif
+	return;
+}
diff --git a/grsecurity/grsec_proc.c b/grsecurity/grsec_proc.c
new file mode 100644
index 000000000000..2005a3a3224d
--- /dev/null
+++ b/grsecurity/grsec_proc.c
@@ -0,0 +1,20 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int gr_proc_is_restricted(void)
+{
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	const struct cred *cred = current_cred();
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	if (!uid_eq(cred->fsuid, GLOBAL_ROOT_UID))
+		return -EACCES;
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	if (!uid_eq(cred->fsuid, GLOBAL_ROOT_UID) && !in_group_p(grsec_proc_gid))
+		return -EACCES;
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_ptrace.c b/grsecurity/grsec_ptrace.c
new file mode 100644
index 000000000000..304c5180b929
--- /dev/null
+++ b/grsecurity/grsec_ptrace.c
@@ -0,0 +1,30 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grinternal.h>
+#include <linux/security.h>
+
+void
+gr_audit_ptrace(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_PTRACE
+	if (grsec_enable_audit_ptrace)
+		gr_log_ptrace(GR_DO_AUDIT, GR_PTRACE_AUDIT_MSG, task);
+#endif
+	return;
+}
+
+int
+gr_ptrace_readexec(struct file *file, int unsafe_flags)
+{
+#ifdef CONFIG_GRKERNSEC_PTRACE_READEXEC
+	const struct dentry *dentry = file->f_path.dentry;
+	const struct vfsmount *mnt = file->f_path.mnt;
+
+	if (grsec_enable_ptrace_readexec && (unsafe_flags & LSM_UNSAFE_PTRACE) && 
+	    (inode_permission(d_backing_inode(dentry), MAY_READ) || !gr_acl_handle_open(dentry, mnt, MAY_READ))) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_PTRACE_READEXEC_MSG, dentry, mnt);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_sig.c b/grsecurity/grsec_sig.c
new file mode 100644
index 000000000000..f072c9d4291a
--- /dev/null
+++ b/grsecurity/grsec_sig.c
@@ -0,0 +1,248 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/hardirq.h>
+#include <asm/pgtable.h>
+
+char *signames[] = {
+	[SIGSEGV] = "Segmentation fault",
+	[SIGILL] = "Illegal instruction",
+	[SIGABRT] = "Abort",
+	[SIGBUS] = "Invalid alignment/Bus error"
+};
+
+void
+gr_log_signal(const int sig, const void *addr, const struct task_struct *t)
+{
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	if (grsec_enable_signal && ((sig == SIGSEGV) || (sig == SIGILL) ||
+				    (sig == SIGABRT) || (sig == SIGBUS))) {
+		if (task_pid_nr(t) == task_pid_nr(current)) {
+			gr_log_sig_addr(GR_DONT_AUDIT_GOOD, GR_UNISIGLOG_MSG, signames[sig], addr);
+		} else {
+			gr_log_sig_task(GR_DONT_AUDIT_GOOD, GR_DUALSIGLOG_MSG, t, sig);
+		}
+	}
+#endif
+	return;
+}
+
+int
+gr_handle_signal(const struct task_struct *p, const int sig)
+{
+#ifdef CONFIG_GRKERNSEC
+	/* ignore the 0 signal for protected task checks */
+	if (task_pid_nr(current) > 1 && sig && gr_check_protected_task(p)) {
+		gr_log_sig_task(GR_DONT_AUDIT, GR_SIG_ACL_MSG, p, sig);
+		return -EPERM;
+	} else if (gr_pid_is_chrooted((struct task_struct *)p)) {
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_GRKERNSEC
+extern int specific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t);
+
+int gr_fake_force_sig(int sig, struct task_struct *t)
+{
+	unsigned long int flags;
+	int ret, blocked, ignored;
+	struct k_sigaction *action;
+
+	spin_lock_irqsave(&t->sighand->siglock, flags);
+	action = &t->sighand->action[sig-1];
+	ignored = action->sa.sa_handler == SIG_IGN;
+	blocked = sigismember(&t->blocked, sig);
+	if (blocked || ignored) {
+		action->sa.sa_handler = SIG_DFL;
+		if (blocked) {
+			sigdelset(&t->blocked, sig);
+			recalc_sigpending_and_wake(t);
+		}
+	}
+	if (action->sa.sa_handler == SIG_DFL)
+		t->signal->flags &= ~SIGNAL_UNKILLABLE;
+	ret = specific_send_sig_info(sig, SEND_SIG_PRIV, t);
+
+	spin_unlock_irqrestore(&t->sighand->siglock, flags);
+
+	return ret;
+}
+#endif
+
+#define GR_USER_BAN_TIME (15 * 60)
+#define GR_DAEMON_BRUTE_TIME (30 * 60)
+
+void gr_handle_brute_attach(int dumpable)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	struct task_struct *p = current;
+	kuid_t uid = GLOBAL_ROOT_UID;
+	int is_priv = 0;
+	int daemon = 0;
+
+	if (!grsec_enable_brute)
+		return;
+
+	if (is_privileged_binary(p->mm->exe_file->f_path.dentry))
+		is_priv = 1;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	if (!is_priv && p->real_parent && gr_is_same_file(p->real_parent->exec_file, p->exec_file)) {
+		p->real_parent->brute_expires = get_seconds() + GR_DAEMON_BRUTE_TIME;
+		p->real_parent->brute = 1;
+		daemon = 1;
+	} else {
+		const struct cred *cred = __task_cred(p), *cred2;
+		struct task_struct *tsk, *tsk2;
+
+		if (dumpable != SUID_DUMP_USER && gr_is_global_nonroot(cred->uid)) {
+			struct user_struct *user;
+
+			uid = cred->uid;
+
+			/* this is put upon execution past expiration */
+			user = find_user(uid);
+			if (user == NULL)
+				goto unlock;
+			user->sugid_banned = 1;
+			user->sugid_ban_expires = get_seconds() + GR_USER_BAN_TIME;
+			if (user->sugid_ban_expires == ~0UL)
+				user->sugid_ban_expires--;
+
+			/* only kill other threads of the same binary, from the same user */
+			do_each_thread(tsk2, tsk) {
+				cred2 = __task_cred(tsk);
+				if (tsk != p && uid_eq(cred2->uid, uid) && gr_is_same_file(tsk->exec_file, p->exec_file))
+					gr_fake_force_sig(SIGKILL, tsk);
+			} while_each_thread(tsk2, tsk);
+		}
+	}
+unlock:
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	if (gr_is_global_nonroot(uid))
+		gr_log_fs_int2(GR_DONT_AUDIT, GR_BRUTE_SUID_MSG, p->exec_file->f_path.dentry, p->exec_file->f_path.mnt, GR_GLOBAL_UID(uid), GR_USER_BAN_TIME / 60);
+	else if (daemon)
+		gr_log_noargs(GR_DONT_AUDIT, GR_BRUTE_DAEMON_MSG);
+
+#endif
+	return;
+}
+
+void gr_handle_brute_check(void)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	struct task_struct *p = current;
+
+	if (unlikely(p->brute)) {
+		if (!grsec_enable_brute)
+			p->brute = 0;
+		else if (time_before(get_seconds(), p->brute_expires))
+			msleep(30 * 1000);
+	}
+#endif
+	return;
+}
+
+void gr_handle_kernel_exploit(void)
+{
+#ifdef CONFIG_GRKERNSEC_KERN_LOCKOUT
+	static unsigned int num_banned_users __read_only;
+	const struct cred *cred;
+	struct task_struct *tsk, *tsk2;
+	struct user_struct *user;
+	kuid_t uid;
+
+	if (in_irq() || in_serving_softirq() || in_nmi())
+		panic("grsec: halting the system due to suspicious kernel crash caused in interrupt context");
+
+	uid = current_uid();
+
+	if (gr_is_global_root(uid))
+		panic("grsec: halting the system due to suspicious kernel crash caused by root");
+	else {
+		pax_open_kernel();
+		num_banned_users++;
+		pax_close_kernel();
+		if (num_banned_users > 8)
+			panic("grsec: halting the system due to suspicious kernel crash caused by a large number of different users");
+
+		/* kill all the processes of this user, hold a reference
+		   to their creds struct, and prevent them from creating
+		   another process until system reset
+		*/
+		printk(KERN_ALERT "grsec: banning user with uid %u until system restart for suspicious kernel crash\n",
+			GR_GLOBAL_UID(uid));
+		/* we intentionally leak this ref */
+		user = get_uid(current->cred->user);
+		if (user)
+			user->kernel_banned = 1;
+
+		/* kill all processes of this user */
+		read_lock(&tasklist_lock);
+		do_each_thread(tsk2, tsk) {
+			cred = __task_cred(tsk);
+			if (uid_eq(cred->uid, uid))
+				gr_fake_force_sig(SIGKILL, tsk);
+		} while_each_thread(tsk2, tsk);
+		read_unlock(&tasklist_lock); 
+	}
+#endif
+}
+
+#ifdef CONFIG_GRKERNSEC_BRUTE
+static bool sugid_ban_expired(struct user_struct *user)
+{
+	if (user->sugid_ban_expires != ~0UL && time_after_eq(get_seconds(), user->sugid_ban_expires)) {
+		user->sugid_banned = 0;
+		user->sugid_ban_expires = 0;
+		free_uid(user);
+		return true;
+	}
+
+	return false;
+}
+#endif
+
+int gr_process_kernel_exec_ban(void)
+{
+#ifdef CONFIG_GRKERNSEC_KERN_LOCKOUT
+	if (unlikely(current->cred->user->kernel_banned))
+		return -EPERM;
+#endif
+	return 0;
+}
+
+int gr_process_kernel_setuid_ban(struct user_struct *user)
+{
+#ifdef CONFIG_GRKERNSEC_KERN_LOCKOUT
+	if (unlikely(user->kernel_banned))
+		gr_fake_force_sig(SIGKILL, current);
+#endif
+	return 0;
+}
+
+int gr_process_sugid_exec_ban(const struct linux_binprm *bprm)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	struct user_struct *user = current->cred->user;
+	if (unlikely(user->sugid_banned)) {
+		if (sugid_ban_expired(user))
+			return 0;
+		/* disallow execution of suid/sgid binaries only */
+		else if (is_privileged_binary(bprm->file->f_path.dentry))
+			return -EPERM;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_sock.c b/grsecurity/grsec_sock.c
new file mode 100644
index 000000000000..3cdd9461fc9d
--- /dev/null
+++ b/grsecurity/grsec_sock.c
@@ -0,0 +1,244 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <net/sock.h>
+#include <net/inet_sock.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+extern int gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr);
+
+EXPORT_SYMBOL_GPL(gr_search_udp_recvmsg);
+EXPORT_SYMBOL_GPL(gr_search_udp_sendmsg);
+
+#ifdef CONFIG_UNIX_MODULE
+EXPORT_SYMBOL_GPL(gr_acl_handle_unix);
+EXPORT_SYMBOL_GPL(gr_acl_handle_mknod);
+EXPORT_SYMBOL_GPL(gr_handle_chroot_unix);
+EXPORT_SYMBOL_GPL(gr_handle_create);
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+#define gr_conn_table_size 32749
+struct conn_table_entry {
+	struct conn_table_entry *next;
+	struct signal_struct *sig;
+};
+
+struct conn_table_entry *gr_conn_table[gr_conn_table_size];
+DEFINE_SPINLOCK(gr_conn_table_lock);
+
+extern const char * gr_socktype_to_name(unsigned char type);
+extern const char * gr_proto_to_name(unsigned char proto);
+extern const char * gr_sockfamily_to_name(unsigned char family);
+
+static int 
+conn_hash(__u32 saddr, __u32 daddr, __u16 sport, __u16 dport, unsigned int size)
+{
+	return ((daddr + saddr + (sport << 8) + (dport << 16)) % size);
+}
+
+static int
+conn_match(const struct signal_struct *sig, __u32 saddr, __u32 daddr, 
+	   __u16 sport, __u16 dport)
+{
+	if (unlikely(sig->gr_saddr == saddr && sig->gr_daddr == daddr &&
+		     sig->gr_sport == sport && sig->gr_dport == dport))
+		return 1;
+	else
+		return 0;
+}
+
+static void gr_add_to_task_ip_table_nolock(struct signal_struct *sig, struct conn_table_entry *newent)
+{
+	struct conn_table_entry **match;
+	unsigned int index;
+
+	index = conn_hash(sig->gr_saddr, sig->gr_daddr, 
+			  sig->gr_sport, sig->gr_dport, 
+			  gr_conn_table_size);
+
+	newent->sig = sig;
+	
+	match = &gr_conn_table[index];
+	newent->next = *match;
+	*match = newent;
+
+	return;
+}
+
+static void gr_del_task_from_ip_table_nolock(struct signal_struct *sig)
+{
+	struct conn_table_entry *match, *last = NULL;
+	unsigned int index;
+
+	index = conn_hash(sig->gr_saddr, sig->gr_daddr, 
+			  sig->gr_sport, sig->gr_dport, 
+			  gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->sig, 
+		sig->gr_saddr, sig->gr_daddr, sig->gr_sport, 
+		sig->gr_dport)) {
+		last = match;
+		match = match->next;
+	}
+
+	if (match) {
+		if (last)
+			last->next = match->next;
+		else
+			gr_conn_table[index] = NULL;
+		kfree(match);
+	}
+
+	return;
+}
+
+static struct signal_struct * gr_lookup_task_ip_table(__u32 saddr, __u32 daddr,
+					     __u16 sport, __u16 dport)
+{
+	struct conn_table_entry *match;
+	unsigned int index;
+
+	index = conn_hash(saddr, daddr, sport, dport, gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->sig, saddr, daddr, sport, dport))
+		match = match->next;
+
+	if (match)
+		return match->sig;
+	else
+		return NULL;
+}
+
+#endif
+
+void gr_update_task_in_ip_table(const struct inet_sock *inet)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct signal_struct *sig = current->signal;
+	struct conn_table_entry *newent;
+
+	newent = kmalloc(sizeof(struct conn_table_entry), GFP_ATOMIC);
+	if (newent == NULL)
+		return;
+	/* no bh lock needed since we are called with bh disabled */
+	spin_lock(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(sig);
+	sig->gr_saddr = inet->inet_rcv_saddr;
+	sig->gr_daddr = inet->inet_daddr;
+	sig->gr_sport = inet->inet_sport;
+	sig->gr_dport = inet->inet_dport;
+	gr_add_to_task_ip_table_nolock(sig, newent);
+	spin_unlock(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void gr_del_task_from_ip_table(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC
+	spin_lock_bh(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(task->signal);
+	spin_unlock_bh(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void
+gr_attach_curr_ip(const struct sock *sk)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct signal_struct *p, *set;
+	const struct inet_sock *inet = inet_sk(sk);	
+
+	if (unlikely(sk->sk_protocol != IPPROTO_TCP))
+		return;
+
+	set = current->signal;
+
+	spin_lock_bh(&gr_conn_table_lock);
+	p = gr_lookup_task_ip_table(inet->inet_daddr, inet->inet_rcv_saddr,
+				    inet->inet_dport, inet->inet_sport);
+	if (unlikely(p != NULL)) {
+		set->curr_ip = p->curr_ip;
+		set->used_accept = 1;
+		gr_del_task_from_ip_table_nolock(p);
+		spin_unlock_bh(&gr_conn_table_lock);
+		return;
+	}
+	spin_unlock_bh(&gr_conn_table_lock);
+
+	set->curr_ip = inet->inet_daddr;
+	set->used_accept = 1;
+#endif
+	return;
+}
+
+int
+gr_handle_sock_all(const int family, const int type, const int protocol)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	if (grsec_enable_socket_all && in_group_p(grsec_socket_all_gid) &&
+	    (family != AF_UNIX)) {
+		if (family == AF_INET)
+			gr_log_str3(GR_DONT_AUDIT, GR_SOCK_MSG, gr_sockfamily_to_name(family), gr_socktype_to_name(type), gr_proto_to_name(protocol));
+		else
+			gr_log_str2_int(GR_DONT_AUDIT, GR_SOCK_NOINET_MSG, gr_sockfamily_to_name(family), gr_socktype_to_name(type), protocol);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server_other(const struct sock *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->sk_family != AF_UNIX) &&
+	    (sck->sk_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_client(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	if (grsec_enable_socket_client && in_group_p(grsec_socket_client_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_CONNECT_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_sysctl.c b/grsecurity/grsec_sysctl.c
new file mode 100644
index 000000000000..4f673f8c21d8
--- /dev/null
+++ b/grsecurity/grsec_sysctl.c
@@ -0,0 +1,497 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/sysctl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_sysctl_mod(const char *dirname, const char *name, const int op)
+{
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+	if (dirname == NULL || name == NULL)
+		return 0;
+	if (!strcmp(dirname, "grsecurity") && grsec_lock && (op & MAY_WRITE)) {
+		gr_log_str(GR_DONT_AUDIT, GR_SYSCTL_MSG, name);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+#if defined(CONFIG_GRKERNSEC_ROFS) || defined(CONFIG_GRKERNSEC_DENYUSB)
+static int __maybe_unused __read_only one = 1;
+#endif
+
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_ROFS) || \
+	defined(CONFIG_GRKERNSEC_DENYUSB)
+struct ctl_table grsecurity_table[] = {
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+#ifdef CONFIG_GRKERNSEC_SYSCTL_DISTRO
+#ifdef CONFIG_GRKERNSEC_IO
+	{
+		.procname	= "disable_priv_io",
+		.data		= &grsec_disable_privio,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+	{
+		.procname	= "linking_restrictions",
+		.data		= &grsec_enable_link,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SYMLINKOWN
+	{
+		.procname	= "enforce_symlinksifowner",
+		.data		= &grsec_enable_symlinkown,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "symlinkown_gid",
+		.data		= &grsec_symlinkown_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	{
+		.procname	= "deter_bruteforce",
+		.data		= &grsec_enable_brute,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	{
+		.procname	= "fifo_restrictions",
+		.data		= &grsec_enable_fifo,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_PTRACE_READEXEC
+	{
+		.procname	= "ptrace_readexec",
+		.data		= &grsec_enable_ptrace_readexec,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SETXID
+	{
+		.procname	= "consistent_setxid",
+		.data		= &grsec_enable_setxid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	{
+		.procname	= "ip_blackhole",
+		.data		= &grsec_enable_blackhole,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "lastack_retries",
+		.data		= &grsec_lastack_retries,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	{
+		.procname	= "exec_logging",
+		.data		= &grsec_enable_execlog,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+	{
+		.procname	= "rwxmap_logging",
+		.data		= &grsec_enable_log_rwxmaps,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	{
+		.procname	= "signal_logging",
+		.data		= &grsec_enable_signal,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	{
+		.procname	= "forkfail_logging",
+		.data		= &grsec_enable_forkfail,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	{
+		.procname	= "timechange_logging",
+		.data		= &grsec_enable_time,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	{
+		.procname	= "chroot_deny_shmat",
+		.data		= &grsec_enable_chroot_shmat,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	{
+		.procname	= "chroot_deny_unix",
+		.data		= &grsec_enable_chroot_unix,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	{
+		.procname	= "chroot_deny_mount",
+		.data		= &grsec_enable_chroot_mount,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	{
+		.procname	= "chroot_deny_fchdir",
+		.data		= &grsec_enable_chroot_fchdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	{
+		.procname	= "chroot_deny_chroot",
+		.data		= &grsec_enable_chroot_double,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	{
+		.procname	= "chroot_deny_pivot",
+		.data		= &grsec_enable_chroot_pivot,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	{
+		.procname	= "chroot_enforce_chdir",
+		.data		= &grsec_enable_chroot_chdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	{
+		.procname	= "chroot_deny_chmod",
+		.data		= &grsec_enable_chroot_chmod,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	{
+		.procname	= "chroot_deny_mknod",
+		.data		= &grsec_enable_chroot_mknod,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	{
+		.procname	= "chroot_restrict_nice",
+		.data		= &grsec_enable_chroot_nice,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	{
+		.procname	= "chroot_execlog",
+		.data		= &grsec_enable_chroot_execlog,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	{
+		.procname	= "chroot_caps",
+		.data		= &grsec_enable_chroot_caps,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	{
+		.procname	= "chroot_deny_bad_rename",
+		.data		= &grsec_enable_chroot_rename,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	{
+		.procname	= "chroot_deny_sysctl",
+		.data		= &grsec_enable_chroot_sysctl,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	{
+		.procname	= "tpe",
+		.data		= &grsec_enable_tpe,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "tpe_gid",
+		.data		= &grsec_tpe_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_INVERT
+	{
+		.procname	= "tpe_invert",
+		.data		= &grsec_enable_tpe_invert,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	{
+		.procname	= "tpe_restrict_all",
+		.data		= &grsec_enable_tpe_all,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	{
+		.procname	= "socket_all",
+		.data		= &grsec_enable_socket_all,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "socket_all_gid",
+		.data		= &grsec_socket_all_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	{
+		.procname	= "socket_client",
+		.data		= &grsec_enable_socket_client,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "socket_client_gid",
+		.data		= &grsec_socket_client_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	{
+		.procname	= "socket_server",
+		.data		= &grsec_enable_socket_server,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "socket_server_gid",
+		.data		= &grsec_socket_server_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	{
+		.procname	= "audit_group",
+		.data		= &grsec_enable_group,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+	{
+		.procname	= "audit_gid",
+		.data		= &grsec_audit_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	{
+		.procname	= "audit_chdir",
+		.data		= &grsec_enable_chdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	{
+		.procname	= "audit_mount",
+		.data		= &grsec_enable_mount,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	{
+		.procname	= "dmesg",
+		.data		= &grsec_enable_dmesg,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	{
+		.procname	= "chroot_findtask",
+		.data		= &grsec_enable_chroot_findtask,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_RESLOG
+	{
+		.procname	= "resource_logging",
+		.data		= &grsec_resource_logging,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_PTRACE
+	{
+		.procname	= "audit_ptrace",
+		.data		= &grsec_enable_audit_ptrace,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	{
+		.procname	= "harden_ptrace",
+		.data		= &grsec_enable_harden_ptrace,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_IPC
+	{
+		.procname	= "harden_ipc",
+		.data		= &grsec_enable_harden_ipc,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_HARDEN_TTY
+	{
+		.procname	= "harden_tty",
+		.data		= &grsec_enable_harden_tty,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+	{
+		.procname	= "grsec_lock",
+		.data		= &grsec_lock,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_ROFS
+	{
+		.procname	= "romount_protect",
+		.data		= &grsec_enable_rofs,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_minmax_secure,
+		.extra1		= &one,
+		.extra2		= &one,
+	},
+#endif
+#if defined(CONFIG_GRKERNSEC_DENYUSB) && !defined(CONFIG_GRKERNSEC_DENYUSB_FORCE)
+	{
+		.procname	= "deny_new_usb",
+		.data		= &grsec_deny_new_usb,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec_secure,
+	},
+#endif
+	{ }
+};
+#endif
diff --git a/grsecurity/grsec_time.c b/grsecurity/grsec_time.c
new file mode 100644
index 000000000000..61b514e0d46c
--- /dev/null
+++ b/grsecurity/grsec_time.c
@@ -0,0 +1,16 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grinternal.h>
+#include <linux/module.h>
+
+void
+gr_log_timechange(void)
+{
+#ifdef CONFIG_GRKERNSEC_TIME
+	if (grsec_enable_time)
+		gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_TIME_MSG);
+#endif
+	return;
+}
+
+EXPORT_SYMBOL_GPL(gr_log_timechange);
diff --git a/grsecurity/grsec_tpe.c b/grsecurity/grsec_tpe.c
new file mode 100644
index 000000000000..cbd277622bbf
--- /dev/null
+++ b/grsecurity/grsec_tpe.c
@@ -0,0 +1,78 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/grinternal.h>
+
+extern int gr_acl_tpe_check(void);
+
+int
+gr_tpe_allow(const struct file *file)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct inode *inode = d_backing_inode(file->f_path.dentry->d_parent);
+	struct inode *file_inode = d_backing_inode(file->f_path.dentry);
+	const struct cred *cred = current_cred();
+	char *msg = NULL;
+	char *msg2 = NULL;
+
+	// never restrict root
+	if (gr_is_global_root(cred->uid))
+		return 1;
+
+	if (grsec_enable_tpe) {
+#ifdef CONFIG_GRKERNSEC_TPE_INVERT
+		if (grsec_enable_tpe_invert && !in_group_p(grsec_tpe_gid))
+			msg = "not being in trusted group";
+		else if (!grsec_enable_tpe_invert && in_group_p(grsec_tpe_gid))
+			msg = "being in untrusted group";
+#else
+		if (in_group_p(grsec_tpe_gid))
+			msg = "being in untrusted group";
+#endif
+	}
+	if (!msg && gr_acl_tpe_check())
+		msg = "being in untrusted role";
+
+	// not in any affected group/role
+	if (!msg)
+		goto next_check;
+
+	if (gr_is_global_nonroot(inode->i_uid))
+		msg2 = "file in non-root-owned directory";
+	else if (inode->i_mode & S_IWOTH)
+		msg2 = "file in world-writable directory";
+	else if ((inode->i_mode & S_IWGRP) && gr_is_global_nonroot_gid(inode->i_gid))
+		msg2 = "file in group-writable directory";
+	else if (file_inode->i_mode & S_IWOTH)
+		msg2 = "file is world-writable";
+
+	if (msg && msg2) {
+		char fullmsg[70] = {0};
+		snprintf(fullmsg, sizeof(fullmsg)-1, "%s and %s", msg, msg2);
+		gr_log_str_fs(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, fullmsg, file->f_path.dentry, file->f_path.mnt);
+		return 0;
+	}
+	msg = NULL;
+next_check:
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	if (!grsec_enable_tpe || !grsec_enable_tpe_all)
+		return 1;
+
+	if (gr_is_global_nonroot(inode->i_uid) && !uid_eq(inode->i_uid, cred->uid))
+		msg = "directory not owned by user";
+	else if (inode->i_mode & S_IWOTH)
+		msg = "file in world-writable directory";
+	else if ((inode->i_mode & S_IWGRP) && gr_is_global_nonroot_gid(inode->i_gid))
+		msg = "file in group-writable directory";
+	else if (file_inode->i_mode & S_IWOTH)
+		msg = "file is world-writable";
+
+	if (msg) {
+		gr_log_str_fs(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, msg, file->f_path.dentry, file->f_path.mnt);
+		return 0;
+	}
+#endif
+#endif
+	return 1;
+}
diff --git a/grsecurity/grsec_tty.c b/grsecurity/grsec_tty.c
new file mode 100644
index 000000000000..ad8b9c542388
--- /dev/null
+++ b/grsecurity/grsec_tty.c
@@ -0,0 +1,18 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/capability.h>
+#include <linux/tty.h>
+
+int gr_handle_tiocsti(struct tty_struct *tty)
+{
+#ifdef CONFIG_GRKERNSEC_HARDEN_TTY
+	if (grsec_enable_harden_tty && (current->signal->tty == tty) &&
+	    !capable(CAP_SYS_ADMIN)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_TIOCSTI_MSG);
+		return 1;
+	}
+#endif
+	return 0;
+}
diff --git a/grsecurity/grsec_usb.c b/grsecurity/grsec_usb.c
new file mode 100644
index 000000000000..ae02d8e05267
--- /dev/null
+++ b/grsecurity/grsec_usb.c
@@ -0,0 +1,15 @@
+#include <linux/kernel.h>
+#include <linux/grinternal.h>
+#include <linux/module.h>
+
+int gr_handle_new_usb(void)
+{
+#ifdef CONFIG_GRKERNSEC_DENYUSB
+	if (grsec_deny_new_usb) {
+		printk(KERN_ALERT "grsec: denied insert of new USB device\n");
+		return 1;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gr_handle_new_usb);
diff --git a/grsecurity/grsum.c b/grsecurity/grsum.c
new file mode 100644
index 000000000000..1af1e63a35c5
--- /dev/null
+++ b/grsecurity/grsum.c
@@ -0,0 +1,56 @@
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/crypto.h>
+#include <linux/gracl.h>
+#include <crypto/algapi.h>
+#include <crypto/hash.h>
+
+#if !defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE) || !defined(CONFIG_CRYPTO_SHA256) || defined(CONFIG_CRYPTO_SHA256_MODULE)
+#error "crypto and sha256 must be built into the kernel"
+#endif
+
+int
+chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum)
+{
+	struct crypto_ahash *tfm;
+	struct ahash_request *req;
+	struct scatterlist sg[2];
+	unsigned char temp_sum[GR_SHA_LEN];
+	unsigned long *tmpsumptr = (unsigned long *)temp_sum;
+	unsigned long *sumptr = (unsigned long *)sum;
+	int retval = 1;
+
+	tfm = crypto_alloc_ahash("sha256", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
+		goto out_wipe;
+
+	sg_init_table(sg, 2);
+	sg_set_buf(&sg[0], salt, GR_SALT_LEN);
+	sg_set_buf(&sg[1], entry->pw, strlen((const char *)entry->pw));
+
+	req = ahash_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		crypto_free_ahash(tfm);
+		goto out_wipe;
+	}
+
+	ahash_request_set_callback(req, 0, NULL, NULL);
+	ahash_request_set_crypt(req, sg, temp_sum, GR_SALT_LEN + strlen((const char *)entry->pw));
+
+	if (crypto_ahash_digest(req))
+		goto out_free;
+
+	if (!crypto_memneq(sumptr, tmpsumptr, GR_SHA_LEN))
+		retval = 0;
+
+out_free:
+	ahash_request_free(req);
+	crypto_free_ahash(tfm);
+out_wipe:
+	memset(entry->pw, 0, GR_PW_LEN);
+
+	return retval;
+}
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index 3b1f424034c5..c8196d80551a 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -44,7 +44,7 @@ struct linux_binprm {
 	unsigned interp_flags;
 	unsigned interp_data;
 	unsigned long loader, exec;
-};
+} __randomize_layout;
 
 #define BINPRM_FLAGS_ENFORCE_NONDUMP_BIT 0
 #define BINPRM_FLAGS_ENFORCE_NONDUMP (1 << BINPRM_FLAGS_ENFORCE_NONDUMP_BIT)
@@ -79,8 +79,9 @@ struct linux_binfmt {
 	int (*load_shlib)(struct file *);
 	int (*core_dump)(struct coredump_params *cprm);
 	void (*handle_mprotect)(struct vm_area_struct *vma, unsigned long newflags);
+	void (*handle_mmap)(struct file *);
 	unsigned long min_coredump;	/* minimal dump size */
-} __do_const;
+} __do_const __randomize_layout;
 
 extern void __register_binfmt(struct linux_binfmt *fmt, int insert);
 
diff --git a/include/linux/capability.h b/include/linux/capability.h
index 6ffb67e10c06..ef1ec2aa023f 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -231,6 +231,10 @@ static inline bool capable(int cap)
 {
 	return true;
 }
+static inline bool capable_nolog(int cap)
+{
+	return true;
+}
 static inline bool ns_capable(struct user_namespace *ns, int cap)
 {
 	return true;
@@ -242,10 +246,14 @@ static inline bool ns_capable_noaudit(struct user_namespace *ns, int cap)
 #endif /* CONFIG_MULTIUSER */
 extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);
 extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
+extern bool capable_wrt_inode_uidgid_nolog(const struct inode *inode, int cap);
 extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
+extern bool capable_nolog(int cap);
 extern bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns);
 
 /* audit system wants to get cap info from files as well */
 extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
 
+extern int is_privileged_binary(const struct dentry *dentry);
+
 #endif /* !_LINUX_CAPABILITY_H */
diff --git a/include/linux/cdev.h b/include/linux/cdev.h
index f8763615a5f2..7c05fd9dd830 100644
--- a/include/linux/cdev.h
+++ b/include/linux/cdev.h
@@ -16,7 +16,7 @@ struct cdev {
 	struct list_head list;
 	dev_t dev;
 	unsigned int count;
-};
+} __randomize_layout;
 
 void cdev_init(struct cdev *, const struct file_operations *);
 
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 79b72610635d..dc13b5a92a29 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -194,6 +194,11 @@
 
 #if GCC_VERSION >= 40500
 
+#ifdef RANDSTRUCT_PLUGIN
+#define __randomize_layout __attribute__((randomize_layout))
+#define __no_randomize_layout __attribute__((no_randomize_layout))
+#endif
+
 #ifdef CONSTIFY_PLUGIN
 #define __no_const __attribute__((no_const))
 #define __do_const __attribute__((do_const))
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 2e1fda8299dc..a7444a7b2ea9 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -447,6 +447,14 @@ void __read_once_size_nocheck(const volatile void *p, void *res, int size)
 # define __latent_entropy
 #endif
 
+#ifndef __randomize_layout
+# define __randomize_layout
+#endif
+
+#ifndef __no_randomize_layout
+# define __no_randomize_layout
+#endif
+
 #ifndef __no_const
 # define __no_const
 #endif
diff --git a/include/linux/cred.h b/include/linux/cred.h
index f0e70a1bb3ac..0de3207d3efe 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -30,7 +30,7 @@ struct group_info {
 	atomic_t	usage;
 	int		ngroups;
 	kgid_t		gid[0];
-};
+} __randomize_layout;
 
 /**
  * get_group_info - Get a reference to a group info structure
@@ -144,7 +144,7 @@ struct cred {
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
 	struct rcu_head	rcu;		/* RCU deletion hook */
-};
+} __randomize_layout;
 
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);
@@ -202,6 +202,9 @@ static inline void validate_creds_for_do_exit(struct task_struct *tsk)
 static inline void validate_process_creds(void)
 {
 }
+static inline void validate_task_creds(struct task_struct *task)
+{
+}
 #endif
 
 static inline bool cap_ambient_invariant_ok(const struct cred *cred)
@@ -346,6 +349,7 @@ static inline void put_cred(const struct cred *_cred)
 
 #define task_uid(task)		(task_cred_xxx((task), uid))
 #define task_euid(task)		(task_cred_xxx((task), euid))
+#define task_securebits(task)	(task_cred_xxx((task), securebits))
 
 #define current_cred_xxx(xxx)			\
 ({						\
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index 52fff00af3dc..2b3dcac0b86b 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -102,6 +102,9 @@ struct dentry {
 		struct list_head d_lru;		/* LRU list */
 		wait_queue_head_t *d_wait;	/* in-lookup ones only */
 	};
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	atomic_t chroot_refcnt;		/* tracks use of directory in chroot */
+#endif
 	struct list_head d_child;	/* child of parent list */
 	struct list_head d_subdirs;	/* our children */
 	/*
@@ -112,7 +115,7 @@ struct dentry {
 		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
 	 	struct rcu_head d_rcu;
 	} d_u;
-};
+} __randomize_layout;
 
 /*
  * dentry->d_lock spinlock nesting subclasses:
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 44d97a52ff50..473e4cd78de1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -329,7 +329,7 @@ struct kiocb {
 	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 	void			*private;
 	int			ki_flags;
-};
+} __randomize_layout;
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
 {
@@ -446,7 +446,7 @@ struct address_space {
 	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
 	struct list_head	private_list;	/* ditto */
 	void			*private_data;	/* ditto */
-} __attribute__((aligned(sizeof(long))));
+} __attribute__((aligned(sizeof(long)))) __randomize_layout;
 	/*
 	 * On most architectures that alignment is already the case; but
 	 * must be enforced here for CRIS, to let the least significant bit
@@ -488,7 +488,7 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
-};
+} __randomize_layout;
 
 /*
  * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
@@ -703,7 +703,7 @@ struct inode {
 #endif
 
 	void			*i_private; /* fs or device private pointer */
-};
+} __randomize_layout;
 
 static inline int inode_unhashed(struct inode *inode)
 {
@@ -913,7 +913,7 @@ struct file {
 	struct list_head	f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
-} __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
+} __attribute__((aligned(4))) __randomize_layout;	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
 	__u32 handle_bytes;
@@ -1048,7 +1048,7 @@ struct file_lock {
 			int state;		/* state of grant or error if -ve */
 		} afs;
 	} fl_u;
-};
+} __randomize_layout;
 
 struct file_lock_context {
 	spinlock_t		flc_lock;
@@ -1447,7 +1447,7 @@ struct super_block {
 
 	spinlock_t		s_inode_wblist_lock;
 	struct list_head	s_inodes_wb;	/* writeback inodes */
-};
+} __randomize_layout;
 
 /* Helper functions so that in most cases filesystems will
  * not need to deal directly with kuid_t and kgid_t and can
@@ -1731,7 +1731,7 @@ struct file_operations {
 			u64);
 	ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,
 			u64);
-} __do_const;
+} __do_const __randomize_layout;
 typedef struct file_operations __no_const file_operations_no_const;
 
 struct inode_operations {
@@ -3210,4 +3210,14 @@ static inline bool dir_relax_shared(struct inode *inode)
 extern bool path_noexec(const struct path *path);
 extern void inode_nohighmem(struct inode *inode);
 
+static inline bool is_sidechannel_device(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_DEVICE_SIDECHANNEL
+	umode_t mode = inode->i_mode;
+	return ((S_ISCHR(mode) || S_ISBLK(mode)) && (mode & (S_IROTH | S_IWOTH)));
+#else
+	return false;
+#endif
+}
+
 #endif /* _LINUX_FS_H */
diff --git a/include/linux/fs_struct.h b/include/linux/fs_struct.h
index e0e1e5f6926f..fd236105cae6 100644
--- a/include/linux/fs_struct.h
+++ b/include/linux/fs_struct.h
@@ -12,7 +12,7 @@ struct fs_struct {
 	int umask;
 	int in_exec;
 	struct path root, pwd;
-};
+} __randomize_layout;
 
 extern struct kmem_cache *fs_cachep;
 
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index 31f1ad9f67e5..fd880400b463 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -180,6 +180,9 @@ static inline void fsnotify_access(struct file *file)
 	struct inode *inode = path->dentry->d_inode;
 	__u32 mask = FS_ACCESS;
 
+	if (is_sidechannel_device(inode))
+		return;
+
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
@@ -198,6 +201,9 @@ static inline void fsnotify_modify(struct file *file)
 	struct inode *inode = path->dentry->d_inode;
 	__u32 mask = FS_MODIFY;
 
+	if (is_sidechannel_device(inode))
+		return;
+
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
diff --git a/include/linux/gracl.h b/include/linux/gracl.h
new file mode 100644
index 000000000000..a3c4df76dc80
--- /dev/null
+++ b/include/linux/gracl.h
@@ -0,0 +1,342 @@
+#ifndef GR_ACL_H
+#define GR_ACL_H
+
+#include <linux/grdefs.h>
+#include <linux/resource.h>
+#include <linux/capability.h>
+#include <linux/dcache.h>
+#include <asm/resource.h>
+
+/* Major status information */
+
+#define GR_VERSION  "grsecurity 3.1"
+#define GRSECURITY_VERSION 0x3100
+
+enum {
+	GR_SHUTDOWN = 0,
+	GR_ENABLE = 1,
+	GR_SPROLE = 2,
+	GR_OLDRELOAD = 3,
+	GR_SEGVMOD = 4,
+	GR_STATUS = 5,
+	GR_UNSPROLE = 6,
+	GR_PASSSET = 7,
+	GR_SPROLEPAM = 8,
+	GR_RELOAD = 9,
+};
+
+/* Password setup definitions
+ * kernel/grhash.c */
+enum {
+	GR_PW_LEN = 128,
+	GR_SALT_LEN = 16,
+	GR_SHA_LEN = 32,
+};
+
+enum {
+	GR_SPROLE_LEN = 64,
+};
+
+enum {
+	GR_NO_GLOB = 0,
+	GR_REG_GLOB,
+	GR_CREATE_GLOB
+};
+
+#define GR_NLIMITS 32
+
+/* Begin Data Structures */
+
+struct sprole_pw {
+	unsigned char *rolename;
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];	/* 256-bit SHA hash of the password */
+};
+
+struct name_entry {
+	__u32 key;
+	u64 inode;
+	dev_t device;
+	char *name;
+	__u16 len;
+	__u8 deleted;
+	struct name_entry *prev;
+	struct name_entry *next;
+};
+
+struct inodev_entry {
+	struct name_entry *nentry;
+	struct inodev_entry *prev;
+	struct inodev_entry *next;
+};
+
+struct acl_role_db {
+	struct acl_role_label **r_hash;
+	__u32 r_size;
+};
+
+struct inodev_db {
+	struct inodev_entry **i_hash;
+	__u32 i_size;
+};
+
+struct name_db {
+	struct name_entry **n_hash;
+	__u32 n_size;
+};
+
+struct crash_uid {
+	uid_t uid;
+	unsigned long expires;
+};
+
+struct gr_hash_struct {
+	void **table;
+	void **nametable;
+	void *first;
+	__u32 table_size;
+	__u32 used_size;
+	int type;
+};
+
+/* Userspace Grsecurity ACL data structures */
+
+struct acl_subject_label {
+	char *filename;
+	u64 inode;
+	dev_t device;
+	__u32 mode;
+	kernel_cap_t cap_mask;
+	kernel_cap_t cap_lower;
+	kernel_cap_t cap_invert_audit;
+
+	struct rlimit res[GR_NLIMITS];
+	__u32 resmask;
+
+	__u8 user_trans_type;
+	__u8 group_trans_type;
+	uid_t *user_transitions;
+	gid_t *group_transitions;
+	__u16 user_trans_num;
+	__u16 group_trans_num;
+
+	__u32 sock_families[2];
+	__u32 ip_proto[8];
+	__u32 ip_type;
+	struct acl_ip_label **ips;
+	__u32 ip_num;
+	__u32 inaddr_any_override;
+
+	__u32 crashes;
+	unsigned long expires;
+
+	struct acl_subject_label *parent_subject;
+	struct gr_hash_struct *hash;
+	struct acl_subject_label *prev;
+	struct acl_subject_label *next;
+
+	struct acl_object_label **obj_hash;
+	__u32 obj_hash_size;
+	__u16 pax_flags;
+};
+
+struct role_allowed_ip {
+	__u32 addr;
+	__u32 netmask;
+
+	struct role_allowed_ip *prev;
+	struct role_allowed_ip *next;
+};
+
+struct role_transition {
+	char *rolename;
+
+	struct role_transition *prev;
+	struct role_transition *next;
+};
+
+struct acl_role_label {
+	char *rolename;
+	uid_t uidgid;
+	__u16 roletype;
+
+	__u16 auth_attempts;
+	unsigned long expires;
+
+	struct acl_subject_label *root_label;
+	struct gr_hash_struct *hash;
+
+	struct acl_role_label *prev;
+	struct acl_role_label *next;
+
+	struct role_transition *transitions;
+	struct role_allowed_ip *allowed_ips;
+	uid_t *domain_children;
+	__u16 domain_child_num;
+
+	umode_t umask;
+
+	struct acl_subject_label **subj_hash;
+	__u32 subj_hash_size;
+};
+
+struct user_acl_role_db {
+	struct acl_role_label **r_table;
+	__u32 num_pointers;		/* Number of allocations to track */
+	__u32 num_roles;		/* Number of roles */
+	__u32 num_domain_children;	/* Number of domain children */
+	__u32 num_subjects;		/* Number of subjects */
+	__u32 num_objects;		/* Number of objects */
+};
+
+struct acl_object_label {
+	char *filename;
+	u64 inode;
+	dev_t device;
+	__u32 mode;
+
+	struct acl_subject_label *nested;
+	struct acl_object_label *globbed;
+
+	/* next two structures not used */
+
+	struct acl_object_label *prev;
+	struct acl_object_label *next;
+};
+
+struct acl_ip_label {
+	char *iface;
+	__u32 addr;
+	__u32 netmask;
+	__u16 low, high;
+	__u8 mode;
+	__u32 type;
+	__u32 proto[8];
+
+	/* next two structures not used */
+
+	struct acl_ip_label *prev;
+	struct acl_ip_label *next;
+};
+
+struct gr_arg {
+	struct user_acl_role_db role_db;
+	unsigned char pw[GR_PW_LEN];
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];
+	unsigned char sp_role[GR_SPROLE_LEN];
+	struct sprole_pw *sprole_pws;
+	dev_t segv_device;
+	u64 segv_inode;
+	uid_t segv_uid;
+	__u16 num_sprole_pws;
+	__u16 mode;
+};
+
+struct gr_arg_wrapper {
+	struct gr_arg *arg;
+	__u32 version;
+	__u32 size;
+};
+
+struct subject_map {
+	struct acl_subject_label *user;
+	struct acl_subject_label *kernel;
+	struct subject_map *prev;
+	struct subject_map *next;
+};
+
+struct acl_subj_map_db {
+	struct subject_map **s_hash;
+	__u32 s_size;
+};
+
+struct gr_policy_state {
+	struct sprole_pw **acl_special_roles;
+	__u16 num_sprole_pws;
+	struct acl_role_label *kernel_role;
+	struct acl_role_label *role_list;
+	struct acl_role_label *default_role;
+	struct acl_role_db acl_role_set;
+	struct acl_subj_map_db subj_map_set;
+	struct name_db name_set;
+	struct inodev_db inodev_set;
+};
+
+struct gr_alloc_state {
+	unsigned long alloc_stack_next;
+	unsigned long alloc_stack_size;
+	void **alloc_stack;
+};
+
+struct gr_reload_state {
+	struct gr_policy_state oldpolicy;
+	struct gr_alloc_state oldalloc;
+	struct gr_policy_state newpolicy;
+	struct gr_alloc_state newalloc;
+	struct gr_policy_state *oldpolicy_ptr;
+	struct gr_alloc_state *oldalloc_ptr;
+	unsigned char oldmode;
+};
+
+/* End Data Structures Section */
+
+/* Hash functions generated by empirical testing by Brad Spengler
+   Makes good use of the low bits of the inode.  Generally 0-1 times
+   in loop for successful match.  0-3 for unsuccessful match.
+   Shift/add algorithm with modulus of table size and an XOR*/
+
+static __inline__ unsigned int
+gr_rhash(const uid_t uid, const __u16 type, const unsigned int sz)
+{
+	return ((((uid + type) << (16 + type)) ^ uid) % sz);
+}
+
+ static __inline__ unsigned int
+gr_shash(const struct acl_subject_label *userp, const unsigned int sz)
+{
+	return ((const unsigned long)userp % sz);
+}
+
+static __inline__ unsigned int
+gr_fhash(const u64 ino, const dev_t dev, const unsigned int sz)
+{
+	unsigned int rem;
+	div_u64_rem((ino + dev) ^ ((ino << 13) + (ino << 23) + (dev << 9)), sz, &rem);
+	return rem;
+}
+
+static __inline__ unsigned int
+gr_nhash(const char *name, const __u16 len, const unsigned int sz)
+{
+	return full_name_hash(NULL, (const unsigned char *)name, len) % sz;
+}
+
+#define FOR_EACH_SUBJECT_START(role,subj,iter) \
+	subj = NULL; \
+	iter = 0; \
+	while (iter < role->subj_hash_size) { \
+		if (subj == NULL) \
+			subj = role->subj_hash[iter]; \
+		if (subj == NULL) { \
+			iter++; \
+			continue; \
+		}
+
+#define FOR_EACH_SUBJECT_END(subj,iter) \
+		subj = subj->next; \
+		if (subj == NULL) \
+			iter++; \
+	}
+
+
+#define FOR_EACH_NESTED_SUBJECT_START(role,subj) \
+	subj = role->hash->first; \
+	while (subj != NULL) {
+
+#define FOR_EACH_NESTED_SUBJECT_END(subj) \
+		subj = subj->next; \
+	}
+
+#endif
+
diff --git a/include/linux/gracl_compat.h b/include/linux/gracl_compat.h
new file mode 100644
index 000000000000..af640920c025
--- /dev/null
+++ b/include/linux/gracl_compat.h
@@ -0,0 +1,156 @@
+#ifndef GR_ACL_COMPAT_H
+#define GR_ACL_COMPAT_H
+
+#include <linux/resource.h>
+#include <asm/resource.h>
+
+struct sprole_pw_compat {
+	compat_uptr_t rolename;
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];
+};
+
+struct gr_hash_struct_compat {
+	compat_uptr_t table;
+	compat_uptr_t nametable;
+	compat_uptr_t first;
+	__u32 table_size;
+	__u32 used_size;
+	int type;
+};
+
+struct acl_subject_label_compat {
+	compat_uptr_t filename;
+	compat_u64 inode;
+	__u32 device;
+	__u32 mode;
+	kernel_cap_t cap_mask;
+	kernel_cap_t cap_lower;
+	kernel_cap_t cap_invert_audit;
+
+	struct compat_rlimit res[GR_NLIMITS];
+	__u32 resmask;
+
+	__u8 user_trans_type;
+	__u8 group_trans_type;
+	compat_uptr_t user_transitions;
+	compat_uptr_t group_transitions;
+	__u16 user_trans_num;
+	__u16 group_trans_num;
+
+	__u32 sock_families[2];
+	__u32 ip_proto[8];
+	__u32 ip_type;
+	compat_uptr_t ips;
+	__u32 ip_num;
+	__u32 inaddr_any_override;
+
+	__u32 crashes;
+	compat_ulong_t expires;
+
+	compat_uptr_t parent_subject;
+	compat_uptr_t hash;
+	compat_uptr_t prev;
+	compat_uptr_t next;
+
+	compat_uptr_t obj_hash;
+	__u32 obj_hash_size;
+	__u16 pax_flags;
+};
+
+struct role_allowed_ip_compat {
+	__u32 addr;
+	__u32 netmask;
+
+	compat_uptr_t prev;
+	compat_uptr_t next;
+};
+
+struct role_transition_compat {
+	compat_uptr_t rolename;
+
+	compat_uptr_t prev;
+	compat_uptr_t next;
+};
+
+struct acl_role_label_compat {
+	compat_uptr_t rolename;
+	uid_t uidgid;
+	__u16 roletype;
+
+	__u16 auth_attempts;
+	compat_ulong_t expires;
+
+	compat_uptr_t root_label;
+	compat_uptr_t hash;
+
+	compat_uptr_t prev;
+	compat_uptr_t next;
+
+	compat_uptr_t transitions;
+	compat_uptr_t allowed_ips;
+	compat_uptr_t domain_children;
+	__u16 domain_child_num;
+
+	umode_t umask;
+
+	compat_uptr_t subj_hash;
+	__u32 subj_hash_size;
+};
+
+struct user_acl_role_db_compat {
+	compat_uptr_t r_table;
+	__u32 num_pointers;
+	__u32 num_roles;
+	__u32 num_domain_children;
+	__u32 num_subjects;
+	__u32 num_objects;
+};
+
+struct acl_object_label_compat {
+	compat_uptr_t filename;
+	compat_u64 inode;
+	__u32 device;
+	__u32 mode;
+
+	compat_uptr_t nested;
+	compat_uptr_t globbed;
+
+	compat_uptr_t prev;
+	compat_uptr_t next;
+};
+
+struct acl_ip_label_compat {
+	compat_uptr_t iface;
+	__u32 addr;
+	__u32 netmask;
+	__u16 low, high;
+	__u8 mode;
+	__u32 type;
+	__u32 proto[8];
+
+	compat_uptr_t prev;
+	compat_uptr_t next;
+};
+
+struct gr_arg_compat {
+	struct user_acl_role_db_compat role_db;
+	unsigned char pw[GR_PW_LEN];
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];
+	unsigned char sp_role[GR_SPROLE_LEN];
+	compat_uptr_t sprole_pws;
+	__u32 segv_device;
+	compat_u64 segv_inode;
+	uid_t segv_uid;
+	__u16 num_sprole_pws;
+	__u16 mode;
+};
+
+struct gr_arg_wrapper_compat {
+	compat_uptr_t arg;
+	__u32 version;
+	__u32 size;
+};
+
+#endif
diff --git a/include/linux/gralloc.h b/include/linux/gralloc.h
new file mode 100644
index 000000000000..323ecf28024c
--- /dev/null
+++ b/include/linux/gralloc.h
@@ -0,0 +1,9 @@
+#ifndef __GRALLOC_H
+#define __GRALLOC_H
+
+void acl_free_all(void);
+int acl_alloc_stack_init(unsigned long size);
+void *acl_alloc(unsigned long len);
+void *acl_alloc_num(unsigned long num, unsigned long len);
+
+#endif
diff --git a/include/linux/grdefs.h b/include/linux/grdefs.h
new file mode 100644
index 000000000000..be66033e666b
--- /dev/null
+++ b/include/linux/grdefs.h
@@ -0,0 +1,140 @@
+#ifndef GRDEFS_H
+#define GRDEFS_H
+
+/* Begin grsecurity status declarations */
+
+enum {
+	GR_READY = 0x01,
+	GR_STATUS_INIT = 0x00	// disabled state
+};
+
+/* Begin  ACL declarations */
+
+/* Role flags */
+
+enum {
+	GR_ROLE_USER = 0x0001,
+	GR_ROLE_GROUP = 0x0002,
+	GR_ROLE_DEFAULT = 0x0004,
+	GR_ROLE_SPECIAL = 0x0008,
+	GR_ROLE_AUTH = 0x0010,
+	GR_ROLE_NOPW = 0x0020,
+	GR_ROLE_GOD = 0x0040,
+	GR_ROLE_LEARN = 0x0080,
+	GR_ROLE_TPE = 0x0100,
+	GR_ROLE_DOMAIN = 0x0200,
+	GR_ROLE_PAM = 0x0400,
+	GR_ROLE_PERSIST = 0x0800
+};
+
+/* ACL Subject and Object mode flags */
+enum {
+	GR_DELETED = 0x80000000
+};
+
+/* ACL Object-only mode flags */
+enum {
+	GR_READ 	= 0x00000001,
+	GR_APPEND 	= 0x00000002,
+	GR_WRITE 	= 0x00000004,
+	GR_EXEC 	= 0x00000008,
+	GR_FIND 	= 0x00000010,
+	GR_INHERIT 	= 0x00000020,
+	GR_SETID 	= 0x00000040,
+	GR_CREATE 	= 0x00000080,
+	GR_DELETE 	= 0x00000100,
+	GR_LINK		= 0x00000200,
+	GR_AUDIT_READ 	= 0x00000400,
+	GR_AUDIT_APPEND = 0x00000800,
+	GR_AUDIT_WRITE 	= 0x00001000,
+	GR_AUDIT_EXEC 	= 0x00002000,
+	GR_AUDIT_FIND 	= 0x00004000,
+	GR_AUDIT_INHERIT= 0x00008000,
+	GR_AUDIT_SETID 	= 0x00010000,
+	GR_AUDIT_CREATE = 0x00020000,
+	GR_AUDIT_DELETE = 0x00040000,
+	GR_AUDIT_LINK	= 0x00080000,
+	GR_PTRACERD 	= 0x00100000,
+	GR_NOPTRACE	= 0x00200000,
+	GR_SUPPRESS 	= 0x00400000,
+	GR_NOLEARN 	= 0x00800000,
+	GR_INIT_TRANSFER= 0x01000000
+};
+
+#define GR_AUDITS (GR_AUDIT_READ | GR_AUDIT_WRITE | GR_AUDIT_APPEND | GR_AUDIT_EXEC | \
+		   GR_AUDIT_FIND | GR_AUDIT_INHERIT | GR_AUDIT_SETID | \
+		   GR_AUDIT_CREATE | GR_AUDIT_DELETE | GR_AUDIT_LINK)
+
+/* ACL subject-only mode flags */
+enum {
+	GR_KILL 	= 0x00000001,
+	GR_VIEW 	= 0x00000002,
+	GR_PROTECTED 	= 0x00000004,
+	GR_LEARN 	= 0x00000008,
+	GR_OVERRIDE 	= 0x00000010,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_DUMMY 	= 0x00000020,
+	GR_PROTSHM	= 0x00000040,
+	GR_KILLPROC	= 0x00000080,
+	GR_KILLIPPROC	= 0x00000100,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_NOTROJAN	= 0x00000200,
+	GR_PROTPROCFD	= 0x00000400,
+	GR_PROCACCT	= 0x00000800,
+	GR_RELAXPTRACE	= 0x00001000,
+	//GR_NESTED	= 0x00002000,
+	GR_INHERITLEARN	= 0x00004000,
+	GR_PROCFIND	= 0x00008000,
+	GR_POVERRIDE	= 0x00010000,
+	GR_KERNELAUTH	= 0x00020000,
+	GR_ATSECURE	= 0x00040000,
+	GR_SHMEXEC	= 0x00080000
+};
+
+enum {
+	GR_PAX_ENABLE_SEGMEXEC	= 0x0001,
+	GR_PAX_ENABLE_PAGEEXEC	= 0x0002,
+	GR_PAX_ENABLE_MPROTECT	= 0x0004,
+	GR_PAX_ENABLE_RANDMMAP	= 0x0008,
+	GR_PAX_ENABLE_EMUTRAMP	= 0x0010,
+	GR_PAX_DISABLE_SEGMEXEC	= 0x0100,
+	GR_PAX_DISABLE_PAGEEXEC	= 0x0200,
+	GR_PAX_DISABLE_MPROTECT	= 0x0400,
+	GR_PAX_DISABLE_RANDMMAP	= 0x0800,
+	GR_PAX_DISABLE_EMUTRAMP	= 0x1000,
+};
+
+enum {
+	GR_ID_USER	= 0x01,
+	GR_ID_GROUP	= 0x02,
+};
+
+enum {
+	GR_ID_ALLOW	= 0x01,
+	GR_ID_DENY	= 0x02,
+};
+
+#define GR_CRASH_RES	31
+#define GR_UIDTABLE_MAX 500
+
+/* begin resource learning section */
+enum {
+	GR_RLIM_CPU_BUMP = 60,
+	GR_RLIM_FSIZE_BUMP = 50000,
+	GR_RLIM_DATA_BUMP = 10000,
+	GR_RLIM_STACK_BUMP = 1000,
+	GR_RLIM_CORE_BUMP = 10000,
+	GR_RLIM_RSS_BUMP = 500000,
+	GR_RLIM_NPROC_BUMP = 1,
+	GR_RLIM_NOFILE_BUMP = 5,
+	GR_RLIM_MEMLOCK_BUMP = 50000,
+	GR_RLIM_AS_BUMP = 500000,
+	GR_RLIM_LOCKS_BUMP = 2,
+	GR_RLIM_SIGPENDING_BUMP = 5,
+	GR_RLIM_MSGQUEUE_BUMP = 10000,
+	GR_RLIM_NICE_BUMP = 1,
+	GR_RLIM_RTPRIO_BUMP = 1,
+	GR_RLIM_RTTIME_BUMP = 1000000
+};
+
+#endif
diff --git a/include/linux/grinternal.h b/include/linux/grinternal.h
new file mode 100644
index 000000000000..1dbf9c87108e
--- /dev/null
+++ b/include/linux/grinternal.h
@@ -0,0 +1,231 @@
+#ifndef __GRINTERNAL_H
+#define __GRINTERNAL_H
+
+#ifdef CONFIG_GRKERNSEC
+
+#include <linux/fs.h>
+#include <linux/mnt_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/gracl.h>
+#include <linux/grdefs.h>
+#include <linux/grmsg.h>
+
+void gr_add_learn_entry(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+__u32 gr_search_file(const struct dentry *dentry, const __u32 mode,
+			    const struct vfsmount *mnt);
+__u32 gr_check_create(const struct dentry *new_dentry,
+			     const struct dentry *parent,
+			     const struct vfsmount *mnt, const __u32 mode);
+int gr_check_protected_task(const struct task_struct *task);
+__u32 to_gr_audit(const __u32 reqmode);
+int gr_set_acls(const int type);
+int gr_acl_is_enabled(void);
+char gr_roletype_to_char(void);
+
+void gr_handle_alertkill(struct task_struct *task);
+char *gr_to_filename(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename1(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename2(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename3(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+
+extern int grsec_enable_ptrace_readexec;
+extern int grsec_enable_harden_ptrace;
+extern int grsec_enable_link;
+extern int grsec_enable_fifo;
+extern int grsec_enable_execve;
+extern int grsec_enable_shm;
+extern int grsec_enable_execlog;
+extern int grsec_enable_signal;
+extern int grsec_enable_audit_ptrace;
+extern int grsec_enable_forkfail;
+extern int grsec_enable_time;
+extern int grsec_enable_rofs;
+extern int grsec_deny_new_usb;
+extern int grsec_enable_chroot_shmat;
+extern int grsec_enable_chroot_mount;
+extern int grsec_enable_chroot_double;
+extern int grsec_enable_chroot_pivot;
+extern int grsec_enable_chroot_chdir;
+extern int grsec_enable_chroot_chmod;
+extern int grsec_enable_chroot_mknod;
+extern int grsec_enable_chroot_fchdir;
+extern int grsec_enable_chroot_nice;
+extern int grsec_enable_chroot_execlog;
+extern int grsec_enable_chroot_caps;
+extern int grsec_enable_chroot_rename;
+extern int grsec_enable_chroot_sysctl;
+extern int grsec_enable_chroot_unix;
+extern int grsec_enable_symlinkown;
+extern kgid_t grsec_symlinkown_gid;
+extern int grsec_enable_tpe;
+extern kgid_t grsec_tpe_gid;
+extern int grsec_enable_tpe_all;
+extern int grsec_enable_tpe_invert;
+extern int grsec_enable_socket_all;
+extern kgid_t grsec_socket_all_gid;
+extern int grsec_enable_socket_client;
+extern kgid_t grsec_socket_client_gid;
+extern int grsec_enable_socket_server;
+extern kgid_t grsec_socket_server_gid;
+extern kgid_t grsec_audit_gid;
+extern int grsec_enable_group;
+extern int grsec_enable_log_rwxmaps;
+extern int grsec_enable_mount;
+extern int grsec_enable_chdir;
+extern int grsec_resource_logging;
+extern int grsec_enable_blackhole;
+extern int grsec_lastack_retries;
+extern int grsec_enable_brute;
+extern int grsec_enable_harden_ipc;
+extern int grsec_enable_harden_tty;
+extern int grsec_lock;
+
+extern spinlock_t grsec_alert_lock;
+extern unsigned long grsec_alert_wtime;
+extern unsigned long grsec_alert_fyet;
+
+extern spinlock_t grsec_audit_lock;
+
+extern rwlock_t grsec_exec_file_lock;
+
+#define gr_task_fullpath(tsk) ((tsk)->exec_file ? \
+			gr_to_filename2((tsk)->exec_file->f_path.dentry, \
+			(tsk)->exec_file->f_path.mnt) : "/")
+
+#define gr_parent_task_fullpath(tsk) ((tsk)->real_parent->exec_file ? \
+			gr_to_filename3((tsk)->real_parent->exec_file->f_path.dentry, \
+			(tsk)->real_parent->exec_file->f_path.mnt) : "/")
+
+#define gr_task_fullpath0(tsk) ((tsk)->exec_file ? \
+			gr_to_filename((tsk)->exec_file->f_path.dentry, \
+			(tsk)->exec_file->f_path.mnt) : "/")
+
+#define gr_parent_task_fullpath0(tsk) ((tsk)->real_parent->exec_file ? \
+			gr_to_filename1((tsk)->real_parent->exec_file->f_path.dentry, \
+			(tsk)->real_parent->exec_file->f_path.mnt) : "/")
+
+#define proc_is_chrooted(tsk_a)  ((tsk_a)->gr_is_chrooted)
+
+#define have_same_root(tsk_a,tsk_b) ((tsk_a)->gr_chroot_dentry == (tsk_b)->gr_chroot_dentry)
+
+static inline bool gr_is_same_file(const struct file *file1, const struct file *file2)
+{
+	if (file1 && file2) {
+		const struct inode *inode1 = file1->f_path.dentry->d_inode;
+		const struct inode *inode2 = file2->f_path.dentry->d_inode;
+		if (inode1->i_ino == inode2->i_ino && inode1->i_sb->s_dev == inode2->i_sb->s_dev)
+			return true;
+	}
+
+	return false;
+}
+
+#define GR_CHROOT_CAPS {{ \
+	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG) | \
+	CAP_TO_MASK(CAP_IPC_OWNER) | CAP_TO_MASK(CAP_SETFCAP), \
+	CAP_TO_MASK(CAP_SYSLOG) | CAP_TO_MASK(CAP_MAC_ADMIN) }}
+
+#define security_learn(normal_msg,args...) \
+({ \
+	read_lock(&grsec_exec_file_lock); \
+	gr_add_learn_entry(normal_msg "\n", ## args); \
+	read_unlock(&grsec_exec_file_lock); \
+})
+
+enum {
+	GR_DO_AUDIT,
+	GR_DONT_AUDIT,
+	/* used for non-audit messages that we shouldn't kill the task on */
+	GR_DONT_AUDIT_GOOD
+};
+
+enum {
+	GR_TTYSNIFF,
+	GR_RBAC,
+	GR_RBAC_STR,
+	GR_STR_RBAC,
+	GR_RBAC_MODE2,
+	GR_RBAC_MODE3,
+	GR_FILENAME,
+	GR_SYSCTL_HIDDEN,
+	GR_NOARGS,
+	GR_ONE_INT,
+	GR_ONE_INT_TWO_STR,
+	GR_ONE_STR,
+	GR_STR_INT,
+	GR_TWO_STR_INT,
+	GR_TWO_INT,
+	GR_TWO_U64,
+	GR_THREE_INT,
+	GR_FIVE_INT_TWO_STR,
+	GR_TWO_STR,
+	GR_THREE_STR,
+	GR_FOUR_STR,
+	GR_STR_FILENAME,
+	GR_FILENAME_STR,
+	GR_FILENAME_TWO_INT,
+	GR_FILENAME_TWO_INT_STR,
+	GR_TEXTREL,
+	GR_PTRACE,
+	GR_RESOURCE,
+	GR_CAP,
+	GR_SIG,
+	GR_SIG2,
+	GR_CRASH1,
+	GR_CRASH2,
+	GR_PSACCT,
+	GR_RWXMAP,
+	GR_RWXMAPVMA
+};
+
+#define gr_log_hidden_sysctl(audit, msg, str) gr_log_varargs(audit, msg, GR_SYSCTL_HIDDEN, str)
+#define gr_log_ttysniff(audit, msg, task) gr_log_varargs(audit, msg, GR_TTYSNIFF, task)
+#define gr_log_fs_rbac_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_RBAC, dentry, mnt)
+#define gr_log_fs_rbac_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_RBAC_STR, dentry, mnt, str)
+#define gr_log_fs_str_rbac(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_RBAC, str, dentry, mnt)
+#define gr_log_fs_rbac_mode2(audit, msg, dentry, mnt, str1, str2) gr_log_varargs(audit, msg, GR_RBAC_MODE2, dentry, mnt, str1, str2)
+#define gr_log_fs_rbac_mode3(audit, msg, dentry, mnt, str1, str2, str3) gr_log_varargs(audit, msg, GR_RBAC_MODE3, dentry, mnt, str1, str2, str3)
+#define gr_log_fs_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_FILENAME, dentry, mnt)
+#define gr_log_noargs(audit, msg) gr_log_varargs(audit, msg, GR_NOARGS)
+#define gr_log_int(audit, msg, num) gr_log_varargs(audit, msg, GR_ONE_INT, num)
+#define gr_log_int_str2(audit, msg, num, str1, str2) gr_log_varargs(audit, msg, GR_ONE_INT_TWO_STR, num, str1, str2)
+#define gr_log_str(audit, msg, str) gr_log_varargs(audit, msg, GR_ONE_STR, str)
+#define gr_log_str_int(audit, msg, str, num) gr_log_varargs(audit, msg, GR_STR_INT, str, num)
+#define gr_log_int_int(audit, msg, num1, num2) gr_log_varargs(audit, msg, GR_TWO_INT, num1, num2)
+#define gr_log_two_u64(audit, msg, num1, num2) gr_log_varargs(audit, msg, GR_TWO_U64, num1, num2)
+#define gr_log_int3(audit, msg, num1, num2, num3) gr_log_varargs(audit, msg, GR_THREE_INT, num1, num2, num3)
+#define gr_log_int5_str2(audit, msg, num1, num2, str1, str2) gr_log_varargs(audit, msg, GR_FIVE_INT_TWO_STR, num1, num2, str1, str2)
+#define gr_log_str_str(audit, msg, str1, str2) gr_log_varargs(audit, msg, GR_TWO_STR, str1, str2)
+#define gr_log_str2_int(audit, msg, str1, str2, num) gr_log_varargs(audit, msg, GR_TWO_STR_INT, str1, str2, num)
+#define gr_log_str3(audit, msg, str1, str2, str3) gr_log_varargs(audit, msg, GR_THREE_STR, str1, str2, str3)
+#define gr_log_str4(audit, msg, str1, str2, str3, str4) gr_log_varargs(audit, msg, GR_FOUR_STR, str1, str2, str3, str4)
+#define gr_log_str_fs(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_FILENAME, str, dentry, mnt)
+#define gr_log_fs_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_FILENAME_STR, dentry, mnt, str)
+#define gr_log_fs_int2(audit, msg, dentry, mnt, num1, num2) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT, dentry, mnt, num1, num2)
+#define gr_log_fs_int2_str(audit, msg, dentry, mnt, num1, num2, str) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT_STR, dentry, mnt, num1, num2, str)
+#define gr_log_textrel_ulong_ulong(audit, msg, str, file, ulong1, ulong2) gr_log_varargs(audit, msg, GR_TEXTREL, str, file, ulong1, ulong2)
+#define gr_log_ptrace(audit, msg, task) gr_log_varargs(audit, msg, GR_PTRACE, task)
+#define gr_log_res_ulong2_str(audit, msg, task, ulong1, str, ulong2) gr_log_varargs(audit, msg, GR_RESOURCE, task, ulong1, str, ulong2)
+#define gr_log_cap(audit, msg, task, str) gr_log_varargs(audit, msg, GR_CAP, task, str)
+#define gr_log_sig_addr(audit, msg, str, addr) gr_log_varargs(audit, msg, GR_SIG, str, addr)
+#define gr_log_sig_task(audit, msg, task, num) gr_log_varargs(audit, msg, GR_SIG2, task, num)
+#define gr_log_crash1(audit, msg, task, ulong) gr_log_varargs(audit, msg, GR_CRASH1, task, ulong)
+#define gr_log_crash2(audit, msg, task, ulong1) gr_log_varargs(audit, msg, GR_CRASH2, task, ulong1)
+#define gr_log_procacct(audit, msg, task, num1, num2, num3, num4, num5, num6, num7, num8, num9) gr_log_varargs(audit, msg, GR_PSACCT, task, num1, num2, num3, num4, num5, num6, num7, num8, num9)
+#define gr_log_rwxmap(audit, msg, str) gr_log_varargs(audit, msg, GR_RWXMAP, str)
+#define gr_log_rwxmap_vma(audit, msg, str) gr_log_varargs(audit, msg, GR_RWXMAPVMA, str)
+
+void gr_log_varargs(int audit, const char *msg, int argtypes, ...);
+
+#endif
+
+#endif
diff --git a/include/linux/grmsg.h b/include/linux/grmsg.h
new file mode 100644
index 000000000000..f1d36054b8e4
--- /dev/null
+++ b/include/linux/grmsg.h
@@ -0,0 +1,121 @@
+#define DEFAULTSECMSG "%.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u, parent %.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_ACL_PROCACCT_MSG "%.256s[%.16s:%d] IP:%pI4 TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u run time:[%ud %uh %um %us] cpu time:[%ud %uh %um %us] %s with exit code %ld, parent %.256s[%.16s:%d] IP:%pI4 TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_PTRACE_ACL_MSG "denied ptrace of %.950s(%.16s:%d) by "
+#define GR_STOPMOD_MSG "denied modification of module state by "
+#define GR_ROFS_BLOCKWRITE_MSG "denied write to block device %.950s by "
+#define GR_ROFS_MOUNT_MSG "denied writable mount of %.950s by "
+#define GR_IOPERM_MSG "denied use of ioperm() by "
+#define GR_IOPL_MSG "denied use of iopl() by "
+#define GR_SHMAT_ACL_MSG "denied attach of shared memory of UID %u, PID %d, ID %u by "
+#define GR_UNIX_CHROOT_MSG "denied connect() to abstract AF_UNIX socket outside of chroot by "
+#define GR_SHMAT_CHROOT_MSG "denied attach of shared memory outside of chroot by "
+#define GR_MEM_READWRITE_MSG "denied access of range %Lx -> %Lx in /dev/mem by "
+#define GR_SYMLINK_MSG "not following symlink %.950s owned by %d.%d by "
+#define GR_LEARN_AUDIT_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%lu\t%lu\t%.4095s\t%lu\t%pI4"
+#define GR_ID_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%c\t%d\t%d\t%d\t%pI4"
+#define GR_HIDDEN_ACL_MSG "%s access to hidden file %.950s by "
+#define GR_OPEN_ACL_MSG "%s open of %.950s for%s%s by "
+#define GR_CREATE_ACL_MSG "%s create of %.950s for%s%s by "
+#define GR_FIFO_MSG "denied writing FIFO %.950s of %d.%d by "
+#define GR_MKNOD_CHROOT_MSG "denied mknod of %.950s from chroot by "
+#define GR_MKNOD_ACL_MSG "%s mknod of %.950s by "
+#define GR_UNIXCONNECT_ACL_MSG "%s connect() to the unix domain socket %.950s by "
+#define GR_TTYSNIFF_ACL_MSG "terminal being sniffed by IP:%pI4 %.480s[%.16s:%d], parent %.480s[%.16s:%d] against "
+#define GR_MKDIR_ACL_MSG "%s mkdir of %.950s by "
+#define GR_RMDIR_ACL_MSG "%s rmdir of %.950s by "
+#define GR_UNLINK_ACL_MSG "%s unlink of %.950s by "
+#define GR_SYMLINK_ACL_MSG "%s symlink from %.480s to %.480s by "
+#define GR_HARDLINK_MSG "denied hardlink of %.930s (owned by %d.%d) to %.30s for "
+#define GR_LINK_ACL_MSG "%s link of %.480s to %.480s by "
+#define GR_INHERIT_ACL_MSG "successful inherit of %.480s's ACL for %.480s by "
+#define GR_RENAME_ACL_MSG "%s rename of %.480s to %.480s by "
+#define GR_UNSAFESHARE_EXEC_ACL_MSG "denied exec with cloned fs of %.950s by "
+#define GR_PTRACE_EXEC_ACL_MSG "denied ptrace of %.950s by "
+#define GR_NNP_EXEC_ACL_MSG "denied exec of %.950s due to NNP by "
+#define GR_EXEC_ACL_MSG "%s execution of %.950s by "
+#define GR_EXEC_TPE_MSG "denied untrusted exec (due to %.70s) of %.950s by "
+#define GR_SEGVSTART_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning uid %u from login for %lu seconds"
+#define GR_SEGVNOSUID_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning execution for %lu seconds"
+#define GR_MOUNT_CHROOT_MSG "denied mount of %.256s as %.930s from chroot by "
+#define GR_PIVOT_CHROOT_MSG "denied pivot_root from chroot by "
+#define GR_TRUNCATE_ACL_MSG "%s truncate of %.950s by "
+#define GR_ATIME_ACL_MSG "%s access time change of %.950s by "
+#define GR_ACCESS_ACL_MSG "%s access of %.950s for%s%s%s by "
+#define GR_CHROOT_CHROOT_MSG "denied double chroot to %.950s by "
+#define GR_CHROOT_RENAME_MSG "denied bad rename of %.950s out of a chroot by "
+#define GR_CHMOD_CHROOT_MSG "denied chmod +s of %.950s by "
+#define GR_CHMOD_ACL_MSG "%s chmod of %.950s by "
+#define GR_CHROOT_FCHDIR_MSG "denied fchdir outside of chroot to %.950s by "
+#define GR_CHROOT_PATHAT_MSG "denied relative path access outside of chroot to %.950s by "
+#define GR_CHROOT_FHANDLE_MSG "denied use of file handles inside chroot by "
+#define GR_CHOWN_ACL_MSG "%s chown of %.950s by "
+#define GR_SETXATTR_ACL_MSG "%s setting extended attribute of %.950s by "
+#define GR_REMOVEXATTR_ACL_MSG "%s removing extended attribute of %.950s by "
+#define GR_WRITLIB_ACL_MSG "denied load of writable library %.950s by "
+#define GR_INITF_ACL_MSG "init_variables() failed %s by "
+#define GR_DISABLED_ACL_MSG "Error loading %s, trying to run kernel with acls disabled. To disable acls at startup use <kernel image name> gracl=off from your boot loader"
+#define GR_DEV_ACL_MSG "/dev/grsec: %d bytes sent %d required, being fed garbage by "
+#define GR_SHUTS_ACL_MSG "shutdown auth success for "
+#define GR_SHUTF_ACL_MSG "shutdown auth failure for "
+#define GR_SHUTI_ACL_MSG "ignoring shutdown for disabled RBAC system for "
+#define GR_SEGVMODS_ACL_MSG "segvmod auth success for "
+#define GR_SEGVMODF_ACL_MSG "segvmod auth failure for "
+#define GR_SEGVMODI_ACL_MSG "ignoring segvmod for disabled RBAC system for "
+#define GR_ENABLE_ACL_MSG "%s RBAC system loaded by "
+#define GR_ENABLEF_ACL_MSG "unable to load %s for "
+#define GR_RELOADI_ACL_MSG "ignoring reload request for disabled RBAC system"
+#define GR_RELOAD_ACL_MSG "%s RBAC system reloaded by "
+#define GR_RELOADF_ACL_MSG "failed reload of %s for "
+#define GR_SPROLEI_ACL_MSG "ignoring change to special role for disabled RBAC system for "
+#define GR_SPROLES_ACL_MSG "successful change to special role %s (id %d) by "
+#define GR_SPROLEL_ACL_MSG "special role %s (id %d) exited by "
+#define GR_SPROLEF_ACL_MSG "special role %s failure for "
+#define GR_UNSPROLEI_ACL_MSG "ignoring unauth of special role for disabled RBAC system for "
+#define GR_UNSPROLES_ACL_MSG "successful unauth of special role %s (id %d) by "
+#define GR_INVMODE_ACL_MSG "invalid mode %d by "
+#define GR_PRIORITY_CHROOT_MSG "denied priority change of process (%.16s:%d) by "
+#define GR_FAILFORK_MSG "failed fork with errno %s by "
+#define GR_NICE_CHROOT_MSG "denied priority change by "
+#define GR_UNISIGLOG_MSG "%.32s occurred at %p in "
+#define GR_DUALSIGLOG_MSG "signal %d sent to " DEFAULTSECMSG " by "
+#define GR_SIG_ACL_MSG "denied send of signal %d to protected task " DEFAULTSECMSG " by "
+#define GR_SYSCTL_MSG "denied modification of grsecurity sysctl value : %.32s by "
+#define GR_SYSCTL_ACL_MSG "%s sysctl of %.950s for%s%s by "
+#define GR_TIME_MSG "time set by "
+#define GR_DEFACL_MSG "fatal: unable to find subject for (%.16s:%d), loaded by "
+#define GR_MMAP_ACL_MSG "%s executable mmap of %.950s by "
+#define GR_MPROTECT_ACL_MSG "%s executable mprotect of %.950s by "
+#define GR_SOCK_MSG "denied socket(%.16s,%.16s,%.16s) by "
+#define GR_SOCK_NOINET_MSG "denied socket(%.16s,%.16s,%d) by "
+#define GR_BIND_MSG "denied bind() by "
+#define GR_CONNECT_MSG "denied connect() by "
+#define GR_BIND_ACL_MSG "denied bind() to %pI4 port %u sock type %.16s protocol %.16s by "
+#define GR_CONNECT_ACL_MSG "denied connect() to %pI4 port %u sock type %.16s protocol %.16s by "
+#define GR_IP_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%pI4\t%u\t%u\t%u\t%u\t%pI4"
+#define GR_EXEC_CHROOT_MSG "exec of %.980s within chroot by process "
+#define GR_CAP_ACL_MSG "use of %s denied for "
+#define GR_CAP_CHROOT_MSG "use of %s in chroot denied for "
+#define GR_CAP_ACL_MSG2 "use of %s permitted for "
+#define GR_USRCHANGE_ACL_MSG "change to uid %u denied for "
+#define GR_GRPCHANGE_ACL_MSG "change to gid %u denied for "
+#define GR_REMOUNT_AUDIT_MSG "remount of %.256s by "
+#define GR_UNMOUNT_AUDIT_MSG "unmount of %.256s by "
+#define GR_MOUNT_AUDIT_MSG "mount of %.256s to %.256s by "
+#define GR_CHDIR_AUDIT_MSG "chdir to %.980s by "
+#define GR_EXEC_AUDIT_MSG "exec of %.930s (%.128s) by "
+#define GR_RESOURCE_MSG "denied resource overstep by requesting %lu for %.16s against limit %lu for "
+#define GR_RWXMMAP_MSG "denied RWX mmap of %.950s by "
+#define GR_RWXMPROTECT_MSG "denied RWX mprotect of %.950s by "
+#define GR_TEXTREL_AUDIT_MSG "allowed %s text relocation transition in %.950s, VMA:0x%08lx 0x%08lx by "
+#define GR_PTGNUSTACK_MSG "denied marking stack executable as requested by PT_GNU_STACK marking in %.950s by "
+#define GR_VM86_MSG "denied use of vm86 by "
+#define GR_PTRACE_AUDIT_MSG "process %.950s(%.16s:%d) attached to via ptrace by "
+#define GR_PTRACE_READEXEC_MSG "denied ptrace of unreadable binary %.950s by "
+#define GR_INIT_TRANSFER_MSG "persistent special role transferred privilege to init by "
+#define GR_BADPROCPID_MSG "denied read of sensitive /proc/pid/%s entry via fd passed across exec by "
+#define GR_SYMLINKOWNER_MSG "denied following symlink %.950s since symlink owner %u does not match target owner %u, by "
+#define GR_BRUTE_DAEMON_MSG "bruteforce prevention initiated for the next 30 minutes or until service restarted, stalling each fork 30 seconds.  Please investigate the crash report for "
+#define GR_BRUTE_SUID_MSG "bruteforce prevention initiated due to crash of %.950s against uid %u, banning suid/sgid execs for %u minutes.  Please investigate the crash report for "
+#define GR_IPC_DENIED_MSG "denied %s of overly-permissive IPC object with creator uid %u by "
+#define GR_TIOCSTI_MSG "denied unprivileged use of TIOCSTI by "
+#define GR_MSRWRITE_MSG "denied write to CPU MSR by "
diff --git a/include/linux/grsecurity.h b/include/linux/grsecurity.h
new file mode 100644
index 000000000000..749b915012c6
--- /dev/null
+++ b/include/linux/grsecurity.h
@@ -0,0 +1,259 @@
+#ifndef GR_SECURITY_H
+#define GR_SECURITY_H
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/binfmts.h>
+#include <linux/tty.h>
+#include <linux/gracl.h>
+
+/* notify of brain-dead configs */
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_GRKERNSEC_KMEM)
+#error "CONFIG_DEBUG_FS being enabled is a security risk when CONFIG_GRKERNSEC_KMEM is enabled"
+#endif
+#if defined(CONFIG_PROC_PAGE_MONITOR) && defined(CONFIG_GRKERNSEC)
+#error "CONFIG_PROC_PAGE_MONITOR is a security risk"
+#endif
+#if defined(CONFIG_GRKERNSEC_PROC_USER) && defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+#error "CONFIG_GRKERNSEC_PROC_USER and CONFIG_GRKERNSEC_PROC_USERGROUP cannot both be enabled."
+#endif
+#if defined(CONFIG_GRKERNSEC_PROC) && !defined(CONFIG_GRKERNSEC_PROC_USER) && !defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+#error "CONFIG_GRKERNSEC_PROC enabled, but neither CONFIG_GRKERNSEC_PROC_USER nor CONFIG_GRKERNSEC_PROC_USERGROUP enabled"
+#endif
+#if defined(CONFIG_PAX_NOEXEC) && !defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_PAX_SEGMEXEC) && !defined(CONFIG_PAX_KERNEXEC)
+#error "CONFIG_PAX_NOEXEC enabled, but PAGEEXEC, SEGMEXEC, and KERNEXEC are disabled."
+#endif
+#if defined(CONFIG_PAX_ASLR) && !defined(CONFIG_PAX_RANDKSTACK) && !defined(CONFIG_PAX_RANDUSTACK) && !defined(CONFIG_PAX_RANDMMAP)
+#error "CONFIG_PAX_ASLR enabled, but RANDKSTACK, RANDUSTACK, and RANDMMAP are disabled."
+#endif
+#if defined(CONFIG_PAX) && !defined(CONFIG_PAX_NOEXEC) && !defined(CONFIG_PAX_ASLR)
+#error "CONFIG_PAX enabled, but no PaX options are enabled."
+#endif
+
+int gr_handle_new_usb(void);
+
+void gr_handle_brute_attach(int dumpable);
+void gr_handle_brute_check(void);
+void gr_handle_kernel_exploit(void);
+
+char gr_roletype_to_char(void);
+
+int gr_proc_is_restricted(void);
+
+int gr_acl_enable_at_secure(void);
+
+int gr_check_user_change(kuid_t real, kuid_t effective, kuid_t fs);
+int gr_check_group_change(kgid_t real, kgid_t effective, kgid_t fs);
+
+int gr_learn_cap(const struct task_struct *task, const struct cred *cred, const int cap, bool log);
+
+void gr_del_task_from_ip_table(struct task_struct *p);
+
+int gr_pid_is_chrooted(struct task_struct *p);
+int gr_handle_chroot_fowner(struct pid *pid, enum pid_type type);
+int gr_handle_chroot_nice(void);
+int gr_handle_chroot_sysctl(const int op);
+int gr_handle_chroot_setpriority(struct task_struct *p,
+					const int niceval);
+int gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt);
+int gr_chroot_pathat(int dfd, struct dentry *u_dentry, struct vfsmount *u_mnt, unsigned flags);
+int gr_chroot_fhandle(void);
+int gr_handle_chroot_chroot(const struct dentry *dentry,
+				   const struct vfsmount *mnt);
+void gr_handle_chroot_chdir(const struct path *path);
+int gr_handle_chroot_chmod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+int gr_handle_chroot_mknod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+int gr_handle_chroot_mount(const struct dentry *dentry,
+				  const struct vfsmount *mnt,
+				  const char *dev_name);
+int gr_handle_chroot_pivot(void);
+int gr_handle_chroot_unix(const pid_t pid);
+
+int gr_handle_rawio(const struct inode *inode);
+
+void gr_handle_ioperm(void);
+void gr_handle_iopl(void);
+void gr_handle_msr_write(void);
+
+umode_t gr_acl_umask(void);
+
+int gr_tpe_allow(const struct file *file);
+
+void gr_set_chroot_entries(struct task_struct *task, const struct path *path);
+void gr_clear_chroot_entries(struct task_struct *task);
+
+void gr_log_forkfail(const int retval);
+void gr_log_timechange(void);
+void gr_log_signal(const int sig, const void *addr, const struct task_struct *t);
+void gr_log_chdir(const struct dentry *dentry,
+			 const struct vfsmount *mnt);
+void gr_log_chroot_exec(const struct dentry *dentry,
+			       const struct vfsmount *mnt);
+void gr_log_remount(const char *devname, const int retval);
+void gr_log_unmount(const char *devname, const int retval);
+void gr_log_mount(const char *from, struct path *to, const int retval);
+void gr_log_textrel(struct vm_area_struct *vma, bool is_textrel_rw);
+void gr_log_ptgnustack(struct file *file);
+void gr_log_rwxmmap(struct file *file);
+void gr_log_rwxmprotect(struct vm_area_struct *vma);
+
+int gr_handle_follow_link(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+int gr_handle_fifo(const struct dentry *dentry,
+			  const struct vfsmount *mnt,
+			  const struct dentry *dir, const int flag,
+			  const int acc_mode);
+int gr_handle_hardlink(const struct dentry *dentry,
+			      const struct vfsmount *mnt,
+			      const struct filename *to);
+
+int gr_is_capable(const int cap);
+int gr_is_capable_nolog(const int cap);
+int gr_task_is_capable(const struct task_struct *task, const struct cred *cred, const int cap);
+int gr_task_is_capable_nolog(const struct task_struct *task, const struct cred *cred, const int cap);
+
+void gr_copy_label(struct task_struct *tsk);
+void gr_handle_crash(struct task_struct *task, const int sig);
+int gr_handle_signal(const struct task_struct *p, const int sig);
+int gr_check_crash_uid(const kuid_t uid);
+int gr_check_protected_task(const struct task_struct *task);
+int gr_check_protected_task_fowner(struct pid *pid, enum pid_type type);
+int gr_acl_handle_mmap(const struct file *file,
+			      const unsigned long prot);
+int gr_acl_handle_mprotect(const struct file *file,
+				  const unsigned long prot);
+int gr_check_hidden_task(const struct task_struct *tsk);
+__u32 gr_acl_handle_truncate(const struct dentry *dentry,
+				    const struct vfsmount *mnt);
+__u32 gr_acl_handle_utime(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+__u32 gr_acl_handle_access(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int fmode);
+__u32 gr_acl_handle_chmod(const struct dentry *dentry,
+				 const struct vfsmount *mnt, umode_t *mode);
+__u32 gr_acl_handle_chown(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+__u32 gr_acl_handle_setxattr(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+__u32 gr_acl_handle_removexattr(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+int gr_handle_ptrace(struct task_struct *task, const long request);
+int gr_handle_proc_ptrace(struct task_struct *task);
+__u32 gr_acl_handle_execve(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+int gr_check_crash_exec(const struct file *filp);
+int gr_acl_is_enabled(void);
+void gr_set_role_label(struct task_struct *task, const kuid_t uid,
+			      const kgid_t gid);
+int gr_set_proc_label(const struct dentry *dentry,
+			const struct vfsmount *mnt,
+			const int unsafe_flags);
+__u32 gr_acl_handle_hidden_file(const struct dentry *dentry,
+				const struct vfsmount *mnt);
+__u32 gr_acl_handle_open(const struct dentry *dentry,
+				const struct vfsmount *mnt, int acc_mode);
+__u32 gr_acl_handle_creat(const struct dentry *dentry,
+				 const struct dentry *p_dentry,
+				 const struct vfsmount *p_mnt,
+				 int open_flags, int acc_mode, const int imode);
+void gr_handle_create(const struct dentry *dentry,
+			     const struct vfsmount *mnt);
+void gr_handle_proc_create(const struct dentry *dentry,
+			   const struct inode *inode);
+__u32 gr_acl_handle_mknod(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt,
+				 const int mode);
+__u32 gr_acl_handle_mkdir(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt);
+__u32 gr_acl_handle_rmdir(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+void gr_handle_delete(const u64 ino, const dev_t dev);
+__u32 gr_acl_handle_unlink(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+__u32 gr_acl_handle_symlink(const struct dentry *new_dentry,
+				   const struct dentry *parent_dentry,
+				   const struct vfsmount *parent_mnt,
+				   const struct filename *from);
+__u32 gr_acl_handle_link(const struct dentry *new_dentry,
+				const struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				const struct dentry *old_dentry,
+				const struct vfsmount *old_mnt, const struct filename *to);
+int gr_handle_symlink_owner(const struct path *link, const struct inode *target);
+int gr_acl_handle_rename(struct dentry *new_dentry,
+				struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				struct dentry *old_dentry,
+				struct inode *old_parent_inode,
+				struct vfsmount *old_mnt, const struct filename *newname, unsigned int flags);
+void gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+				struct dentry *old_dentry,
+				struct dentry *new_dentry,
+				struct vfsmount *mnt, const __u8 replace, unsigned int flags);
+__u32 gr_check_link(const struct dentry *new_dentry,
+			   const struct dentry *parent_dentry,
+			   const struct vfsmount *parent_mnt,
+			   const struct dentry *old_dentry,
+			   const struct vfsmount *old_mnt);
+int gr_acl_handle_filldir(const struct file *file, const char *name,
+				 const unsigned int namelen, const u64 ino);
+
+__u32 gr_acl_handle_unix(const struct dentry *dentry,
+				const struct vfsmount *mnt);
+void gr_acl_handle_exit(void);
+void gr_acl_handle_psacct(struct task_struct *task, const long code);
+int gr_acl_handle_procpidmem(const struct task_struct *task);
+int gr_handle_rofs_mount(struct dentry *dentry, struct vfsmount *mnt, int mnt_flags);
+int gr_handle_rofs_blockwrite(struct dentry *dentry, struct vfsmount *mnt, int acc_mode);
+void gr_audit_ptrace(struct task_struct *task);
+dev_t gr_get_dev_from_dentry(struct dentry *dentry);
+u64 gr_get_ino_from_dentry(struct dentry *dentry);
+void gr_put_exec_file(struct task_struct *task);
+
+int gr_get_symlinkown_enabled(void);
+
+int gr_ptrace_readexec(struct file *file, int unsafe_flags);
+
+int gr_handle_tiocsti(struct tty_struct *tty);
+
+void gr_inc_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt);
+void gr_dec_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt);
+int gr_bad_chroot_rename(struct dentry *olddentry, struct vfsmount *oldmnt,
+			 struct dentry *newdentry, struct vfsmount *newmnt);
+
+#ifdef CONFIG_GRKERNSEC_RESLOG
+extern void gr_log_resource(const struct task_struct *task, const int res,
+				   const unsigned long wanted, const int gt);
+#else
+static inline void gr_log_resource(const struct task_struct *task, const int res,
+				   const unsigned long wanted, const int gt)
+{
+}
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+void task_grsec_rbac(struct seq_file *m, struct task_struct *p);
+void gr_handle_vm86(void);
+void gr_handle_mem_readwrite(u64 from, u64 to);
+
+void gr_log_badprocpid(const char *entry);
+
+extern int grsec_enable_dmesg;
+extern int grsec_disable_privio;
+
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+extern kgid_t grsec_proc_gid;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+extern int grsec_enable_chroot_findtask;
+#endif
+#ifdef CONFIG_GRKERNSEC_SETXID
+extern int grsec_enable_setxid;
+#endif
+#endif
+
+#endif
diff --git a/include/linux/grsock.h b/include/linux/grsock.h
new file mode 100644
index 000000000000..e7ffaafc548e
--- /dev/null
+++ b/include/linux/grsock.h
@@ -0,0 +1,19 @@
+#ifndef __GRSOCK_H
+#define __GRSOCK_H
+
+extern void gr_attach_curr_ip(const struct sock *sk);
+extern int gr_handle_sock_all(const int family, const int type,
+			      const int protocol);
+extern int gr_handle_sock_server(const struct sockaddr *sck);
+extern int gr_handle_sock_server_other(const struct sock *sck);
+extern int gr_handle_sock_client(const struct sockaddr *sck);
+extern int gr_search_connect(struct socket * sock,
+			     struct sockaddr_in * addr);
+extern int gr_search_bind(struct socket * sock,
+			  struct sockaddr_in * addr);
+extern int gr_search_listen(struct socket * sock);
+extern int gr_search_accept(struct socket * sock);
+extern int gr_search_socket(const int domain, const int type,
+			    const int protocol);
+
+#endif
diff --git a/include/linux/ipc.h b/include/linux/ipc.h
index 882a9c3d45fd..12d5bdf5bd89 100644
--- a/include/linux/ipc.h
+++ b/include/linux/ipc.h
@@ -21,6 +21,6 @@ struct kern_ipc_perm
 	umode_t		mode; 
 	unsigned long	seq __intentional_overflow(-1);
 	void		*security;
-};
+} __randomize_layout;
 
 #endif /* _LINUX_IPC_H */
diff --git a/include/linux/ipc_namespace.h b/include/linux/ipc_namespace.h
index 848e5796400e..65327ee0936b 100644
--- a/include/linux/ipc_namespace.h
+++ b/include/linux/ipc_namespace.h
@@ -61,7 +61,7 @@ struct ipc_namespace {
 	struct ucounts *ucounts;
 
 	struct ns_common ns;
-};
+} __randomize_layout;
 
 extern struct ipc_namespace init_ipc_ns;
 extern spinlock_t mq_lock;
diff --git a/include/linux/kallsyms.h b/include/linux/kallsyms.h
index 47a057cd4425..d2c774623a11 100644
--- a/include/linux/kallsyms.h
+++ b/include/linux/kallsyms.h
@@ -15,7 +15,8 @@
 
 struct module;
 
-#ifdef CONFIG_KALLSYMS
+#if !defined(__INCLUDED_BY_HIDESYM) || !defined(CONFIG_KALLSYMS)
+#if defined(CONFIG_KALLSYMS) && !defined(CONFIG_GRKERNSEC_HIDESYM)
 /* Lookup the address for a symbol. Returns 0 if not found. */
 unsigned long kallsyms_lookup_name(const char *name);
 
@@ -106,6 +107,21 @@ static inline int lookup_symbol_attrs(unsigned long addr, unsigned long *size, u
 /* Stupid that this does nothing, but I didn't create this mess. */
 #define __print_symbol(fmt, addr, args...)
 #endif /*CONFIG_KALLSYMS*/
+#else /* when included by kallsyms.c, vsnprintf.c, kprobes.c, or
+	arch/x86/kernel/dumpstack.c, with HIDESYM enabled */
+extern unsigned long kallsyms_lookup_name(const char *name);
+extern __printf(1, 3) void __print_symbol(const char *fmt, unsigned long address, ...);
+extern int sprint_backtrace(char *buffer, unsigned long address);
+extern int sprint_symbol(char *buffer, unsigned long address);
+extern int sprint_symbol_no_offset(char *buffer, unsigned long address);
+const char *kallsyms_lookup(unsigned long addr,
+			    unsigned long *symbolsize,
+			    unsigned long *offset,
+			    char **modname, char *namebuf);
+extern int kallsyms_lookup_size_offset(unsigned long addr,
+				  unsigned long *symbolsize,
+				  unsigned long *offset);
+#endif
 
 #define print_symbol(fmt, addr) \
 	__print_symbol(fmt, addr, "")
diff --git a/include/linux/key-type.h b/include/linux/key-type.h
index 0c5f427c51e8..d1d24c37f4b5 100644
--- a/include/linux/key-type.h
+++ b/include/linux/key-type.h
@@ -45,7 +45,7 @@ struct key_preparsed_payload {
 	size_t		datalen;	/* Raw datalen */
 	size_t		quotalen;	/* Quota length for proposed payload */
 	time_t		expiry;		/* Expiry time of key */
-};
+} __randomize_layout;
 
 typedef int (*request_key_actor_t)(struct key_construction *key,
 				   const char *op, void *aux);
@@ -150,7 +150,7 @@ struct key_type {
 	/* internal fields */
 	struct list_head	link;		/* link in types list */
 	struct lock_class_key	lock_class;	/* key->sem lock class */
-} __do_const;
+} __do_const __randomize_layout;
 
 extern struct key_type key_type_keyring;
 
diff --git a/include/linux/kmod.h b/include/linux/kmod.h
index fcfd2bf14d3f..e4f5edba0940 100644
--- a/include/linux/kmod.h
+++ b/include/linux/kmod.h
@@ -34,6 +34,8 @@ extern char modprobe_path[]; /* for sysctl */
  * usually useless though. */
 extern __printf(2, 3)
 int __request_module(bool wait, const char *name, ...);
+extern __printf(3, 4)
+int ___request_module(bool wait, char *param_name, const char *name, ...);
 #define request_module(mod...) __request_module(true, mod)
 #define request_module_nowait(mod...) __request_module(false, mod)
 #define try_then_request_module(x, mod...) \
@@ -57,6 +59,9 @@ struct subprocess_info {
 	struct work_struct work;
 	struct completion *complete;
 	char *path;
+#ifdef CONFIG_GRKERNSEC
+	char *origpath;
+#endif
 	char **argv;
 	char **envp;
 	int wait;
@@ -64,7 +69,7 @@ struct subprocess_info {
 	int (*init)(struct subprocess_info *info, struct cred *new);
 	void (*cleanup)(struct subprocess_info *info);
 	void *data;
-};
+} __randomize_layout;
 
 extern int
 call_usermodehelper(char *path, char **argv, char **envp, int wait);
diff --git a/include/linux/kobject.h b/include/linux/kobject.h
index fef2d4270471..9d45d56c548b 100644
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -178,7 +178,7 @@ struct kset {
 	spinlock_t list_lock;
 	struct kobject kobj;
 	const struct kset_uevent_ops *uevent_ops;
-};
+} __randomize_layout;
 
 extern void kset_init(struct kset *kset);
 extern int __must_check kset_register(struct kset *kset);
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index 558adfa5c8a8..91278953023c 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1866,7 +1866,7 @@ struct security_hook_heads {
 	struct list_head audit_rule_match;
 	struct list_head audit_rule_free;
 #endif /* CONFIG_AUDIT */
-};
+} __randomize_layout;
 
 /*
  * Security module hook list structure.
@@ -1876,7 +1876,7 @@ struct security_hook_list {
 	struct list_head		list;
 	struct list_head		*head;
 	union security_list_options	hook;
-};
+} __randomize_layout;
 
 /*
  * Initializing a security_hook_list structure takes
diff --git a/include/linux/mm.h b/include/linux/mm.h
index eb958ef2730d..8f2773e6ba59 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1994,12 +1994,23 @@ extern struct vm_area_struct *copy_vma(struct vm_area_struct **,
 	bool *need_rmap_locks);
 extern void exit_mmap(struct mm_struct *);
 
+#if defined(CONFIG_GRKERNSEC) && (defined(CONFIG_GRKERNSEC_RESLOG) || !defined(CONFIG_GRKERNSEC_NO_RBAC))
+extern void gr_learn_resource(const struct task_struct *task, const int res,
+			      const unsigned long wanted, const int gt);
+#else
+static inline void gr_learn_resource(const struct task_struct *task, const int res,
+				     const unsigned long wanted, const int gt)
+{
+}
+#endif
+
 static inline int check_data_rlimit(unsigned long rlim,
 				    unsigned long new,
 				    unsigned long start,
 				    unsigned long end_data,
 				    unsigned long start_data)
 {
+	gr_learn_resource(current, RLIMIT_DATA, (new - start) + (end_data - start_data), 1);
 	if (rlim < RLIM_INFINITY) {
 		if (((new - start) + (end_data - start_data)) > rlim)
 			return -ENOSPC;
@@ -2074,6 +2085,7 @@ struct vm_unmapped_area_info {
 	unsigned long high_limit;
 	unsigned long align_mask;
 	unsigned long align_offset;
+	unsigned long threadstack_offset;
 };
 
 extern unsigned long unmapped_area(const struct vm_unmapped_area_info *info);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 8c3054748806..ceb5da6c2a50 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -360,7 +360,7 @@ struct vm_area_struct {
 	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
 
 	struct vm_area_struct *vm_mirror;/* PaX: mirror vma or NULL */
-};
+} __randomize_layout;
 
 struct core_thread {
 	struct task_struct *task;
@@ -537,7 +537,7 @@ struct mm_struct {
 	unsigned long delta_stack;		/* randomized offset */
 #endif
 
-};
+} __randomize_layout;
 
 static inline void mm_init_cpumask(struct mm_struct *mm)
 {
diff --git a/include/linux/module.h b/include/linux/module.h
index 6487f2ca5ae1..18808a587ecd 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -48,7 +48,7 @@ struct module_kobject {
 	struct kobject *drivers_dir;
 	struct module_param_attrs *mp;
 	struct completion *kobj_completion;
-};
+} __randomize_layout;
 
 struct module_attribute {
 	struct attribute attr;
@@ -484,7 +484,8 @@ struct module {
 	ctor_fn_t *ctors;
 	unsigned int num_ctors;
 #endif
-} ____cacheline_aligned;
+} ____cacheline_aligned __randomize_layout;
+
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
 #endif
diff --git a/include/linux/mount.h b/include/linux/mount.h
index e0f3a82eee6d..377fcf14bd5a 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -67,7 +67,7 @@ struct vfsmount {
 	struct dentry *mnt_root;	/* root of the mounted tree */
 	struct super_block *mnt_sb;	/* pointer to superblock */
 	int mnt_flags;
-};
+} __randomize_layout;
 
 struct file; /* forward dec */
 struct path;
diff --git a/include/linux/msg.h b/include/linux/msg.h
index f3f302f9c197..a001305f5a79 100644
--- a/include/linux/msg.h
+++ b/include/linux/msg.h
@@ -29,7 +29,7 @@ struct msg_queue {
 	struct list_head q_messages;
 	struct list_head q_receivers;
 	struct list_head q_senders;
-};
+} __randomize_layout;
 
 /* Helper routines for sys_msgsnd and sys_msgrcv */
 extern long do_msgsnd(int msqid, long mtype, void __user *mtext,
diff --git a/include/linux/netfilter/xt_gradm.h b/include/linux/netfilter/xt_gradm.h
new file mode 100644
index 000000000000..33f4af893576
--- /dev/null
+++ b/include/linux/netfilter/xt_gradm.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_NETFILTER_XT_GRADM_H
+#define _LINUX_NETFILTER_XT_GRADM_H 1
+
+struct xt_gradm_mtinfo {
+	__u16 flags;
+	__u16 invflags;
+};
+
+#endif
diff --git a/include/linux/path.h b/include/linux/path.h
index d1372186f431..be0c176b20f7 100644
--- a/include/linux/path.h
+++ b/include/linux/path.h
@@ -1,13 +1,15 @@
 #ifndef _LINUX_PATH_H
 #define _LINUX_PATH_H
 
+#include <linux/compiler.h>
+
 struct dentry;
 struct vfsmount;
 
 struct path {
 	struct vfsmount *mnt;
 	struct dentry *dentry;
-};
+} __randomize_layout;
 
 extern void path_get(const struct path *);
 extern void path_put(const struct path *);
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 6dfb6c6ecc5f..fd324404c2b8 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -1151,7 +1151,7 @@ static inline int perf_callchain_store(struct perf_callchain_entry_ctx *ctx, u64
 	}
 }
 
-extern int sysctl_perf_event_paranoid;
+extern int sysctl_perf_event_legitimately_concerned;
 extern int sysctl_perf_event_mlock;
 extern int sysctl_perf_event_sample_rate;
 extern int sysctl_perf_cpu_time_max_percent;
@@ -1168,19 +1168,24 @@ extern int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,
 int perf_event_max_stack_handler(struct ctl_table *table, int write,
 				 void __user *buffer, size_t *lenp, loff_t *ppos);
 
+static inline bool perf_paranoid_any(void)
+{
+	return sysctl_perf_event_legitimately_concerned > 2;
+}
+
 static inline bool perf_paranoid_tracepoint_raw(void)
 {
-	return sysctl_perf_event_paranoid > -1;
+	return sysctl_perf_event_legitimately_concerned > -1;
 }
 
 static inline bool perf_paranoid_cpu(void)
 {
-	return sysctl_perf_event_paranoid > 0;
+	return sysctl_perf_event_legitimately_concerned > 0;
 }
 
 static inline bool perf_paranoid_kernel(void)
 {
-	return sysctl_perf_event_paranoid > 1;
+	return sysctl_perf_event_legitimately_concerned > 1;
 }
 
 extern void perf_event_init(void);
diff --git a/include/linux/pid_namespace.h b/include/linux/pid_namespace.h
index 34cce96741bc..c925afb66793 100644
--- a/include/linux/pid_namespace.h
+++ b/include/linux/pid_namespace.h
@@ -46,7 +46,7 @@ struct pid_namespace {
 	int hide_pid;
 	int reboot;	/* group exit code if this pidns was rebooted */
 	struct ns_common ns;
-};
+} __randomize_layout;
 
 extern struct pid_namespace init_pid_ns;
 
diff --git a/include/linux/printk.h b/include/linux/printk.h
index f83bc92473f4..a29982a62f06 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -145,6 +145,8 @@ static inline void printk_nmi_flush(void) { }
 static inline void printk_nmi_flush_on_panic(void) { }
 #endif /* PRINTK_NMI */
 
+extern int kptr_restrict;
+
 #ifdef CONFIG_PRINTK
 asmlinkage __printf(5, 0)
 int vprintk_emit(int facility, int level,
@@ -179,7 +181,6 @@ extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
 
 extern int printk_delay_msec;
 extern int dmesg_restrict;
-extern int kptr_restrict;
 
 extern int
 devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void __user *buf,
diff --git a/include/linux/proc_fs.h b/include/linux/proc_fs.h
index b97bf2ef996e..f14c92d4caf0 100644
--- a/include/linux/proc_fs.h
+++ b/include/linux/proc_fs.h
@@ -17,8 +17,11 @@ extern void proc_flush_task(struct task_struct *);
 extern struct proc_dir_entry *proc_symlink(const char *,
 		struct proc_dir_entry *, const char *);
 extern struct proc_dir_entry *proc_mkdir(const char *, struct proc_dir_entry *);
+extern struct proc_dir_entry *proc_mkdir_restrict(const char *, struct proc_dir_entry *);
 extern struct proc_dir_entry *proc_mkdir_data(const char *, umode_t,
 					      struct proc_dir_entry *, void *);
+extern struct proc_dir_entry *proc_mkdir_data_restrict(const char *, umode_t,
+					      struct proc_dir_entry *, void *);
 extern struct proc_dir_entry *proc_mkdir_mode(const char *, umode_t,
 					      struct proc_dir_entry *);
  
@@ -34,6 +37,19 @@ static inline struct proc_dir_entry *proc_create(
 	return proc_create_data(name, mode, parent, proc_fops, NULL);
 }
 
+static inline struct proc_dir_entry *proc_create_grsec(const char *name, umode_t mode,
+	struct proc_dir_entry *parent, const struct file_operations *proc_fops)
+{
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	return proc_create_data(name, S_IRUSR, parent, proc_fops, NULL);
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	return proc_create_data(name, S_IRUSR | S_IRGRP, parent, proc_fops, NULL);
+#else
+	return proc_create_data(name, mode, parent, proc_fops, NULL);
+#endif
+}
+
+
 extern void proc_set_size(struct proc_dir_entry *, loff_t);
 extern void proc_set_user(struct proc_dir_entry *, kuid_t, kgid_t);
 extern void *PDE_DATA(const struct inode *);
@@ -56,8 +72,12 @@ static inline struct proc_dir_entry *proc_symlink(const char *name,
 		struct proc_dir_entry *parent,const char *dest) { return NULL;}
 static inline struct proc_dir_entry *proc_mkdir(const char *name,
 	struct proc_dir_entry *parent) {return NULL;}
+static inline struct proc_dir_entry *proc_mkdir_restrict(const char *name,
+	struct proc_dir_entry *parent) { return NULL; }
 static inline struct proc_dir_entry *proc_mkdir_data(const char *name,
 	umode_t mode, struct proc_dir_entry *parent, void *data) { return NULL; }
+static inline  struct proc_dir_entry *proc_mkdir_data_restrict(const char *name,
+	umode_t mode, struct proc_dir_entry *parent, void *data) { return NULL; }
 static inline struct proc_dir_entry *proc_mkdir_mode(const char *name,
 	umode_t mode, struct proc_dir_entry *parent) { return NULL; }
 #define proc_create(name, mode, parent, proc_fops) ({NULL;})
@@ -79,7 +99,7 @@ struct net;
 static inline struct proc_dir_entry *proc_net_mkdir(
 	struct net *net, const char *name, struct proc_dir_entry *parent)
 {
-	return proc_mkdir_data(name, 0, parent, net);
+	return proc_mkdir_data_restrict(name, 0, parent, net);
 }
 
 #endif /* _LINUX_PROC_FS_H */
diff --git a/include/linux/proc_ns.h b/include/linux/proc_ns.h
index 7ec9d951e165..00d516204572 100644
--- a/include/linux/proc_ns.h
+++ b/include/linux/proc_ns.h
@@ -20,7 +20,7 @@ struct proc_ns_operations {
 	int (*install)(struct nsproxy *nsproxy, struct ns_common *ns);
 	struct user_namespace *(*owner)(struct ns_common *ns);
 	struct ns_common *(*get_parent)(struct ns_common *ns);
-} __do_const;
+} __do_const __randomize_layout;
 
 extern const struct proc_ns_operations netns_operations;
 extern const struct proc_ns_operations utsns_operations;
diff --git a/include/linux/rbtree_augmented.h b/include/linux/rbtree_augmented.h
index d076183e49be..9702b6e183bc 100644
--- a/include/linux/rbtree_augmented.h
+++ b/include/linux/rbtree_augmented.h
@@ -90,7 +90,9 @@ rbname ## _rotate(struct rb_node *rb_old, struct rb_node *rb_new)	\
 	old->rbaugmented = rbcompute(old);				\
 }									\
 rbstatic const struct rb_augment_callbacks rbname = {			\
-	rbname ## _propagate, rbname ## _copy, rbname ## _rotate	\
+	.propagate = rbname ## _propagate,				\
+	.copy = rbname ## _copy,					\
+	.rotate = rbname ## _rotate					\
 };
 
 
diff --git a/include/linux/scatterlist.h b/include/linux/scatterlist.h
index cb3c8fe6acd7..a001ef9073ae 100644
--- a/include/linux/scatterlist.h
+++ b/include/linux/scatterlist.h
@@ -1,6 +1,7 @@
 #ifndef _LINUX_SCATTERLIST_H
 #define _LINUX_SCATTERLIST_H
 
+#include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/bug.h>
@@ -136,10 +137,12 @@ static inline struct page *sg_page(struct scatterlist *sg)
 static inline void sg_set_buf(struct scatterlist *sg, const void *buf,
 			      unsigned int buflen)
 {
+	const void *realbuf = gr_convert_stack_address_to_lowmem(buf);
+
 #ifdef CONFIG_DEBUG_SG
-	BUG_ON(!virt_addr_valid(buf));
+	BUG_ON(!virt_addr_valid(realbuf));
 #endif
-	sg_set_page(sg, virt_to_page(buf), buflen, offset_in_page(buf));
+	sg_set_page(sg, virt_to_page(realbuf), buflen, offset_in_page(realbuf));
 }
 
 /*
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 4375a7b09262..2b11430f1dfe 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -455,7 +455,18 @@ struct nsproxy;
 struct user_namespace;
 
 #ifdef CONFIG_MMU
-extern bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len);
+
+#ifdef CONFIG_GRKERNSEC_RAND_THREADSTACK
+extern unsigned long gr_rand_threadstack_offset(const struct mm_struct *mm, const struct file *filp, unsigned long flags);
+#else
+static inline unsigned long gr_rand_threadstack_offset(const struct mm_struct *mm, const struct file *filp, unsigned long flags)
+{
+	return 0;
+}
+#endif
+
+extern bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len, unsigned long offset);
+
 extern void arch_pick_mmap_layout(struct mm_struct *mm);
 extern unsigned long
 arch_get_unmapped_area(struct file *, unsigned long, unsigned long,
@@ -795,6 +806,17 @@ struct signal_struct {
 #ifdef CONFIG_TASKSTATS
 	struct taskstats *stats;
 #endif
+
+#ifdef CONFIG_GRKERNSEC
+	u32 curr_ip;
+	u32 saved_ip;
+	u32 gr_saddr;
+	u32 gr_daddr;
+	u16 gr_sport;
+	u16 gr_dport;
+	u8 used_accept:1;
+#endif
+
 #ifdef CONFIG_AUDIT
 	unsigned audit_tty;
 	struct tty_audit_buf *tty_audit_buf;
@@ -814,7 +836,7 @@ struct signal_struct {
 	struct mutex cred_guard_mutex;	/* guard against foreign influences on
 					 * credential calculations
 					 * (notably. ptrace) */
-};
+} __randomize_layout;
 
 /*
  * Bits in flags field of signal_struct.
@@ -869,6 +891,14 @@ struct user_struct {
 	struct key *session_keyring;	/* UID's default session keyring */
 #endif
 
+#ifdef CONFIG_GRKERNSEC_KERN_LOCKOUT
+	unsigned char kernel_banned;
+#endif
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	unsigned char sugid_banned;
+	unsigned long sugid_ban_expires;
+#endif
+
 	/* Hash table maintenance information */
 	struct hlist_node uidhash_node;
 	kuid_t uid;
@@ -876,7 +906,7 @@ struct user_struct {
 #if defined(CONFIG_PERF_EVENTS) || defined(CONFIG_BPF_SYSCALL)
 	atomic_long_t locked_vm;
 #endif
-};
+} __randomize_layout;
 
 extern int uids_sysfs_init(void);
 
@@ -1484,6 +1514,9 @@ struct task_struct {
 #endif
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	void *stack;
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	void *lowmem_stack;
+#endif
 	atomic_t usage;
 	unsigned int flags;	/* per process flags, defined below */
 	unsigned int ptrace;
@@ -1616,6 +1649,8 @@ struct task_struct {
 	struct list_head sibling;	/* linkage in my parent's children list */
 	struct task_struct *group_leader;	/* threadgroup leader */
 
+	const struct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */
+
 	/*
 	 * ptraced is the list of tasks this task is using ptrace on.
 	 * This includes both natural children and PTRACE_ATTACH targets.
@@ -1661,12 +1696,6 @@ struct task_struct {
 	struct task_cputime cputime_expires;
 	struct list_head cpu_timers[3];
 
-/* process credentials */
-	const struct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */
-	const struct cred __rcu *real_cred; /* objective and real subjective task
-					 * credentials (COW) */
-	const struct cred __rcu *cred;	/* effective (overridable) subjective task
-					 * credentials (COW) */
 	char comm[TASK_COMM_LEN]; /* executable name excluding path
 				     - access with [gs]et_task_comm (which lock
 				       it with task_lock())
@@ -1682,6 +1711,8 @@ struct task_struct {
 /* hung task detection */
 	unsigned long last_switch_count;
 #endif
+/* CPU-specific state of this task */
+	struct thread_struct thread;
 /* filesystem information */
 	struct fs_struct *fs;
 /* open file information */
@@ -1763,6 +1794,10 @@ struct task_struct {
 	unsigned int in_ubsan;
 #endif
 
+/* process credentials */
+	const struct cred __rcu *real_cred; /* objective and real subjective task
+					 * credentials (COW) */
+
 /* journalling filesystem info */
 	void *journal_info;
 
@@ -1801,6 +1836,10 @@ struct task_struct {
 	/* cg_list protected by css_set_lock and tsk->alloc_lock */
 	struct list_head cg_list;
 #endif
+
+	const struct cred __rcu *cred;	/* effective (overridable) subjective task
+					 * credentials (COW) */
+
 #ifdef CONFIG_FUTEX
 	struct robust_list_head __user *robust_list;
 #ifdef CONFIG_COMPAT
@@ -1964,16 +2003,37 @@ struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/* A live task holds one reference. */
 	atomic_t stack_refcount;
+
+/* thread_info moved to task_struct */
+#ifdef CONFIG_X86
+	struct thread_info tinfo;
 #endif
-/* CPU-specific state of this task */
-	struct thread_struct thread;
-/*
- * WARNING: on x86, 'thread_struct' contains a variable-sized
- * structure.  It *MUST* be at the end of 'task_struct'.
- *
- * Do not put anything below here!
- */
-};
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+	/* grsecurity */
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	u64 exec_id;
+#endif
+#ifdef CONFIG_GRKERNSEC_SETXID
+	const struct cred *delayed_cred;
+#endif
+	struct dentry *gr_chroot_dentry;
+	struct acl_subject_label *acl;
+	struct acl_subject_label *tmpacl;
+	struct acl_role_label *role;
+	struct file *exec_file;
+	unsigned long brute_expires;
+	u16 acl_role_id;
+	u8 inherited;
+	/* is this the task that authenticated to the special role */
+	u8 acl_sp_role;
+	u8 is_writable;
+	u8 brute;
+	u8 gr_is_chrooted;
+#endif
+
+} __randomize_layout;
 
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 #ifndef current_thread_info
@@ -2162,7 +2222,7 @@ struct pid_namespace;
 pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,
 			struct pid_namespace *ns);
 
-static inline pid_t task_pid_nr(struct task_struct *tsk)
+static inline pid_t task_pid_nr(const struct task_struct *tsk)
 {
 	return tsk->pid;
 }
@@ -2529,6 +2589,50 @@ extern u64 sched_clock_cpu(int cpu);
 
 extern void sched_clock_init(void);
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+static inline void populate_stack(void *stack, unsigned int size)
+{
+	int c;
+	int *ptr = stack;
+	int *end = stack + size;
+
+	while (ptr < end) {
+		c = *(volatile int *)ptr;
+		(void)c;
+		ptr += PAGE_SIZE/sizeof(int);
+	}
+}
+#else
+static inline void populate_stack(void *stack, unsigned int size)
+{
+}
+#endif
+
+const void *gr_convert_stack_address_to_lowmem(const void *buf);
+
+#ifdef CONFIG_GRKERNSEC
+static inline bool current_is_ptracer(struct task_struct *task, u64 *exec_id)
+{
+	bool ret = false;
+        if (!task->ptrace)
+		return ret;
+
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	if (task->parent && task->parent == current) {
+		ret = true;
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+		if (exec_id)
+			*exec_id = task->parent->exec_id;
+#endif
+	}
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	return ret;
+}
+#endif
+
 #ifndef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
 static inline void sched_clock_tick(void)
 {
@@ -2721,6 +2825,7 @@ extern struct pid_namespace init_pid_ns;
  */
 
 extern struct task_struct *find_task_by_vpid(pid_t nr);
+extern struct task_struct *find_task_by_vpid_unrestricted(pid_t nr);
 extern struct task_struct *find_task_by_pid_ns(pid_t nr,
 		struct pid_namespace *ns);
 
@@ -3274,6 +3379,17 @@ static inline int object_starts_on_stack(const void *obj)
 	return (obj >= stack) && (obj < (stack + THREAD_SIZE));
 }
 
+#if defined(CONFIG_GRKERNSEC_KSTACKOVERFLOW) && defined(CONFIG_X86_64)
+static inline int object_starts_on_irq_stack(const void *obj)
+{
+	const void *stack = this_cpu_read(irq_stack_ptr);
+
+	return (obj >= stack) && (obj < (stack + IRQ_STACK_SIZE));
+}
+#else
+static inline int object_starts_on_irq_stack(const void *obj) { return 0; }
+#endif
+
 extern void thread_stack_cache_init(void);
 
 #ifdef CONFIG_DEBUG_STACK_USAGE
diff --git a/include/linux/security.h b/include/linux/security.h
index c2125e9093e8..365bf43bc9fc 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -30,6 +30,7 @@
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/fs.h>
+#include <linux/grsecurity.h>
 
 struct linux_binprm;
 struct cred;
diff --git a/include/linux/sem.h b/include/linux/sem.h
index d0efd6e6c20a..c68948cac604 100644
--- a/include/linux/sem.h
+++ b/include/linux/sem.h
@@ -22,7 +22,7 @@ struct sem_array {
 	int			sem_nsems;	/* no. of semaphores in array */
 	int			complex_count;	/* pending complex operations */
 	bool			complex_mode;	/* no parallel simple ops */
-};
+} __randomize_layout;
 
 #ifdef CONFIG_SYSVIPC
 
diff --git a/include/linux/seq_file.h b/include/linux/seq_file.h
index bc96f42ed3d4..44b0ad9516c5 100644
--- a/include/linux/seq_file.h
+++ b/include/linux/seq_file.h
@@ -25,6 +25,9 @@ struct seq_file {
 	const struct seq_operations *op;
 	int poll_event;
 	const struct file *file;
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	u64 exec_id;
+#endif
 	void *private;
 };
 
@@ -107,6 +110,7 @@ void seq_pad(struct seq_file *m, char c);
 
 char *mangle_path(char *s, const char *p, const char *esc);
 int seq_open(struct file *, const struct seq_operations *);
+int seq_open_restrict(struct file *, const struct seq_operations *);
 ssize_t seq_read(struct file *, char __user *, size_t, loff_t *);
 loff_t seq_lseek(struct file *, loff_t, int);
 int seq_release(struct inode *, struct file *);
@@ -134,6 +138,7 @@ int seq_path_root(struct seq_file *m, const struct path *path,
 		  const struct path *root, const char *esc);
 
 int single_open(struct file *, int (*)(struct seq_file *, void *), void *);
+int single_open_restrict(struct file *, int (*)(struct seq_file *, void *), void *);
 int single_open_size(struct file *, int (*)(struct seq_file *, void *), void *, size_t);
 int single_release(struct inode *, struct file *);
 void *__seq_open_private(struct file *, const struct seq_operations *, int);
diff --git a/include/linux/shm.h b/include/linux/shm.h
index 04e881829625..af8580566e52 100644
--- a/include/linux/shm.h
+++ b/include/linux/shm.h
@@ -22,7 +22,11 @@ struct shmid_kernel /* private to the kernel */
 	/* The task created the shm object.  NULL if the task is dead. */
 	struct task_struct	*shm_creator;
 	struct list_head	shm_clist;	/* list by creator */
-};
+#ifdef CONFIG_GRKERNSEC
+	u64			shm_createtime;
+	pid_t			shm_lapid;
+#endif
+} __randomize_layout;
 
 /* shm_mode upper byte flags */
 #define	SHM_DEST	01000	/* segment will be destroyed on last detach */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 4f4cb679e4ce..66eb624a9929 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -3575,6 +3575,9 @@ static inline void nf_reset(struct sk_buff *skb)
 	nf_bridge_put(skb->nf_bridge);
 	skb->nf_bridge = NULL;
 #endif
+#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
+	skb->nf_trace = 0;
+#endif
 }
 
 static inline void nf_reset_trace(struct sk_buff *skb)
diff --git a/include/linux/slab.h b/include/linux/slab.h
index beb57a34c393..9da238a10c52 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -22,6 +22,13 @@
  * The ones marked DEBUG are only valid if CONFIG_DEBUG_SLAB is set.
  */
 #define SLAB_CONSISTENCY_CHECKS	0x00000100UL	/* DEBUG: Perform (expensive) checks on alloc/free */
+
+#ifdef CONFIG_PAX_USERCOPY
+#define SLAB_USERCOPY		0x00000200UL	/* PaX: Allow copying objs to/from userland */
+#else
+#define SLAB_USERCOPY		0x00000000UL
+#endif
+
 #define SLAB_RED_ZONE		0x00000400UL	/* DEBUG: Red zone objs in a cache */
 #define SLAB_POISON		0x00000800UL	/* DEBUG: Poison objects */
 
@@ -582,13 +589,6 @@ struct memcg_cache_params {
 
 int memcg_update_all_caches(int num_memcgs);
 
-extern void kmalloc_array_error(void)
-#if defined(CONFIG_GCOV_KERNEL) && defined(PAX_SIZE_OVERFLOW)
-__compiletime_warning("kmalloc_array called with swapped arguments?");
-#else
-__compiletime_error("kmalloc_array called with swapped arguments?");
-#endif
-
 /**
  * kmalloc_array - allocate memory for an array.
  * @n: number of elements.
@@ -597,8 +597,6 @@ __compiletime_error("kmalloc_array called with swapped arguments?");
  */
 static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
 {
-	if (__builtin_constant_p(n) && !__builtin_constant_p(size))
-		kmalloc_array_error();
 	if (size != 0 && n > SIZE_MAX / size)
 		return NULL;
 	if (__builtin_constant_p(n) && __builtin_constant_p(size))
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index bc9731667bdb..807838b419cc 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -41,12 +41,18 @@ typedef int proc_handler (struct ctl_table *ctl, int write,
 
 extern int proc_dostring(struct ctl_table *, int,
 			 void __user *, size_t *, loff_t *);
+extern int proc_dostring_modpriv(struct ctl_table *, int,
+			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec(struct ctl_table *, int,
 			 void __user *, size_t *, loff_t *);
+extern int proc_dointvec_secure(struct ctl_table *, int,
+                     		void __user *, size_t *, loff_t *);
 extern int proc_douintvec(struct ctl_table *, int,
 			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_minmax(struct ctl_table *, int,
 				void __user *, size_t *, loff_t *);
+extern int proc_dointvec_minmax_secure(struct ctl_table *, int,
+				       void __user *, size_t *, loff_t *);
 extern int proc_dointvec_jiffies(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_userhz_jiffies(struct ctl_table *, int,
@@ -117,7 +123,7 @@ struct ctl_table
 	struct ctl_table_poll *poll;
 	void *extra1;
 	void *extra2;
-} __do_const;
+} __do_const __randomize_layout;
 typedef struct ctl_table __no_const ctl_table_no_const;
 
 struct ctl_node {
diff --git a/include/linux/timer.h b/include/linux/timer.h
index 51d601f192d4..6769812d0a43 100644
--- a/include/linux/timer.h
+++ b/include/linux/timer.h
@@ -28,7 +28,7 @@ struct timer_list {
 #ifdef CONFIG_LOCKDEP
 	struct lockdep_map	lockdep_map;
 #endif
-};
+} __randomize_layout;
 
 #ifdef CONFIG_LOCKDEP
 /*
diff --git a/include/linux/tty.h b/include/linux/tty.h
index d520a07118a5..610732a17fff 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -326,7 +326,7 @@ struct tty_struct {
 	/* If the tty has a pending do_SAK, queue it here - akpm */
 	struct work_struct SAK_work;
 	struct tty_port *port;
-};
+} __randomize_layout;
 
 /* Each of a tty's open files has private_data pointing to tty_file_private */
 struct tty_file_private {
diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index f9d5a4035fae..76dc1fa826e4 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -291,7 +291,7 @@ struct tty_operations {
 	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
 #endif
 	const struct file_operations *proc_fops;
-} __do_const;
+} __do_const __randomize_layout;
 
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
@@ -325,7 +325,7 @@ struct tty_driver {
 
 	const struct tty_operations *ops;
 	struct list_head tty_drivers;
-};
+} __randomize_layout;
 
 extern struct list_head tty_drivers;
 
diff --git a/include/linux/uidgid.h b/include/linux/uidgid.h
index 25e9d9216340..1b34fffb9c7d 100644
--- a/include/linux/uidgid.h
+++ b/include/linux/uidgid.h
@@ -187,4 +187,10 @@ static inline bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
 
 #endif /* CONFIG_USER_NS */
 
+#define GR_GLOBAL_UID(x) from_kuid_munged(&init_user_ns, (x))
+#define GR_GLOBAL_GID(x) from_kgid_munged(&init_user_ns, (x))
+#define gr_is_global_root(x) uid_eq((x), GLOBAL_ROOT_UID)
+#define gr_is_global_nonroot(x) (!uid_eq((x), GLOBAL_ROOT_UID))
+#define gr_is_global_nonroot_gid(x) (!gid_eq((x), GLOBAL_ROOT_GID))
+
 #endif /* _LINUX_UIDGID_H */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 94c966fa11db..eac1b5280b4a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1700,7 +1700,7 @@ extern int usb_string(struct usb_device *dev, int index,
 	char *buf, size_t size);
 
 /* wrappers that also update important state inside usbcore */
-extern int usb_clear_halt(struct usb_device *dev, int pipe);
+extern int usb_clear_halt(struct usb_device *dev, unsigned int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
 extern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);
@@ -1845,7 +1845,7 @@ usb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)
 /*-------------------------------------------------------------------------*/
 
 static inline __u16
-usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
+usb_maxpacket(struct usb_device *udev, unsigned int pipe, int is_out)
 {
 	struct usb_host_endpoint	*ep;
 	unsigned			epnum = usb_pipeendpoint(pipe);
diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index dc797739f164..5d396eaaaed6 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -59,7 +59,7 @@ struct user_namespace {
 #endif
 	struct ucounts		*ucounts;
 	int ucount_max[UCOUNT_COUNTS];
-};
+} __randomize_layout;
 
 struct ucounts {
 	struct hlist_node node;
diff --git a/include/linux/utsname.h b/include/linux/utsname.h
index 60f0bb83b313..da826ed059cf 100644
--- a/include/linux/utsname.h
+++ b/include/linux/utsname.h
@@ -26,7 +26,7 @@ struct uts_namespace {
 	struct user_namespace *user_ns;
 	struct ucounts *ucounts;
 	struct ns_common ns;
-};
+} __randomize_layout;
 extern struct uts_namespace init_uts_ns;
 
 #ifdef CONFIG_UTS_NS
diff --git a/include/linux/vermagic.h b/include/linux/vermagic.h
index a0e9cbdcb3d6..4efc177ca510 100644
--- a/include/linux/vermagic.h
+++ b/include/linux/vermagic.h
@@ -43,10 +43,24 @@
 #define MODULE_STACKLEAK_PLUGIN ""
 #endif
 
+#ifdef RANDSTRUCT_PLUGIN
+#include <generated/randomize_layout_hash.h>
+#define MODULE_RANDSTRUCT_PLUGIN "RANDSTRUCT_PLUGIN_" RANDSTRUCT_HASHED_SEED
+#else
+#define MODULE_RANDSTRUCT_PLUGIN
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+#define MODULE_GRSEC "GRSEC "
+#else
+#define MODULE_GRSEC ""
+#endif
+
 #define VERMAGIC_STRING 						\
 	UTS_RELEASE " "							\
 	MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT 			\
 	MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS	\
 	MODULE_ARCH_VERMAGIC						\
-	MODULE_PAX_REFCOUNT MODULE_CONSTIFY_PLUGIN MODULE_STACKLEAK_PLUGIN
+	MODULE_PAX_REFCOUNT MODULE_CONSTIFY_PLUGIN MODULE_STACKLEAK_PLUGIN \
+	MODULE_GRSEC MODULE_RANDSTRUCT_PLUGIN
 
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index 6144dce18686..56059bf07f6d 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -24,6 +24,9 @@ struct notifier_block;		/* in notifier.h */
 #define VM_KERNEXEC		0x00000100	/* allocate from executable kernel memory range */
 #endif
 
+#define VM_USERCOPY		0x00000200	/* allocation intended for copies to userland */
+
+
 /* bits [20..32] reserved for arch specific ioremap internals */
 
 /*
@@ -73,6 +76,7 @@ static inline void vmalloc_init(void)
 #endif
 
 extern void *vmalloc(unsigned long size);
+extern void *vmalloc_usercopy(unsigned long size);
 extern void *vzalloc(unsigned long size);
 extern void *vmalloc_user(unsigned long size);
 extern void *vmalloc_node(unsigned long size, int node);
@@ -92,6 +96,10 @@ extern void *vmap(struct page **pages, unsigned int count,
 			unsigned long flags, pgprot_t prot);
 extern void vunmap(const void *addr);
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+extern void unmap_process_stacks(struct task_struct *task);
+#endif
+
 extern int remap_vmalloc_range_partial(struct vm_area_struct *vma,
 				       unsigned long uaddr, void *kaddr,
 				       unsigned long size);
diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index fd60eccb59a6..64e2a1e24a2c 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -36,7 +36,7 @@ struct unix_skb_parms {
 	u32			secid;		/* Security ID		*/
 #endif
 	u32			consumed;
-};
+} __randomize_layout;
 
 #define UNIXCB(skb) 	(*(struct unix_skb_parms *)&((skb)->cb))
 
diff --git a/include/net/ip.h b/include/net/ip.h
index d3a107850a41..73cb3cddba4b 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -354,7 +354,7 @@ static inline unsigned int ip_skb_dst_mtu(struct sock *sk,
 	return min(skb_dst(skb)->dev->mtu, IP_MAX_MTU);
 }
 
-u32 ip_idents_reserve(u32 hash, int segs);
+u32 ip_idents_reserve(u32 hash, int segs) __intentional_overflow(-1);
 void __ip_select_ident(struct net *net, struct iphdr *iph, int segs);
 
 static inline void ip_select_ident_segs(struct net *net, struct sk_buff *skb,
diff --git a/include/net/neighbour.h b/include/net/neighbour.h
index 93fe3fa4f9a9..48fe40e3840e 100644
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@ -217,7 +217,7 @@ struct neigh_table {
 	struct neigh_statistics	__percpu *stats;
 	struct neigh_hash_table __rcu *nht;
 	struct pneigh_entry	**phash_buckets;
-};
+} __randomize_layout;
 
 enum {
 	NEIGH_ARP_TABLE = 0,
diff --git a/include/net/net_namespace.h b/include/net/net_namespace.h
index d4d66db497f8..e69bc18c005a 100644
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -143,7 +143,7 @@ struct net {
 #endif
 	struct sock		*diag_nlsk;
 	atomic_unchecked_t	fnhe_genid;
-};
+} __randomize_layout;
 
 #include <linux/seq_file_net.h>
 
diff --git a/include/net/sock.h b/include/net/sock.h
index 1eb47e445a0b..db680f58df39 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1072,7 +1072,7 @@ struct proto {
 	atomic_t		socks;
 #endif
 	int			(*diag_destroy)(struct sock *sk, int err);
-};
+} __randomize_layout;
 
 int proto_register(struct proto *prot, int alloc_slab);
 void proto_unregister(struct proto *prot);
diff --git a/include/trace/events/fs.h b/include/trace/events/fs.h
new file mode 100644
index 000000000000..fb634b74adf3
--- /dev/null
+++ b/include/trace/events/fs.h
@@ -0,0 +1,53 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM fs
+
+#if !defined(_TRACE_FS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_FS_H
+
+#include <linux/fs.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(do_sys_open,
+
+	TP_PROTO(const char *filename, int flags, int mode),
+
+	TP_ARGS(filename, flags, mode),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+		__field(	int, flags			)
+		__field(	int, mode			)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+		__entry->flags = flags;
+		__entry->mode = mode;
+	),
+
+	TP_printk("\"%s\" %x %o",
+		  __get_str(filename), __entry->flags, __entry->mode)
+);
+
+TRACE_EVENT(open_exec,
+
+	TP_PROTO(const char *filename),
+
+	TP_ARGS(filename),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+	),
+
+	TP_printk("\"%s\"",
+		  __get_str(filename))
+);
+
+#endif /* _TRACE_FS_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/init/Kconfig b/init/Kconfig
index 68e49e1f16c0..0e6a185d8604 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -301,7 +301,8 @@ config FHANDLE
 
 config USELIB
 	bool "uselib syscall"
-	def_bool ALPHA || M68K || SPARC || X86_32 || IA32_EMULATION
+	default n
+	depends on !GRKERNSEC
 	help
 	  This option enables the uselib syscall, a system call used in the
 	  dynamic linker from libc5 and earlier.  glibc does not use this
@@ -645,6 +646,7 @@ config RCU_FAST_NO_HZ
 config TREE_RCU_TRACE
 	def_bool RCU_TRACE && ( TREE_RCU || PREEMPT_RCU )
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	help
 	  This option provides tracing for the TREE_RCU and
 	  PREEMPT_RCU implementations, permitting Makefile to
@@ -1171,6 +1173,7 @@ endif # CGROUPS
 config CHECKPOINT_RESTORE
 	bool "Checkpoint/restore support" if EXPERT
 	select PROC_CHILDREN
+	depends on !GRKERNSEC
 	default n
 	help
 	  Enables additional kernel features in a sake of checkpoint/restore.
@@ -1644,7 +1647,7 @@ config ADVISE_SYSCALLS
 config USERFAULTFD
 	bool "Enable userfaultfd() system call"
 	select ANON_INODES
-	depends on MMU
+	depends on MMU && !GRKERNSEC
 	help
 	  Enable the userfaultfd() system call that allows to intercept and
 	  handle page faults in userland.
diff --git a/init/main.c b/init/main.c
index 320d4ffdc429..5a222fc692e4 100644
--- a/init/main.c
+++ b/init/main.c
@@ -11,6 +11,10 @@
 
 #define DEBUG		/* Enable initcall_debug */
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+#define __INCLUDED_BY_HIDESYM 1
+#endif
+
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
@@ -94,6 +98,8 @@ extern void init_IRQ(void);
 extern void fork_init(void);
 extern void radix_tree_init(void);
 
+extern void grsecurity_init(void);
+
 /*
  * Debug helper: via this flag we know that we are in 'early bootup code'
  * where only the boot processor is running with IRQ disabled.  This means
@@ -155,6 +161,26 @@ static int __init set_reset_devices(char *str)
 
 __setup("reset_devices", set_reset_devices);
 
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+kgid_t grsec_proc_gid = KGIDT_INIT(CONFIG_GRKERNSEC_PROC_GID);
+static int __init setup_grsec_proc_gid(char *str)
+{
+	grsec_proc_gid = KGIDT_INIT(simple_strtol(str, NULL, 0));
+	return 1;
+}
+__setup("grsec_proc_gid=", setup_grsec_proc_gid);
+#endif
+#ifdef CONFIG_GRKERNSEC_SYSFS_RESTRICT
+int grsec_enable_sysfs_restrict = 1;
+static int __init setup_grsec_sysfs_restrict(char *str)
+{
+	if (!simple_strtol(str, NULL, 0))
+		grsec_enable_sysfs_restrict = 0;
+	return 1;
+}
+__setup("grsec_sysfs_restrict", setup_grsec_sysfs_restrict);
+#endif
+
 #ifdef CONFIG_PAX_SOFTMODE
 int pax_softmode;
 
@@ -931,6 +957,10 @@ static int try_to_run_init_process(const char *init_filename)
 	return ret;
 }
 
+#ifdef CONFIG_GRKERNSEC_CHROOT_INITRD
+extern int gr_init_ran;
+#endif
+
 static noinline void __init kernel_init_freeable(void);
 
 #ifdef CONFIG_DEBUG_RODATA
@@ -979,6 +1009,11 @@ static int __ref kernel_init(void *unused)
 		       ramdisk_execute_command, ret);
 	}
 
+#ifdef CONFIG_GRKERNSEC_CHROOT_INITRD
+	/* if no initrd was used, be extra sure we enforce chroot restrictions */
+	gr_init_ran = 1;
+#endif
+
 	/*
 	 * We try each of these until one succeeds.
 	 *
@@ -1054,6 +1089,8 @@ static noinline void __init kernel_init_freeable(void)
 		prepare_namespace();
 	}
 
+	grsecurity_init();
+
 	/*
 	 * Ok, we have completed the initial bootup, and
 	 * we're essentially up and running. Get rid of the
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index 8cbd6e6894d5..38293ad574bd 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -274,6 +274,7 @@ static struct inode *mqueue_get_inode(struct super_block *sb,
 		mq_bytes = mq_treesize + (info->attr.mq_maxmsg *
 					  info->attr.mq_msgsize);
 
+		gr_learn_resource(current, RLIMIT_MSGQUEUE, u->mq_bytes + mq_bytes, 1);
 		spin_lock(&mq_lock);
 		if (u->mq_bytes + mq_bytes < u->mq_bytes ||
 		    u->mq_bytes + mq_bytes > rlimit(RLIMIT_MSGQUEUE)) {
diff --git a/ipc/msg.c b/ipc/msg.c
index e12307d0c920..de96eac5f2bb 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -1031,7 +1031,8 @@ void msg_exit_ns(struct ipc_namespace *ns)
 static int sysvipc_msg_proc_show(struct seq_file *s, void *it)
 {
 	struct user_namespace *user_ns = seq_user_ns(s);
-	struct msg_queue *msq = it;
+	struct kern_ipc_perm *perm = it;
+	struct msg_queue *msq = container_of(perm, struct msg_queue, q_perm);
 
 	seq_printf(s,
 		   "%10d %10d  %4o  %10lu %10lu %5u %5u %5u %5u %5u %5u %10lu %10lu %10lu\n",
diff --git a/ipc/msgutil.c b/ipc/msgutil.c
index bf74eaa5c39f..dc6dbf710096 100644
--- a/ipc/msgutil.c
+++ b/ipc/msgutil.c
@@ -53,7 +53,7 @@ static struct msg_msg *alloc_msg(size_t len)
 	size_t alen;
 
 	alen = min(len, DATALEN_MSG);
-	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);
+	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT|GFP_USERCOPY);
 	if (msg == NULL)
 		return NULL;
 
@@ -65,7 +65,7 @@ static struct msg_msg *alloc_msg(size_t len)
 	while (len > 0) {
 		struct msg_msgseg *seg;
 		alen = min(len, DATALEN_SEG);
-		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);
+		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT|GFP_USERCOPY);
 		if (seg == NULL)
 			goto out_err;
 		*pseg = seg;
diff --git a/ipc/sem.c b/ipc/sem.c
index d7038b35e0e9..136c0ae33d5d 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -2206,7 +2206,8 @@ void exit_sem(struct task_struct *tsk)
 static int sysvipc_sem_proc_show(struct seq_file *s, void *it)
 {
 	struct user_namespace *user_ns = seq_user_ns(s);
-	struct sem_array *sma = it;
+	struct kern_ipc_perm *perm = it;
+	struct sem_array *sma = container_of(perm, struct sem_array, sem_perm);
 	time_t sem_otime;
 
 	/*
diff --git a/ipc/shm.c b/ipc/shm.c
index 9ef098c7e4e7..a0da911603ba 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -72,6 +72,14 @@ static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp);
 static int sysvipc_shm_proc_show(struct seq_file *s, void *it);
 #endif
 
+#ifdef CONFIG_GRKERNSEC
+extern int gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+			   const u64 shm_createtime, const kuid_t cuid,
+			   const int shmid);
+extern int gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+			   const u64 shm_createtime);
+#endif
+
 void shm_init_ns(struct ipc_namespace *ns)
 {
 	ns->shm_ctlmax = BITS_PER_LONG == 32 ? SHMMAX : LONG_MAX;
@@ -590,6 +598,9 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
 	shp->shm_ctim = get_seconds();
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_createtime = ktime_get_ns();
+#endif
 	shp->shm_segsz = size;
 	shp->shm_nattch = 0;
 	shp->shm_file = file;
@@ -1168,6 +1179,15 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg,
 	if (err)
 		goto out_unlock;
 
+#ifdef CONFIG_GRKERNSEC
+	if (!gr_handle_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime,
+			     shp->shm_perm.cuid, shmid) ||
+	    !gr_chroot_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime)) {
+		err = -EACCES;
+		goto out_unlock;
+	}
+#endif
+
 	ipc_lock_object(&shp->shm_perm);
 
 	/* check if shm_destroy() is tearing down shp */
@@ -1180,6 +1200,9 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg,
 	path = shp->shm_file->f_path;
 	path_get(&path);
 	shp->shm_nattch++;
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_lapid = current->pid;
+#endif
 	size = i_size_read(d_inode(path.dentry));
 	ipc_unlock_object(&shp->shm_perm);
 	rcu_read_unlock();
@@ -1383,7 +1406,8 @@ SYSCALL_DEFINE1(shmdt, char __user *, shmaddr)
 static int sysvipc_shm_proc_show(struct seq_file *s, void *it)
 {
 	struct user_namespace *user_ns = seq_user_ns(s);
-	struct shmid_kernel *shp = it;
+	struct kern_ipc_perm *perm = it;
+	struct shmid_kernel *shp = container_of(perm, struct shmid_kernel, shm_perm);
 	unsigned long rss = 0, swp = 0;
 
 	shm_add_rss_swap(shp, &rss, &swp);
diff --git a/ipc/util.c b/ipc/util.c
index 798cad18dd87..d6ffc17c6fa4 100644
--- a/ipc/util.c
+++ b/ipc/util.c
@@ -71,6 +71,8 @@ struct ipc_proc_iface {
 	int (*show)(struct seq_file *, void *);
 };
 
+extern int gr_ipc_permitted(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, int requested_mode, int granted_mode);
+
 /**
  * ipc_init - initialise ipc subsystem
  *
@@ -489,6 +491,10 @@ int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)
 		granted_mode >>= 6;
 	else if (in_group_p(ipcp->cgid) || in_group_p(ipcp->gid))
 		granted_mode >>= 3;
+
+	if (!gr_ipc_permitted(ns, ipcp, requested_mode, granted_mode))
+		return -1;
+
 	/* is there some bit set in requested_mode but not in granted_mode? */
 	if ((requested_mode & ~granted_mode & 0007) &&
 	    !ns_capable(ns->user_ns, CAP_IPC_OWNER))
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index 237f3d6a7ddc..ea9aac0ae736 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -829,8 +829,16 @@ SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, siz
 	union bpf_attr attr = {};
 	int err;
 
-	if (!capable(CAP_SYS_ADMIN) && sysctl_unprivileged_bpf_disabled)
+	/* the syscall is limited to root temporarily. This restriction will be
+	 * lifted by upstream when a half-assed security audit is clean. Note
+	 * that eBPF+tracing must have this restriction, since it may pass
+	 * kernel data to user space
+	 */
+	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+#ifdef CONFIG_GRKERNSEC
+	return -EPERM;
+#endif
 
 	if (!access_ok(VERIFY_READ, uattr, 1))
 		return -EFAULT;
diff --git a/kernel/capability.c b/kernel/capability.c
index 1f2ffc94cf37..a5bf6f538dea 100644
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@ -301,10 +301,11 @@ bool has_ns_capability(struct task_struct *t,
 	int ret;
 
 	rcu_read_lock();
-	ret = security_capable(__task_cred(t), ns, cap);
+	ret = security_capable(__task_cred(t), ns, cap) == 0 &&
+		gr_task_is_capable(t, __task_cred(t), cap);
 	rcu_read_unlock();
 
-	return (ret == 0);
+	return ret;
 }
 
 /**
@@ -341,10 +342,10 @@ bool has_ns_capability_noaudit(struct task_struct *t,
 	int ret;
 
 	rcu_read_lock();
-	ret = security_capable_noaudit(__task_cred(t), ns, cap);
+	ret = security_capable_noaudit(__task_cred(t), ns, cap) == 0 && gr_task_is_capable_nolog(t, __task_cred(t), cap);
 	rcu_read_unlock();
 
-	return (ret == 0);
+	return ret;
 }
 
 /**
@@ -373,9 +374,9 @@ static bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)
 		BUG();
 	}
 
-	capable = audit ? security_capable(current_cred(), ns, cap) :
-			  security_capable_noaudit(current_cred(), ns, cap);
-	if (capable == 0) {
+	capable = audit ? (security_capable(current_cred(), ns, cap) == 0 && gr_is_capable(cap)) :
+			  (security_capable_noaudit(current_cred(), ns, cap) == 0 && gr_is_capable_nolog(cap)) ;
+	if (capable) {
 		current->flags |= PF_SUPERPRIV;
 		return true;
 	}
@@ -432,6 +433,13 @@ bool capable(int cap)
 	return ns_capable(&init_user_ns, cap);
 }
 EXPORT_SYMBOL(capable);
+
+bool capable_nolog(int cap)
+{
+	return ns_capable_noaudit(&init_user_ns, cap);
+}
+EXPORT_SYMBOL(capable_nolog);
+
 #endif /* CONFIG_MULTIUSER */
 
 /**
@@ -489,6 +497,14 @@ bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
 }
 EXPORT_SYMBOL(capable_wrt_inode_uidgid);
 
+bool capable_wrt_inode_uidgid_nolog(const struct inode *inode, int cap)
+{
+	struct user_namespace *ns = current_user_ns();
+
+	return ns_capable_noaudit(ns, cap) && privileged_wrt_inode_uidgid(ns, inode);
+}
+EXPORT_SYMBOL(capable_wrt_inode_uidgid_nolog);
+
 /**
  * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace
  * @tsk: The task that may be ptraced
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 33d3ab5f1508..5c0c12d75030 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -6100,6 +6100,9 @@ static void cgroup_release_agent(struct work_struct *work)
 	if (!pathbuf || !agentbuf)
 		goto out;
 
+	if (agentbuf[0] == '\0')
+		goto out;
+
 	spin_lock_irq(&css_set_lock);
 	ret = cgroup_path_ns_locked(cgrp, pathbuf, PATH_MAX, &init_cgroup_ns);
 	spin_unlock_irq(&css_set_lock);
@@ -6580,7 +6583,7 @@ static int cgroup_css_links_read(struct seq_file *seq, void *v)
 		struct task_struct *task;
 		int count = 0;
 
-		seq_printf(seq, "css_set %p\n", cset);
+		seq_printf(seq, "css_set %pK\n", cset);
 
 		list_for_each_entry(task, &cset->tasks, cg_list) {
 			if (count++ > MAX_TASKS_SHOWN_PER_CSS)
diff --git a/kernel/compat.c b/kernel/compat.c
index 4e6619a3680f..762ec00709f0 100644
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@ -13,6 +13,7 @@
 
 #include <linux/linkage.h>
 #include <linux/compat.h>
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/time.h>
 #include <linux/signal.h>
diff --git a/kernel/configs.c b/kernel/configs.c
index c18b1f1ae515..b9a0132215df 100644
--- a/kernel/configs.c
+++ b/kernel/configs.c
@@ -74,8 +74,19 @@ static int __init ikconfig_init(void)
 	struct proc_dir_entry *entry;
 
 	/* create the current config file */
+#if defined(CONFIG_GRKERNSEC_PROC_ADD) || defined(CONFIG_GRKERNSEC_HIDESYM)
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_HIDESYM)
+	entry = proc_create("config.gz", S_IFREG | S_IRUSR, NULL,
+			    &ikconfig_file_ops);
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	entry = proc_create("config.gz", S_IFREG | S_IRUSR | S_IRGRP, NULL,
+			    &ikconfig_file_ops);
+#endif
+#else
 	entry = proc_create("config.gz", S_IFREG | S_IRUGO, NULL,
 			    &ikconfig_file_ops);
+#endif
+
 	if (!entry)
 		return -ENOMEM;
 
diff --git a/kernel/cred.c b/kernel/cred.c
index 5f264fb5737d..8fc856b49551 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -172,6 +172,15 @@ void exit_creds(struct task_struct *tsk)
 	validate_creds(cred);
 	alter_cred_subscribers(cred, -1);
 	put_cred(cred);
+
+#ifdef CONFIG_GRKERNSEC_SETXID
+	cred = (struct cred *) tsk->delayed_cred;
+	if (cred != NULL) {
+		tsk->delayed_cred = NULL;
+		validate_creds(cred);
+		put_cred(cred);
+	}
+#endif
 }
 
 /**
@@ -419,7 +428,7 @@ static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)
  * Always returns 0 thus allowing this function to be tail-called at the end
  * of, say, sys_setgid().
  */
-int commit_creds(struct cred *new)
+static int __commit_creds(struct cred *new)
 {
 	struct task_struct *task = current;
 	const struct cred *old = task->real_cred;
@@ -438,6 +447,8 @@ int commit_creds(struct cred *new)
 
 	get_cred(new); /* we will require a ref for the subj creds too */
 
+	gr_set_role_label(task, new->uid, new->gid);
+
 	/* dumpability changes */
 	if (!uid_eq(old->euid, new->euid) ||
 	    !gid_eq(old->egid, new->egid) ||
@@ -487,6 +498,105 @@ int commit_creds(struct cred *new)
 	put_cred(old);
 	return 0;
 }
+#ifdef CONFIG_GRKERNSEC_SETXID
+extern int set_user(struct cred *new);
+
+void gr_delayed_cred_worker(void)
+{
+	const struct cred *new = current->delayed_cred;
+	struct cred *ncred;
+
+	current->delayed_cred = NULL;
+
+	if (!uid_eq(current_uid(), GLOBAL_ROOT_UID) && new != NULL) {
+		// from doing get_cred on it when queueing this
+		put_cred(new);
+		return;
+	} else if (new == NULL)
+		return;
+
+	ncred = prepare_creds();
+	if (!ncred)
+		goto die;
+	// uids
+	ncred->uid = new->uid;
+	ncred->euid = new->euid;
+	ncred->suid = new->suid;
+	ncred->fsuid = new->fsuid;
+	// gids
+	ncred->gid = new->gid;
+	ncred->egid = new->egid;
+	ncred->sgid = new->sgid;
+	ncred->fsgid = new->fsgid;
+	// groups
+	set_groups(ncred, new->group_info);
+	// caps
+	ncred->securebits = new->securebits;
+	ncred->cap_inheritable = new->cap_inheritable;
+	ncred->cap_permitted = new->cap_permitted;
+	ncred->cap_effective = new->cap_effective;
+	ncred->cap_bset = new->cap_bset;
+
+	if (set_user(ncred)) {
+		abort_creds(ncred);
+		goto die;
+	}
+
+	// from doing get_cred on it when queueing this
+	put_cred(new);
+
+	__commit_creds(ncred);
+	return;
+die:
+	// from doing get_cred on it when queueing this
+	put_cred(new);
+	do_group_exit(SIGKILL);
+}
+#endif
+
+int commit_creds(struct cred *new)
+{
+#ifdef CONFIG_GRKERNSEC_SETXID
+	int ret;
+	int schedule_it = 0;
+	struct task_struct *t;
+	unsigned oldsecurebits = current_cred()->securebits;
+
+	/* we won't get called with tasklist_lock held for writing
+	   and interrupts disabled as the cred struct in that case is
+	   init_cred
+	*/
+	if (grsec_enable_setxid && !current_is_single_threaded() &&
+	    uid_eq(current_uid(), GLOBAL_ROOT_UID) &&
+	    !uid_eq(new->uid, GLOBAL_ROOT_UID)) {
+		schedule_it = 1;
+	}
+	ret = __commit_creds(new);
+	if (schedule_it) {
+		rcu_read_lock();
+		read_lock(&tasklist_lock);
+		for (t = next_thread(current); t != current;
+		     t = next_thread(t)) {
+			/* we'll check if the thread has uid 0 in
+			 * the delayed worker routine
+			 */
+			if (task_securebits(t) == oldsecurebits &&
+			    t->delayed_cred == NULL) {
+				t->delayed_cred = get_cred(new);
+				set_tsk_thread_flag(t, TIF_GRSEC_SETXID);
+				set_tsk_need_resched(t);
+			}
+		}
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+	}
+
+	return ret;
+#else
+	return __commit_creds(new);
+#endif
+}
+
 EXPORT_SYMBOL(commit_creds);
 
 /**
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 03e65af6c8fd..26e027195a76 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -389,8 +389,15 @@ static struct srcu_struct pmus_srcu;
  *   0 - disallow raw tracepoint access for unpriv
  *   1 - disallow cpu events for unpriv
  *   2 - disallow kernel profiling for unpriv
+ *   3 - disallow all unpriv perf event use
  */
-int sysctl_perf_event_paranoid __read_mostly = 2;
+#ifdef CONFIG_GRKERNSEC_PERF_HARDEN
+int sysctl_perf_event_legitimately_concerned __read_only = 3;
+#elif defined(CONFIG_GRKERNSEC_HIDESYM)
+int sysctl_perf_event_legitimately_concerned __read_only = 2;
+#else
+int sysctl_perf_event_legitimately_concerned __read_only = 2;
+#endif
 
 /* Minimum for 512 kiB + 1 user control page */
 int sysctl_perf_event_mlock __read_mostly = 512 + (PAGE_SIZE / 1024); /* 'free' kiB per user */
@@ -9592,6 +9599,11 @@ SYSCALL_DEFINE5(perf_event_open,
 	if (flags & ~PERF_FLAG_ALL)
 		return -EINVAL;
 
+#ifdef CONFIG_GRKERNSEC_PERF_HARDEN
+	if (perf_paranoid_any() && !capable(CAP_SYS_ADMIN))
+		return -EACCES;
+#endif
+
 	err = perf_copy_attr(attr_uptr, &attr);
 	if (err)
 		return err;
diff --git a/kernel/exit.c b/kernel/exit.c
index 3b16cb15930d..28d8eb4bff11 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -170,6 +170,10 @@ void release_task(struct task_struct *p)
 	struct task_struct *leader;
 	int zap_leader;
 repeat:
+#ifdef CONFIG_NET
+	gr_del_task_from_ip_table(p);
+#endif
+
 	/* don't need to get the RCU readlock here - the process is dead and
 	 * can't be modifying its own credentials. But shut RCU-lockdep up */
 	rcu_read_lock();
@@ -813,6 +817,9 @@ void __noreturn do_exit(long code)
 	tsk->exit_code = code;
 	taskstats_exit(tsk, group_dead);
 
+	gr_acl_handle_psacct(tsk, code);
+	gr_acl_handle_exit();
+
 	exit_mm(tsk);
 
 	if (group_dead)
diff --git a/kernel/fork.c b/kernel/fork.c
index 1405e1ddd793..37d2e1dba97f 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -259,6 +259,61 @@ void thread_stack_cache_init(void)
 # endif
 #endif
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+static inline unsigned long *gr_alloc_thread_stack_node(struct task_struct *tsk,
+						  int node, void **lowmem_stack)
+{
+	struct page *pages[THREAD_SIZE / PAGE_SIZE];
+	void *ret = NULL;
+	unsigned int i;
+
+	*lowmem_stack = alloc_thread_stack_node(tsk, node);
+	if (*lowmem_stack == NULL)
+		goto out;
+
+	for (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)
+		pages[i] = virt_to_page(*lowmem_stack + (i * PAGE_SIZE));
+
+	/* use VM_IOREMAP to gain THREAD_SIZE alignment */
+	ret = vmap(pages, THREAD_SIZE / PAGE_SIZE, VM_IOREMAP, PAGE_KERNEL);
+	if (ret == NULL) {
+		free_thread_stack(*lowmem_stack);
+		*lowmem_stack = NULL;
+	} else
+		populate_stack(ret, THREAD_SIZE);
+
+out:
+	return ret;
+}
+
+static inline void gr_free_thread_stack(struct task_struct *tsk)
+{
+	unmap_process_stacks(tsk);
+}
+#else
+static inline unsigned long *gr_alloc_thread_stack_node(struct task_struct *tsk,
+						  int node, void **lowmem_stack)
+{
+	return alloc_thread_stack_node(tsk, node);
+}
+static inline void gr_free_thread_stack(struct task_struct *tsk)
+{
+	free_thread_stack(tsk);
+}
+#endif
+
+const void *gr_convert_stack_address_to_lowmem(const void *buf)
+{
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	if (object_starts_on_stack(buf))
+		return buf - current->stack + current->lowmem_stack;
+	else if (object_starts_on_irq_stack(buf))
+		return buf - (const void *)__this_cpu_read(irq_stack_ptr) + (const void *)__this_cpu_read(irq_stack_ptr_lowmem);
+#endif
+	return buf;
+}
+EXPORT_SYMBOL_GPL(gr_convert_stack_address_to_lowmem);
+
 /* SLAB cache for signal_struct structures (tsk->signal) */
 static struct kmem_cache *signal_cachep;
 
@@ -279,7 +334,6 @@ static struct kmem_cache *mm_cachep;
 
 static void account_kernel_stack(struct task_struct *tsk, int account)
 {
-	void *stack = task_stack_page(tsk);
 	struct vm_struct *vm = task_stack_vm_area(tsk);
 
 	BUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);
@@ -303,8 +357,12 @@ static void account_kernel_stack(struct task_struct *tsk, int account)
 		 * All stack pages are in the same zone and belong to the
 		 * same memcg.
 		 */
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+		struct page *first_page = virt_to_page(tsk->lowmem_stack);
+#else
+		void *stack = task_stack_page(tsk);
 		struct page *first_page = virt_to_page(stack);
-
+#endif
 		mod_zone_page_state(page_zone(first_page), NR_KERNEL_STACK_KB,
 				    THREAD_SIZE / 1024 * account);
 
@@ -320,7 +378,7 @@ static void release_task_stack(struct task_struct *tsk)
 
 	account_kernel_stack(tsk, -1);
 	arch_release_thread_stack(tsk->stack);
-	free_thread_stack(tsk);
+	gr_free_thread_stack(tsk);
 	tsk->stack = NULL;
 #ifdef CONFIG_VMAP_STACK
 	tsk->stack_vm_area = NULL;
@@ -478,6 +536,7 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	struct task_struct *tsk;
 	unsigned long *stack;
 	struct vm_struct *stack_vm_area;
+	void *lowmem_stack;
 	int err;
 
 	if (node == NUMA_NO_NODE)
@@ -486,7 +545,7 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	if (!tsk)
 		return NULL;
 
-	stack = alloc_thread_stack_node(tsk, node);
+	stack = gr_alloc_thread_stack_node(tsk, node, &lowmem_stack);
 	if (!stack)
 		goto free_tsk;
 
@@ -500,6 +559,9 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	 * functions again.
 	 */
 	tsk->stack = stack;
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	tsk->lowmem_stack = lowmem_stack;
+#endif
 #ifdef CONFIG_VMAP_STACK
 	tsk->stack_vm_area = stack_vm_area;
 #endif
@@ -548,7 +610,7 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	return tsk;
 
 free_stack:
-	free_thread_stack(tsk);
+	gr_free_thread_stack(tsk);
 free_tsk:
 	free_task_struct(tsk);
 	return NULL;
@@ -1066,8 +1128,8 @@ struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
 		return ERR_PTR(err);
 
 	mm = get_task_mm(task);
-	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode)) {
+	if (mm && ((mm != current->mm && !ptrace_may_access(task, mode)) ||
+		  ((mode & PTRACE_MODE_ATTACH) && (gr_handle_proc_ptrace(task) || gr_acl_handle_procpidmem(task))))) {
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
@@ -1273,6 +1335,13 @@ static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)
 	tsk->fs = copy_fs_struct(fs);
 	if (!tsk->fs)
 		return -ENOMEM;
+	/* Carry through gr_chroot_dentry and is_chrooted instead
+	   of recomputing it here.  Already copied when the task struct
+	   is duplicated.  This allows pivot_root to not be treated as
+	   a chroot
+	*/
+	//gr_set_chroot_entries(tsk, &tsk->fs->root);
+
 	return 0;
 }
 
@@ -1578,6 +1647,9 @@ static __latent_entropy struct task_struct *copy_process(
 	DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);
 #endif
 	retval = -EAGAIN;
+
+	gr_learn_resource(p, RLIMIT_NPROC, atomic_read(&p->real_cred->user->processes), 0);
+
 	if (atomic_read(&p->real_cred->user->processes) >=
 			task_rlimit(p, RLIMIT_NPROC)) {
 		if (p->real_cred->user != INIT_USER &&
@@ -1836,6 +1908,16 @@ static __latent_entropy struct task_struct *copy_process(
 		goto bad_fork_cancel_cgroup;
 	}
 
+	/* synchronizes with gr_set_acls()
+	   we need to call this past the point of no return for fork()
+	*/
+	gr_copy_label(p);
+
+#ifdef CONFIG_GRKERNSEC_SETXID
+	if (p->delayed_cred)
+		get_cred(p->delayed_cred);
+#endif
+
 	if (likely(p->pid)) {
 		ptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);
 
@@ -1929,6 +2011,8 @@ static __latent_entropy struct task_struct *copy_process(
 	put_task_stack(p);
 	free_task(p);
 fork_out:
+	gr_log_forkfail(retval);
+
 	return ERR_PTR(retval);
 }
 
@@ -2009,6 +2093,8 @@ long _do_fork(unsigned long clone_flags,
 		if (clone_flags & CLONE_PARENT_SETTID)
 			put_user(nr, parent_tidptr);
 
+		gr_handle_brute_check();
+
 		if (clone_flags & CLONE_VFORK) {
 			p->vfork_done = &vfork;
 			init_completion(&vfork);
@@ -2307,6 +2393,7 @@ SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
 			fs = current->fs;
 			spin_lock(&fs->lock);
 			current->fs = new_fs;
+			gr_set_chroot_entries(current, &current->fs->root);
 			if (atomic_dec_return(&fs->users))
 				new_fs = NULL;
 			else
diff --git a/kernel/futex.c b/kernel/futex.c
index 3bf7594297b1..2f72a221d842 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -210,7 +210,7 @@ struct futex_pi_state {
 	atomic_t refcount;
 
 	union futex_key key;
-};
+} __randomize_layout;
 
 /**
  * struct futex_q - The hashed futex queue entry, one per waiting task
@@ -244,7 +244,7 @@ struct futex_q {
 	struct rt_mutex_waiter *rt_waiter;
 	union futex_key *requeue_pi_key;
 	u32 bitset;
-};
+} __randomize_layout;
 
 static const struct futex_q futex_q_init = {
 	/* list gets initialized in queue_me()*/
diff --git a/kernel/kallsyms.c b/kernel/kallsyms.c
index 7a90ae3724ef..316983eb622a 100644
--- a/kernel/kallsyms.c
+++ b/kernel/kallsyms.c
@@ -11,6 +11,9 @@
  *      Changed the compression method from stem compression to "table lookup"
  *      compression (see scripts/kallsyms.c for a more complete description)
  */
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+#define __INCLUDED_BY_HIDESYM 1
+#endif
 #include <linux/kallsyms.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -589,6 +592,11 @@ static int s_show(struct seq_file *m, void *p)
 {
 	struct kallsym_iter *iter = m->private;
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	if (!uid_eq(current_uid(), GLOBAL_ROOT_UID))
+		return 0;
+#endif
+
 	/* Some debugging symbols have no name.  Ignore them. */
 	if (!iter->name[0])
 		return 0;
@@ -602,6 +610,7 @@ static int s_show(struct seq_file *m, void *p)
 		 */
 		type = iter->exported ? toupper(iter->type) :
 					tolower(iter->type);
+
 		seq_printf(m, "%pK %c %s\t[%s]\n", (void *)iter->value,
 			   type, iter->name, iter->module_name);
 	} else
diff --git a/kernel/kcmp.c b/kernel/kcmp.c
index 3a47fa998fe0..bcb17e3f080c 100644
--- a/kernel/kcmp.c
+++ b/kernel/kcmp.c
@@ -100,6 +100,10 @@ SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,
 	struct task_struct *task1, *task2;
 	int ret;
 
+#ifdef CONFIG_GRKERNSEC
+	return -ENOSYS;
+#endif
+
 	rcu_read_lock();
 
 	/*
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index 561675589511..0affaae51c0d 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -871,7 +871,7 @@ int kimage_load_segment(struct kimage *image,
 
 struct kimage *kexec_image;
 struct kimage *kexec_crash_image;
-int kexec_load_disabled;
+int kexec_load_disabled __read_only;
 
 /*
  * No panic_cpu check version of crash_kexec().  This function is called
diff --git a/kernel/kmod.c b/kernel/kmod.c
index cb0a2ef46db6..2d2899cf738a 100644
--- a/kernel/kmod.c
+++ b/kernel/kmod.c
@@ -66,7 +66,7 @@ static void free_modprobe_argv(struct subprocess_info *info)
 	kfree(info->argv);
 }
 
-static int call_modprobe(char *module_name, int wait)
+static int call_modprobe(char *module_name, char *module_param, int wait)
 {
 	struct subprocess_info *info;
 	static char *envp[] = {
@@ -76,7 +76,7 @@ static int call_modprobe(char *module_name, int wait)
 		NULL
 	};
 
-	char **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);
+	char **argv = kmalloc(sizeof(char *[6]), GFP_KERNEL);
 	if (!argv)
 		goto out;
 
@@ -88,7 +88,8 @@ static int call_modprobe(char *module_name, int wait)
 	argv[1] = "-q";
 	argv[2] = "--";
 	argv[3] = module_name;	/* check free_modprobe_argv() */
-	argv[4] = NULL;
+	argv[4] = module_param;
+	argv[5] = NULL;
 
 	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,
 					 NULL, free_modprobe_argv, NULL);
@@ -121,9 +122,8 @@ static int call_modprobe(char *module_name, int wait)
  * If module auto-loading support is disabled then this function
  * becomes a no-operation.
  */
-int __request_module(bool wait, const char *fmt, ...)
+static int ____request_module(bool wait, char *module_param, const char *fmt, va_list ap)
 {
-	va_list args;
 	char module_name[MODULE_NAME_LEN];
 	unsigned int max_modprobes;
 	int ret;
@@ -142,9 +142,7 @@ int __request_module(bool wait, const char *fmt, ...)
 	if (!modprobe_path[0])
 		return 0;
 
-	va_start(args, fmt);
-	ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);
-	va_end(args);
+	ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, ap);
 	if (ret >= MODULE_NAME_LEN)
 		return -ENAMETOOLONG;
 
@@ -152,6 +150,20 @@ int __request_module(bool wait, const char *fmt, ...)
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+	if (uid_eq(current_uid(), GLOBAL_ROOT_UID)) {
+		/* hack to workaround consolekit/udisks stupidity */
+		read_lock(&tasklist_lock);
+		if (!strcmp(current->comm, "mount") &&
+		    current->real_parent && !strncmp(current->real_parent->comm, "udisk", 5)) {
+			read_unlock(&tasklist_lock);
+			printk(KERN_ALERT "grsec: denied attempt to auto-load fs module %.64s by udisks\n", module_name);
+			return -EPERM;
+		}
+		read_unlock(&tasklist_lock);
+	}
+#endif
+
 	/* If modprobe needs a service that is in a module, we get a recursive
 	 * loop.  Limit the number of running kmod threads to max_threads/2 or
 	 * MAX_KMOD_CONCURRENT, whichever is the smaller.  A cleaner method
@@ -180,16 +192,61 @@ int __request_module(bool wait, const char *fmt, ...)
 
 	trace_module_request(module_name, wait, _RET_IP_);
 
-	ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);
+	ret = call_modprobe(module_name, module_param, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);
 
 	atomic_dec(&kmod_concurrent);
 	return ret;
 }
+
+int ___request_module(bool wait, char *module_param, const char *fmt, ...)
+{
+	va_list args;
+	int ret;
+
+	va_start(args, fmt);
+	ret = ____request_module(wait, module_param, fmt, args);
+	va_end(args);
+
+	return ret;
+}
+
+int __request_module(bool wait, const char *fmt, ...)
+{
+	va_list args;
+	int ret;
+
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+	if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)) {
+		char module_param[MODULE_NAME_LEN];
+
+		memset(module_param, 0, sizeof(module_param));
+
+		snprintf(module_param, sizeof(module_param) - 1, "grsec_modharden_normal%u_", GR_GLOBAL_UID(current_uid()));
+
+		va_start(args, fmt);
+		ret = ____request_module(wait, module_param, fmt, args);
+		va_end(args);
+
+		return ret;
+	}
+#endif
+
+	va_start(args, fmt);
+	ret = ____request_module(wait, NULL, fmt, args);
+	va_end(args);
+
+	return ret;
+}
+
 EXPORT_SYMBOL(__request_module);
 #endif /* CONFIG_MODULES */
 
 static void call_usermodehelper_freeinfo(struct subprocess_info *info)
 {
+#ifdef CONFIG_GRKERNSEC
+	kfree(info->path);
+	info->path = info->origpath;
+#endif
 	if (info->cleanup)
 		(*info->cleanup)(info);
 	kfree(info);
@@ -228,6 +285,22 @@ static int call_usermodehelper_exec_async(void *data)
 	 */
 	set_user_nice(current, 0);
 
+#ifdef CONFIG_GRKERNSEC
+	/* this is race-free as far as userland is concerned as we copied
+	   out the path to be used prior to this point and are now operating
+	   on that copy
+	*/
+	if ((strncmp(sub_info->path, "/sbin/", 6) && strncmp(sub_info->path, "/usr/lib/", 9) &&
+	     strncmp(sub_info->path, "/lib/", 5) && strncmp(sub_info->path, "/lib64/", 7) &&
+	     strncmp(sub_info->path, "/usr/libexec/", 13) && strncmp(sub_info->path, "/usr/bin/", 9) &&
+	     strncmp(sub_info->path, "/usr/sbin/", 10) && strcmp(sub_info->path, "/bin/false") && 
+	     strcmp(sub_info->path, "/usr/share/apport/apport")) || strstr(sub_info->path, "..")) {
+		printk(KERN_ALERT "grsec: denied exec of usermode helper binary %.950s located outside of permitted system paths\n", sub_info->path);
+		retval = -EPERM;
+		goto out;
+	}
+#endif
+
 	retval = -ENOMEM;
 	new = prepare_kernel_cred(current);
 	if (!new)
@@ -528,7 +601,12 @@ struct subprocess_info *call_usermodehelper_setup(char *path, char **argv,
 		goto out;
 
 	INIT_WORK(&sub_info->work, call_usermodehelper_exec_work);
+#ifdef CONFIG_GRKERNSEC
+	sub_info->origpath = path;
+	sub_info->path = kstrdup(path, gfp_mask);
+#else
 	sub_info->path = path;
+#endif
 	sub_info->argv = argv;
 	sub_info->envp = envp;
 
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 1721314eb43f..9c0f54d58675 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -31,6 +31,9 @@
  *		<jkenisto@us.ibm.com> and Prasanna S Panchamukhi
  *		<prasanna@in.ibm.com> added function-return probes.
  */
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+#define __INCLUDED_BY_HIDESYM 1
+#endif
 #include <linux/kprobes.h>
 #include <linux/hash.h>
 #include <linux/init.h>
@@ -2198,11 +2201,11 @@ static void report_probe(struct seq_file *pi, struct kprobe *p,
 		kprobe_type = "k";
 
 	if (sym)
-		seq_printf(pi, "%p  %s  %s+0x%x  %s ",
+		seq_printf(pi, "%pK  %s  %s+0x%x  %s ",
 			p->addr, kprobe_type, sym, offset,
 			(modname ? modname : " "));
 	else
-		seq_printf(pi, "%p  %s  %p ",
+		seq_printf(pi, "%pK  %s  %pK ",
 			p->addr, kprobe_type, p->addr);
 
 	if (!pp)
@@ -2291,7 +2294,7 @@ static int kprobe_blacklist_seq_show(struct seq_file *m, void *v)
 	struct kprobe_blacklist_entry *ent =
 		list_entry(v, struct kprobe_blacklist_entry, list);
 
-	seq_printf(m, "0x%p-0x%p\t%ps\n", (void *)ent->start_addr,
+	seq_printf(m, "0x%pK-0x%pK\t%ps\n", (void *)ent->start_addr,
 		   (void *)ent->end_addr, (void *)ent->start_addr);
 	return 0;
 }
diff --git a/kernel/ksysfs.c b/kernel/ksysfs.c
index 16e831c21808..a35180642fdf 100644
--- a/kernel/ksysfs.c
+++ b/kernel/ksysfs.c
@@ -50,6 +50,8 @@ static ssize_t uevent_helper_store(struct kobject *kobj,
 {
 	if (count+1 > UEVENT_HELPER_PATH_LEN)
 		return -ENOENT;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
 	memcpy(uevent_helper, buf, count);
 	uevent_helper[count] = '\0';
 	if (count && uevent_helper[count-1] == '\n')
diff --git a/kernel/locking/lockdep_proc.c b/kernel/locking/lockdep_proc.c
index a0f61effad25..b6aef3cb648d 100644
--- a/kernel/locking/lockdep_proc.c
+++ b/kernel/locking/lockdep_proc.c
@@ -65,7 +65,7 @@ static int l_show(struct seq_file *m, void *v)
 		return 0;
 	}
 
-	seq_printf(m, "%p", class->key);
+	seq_printf(m, "%pK", class->key);
 #ifdef CONFIG_DEBUG_LOCKDEP
 	seq_printf(m, " OPS:%8ld", class->ops);
 #endif
@@ -83,7 +83,7 @@ static int l_show(struct seq_file *m, void *v)
 
 	list_for_each_entry(entry, &class->locks_after, entry) {
 		if (entry->distance == 1) {
-			seq_printf(m, " -> [%p] ", entry->class->key);
+			seq_printf(m, " -> [%pK] ", entry->class->key);
 			print_name(m, entry->class);
 			seq_puts(m, "\n");
 		}
@@ -154,7 +154,7 @@ static int lc_show(struct seq_file *m, void *v)
 		if (!class->key)
 			continue;
 
-		seq_printf(m, "[%p] ", class->key);
+		seq_printf(m, "[%pK] ", class->key);
 		print_name(m, class);
 		seq_puts(m, "\n");
 	}
@@ -510,7 +510,7 @@ static void seq_stats(struct seq_file *m, struct lock_stat_data *data)
 		if (!i)
 			seq_line(m, '-', 40-namelen, namelen);
 
-		snprintf(ip, sizeof(ip), "[<%p>]",
+		snprintf(ip, sizeof(ip), "[<%pK>]",
 				(void *)class->contention_point[i]);
 		seq_printf(m, "%40s %14lu %29s %pS\n",
 			   name, stats->contention_point[i],
@@ -525,7 +525,7 @@ static void seq_stats(struct seq_file *m, struct lock_stat_data *data)
 		if (!i)
 			seq_line(m, '-', 40-namelen, namelen);
 
-		snprintf(ip, sizeof(ip), "[<%p>]",
+		snprintf(ip, sizeof(ip), "[<%pK>]",
 				(void *)class->contending_point[i]);
 		seq_printf(m, "%40s %14lu %29s %pS\n",
 			   name, stats->contending_point[i],
diff --git a/kernel/module.c b/kernel/module.c
index c64dee1d2428..f9d983bcb62e 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -61,6 +61,7 @@
 #include <linux/pfn.h>
 #include <linux/bsearch.h>
 #include <linux/dynamic_debug.h>
+#include <linux/grsecurity.h>
 #include <uapi/linux/module.h>
 #include "module-internal.h"
 
@@ -320,7 +321,7 @@ module_param(sig_enforce, bool_enable_only, 0644);
 #endif /* !CONFIG_MODULE_SIG_FORCE */
 
 /* Block module loading/unloading? */
-int modules_disabled = 0;
+int modules_disabled __read_only = 0;
 core_param(nomodule, modules_disabled, bint, 0);
 
 /* Waiting for a module to finish initializing? */
@@ -1345,13 +1346,29 @@ static int check_version(Elf_Shdr *sechdrs,
 		goto bad_version;
 	}
 
-	/* Broken toolchain. Warn once, then let it go.. */
+#ifdef CONFIG_GRKERNSEC_RANDSTRUCT
+	/*
+	 * avoid potentially printing jibberish on attempted load
+	 * of a module randomized with a different seed
+	 */
+	pr_warn_once("no symbol version for %s\n", symname);
+#else
 	pr_warn_once("%s: no symbol version for %s\n", mod->name, symname);
+#endif
 	return 1;
 
 bad_version:
+#ifdef CONFIG_GRKERNSEC_RANDSTRUCT
+	/*
+	 * avoid potentially printing jibberish on attempted load
+	 * of a module randomized with a different seed
+	 */
+	pr_warn("attempted module disagrees about version of symbol %s\n",
+	       symname);
+#else
 	pr_warn("%s: disagrees about version of symbol %s\n",
 	       mod->name, symname);
+#endif
 	return 0;
 }
 
@@ -1479,7 +1496,7 @@ resolve_symbol_wait(struct module *mod,
  */
 #ifdef CONFIG_SYSFS
 
-#ifdef CONFIG_KALLSYMS
+#if defined(CONFIG_KALLSYMS) && !defined(CONFIG_GRKERNSEC_HIDESYM)
 static inline bool sect_empty(const Elf_Shdr *sect)
 {
 	return !(sect->sh_flags & SHF_ALLOC) || sect->sh_size == 0;
@@ -2260,9 +2277,31 @@ static int simplify_symbols(struct module *mod, const struct load_info *info)
 	int ret = 0;
 	const struct kernel_symbol *ksym;
 
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+	int is_fs_load = 0;
+	int register_filesystem_found = 0;
+	char *p;
+
+	p = strstr(mod->args, "grsec_modharden_fs");
+	if (p) {
+		char *endptr = p + sizeof("grsec_modharden_fs") - 1;
+		/* copy \0 as well */
+		memmove(p, endptr, strlen(mod->args) - (unsigned int)(endptr - mod->args) + 1);
+		is_fs_load = 1;
+	}
+#endif
+
 	for (i = 1; i < symsec->sh_size / sizeof(Elf_Sym); i++) {
 		const char *name = info->strtab + sym[i].st_name;
 
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+		/* it's a real shame this will never get ripped and copied
+		   upstream! ;(
+		*/
+		if (is_fs_load && !strcmp(name, "register_filesystem"))
+			register_filesystem_found = 1;
+#endif
+
 		switch (sym[i].st_shndx) {
 		case SHN_COMMON:
 			/* Ignore common symbols */
@@ -2319,6 +2358,13 @@ static int simplify_symbols(struct module *mod, const struct load_info *info)
 		}
 	}
 
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+	if (is_fs_load && !register_filesystem_found) {
+		printk(KERN_ALERT "grsec: Denied attempt to load non-fs module %.64s through mount\n", mod->name);
+		ret = -EPERM;
+	}
+#endif
+
 	return ret;
 }
 
@@ -2962,7 +3008,15 @@ static struct module *setup_load_info(struct load_info *info, int flags)
 	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 
 	if (info->index.sym == 0) {
+#ifdef CONFIG_GRKERNSEC_RANDSTRUCT
+		/*
+		 * avoid potentially printing jibberish on attempted load
+		 * of a module randomized with a different seed
+		 */
+		pr_warn("module has no symbols (stripped?)\n");
+#else
 		pr_warn("%s: module has no symbols (stripped?)\n", mod->name);
+#endif
 		return ERR_PTR(-ENOEXEC);
 	}
 
@@ -3743,9 +3797,38 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	if (err)
 		goto free_unload;
 
+	/* Now copy in args */
+	mod->args = strndup_user(uargs, ~0UL >> 1);
+	if (IS_ERR(mod->args)) {
+		err = PTR_ERR(mod->args);
+		goto free_unload;
+	}
+
 	/* Set up MODINFO_ATTR fields */
 	setup_modinfo(mod, info);
 
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+	{
+		char *p, *p2;
+
+		if (strstr(mod->args, "grsec_modharden_netdev")) {
+			printk(KERN_ALERT "grsec: denied auto-loading kernel module for a network device with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%.64s instead.", mod->name);
+			err = -EPERM;
+			goto free_modinfo;
+		} else if ((p = strstr(mod->args, "grsec_modharden_normal"))) {
+			p += sizeof("grsec_modharden_normal") - 1;
+			p2 = strstr(p, "_");
+			if (p2) {
+				*p2 = '\0';
+				printk(KERN_ALERT "grsec: denied kernel module auto-load of %.64s by uid %.9s\n", mod->name, p);
+				*p2 = '_';
+			}
+			err = -EPERM;
+			goto free_modinfo;
+		}
+	}
+#endif
+
 	/* Fix up syms, so that st_value is a pointer to location. */
 	err = simplify_symbols(mod, info);
 	if (err < 0)
@@ -3761,13 +3844,6 @@ static int load_module(struct load_info *info, const char __user *uargs,
 
 	flush_module_icache(mod);
 
-	/* Now copy in args */
-	mod->args = strndup_user(uargs, ~0UL >> 1);
-	if (IS_ERR(mod->args)) {
-		err = PTR_ERR(mod->args);
-		goto free_arch_cleanup;
-	}
-
 	dynamic_debug_setup(info->debug, info->num_debug);
 
 	/* Ftrace init must be called in the MODULE_STATE_UNFORMED state */
@@ -3832,11 +3908,10 @@ static int load_module(struct load_info *info, const char __user *uargs,
  ddebug_cleanup:
 	dynamic_debug_remove(info->debug);
 	synchronize_sched();
-	kfree(mod->args);
- free_arch_cleanup:
 	module_arch_cleanup(mod);
  free_modinfo:
 	free_modinfo(mod);
+	kfree(mod->args);
  free_unload:
 	module_unload_free(mod);
  unlink_mod:
@@ -4252,7 +4327,17 @@ static const struct file_operations proc_modules_operations = {
 
 static int __init proc_modules_init(void)
 {
+#ifndef CONFIG_GRKERNSEC_HIDESYM
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_create("modules", S_IRUSR, NULL, &proc_modules_operations);
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	proc_create("modules", S_IRUSR | S_IRGRP, NULL, &proc_modules_operations);
+#else
 	proc_create("modules", 0, NULL, &proc_modules_operations);
+#endif
+#else
+	proc_create("modules", S_IRUSR, NULL, &proc_modules_operations);
+#endif
 	return 0;
 }
 module_init(proc_modules_init);
diff --git a/kernel/panic.c b/kernel/panic.c
index aca749790ad8..fb9cd2af7717 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -521,11 +521,11 @@ void __warn(const char *file, int line, void *caller, unsigned taint,
 	pr_warn("------------[ cut here ]------------\n");
 
 	if (file)
-		pr_warn("WARNING: CPU: %d PID: %d at %s:%d %pS\n",
+		pr_warn("WARNING: CPU: %d PID: %d at %s:%d %pA\n",
 			raw_smp_processor_id(), current->pid, file, line,
 			caller);
 	else
-		pr_warn("WARNING: CPU: %d PID: %d at %pS\n",
+		pr_warn("WARNING: CPU: %d PID: %d at %pA\n",
 			raw_smp_processor_id(), current->pid, caller);
 
 	if (args)
@@ -596,7 +596,7 @@ EXPORT_SYMBOL(warn_slowpath_null);
 __visible void __stack_chk_fail(void)
 {
 	dump_stack();
-	panic("stack-protector: Kernel stack is corrupted in: %pS\n",
+	panic("stack-protector: Kernel stack is corrupted in: %pA\n",
 		__builtin_return_address(0));
 }
 EXPORT_SYMBOL(__stack_chk_fail);
diff --git a/kernel/pid.c b/kernel/pid.c
index 652e9dbb7f7b..e950a59b2b2c 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -33,6 +33,7 @@
 #include <linux/rculist.h>
 #include <linux/bootmem.h>
 #include <linux/hash.h>
+#include <linux/security.h>
 #include <linux/pid_namespace.h>
 #include <linux/init_task.h>
 #include <linux/syscalls.h>
@@ -451,9 +452,17 @@ EXPORT_SYMBOL(pid_task);
  */
 struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
 {
+	struct task_struct *task;
+
 	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),
 			 "find_task_by_pid_ns() needs rcu_read_lock() protection");
-	return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
+
+	task = pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
+
+	if (gr_pid_is_chrooted(task))
+		return NULL;
+
+	return task;
 }
 
 struct task_struct *find_task_by_vpid(pid_t vnr)
@@ -461,6 +470,13 @@ struct task_struct *find_task_by_vpid(pid_t vnr)
 	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
 }
 
+struct task_struct *find_task_by_vpid_unrestricted(pid_t vnr)
+{
+	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),
+			 "find_task_by_pid_ns() needs rcu_read_lock() protection");
+	return pid_task(find_pid_ns(vnr, task_active_pid_ns(current)), PIDTYPE_PID);
+}
+
 struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
 {
 	struct pid *pid;
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index e8517b63eb37..00d81dcdff92 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -34,6 +34,7 @@ config HIBERNATE_CALLBACKS
 config HIBERNATION
 	bool "Hibernation (aka 'suspend to disk')"
 	depends on SWAP && ARCH_HIBERNATION_POSSIBLE
+	depends on !GRKERNSEC_KMEM
 	select HIBERNATE_CALLBACKS
 	select LZO_COMPRESS
 	select LZO_DECOMPRESS
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9c5b231684d0..aaa4a5cfc2c5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -588,7 +588,7 @@ static int log_store(int facility, int level,
 	return msg->text_len;
 }
 
-int dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
+int dmesg_restrict __read_only = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
 
 static int syslog_action_restricted(int type)
 {
@@ -611,6 +611,11 @@ int check_syslog_permissions(int type, int source)
 	if (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)
 		goto ok;
 
+#ifdef CONFIG_GRKERNSEC_DMESG
+	if (grsec_enable_dmesg && !capable(CAP_SYSLOG) && !capable_nolog(CAP_SYS_ADMIN))
+		return -EPERM;
+#endif
+
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
 			goto ok;
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 517e3f12c6a2..a072a59bc388 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -250,7 +250,35 @@ static int ptrace_check_attach(struct task_struct *child, bool ignore_state)
 	return ret;
 }
 
-static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)
+static bool ptrace_has_cap(const struct cred *tcred, unsigned int mode)
+{
+	struct user_namespace *tns = tcred->user_ns;
+	struct user_namespace *curns = current_cred()->user_ns;
+
+	/* When a root-owned process enters a user namespace created by a
+	 * malicious user, the user shouldn't be able to execute code under
+	 * uid 0 by attaching to the root-owned process via ptrace.
+	 * Therefore, similar to the capable_wrt_inode_uidgid() check,
+	 * verify that all the uids and gids of the target process are
+	 * mapped into the current namespace.
+	 * No fsuid/fsgid check because __ptrace_may_access doesn't do it
+	 * either.
+	 */
+	if (!kuid_has_mapping(curns, tcred->euid) ||
+			!kuid_has_mapping(curns, tcred->suid) ||
+			!kuid_has_mapping(curns, tcred->uid)  ||
+			!kgid_has_mapping(curns, tcred->egid) ||
+			!kgid_has_mapping(curns, tcred->sgid) ||
+			!kgid_has_mapping(curns, tcred->gid))
+		return false;
+
+	if (mode & PTRACE_MODE_NOAUDIT)
+		return has_ns_capability_noaudit(current, tns, CAP_SYS_PTRACE);
+	else
+		return has_ns_capability(current, tns, CAP_SYS_PTRACE);
+}
+
+static bool ptrace_userns_has_cap(struct user_namespace *ns, unsigned int mode)
 {
 	if (mode & PTRACE_MODE_NOAUDIT)
 		return has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);
@@ -265,6 +293,7 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	struct mm_struct *mm;
 	kuid_t caller_uid;
 	kgid_t caller_gid;
+	int dumpable = 0;
 
 	if (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {
 		WARN(1, "denying ptrace access check without PTRACE_MODE_*CREDS\n");
@@ -307,16 +336,27 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	    gid_eq(caller_gid, tcred->sgid) &&
 	    gid_eq(caller_gid, tcred->gid))
 		goto ok;
-	if (ptrace_has_cap(tcred->user_ns, mode))
+	if (ptrace_has_cap(tcred, mode))
 		goto ok;
 	rcu_read_unlock();
 	return -EPERM;
 ok:
 	rcu_read_unlock();
+	smp_rmb();
 	mm = task->mm;
+	if (mm)
+		dumpable = get_dumpable(mm);
+	rcu_read_lock();
+	if (dumpable != SUID_DUMP_USER &&
+	    !ptrace_has_cap(__task_cred(task), mode)) {
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+
 	if (mm &&
-	    ((get_dumpable(mm) != SUID_DUMP_USER) &&
-	     !ptrace_has_cap(mm->user_ns, mode)))
+	    (dumpable != SUID_DUMP_USER) &&
+	     !ptrace_userns_has_cap(mm->user_ns, mode))
 	    return -EPERM;
 
 	return security_ptrace_access_check(task, mode);
@@ -1130,14 +1170,21 @@ SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
 		goto out;
 	}
 
+	if (gr_handle_ptrace(child, request)) {
+		ret = -EPERM;
+		goto out_put_task_struct;
+	}
+
 	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
 		ret = ptrace_attach(child, request, addr, data);
 		/*
 		 * Some architectures need to do book-keeping after
 		 * a ptrace attach.
 		 */
-		if (!ret)
+		if (!ret) {
 			arch_ptrace_attach(child);
+			gr_audit_ptrace(child);
+		}
 		goto out_put_task_struct;
 	}
 
@@ -1277,14 +1324,21 @@ COMPAT_SYSCALL_DEFINE4(ptrace, compat_long_t, request, compat_long_t, pid,
 		goto out;
 	}
 
+	if (gr_handle_ptrace(child, request)) {
+		ret = -EPERM;
+		goto out_put_task_struct;
+	}
+
 	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
 		ret = ptrace_attach(child, request, addr, data);
 		/*
 		 * Some architectures need to do book-keeping after
 		 * a ptrace attach.
 		 */
-		if (!ret)
+		if (!ret) {
 			arch_ptrace_attach(child);
+			gr_audit_ptrace(child);
+		}
 		goto out_put_task_struct;
 	}
 
diff --git a/kernel/resource.c b/kernel/resource.c
index 3650775cc435..b8b0a33385e9 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -171,8 +171,18 @@ static const struct file_operations proc_iomem_operations = {
 
 static int __init ioresources_init(void)
 {
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_create("ioports", S_IRUSR, NULL, &proc_ioports_operations);
+	proc_create("iomem", S_IRUSR, NULL, &proc_iomem_operations);
+#elif defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	proc_create("ioports", S_IRUSR | S_IRGRP, NULL, &proc_ioports_operations);
+	proc_create("iomem", S_IRUSR | S_IRGRP, NULL, &proc_iomem_operations);
+#endif
+#else
 	proc_create("ioports", 0, NULL, &proc_ioports_operations);
 	proc_create("iomem", 0, NULL, &proc_iomem_operations);
+#endif
 	return 0;
 }
 __initcall(ioresources_init);
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index bdf3d16aebad..f95f804a834f 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3795,6 +3795,8 @@ int can_nice(const struct task_struct *p, const int nice)
 	/* convert nice value [19,-20] to rlimit style value [1,40] */
 	int nice_rlim = nice_to_rlimit(nice);
 
+	gr_learn_resource(p, RLIMIT_NICE, nice_rlim, 1);
+
 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
 		capable(CAP_SYS_NICE));
 }
@@ -3821,7 +3823,8 @@ SYSCALL_DEFINE1(nice, int, increment)
 	nice = task_nice(current) + increment;
 
 	nice = clamp_val(nice, MIN_NICE, MAX_NICE);
-	if (increment < 0 && !can_nice(current, nice))
+	if (increment < 0 && (!can_nice(current, nice) ||
+			      gr_handle_chroot_nice()))
 		return -EPERM;
 
 	retval = security_task_setnice(current, nice);
@@ -4131,6 +4134,7 @@ static int __sched_setscheduler(struct task_struct *p,
 			if (policy != p->policy && !rlim_rtprio)
 				return -EPERM;
 
+			gr_learn_resource(p, RLIMIT_RTPRIO, attr->sched_priority, 1);
 			/* can't increase priority */
 			if (attr->sched_priority > p->rt_priority &&
 			    attr->sched_priority > rlim_rtprio)
@@ -7591,6 +7595,30 @@ void __init sched_init(void)
 	for_each_possible_cpu(i) {
 		struct rq *rq;
 
+#if defined(CONFIG_GRKERNSEC_KSTACKOVERFLOW) && defined(CONFIG_X86_64)
+		struct page *newstack_page = alloc_pages_node(cpu_to_node(i), GFP_KERNEL|__GFP_NOTRACK|__GFP_ZERO, IRQ_STACK_ORDER);
+		void *newstack_lowmem = NULL;
+		void *newstack;
+		struct page *pages[IRQ_STACK_SIZE / PAGE_SIZE];
+		unsigned int x;
+
+		if (newstack_page)
+			newstack_lowmem = page_address(newstack_page);
+
+		if (newstack_lowmem == NULL)
+			panic("grsec: Unable to allocate irq stack");
+
+		for (x = 0; x < IRQ_STACK_SIZE / PAGE_SIZE; x++)
+			pages[x] = virt_to_page(newstack_lowmem + (x * PAGE_SIZE));
+
+		newstack = vmap(pages, IRQ_STACK_SIZE / PAGE_SIZE, VM_IOREMAP, PAGE_KERNEL);
+		if (newstack == NULL)
+			panic("grsec: Unable to vmap irq stack");
+		populate_stack(newstack, IRQ_STACK_SIZE);
+		per_cpu(irq_stack_ptr_lowmem, i) = newstack_lowmem + IRQ_STACK_SIZE - 64;
+		per_cpu(irq_stack_ptr, i) = newstack + IRQ_STACK_SIZE - 64;
+#endif
+
 		rq = cpu_rq(i);
 		raw_spin_lock_init(&rq->lock);
 		rq->nr_running = 0;
@@ -7712,7 +7740,7 @@ void __might_sleep(const char *file, int line, int preempt_offset)
 	 */
 	WARN_ONCE(current->state != TASK_RUNNING && current->task_state_change,
 			"do not call blocking ops when !TASK_RUNNING; "
-			"state=%lx set at [<%p>] %pS\n",
+			"state=%lx set at [<%p>] %pA\n",
 			current->state,
 			(void *)current->task_state_change,
 			(void *)current->task_state_change);
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 9bfa2744d4f0..4e6c67e5859d 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -813,7 +813,11 @@ static int __init init_sched_debug_procfs(void)
 {
 	struct proc_dir_entry *pe;
 
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	pe = proc_create("sched_debug", 0400, NULL, &sched_debug_fops);
+#else
 	pe = proc_create("sched_debug", 0444, NULL, &sched_debug_fops);
+#endif
 	if (!pe)
 		return -ENOMEM;
 	return 0;
diff --git a/kernel/signal.c b/kernel/signal.c
index 1a0b903029ba..3a995207359b 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -372,6 +372,9 @@ __sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimi
 	atomic_inc(&user->sigpending);
 	rcu_read_unlock();
 
+	if (!override_rlimit)
+		gr_learn_resource(t, RLIMIT_SIGPENDING, atomic_read(&user->sigpending), 1);
+
 	if (override_rlimit ||
 	    atomic_read(&user->sigpending) <=
 			task_rlimit(t, RLIMIT_SIGPENDING)) {
@@ -743,6 +746,13 @@ static int check_kill_permission(int sig, struct siginfo *info,
 		}
 	}
 
+	/* allow glibc communication via tgkill to other threads in our
+	   thread group */
+	if ((info == SEND_SIG_NOINFO || info->si_code != SI_TKILL ||
+	     sig != (SIGRTMIN+1) || task_tgid_vnr(t) != info->si_pid)
+	    && gr_handle_signal(t, sig))
+		return -EPERM;
+
 	return security_task_kill(t, info, sig, 0);
 }
 
@@ -1126,7 +1136,7 @@ __group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
 	return send_signal(sig, info, p, 1);
 }
 
-static int
+int
 specific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t)
 {
 	return send_signal(sig, info, t, 0);
@@ -1163,6 +1173,7 @@ force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
 	unsigned long int flags;
 	int ret, blocked, ignored;
 	struct k_sigaction *action;
+	int is_unhandled = 0;
 
 	spin_lock_irqsave(&t->sighand->siglock, flags);
 	action = &t->sighand->action[sig-1];
@@ -1177,9 +1188,18 @@ force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
 	}
 	if (action->sa.sa_handler == SIG_DFL)
 		t->signal->flags &= ~SIGNAL_UNKILLABLE;
+	if (action->sa.sa_handler == SIG_IGN || action->sa.sa_handler == SIG_DFL)
+		is_unhandled = 1;
 	ret = specific_send_sig_info(sig, info, t);
 	spin_unlock_irqrestore(&t->sighand->siglock, flags);
 
+	/* only deal with unhandled signals, java etc trigger SIGSEGV during
+	   normal operation */
+	if (is_unhandled) {
+		gr_log_signal(sig, !is_si_special(info) ? info->si_addr : NULL, t);
+		gr_handle_crash(t, sig);
+	}
+
 	return ret;
 }
 
@@ -1260,8 +1280,11 @@ int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
 	ret = check_kill_permission(sig, info, p);
 	rcu_read_unlock();
 
-	if (!ret && sig)
+	if (!ret && sig) {
 		ret = do_send_sig_info(sig, info, p, true);
+		if (!ret)
+			gr_log_signal(sig, !is_si_special(info) ? info->si_addr : NULL, p);
+	}
 
 	return ret;
 }
@@ -2868,7 +2891,15 @@ do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 	int error = -ESRCH;
 
 	rcu_read_lock();
-	p = find_task_by_vpid(pid);
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	/* allow glibc communication via tgkill to other threads in our
+	   thread group */
+	if (grsec_enable_chroot_findtask && info->si_code == SI_TKILL &&
+	    sig == (SIGRTMIN+1) && tgid == info->si_pid)	    
+		p = find_task_by_vpid_unrestricted(pid);
+	else
+#endif
+		p = find_task_by_vpid(pid);
 	if (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {
 		error = check_kill_permission(sig, info, p);
 		/*
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 6c4f1ef3d9b3..ab73a78b370d 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -284,7 +284,7 @@ asmlinkage __visible void __softirq_entry __do_softirq(void)
 		h->action();
 		trace_softirq_exit(vec_nr);
 		if (unlikely(prev_count != preempt_count())) {
-			pr_err("huh, entered softirq %u %s %pS with preempt_count %08x, exited with %08x?\n",
+			pr_err("huh, entered softirq %u %s %pA with preempt_count %08x, exited with %08x?\n",
 			       vec_nr, softirq_to_name[vec_nr], h->action,
 			       prev_count, preempt_count());
 			preempt_count_set(prev_count);
diff --git a/kernel/sys.c b/kernel/sys.c
index 523659fa7ea6..441bef36ed11 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -160,6 +160,12 @@ static int set_one_prio(struct task_struct *p, int niceval, int error)
 		error = -EACCES;
 		goto out;
 	}
+
+	if (gr_handle_chroot_setpriority(p, niceval)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	no_nice = security_task_setnice(p, niceval);
 	if (no_nice) {
 		error = no_nice;
@@ -366,6 +372,20 @@ SYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)
 			goto error;
 	}
 
+	if (gr_check_group_change(new->gid, new->egid, INVALID_GID))
+		goto error;
+
+	if (!gid_eq(new->gid, old->gid)) {
+		/* make sure we generate a learn log for what will
+		   end up being a role transition after a full-learning
+		   policy is generated
+		   CAP_SETGID is required to perform a transition
+		   we may not log a CAP_SETGID check above, e.g.
+		   in the case where new rgid = old egid
+		*/
+		gr_learn_cap(current, new, CAP_SETGID, true);
+	}
+
 	if (rgid != (gid_t) -1 ||
 	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))
 		new->sgid = new->egid;
@@ -401,6 +421,10 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 	old = current_cred();
 
 	retval = -EPERM;
+
+	if (gr_check_group_change(kgid, kgid, kgid))
+		goto error;
+
 	if (ns_capable(old->user_ns, CAP_SETGID))
 		new->gid = new->egid = new->sgid = new->fsgid = kgid;
 	else if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))
@@ -418,7 +442,7 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 /*
  * change the user struct in a credentials set to match the new UID
  */
-static int set_user(struct cred *new)
+int set_user(struct cred *new)
 {
 	struct user_struct *new_user;
 
@@ -498,7 +522,18 @@ SYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)
 			goto error;
 	}
 
+	if (gr_check_user_change(new->uid, new->euid, INVALID_UID))
+		goto error;
+
 	if (!uid_eq(new->uid, old->uid)) {
+		/* make sure we generate a learn log for what will
+		   end up being a role transition after a full-learning
+		   policy is generated
+		   CAP_SETUID is required to perform a transition
+		   we may not log a CAP_SETUID check above, e.g.
+		   in the case where new ruid = old euid
+		*/
+		gr_learn_cap(current, new, CAP_SETUID, true);
 		retval = set_user(new);
 		if (retval < 0)
 			goto error;
@@ -548,6 +583,12 @@ SYSCALL_DEFINE1(setuid, uid_t, uid)
 	old = current_cred();
 
 	retval = -EPERM;
+
+	if (gr_check_crash_uid(kuid))
+		goto error;
+	if (gr_check_user_change(kuid, kuid, kuid))
+		goto error;
+
 	if (ns_capable(old->user_ns, CAP_SETUID)) {
 		new->suid = new->uid = kuid;
 		if (!uid_eq(kuid, old->uid)) {
@@ -617,6 +658,9 @@ SYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
 			goto error;
 	}
 
+	if (gr_check_user_change(kruid, keuid, INVALID_UID))
+		goto error;
+
 	if (ruid != (uid_t) -1) {
 		new->uid = kruid;
 		if (!uid_eq(kruid, old->uid)) {
@@ -701,6 +745,9 @@ SYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
 			goto error;
 	}
 
+	if (gr_check_group_change(krgid, kegid, INVALID_GID))
+		goto error;
+
 	if (rgid != (gid_t) -1)
 		new->gid = krgid;
 	if (egid != (gid_t) -1)
@@ -765,12 +812,16 @@ SYSCALL_DEFINE1(setfsuid, uid_t, uid)
 	    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||
 	    ns_capable(old->user_ns, CAP_SETUID)) {
 		if (!uid_eq(kuid, old->fsuid)) {
+			if (gr_check_user_change(INVALID_UID, INVALID_UID, kuid))
+				goto error;
+
 			new->fsuid = kuid;
 			if (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)
 				goto change_okay;
 		}
 	}
 
+error:
 	abort_creds(new);
 	return old_fsuid;
 
@@ -803,12 +854,16 @@ SYSCALL_DEFINE1(setfsgid, gid_t, gid)
 	if (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||
 	    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||
 	    ns_capable(old->user_ns, CAP_SETGID)) {
+		if (gr_check_group_change(INVALID_GID, INVALID_GID, kgid))
+			goto error;
+
 		if (!gid_eq(kgid, old->fsgid)) {
 			new->fsgid = kgid;
 			goto change_okay;
 		}
 	}
 
+error:
 	abort_creds(new);
 	return old_fsgid;
 
@@ -1400,6 +1455,13 @@ int do_prlimit(struct task_struct *tsk, unsigned int resource,
 			 */
 			new_rlim->rlim_cur = 1;
 		}
+		/* Handle the case where a fork and setuid occur and then RLIMIT_NPROC
+		   is changed to a lower value.  Since tasks can be created by the same
+		   user in between this limit change and an execve by this task, force
+		   a recheck only for this task by setting PF_NPROC_EXCEEDED
+		*/
+		if (resource == RLIMIT_NPROC && tsk->real_cred->user != INIT_USER)
+			tsk->flags |= PF_NPROC_EXCEEDED;
 	}
 	if (!retval) {
 		if (old_rlim)
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 3f2c24b3df0e..a6aef259f883 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -96,7 +96,6 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
-
 /* External variables not in a header file. */
 extern int suid_dumpable;
 #ifdef CONFIG_COREDUMP
@@ -112,23 +111,25 @@ extern unsigned int sysctl_nr_open_min, sysctl_nr_open_max;
 #ifndef CONFIG_MMU
 extern int sysctl_nr_trim_pages;
 #endif
+extern int sysctl_modify_ldt;
 
 /* Constants used for minimum and  maximum */
 #ifdef CONFIG_LOCKUP_DETECTOR
-static int sixty = 60;
+static int sixty __read_only = 60;
 #endif
 
-static int __maybe_unused neg_one = -1;
+static int __maybe_unused neg_one __read_only = -1;
 
-static int zero;
-static int __maybe_unused one = 1;
-static int __maybe_unused two = 2;
-static int __maybe_unused four = 4;
-static unsigned long one_ul = 1;
-static int one_hundred = 100;
-static int one_thousand = 1000;
+static int zero __read_only = 0;
+static int __maybe_unused one __read_only = 1;
+static int __maybe_unused two __read_only = 2;
+static int __maybe_unused three __read_only = 3;
+static int __maybe_unused four __read_only = 4;
+static unsigned long one_ul __read_only = 1;
+static int one_hundred __read_only = 100;
+static int one_thousand __read_only = 1000;
 #ifdef CONFIG_PRINTK
-static int ten_thousand = 10000;
+static int ten_thousand __read_only = 10000;
 #endif
 #ifdef CONFIG_PERF_EVENTS
 static int six_hundred_forty_kb = 640 * 1024;
@@ -185,10 +186,8 @@ static int proc_taint(struct ctl_table *table, int write,
 			       void __user *buffer, size_t *lenp, loff_t *ppos);
 #endif
 
-#ifdef CONFIG_PRINTK
-static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
+static int proc_dointvec_minmax_secure_sysadmin(struct ctl_table *table, int write,
 				void __user *buffer, size_t *lenp, loff_t *ppos);
-#endif
 
 static int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp, loff_t *ppos);
@@ -219,6 +218,8 @@ static int sysrq_sysctl_handler(struct ctl_table *table, int write,
 
 #endif
 
+extern struct ctl_table grsecurity_table[];
+
 static struct ctl_table kern_table[];
 static struct ctl_table vm_table[];
 static struct ctl_table fs_table[];
@@ -295,6 +296,13 @@ static int max_extfrag_threshold = 1000;
 #endif
 
 static struct ctl_table kern_table[] = {
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_ROFS)
+	{
+		.procname	= "grsecurity",
+		.mode		= 0500,
+		.child		= grsecurity_table,
+	},
+#endif
 
 #ifdef CONFIG_PAX_SOFTMODE
 	{
@@ -667,7 +675,7 @@ static struct ctl_table kern_table[] = {
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		/* only handle a transition from default "0" to "1" */
-		.proc_handler	= proc_dointvec_minmax,
+		.proc_handler	= proc_dointvec_minmax_secure,
 		.extra1		= &one,
 		.extra2		= &one,
 	},
@@ -678,7 +686,7 @@ static struct ctl_table kern_table[] = {
 		.data		= &modprobe_path,
 		.maxlen		= KMOD_PATH_LEN,
 		.mode		= 0644,
-		.proc_handler	= proc_dostring,
+		.proc_handler	= proc_dostring_modpriv,
 	},
 	{
 		.procname	= "modules_disabled",
@@ -686,7 +694,7 @@ static struct ctl_table kern_table[] = {
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		/* only handle a transition from default "0" to "1" */
-		.proc_handler	= proc_dointvec_minmax,
+		.proc_handler	= proc_dointvec_minmax_secure,
 		.extra1		= &one,
 		.extra2		= &one,
 	},
@@ -848,20 +856,24 @@ static struct ctl_table kern_table[] = {
 		.data		= &dmesg_restrict,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax_sysadmin,
+		.proc_handler	= proc_dointvec_minmax_secure_sysadmin,
 		.extra1		= &zero,
 		.extra2		= &one,
 	},
+#endif
 	{
 		.procname	= "kptr_restrict",
 		.data		= &kptr_restrict,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax_sysadmin,
+		.proc_handler	= proc_dointvec_minmax_secure_sysadmin,
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+		.extra1		= &one,
+#else
 		.extra1		= &zero,
+#endif
 		.extra2		= &two,
 	},
-#endif
 	{
 		.procname	= "ngroups_max",
 		.data		= &ngroups_max,
@@ -1026,6 +1038,17 @@ static struct ctl_table kern_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#ifdef CONFIG_MODIFY_LDT_SYSCALL
+	{
+		.procname	= "modify_ldt",
+		.data		= &sysctl_modify_ldt,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax_secure_sysadmin,
+		.extra1		= &zero,
+		.extra2		= &one,
+	},
+#endif
 #endif
 #if defined(CONFIG_MMU)
 	{
@@ -1139,10 +1162,17 @@ static struct ctl_table kern_table[] = {
 	 */
 	{
 		.procname	= "perf_event_paranoid",
-		.data		= &sysctl_perf_event_paranoid,
-		.maxlen		= sizeof(sysctl_perf_event_paranoid),
+		.data		= &sysctl_perf_event_legitimately_concerned,
+		.maxlen		= sizeof(sysctl_perf_event_legitimately_concerned),
 		.mode		= 0644,
-		.proc_handler	= proc_dointvec,
+		/* go ahead, be a hero */
+		.proc_handler	= proc_dointvec_minmax_secure_sysadmin,
+		.extra1		= &neg_one,
+#ifdef CONFIG_GRKERNSEC_PERF_HARDEN
+		.extra2		= &three,
+#else
+		.extra2		= &two,
+#endif
 	},
 	{
 		.procname	= "perf_event_mlock_kb",
@@ -2017,6 +2047,16 @@ int proc_dostring(struct ctl_table *table, int write,
 			       (char __user *)buffer, lenp, ppos);
 }
 
+int proc_dostring_modpriv(struct ctl_table *table, int write,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	if (write && !capable(CAP_SYS_MODULE))
+		return -EPERM;
+
+	return _proc_do_string(table->data, table->maxlen, write,
+			       buffer, lenp, ppos);
+}
+
 static size_t proc_skip_spaces(char **buf)
 {
 	size_t ret;
@@ -2328,6 +2368,44 @@ int proc_douintvec(struct ctl_table *table, int write,
 				do_proc_douintvec_conv, NULL);
 }
 
+static int do_proc_dointvec_conv_secure(bool *negp, unsigned long *lvalp,
+				 int *valp,
+				 int write, void *data)
+{
+	if (write) {
+		if (*negp) {
+			if (*lvalp > (unsigned long) INT_MAX + 1)
+				return -EINVAL;
+			pax_open_kernel();
+			*valp = -*lvalp;
+			pax_close_kernel();
+		} else {
+			if (*lvalp > (unsigned long) INT_MAX)
+				return -EINVAL;
+			pax_open_kernel();
+			*valp = *lvalp;
+			pax_close_kernel();
+		}
+	} else {
+		int val = *valp;
+		if (val < 0) {
+			*negp = true;
+			*lvalp = -(unsigned long)val;
+		} else {
+			*negp = false;
+			*lvalp = (unsigned long)val;
+		}
+	}
+	return 0;
+}
+
+int proc_dointvec_secure(struct ctl_table *table, int write,
+		     void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+    return do_proc_dointvec(table,write,buffer,lenp,ppos,
+		    	    do_proc_dointvec_conv_secure,NULL);
+}
+
 /*
  * Taint values can only be increased
  * This means we can safely use a temporary.
@@ -2363,16 +2441,14 @@ static int proc_taint(struct ctl_table *table, int write,
 	return err;
 }
 
-#ifdef CONFIG_PRINTK
-static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
+static int proc_dointvec_minmax_secure_sysadmin(struct ctl_table *table, int write,
 				void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	if (write && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+	return proc_dointvec_minmax_secure(table, write, buffer, lenp, ppos);
 }
-#endif
 
 struct do_proc_dointvec_minmax_conv_param {
 	int *min;
@@ -2403,6 +2479,32 @@ static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,
 	return 0;
 }
 
+static int do_proc_dointvec_minmax_conv_secure(bool *negp, unsigned long *lvalp,
+					int *valp,
+					int write, void *data)
+{
+	struct do_proc_dointvec_minmax_conv_param *param = data;
+	if (write) {
+		int val = *negp ? -*lvalp : *lvalp;
+		if ((param->min && *param->min > val) ||
+		    (param->max && *param->max < val))
+			return -EINVAL;
+		pax_open_kernel();
+		*valp = val;
+		pax_close_kernel();
+	} else {
+		int val = *valp;
+		if (val < 0) {
+			*negp = true;
+			*lvalp = -(unsigned long)val;
+		} else {
+			*negp = false;
+			*lvalp = (unsigned long)val;
+		}
+	}
+	return 0;
+}
+
 /**
  * proc_dointvec_minmax - read a vector of integers with min/max values
  * @table: the sysctl table
@@ -2430,6 +2532,17 @@ int proc_dointvec_minmax(struct ctl_table *table, int write,
 				do_proc_dointvec_minmax_conv, &param);
 }
 
+int proc_dointvec_minmax_secure(struct ctl_table *table, int write,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct do_proc_dointvec_minmax_conv_param param = {
+		.min = (int *) table->extra1,
+		.max = (int *) table->extra2,
+	};
+	return do_proc_dointvec(table, write, buffer, lenp, ppos,
+				do_proc_dointvec_minmax_conv_secure, &param);
+}
+
 static void validate_coredump_safety(void)
 {
 #ifdef CONFIG_COREDUMP
@@ -2918,6 +3031,12 @@ int proc_dostring(struct ctl_table *table, int write,
 	return -ENOSYS;
 }
 
+int proc_dostring_modpriv(struct ctl_table *table, int write,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return -ENOSYS;
+}
+
 int proc_dointvec(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
@@ -2981,5 +3100,6 @@ EXPORT_SYMBOL(proc_dointvec_minmax);
 EXPORT_SYMBOL(proc_dointvec_userhz_jiffies);
 EXPORT_SYMBOL(proc_dointvec_ms_jiffies);
 EXPORT_SYMBOL(proc_dostring);
+EXPORT_SYMBOL(proc_dostring_modpriv);
 EXPORT_SYMBOL(proc_doulongvec_minmax);
 EXPORT_SYMBOL(proc_doulongvec_ms_jiffies_minmax);
diff --git a/kernel/taskstats.c b/kernel/taskstats.c
index cbb387a265db..99d91f644a94 100644
--- a/kernel/taskstats.c
+++ b/kernel/taskstats.c
@@ -28,9 +28,12 @@
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/pid_namespace.h>
+#include <linux/grsecurity.h>
 #include <net/genetlink.h>
 #include <linux/atomic.h>
 
+extern int gr_is_taskstats_denied(int pid);
+
 /*
  * Maximum length of a cpumask that can be specified in
  * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute
@@ -544,6 +547,9 @@ static int cmd_attr_tgid(struct genl_info *info)
 
 static int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)
 {
+	if (gr_is_taskstats_denied(current->pid))
+		return -EACCES;
+
 	if (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])
 		return cmd_attr_register_cpumask(info);
 	else if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])
diff --git a/kernel/time/posix-timers.c b/kernel/time/posix-timers.c
index 4b029e3e17f3..7e6663aea442 100644
--- a/kernel/time/posix-timers.c
+++ b/kernel/time/posix-timers.c
@@ -43,6 +43,7 @@
 #include <linux/hash.h>
 #include <linux/posix-clock.h>
 #include <linux/posix-timers.h>
+#include <linux/grsecurity.h>
 #include <linux/syscalls.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
@@ -1021,6 +1022,13 @@ SYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,
 	if (copy_from_user(&new_tp, tp, sizeof (*tp)))
 		return -EFAULT;
 
+	/* only the CLOCK_REALTIME clock can be set, all other clocks
+	   have their clock_set fptr set to a nosettime dummy function
+	   CLOCK_REALTIME has a NULL clock_set fptr which causes it to
+	   call common_clock_set, which calls do_sys_settimeofday, which
+	   we hook
+	*/
+
 	return kc->clock_set(which_clock, &new_tp);
 }
 
diff --git a/kernel/time/time.c b/kernel/time/time.c
index bd62fb8e8e77..8b387ee6822b 100644
--- a/kernel/time/time.c
+++ b/kernel/time/time.c
@@ -177,6 +177,11 @@ int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz
 		if (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)
 			return -EINVAL;
 
+		/* we log in do_settimeofday called below, so don't log twice
+		*/
+		if (!tv)
+			gr_log_timechange();
+
 		sys_tz = *tz;
 		update_vsyscall_tz();
 		if (firsttime) {
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 46e312e9be38..c96310f407ed 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <linux/grsecurity.h>
 #include <linux/syscore_ops.h>
 #include <linux/clocksource.h>
 #include <linux/jiffies.h>
@@ -1172,6 +1173,8 @@ int do_settimeofday64(const struct timespec64 *ts)
 	if (!timespec64_valid_strict(ts))
 		return -EINVAL;
 
+	gr_log_timechange();
+
 	raw_spin_lock_irqsave(&timekeeper_lock, flags);
 	write_seqcount_begin(&tk_core.seq);
 
diff --git a/kernel/time/timer_list.c b/kernel/time/timer_list.c
index ba7d8b288bb3..aa301b0ec729 100644
--- a/kernel/time/timer_list.c
+++ b/kernel/time/timer_list.c
@@ -50,12 +50,16 @@ static void SEQ_printf(struct seq_file *m, const char *fmt, ...)
 
 static void print_name_offset(struct seq_file *m, void *sym)
 {
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	SEQ_printf(m, "<%p>", NULL);
+#else
 	char symname[KSYM_NAME_LEN];
 
 	if (lookup_symbol_name((unsigned long)sym, symname) < 0)
 		SEQ_printf(m, "<%pK>", sym);
 	else
 		SEQ_printf(m, "%s", symname);
+#endif
 }
 
 static void
@@ -124,11 +128,14 @@ print_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,
 static void
 print_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)
 {
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	SEQ_printf(m, "  .base:       %p\n", NULL);
+#else
 	SEQ_printf(m, "  .base:       %pK\n", base);
+#endif
 	SEQ_printf(m, "  .index:      %d\n", base->index);
 
 	SEQ_printf(m, "  .resolution: %u nsecs\n", (unsigned) hrtimer_resolution);
-
 	SEQ_printf(m,   "  .get_time:   ");
 	print_name_offset(m, base->get_time);
 	SEQ_printf(m,   "\n");
@@ -393,7 +400,11 @@ static int __init init_timer_list_procfs(void)
 {
 	struct proc_dir_entry *pe;
 
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	pe = proc_create("timer_list", 0400, NULL, &timer_list_fops);
+#else
 	pe = proc_create("timer_list", 0444, NULL, &timer_list_fops);
+#endif
 	if (!pe)
 		return -ENOMEM;
 	return 0;
diff --git a/kernel/time/timer_stats.c b/kernel/time/timer_stats.c
index 6c5013d0f973..671b58227f98 100644
--- a/kernel/time/timer_stats.c
+++ b/kernel/time/timer_stats.c
@@ -269,12 +269,16 @@ void timer_stats_update_stats(void *timer, pid_t pid, void *startf,
 
 static void print_name_offset(struct seq_file *m, unsigned long addr)
 {
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	seq_printf(m, "<%p>", NULL);
+#else
 	char symname[KSYM_NAME_LEN];
 
 	if (lookup_symbol_name(addr, symname) < 0)
-		seq_printf(m, "<%p>", (void *)addr);
+		seq_printf(m, "<%pK>", (void *)addr);
 	else
 		seq_printf(m, "%s", symname);
+#endif
 }
 
 static int tstats_show(struct seq_file *m, void *v)
@@ -417,7 +421,11 @@ static int __init init_tstats_procfs(void)
 {
 	struct proc_dir_entry *pe;
 
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	pe = proc_create("timer_stats", 0600, NULL, &tstats_fops);
+#else
 	pe = proc_create("timer_stats", 0644, NULL, &tstats_fops);
+#endif
 	if (!pe)
 		return -ENOMEM;
 	return 0;
diff --git a/kernel/trace/Kconfig b/kernel/trace/Kconfig
index bf30221347e2..9c16b00284ac 100644
--- a/kernel/trace/Kconfig
+++ b/kernel/trace/Kconfig
@@ -102,6 +102,7 @@ config TRACING
 config GENERIC_TRACER
 	bool
 	select TRACING
+	depends on !GRKERNSEC_KMEM
 
 #
 # Minimum requirements an architecture has to meet for us to
@@ -115,6 +116,7 @@ config TRACING_SUPPORT
 	# irqflags tracing for your architecture.
 	depends on TRACE_IRQFLAGS_SUPPORT || PPC32
 	depends on STACKTRACE_SUPPORT
+	depends on !GRKERNSEC_KMEM
 	default y
 
 if TRACING_SUPPORT
@@ -256,6 +258,7 @@ config ENABLE_DEFAULT_TRACERS
 	bool "Trace process context switches and events"
 	depends on !GENERIC_TRACER
 	select TRACING
+	depends on !GRKERNSEC_KMEM
 	help
 	  This tracer hooks to various trace points in the kernel,
 	  allowing the user to pick and choose which trace point they
@@ -409,6 +412,7 @@ config BLK_DEV_IO_TRACE
 	depends on BLOCK
 	select RELAY
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	select TRACEPOINTS
 	select GENERIC_TRACER
 	select STACKTRACE
@@ -433,6 +437,7 @@ config KPROBE_EVENT
 	depends on HAVE_REGS_AND_STACK_ACCESS_API
 	bool "Enable kprobes-based dynamic events"
 	select TRACING
+	depends on !GRKERNSEC_KMEM
 	select PROBE_EVENTS
 	default y
 	help
@@ -454,6 +459,7 @@ config UPROBE_EVENT
 	select UPROBES
 	select PROBE_EVENTS
 	select TRACING
+	depends on !GRKERNSEC_KMEM
 	default n
 	help
 	  This allows the user to add tracing events on top of userspace
diff --git a/kernel/trace/trace_syscalls.c b/kernel/trace/trace_syscalls.c
index 5e10395da88e..c258d96435c7 100644
--- a/kernel/trace/trace_syscalls.c
+++ b/kernel/trace/trace_syscalls.c
@@ -605,6 +605,8 @@ static int perf_sysenter_enable(struct trace_event_call *call)
 	int num;
 
 	num = ((struct syscall_metadata *)call->data)->syscall_nr;
+	if (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))
+		return -EINVAL;
 
 	mutex_lock(&syscall_trace_lock);
 	if (!sys_perf_refcount_enter)
@@ -624,6 +626,8 @@ static void perf_sysenter_disable(struct trace_event_call *call)
 	int num;
 
 	num = ((struct syscall_metadata *)call->data)->syscall_nr;
+	if (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))
+		return;
 
 	mutex_lock(&syscall_trace_lock);
 	sys_perf_refcount_enter--;
@@ -676,6 +680,8 @@ static int perf_sysexit_enable(struct trace_event_call *call)
 	int num;
 
 	num = ((struct syscall_metadata *)call->data)->syscall_nr;
+	if (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))
+		return -EINVAL;
 
 	mutex_lock(&syscall_trace_lock);
 	if (!sys_perf_refcount_exit)
@@ -695,6 +701,8 @@ static void perf_sysexit_disable(struct trace_event_call *call)
 	int num;
 
 	num = ((struct syscall_metadata *)call->data)->syscall_nr;
+	if (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))
+		return;
 
 	mutex_lock(&syscall_trace_lock);
 	sys_perf_refcount_exit--;
diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c
index 8fbc98bacd24..0c3cfe2e5433 100644
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -76,6 +76,21 @@ int create_user_ns(struct cred *new)
 	struct ucounts *ucounts;
 	int ret, i;
 
+#ifdef CONFIG_GRKERNSEC
+	/*
+	 * This doesn't really inspire confidence:
+	 * http://marc.info/?l=linux-kernel&m=135543612731939&w=2
+	 * http://marc.info/?l=linux-kernel&m=135545831607095&w=2
+	 * Increases kernel attack surface in areas developers
+	 * previously cared little about ("low importance due
+	 * to requiring "root" capability")
+	 * To be removed when this code receives *proper* review
+	 */
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SETUID) ||
+			!capable(CAP_SETGID))
+		return -EPERM;
+#endif
+
 	ret = -ENOSPC;
 	if (parent_ns->level > 32)
 		goto fail;
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 8bec5c75ed72..8ff38cd2c1bb 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -244,6 +244,7 @@ config PAGE_OWNER
 	bool "Track page owner"
 	depends on DEBUG_KERNEL && STACKTRACE_SUPPORT
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	select STACKTRACE
 	select STACKDEPOT
 	select PAGE_EXTENSION
@@ -260,6 +261,7 @@ config PAGE_OWNER
 config DEBUG_FS
 	bool "Debug Filesystem"
 	select SRCU
+	depends on !GRKERNSEC_KMEM
 	help
 	  debugfs is a virtual file system that kernel developers use to put
 	  debugging files into.  Enable this option to be able to read and
@@ -513,6 +515,7 @@ config DEBUG_KMEMLEAK
 	bool "Kernel memory leak detector"
 	depends on DEBUG_KERNEL && HAVE_DEBUG_KMEMLEAK
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	select STACKTRACE if STACKTRACE_SUPPORT
 	select KALLSYMS
 	select CRC32
@@ -712,6 +715,7 @@ config KCOV
 	select DEBUG_FS
 	select GCC_PLUGINS if !COMPILE_TEST
 	select GCC_PLUGIN_SANCOV if !COMPILE_TEST
+	depends on !GRKERNSEC_KMEM
 	help
 	  KCOV exposes kernel code coverage information in a form suitable
 	  for coverage-guided fuzzing (randomized testing).
@@ -1013,7 +1017,7 @@ config DEBUG_MUTEXES
 
 config DEBUG_WW_MUTEX_SLOWPATH
 	bool "Wait/wound mutex debugging: Slowpath testing"
-	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
+	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT && !PAX_CONSTIFY_PLUGIN
 	select DEBUG_LOCK_ALLOC
 	select DEBUG_SPINLOCK
 	select DEBUG_MUTEXES
@@ -1511,6 +1515,7 @@ config NOTIFIER_ERROR_INJECTION
 	tristate "Notifier error injection"
 	depends on DEBUG_KERNEL
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	help
 	  This option provides the ability to inject artificial errors to
 	  specified notifier chain callbacks. It is useful to test the error
@@ -1656,6 +1661,7 @@ config FAIL_MMC_REQUEST
 config FAIL_FUTEX
 	bool "Fault-injection capability for futexes"
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	depends on FAULT_INJECTION && FUTEX
 	help
 	  Provide fault-injection capability for futexes.
@@ -1680,6 +1686,7 @@ config LATENCYTOP
 	depends on DEBUG_KERNEL
 	depends on STACKTRACE_SUPPORT
 	depends on PROC_FS
+	depends on !GRKERNSEC_HIDESYM
 	select FRAME_POINTER if !MIPS && !PPC && !S390 && !MICROBLAZE && !ARM_UNWIND && !ARC
 	select KALLSYMS
 	select KALLSYMS_ALL
@@ -1834,7 +1841,7 @@ endmenu # runtime tests
 
 config PROVIDE_OHCI1394_DMA_INIT
 	bool "Remote debugging over FireWire early on boot"
-	depends on PCI && X86
+	depends on PCI && X86 && !GRKERNSEC
 	help
 	  If you want to debug problems which hang or crash the kernel early
 	  on boot and the crashing machine has a FireWire port, you can use
diff --git a/lib/is_single_threaded.c b/lib/is_single_threaded.c
index 391fd23976a2..96e17b6e0146 100644
--- a/lib/is_single_threaded.c
+++ b/lib/is_single_threaded.c
@@ -22,6 +22,9 @@ bool current_is_single_threaded(void)
 	struct task_struct *p, *t;
 	bool ret;
 
+	if (!mm)
+		return true;
+
 	if (atomic_read(&task->signal->live) != 1)
 		return false;
 
diff --git a/lib/list_debug.c b/lib/list_debug.c
index 3a044e295ddc..38bdeaafb060 100644
--- a/lib/list_debug.c
+++ b/lib/list_debug.c
@@ -25,18 +25,26 @@ static bool __list_add_debug(struct list_head *new,
 			     struct list_head *prev,
 			     struct list_head *next)
 {
-	if (WARN(next->prev != prev,
-		"list_add corruption. next->prev should be "
-		"prev (%p), but was %p. (next=%p).\n",
-		prev, next->prev, next) ||
-	    WARN(prev->next != next,
-		"list_add corruption. prev->next should be "
-		"next (%p), but was %p. (prev=%p).\n",
-		next, prev->next, prev) ||
-	    WARN(new == prev || new == next,
-		"list_add double add: new=%p, prev=%p, next=%p.\n",
-		new, prev, next))
+	if (unlikely(next->prev != prev)) {
+		printk(KERN_ERR "list_add corruption. next->prev should be "
+			"prev (%p), but was %p. (next=%p).\n",
+			prev, next->prev, next);
+		BUG();
 		return false;
+	}
+	if (unlikely(prev->next != next)) {
+		printk(KERN_ERR "list_add corruption. prev->next should be "
+			"next (%p), but was %p. (prev=%p).\n",
+			next, prev->next, prev);
+		BUG();
+		return false;
+	}
+	if (unlikely(new == prev || new == next)) {
+		printk(KERN_ERR "list_add double add: new=%p, prev=%p, next=%p.\n",
+			new, prev, next);
+		BUG();
+		return false;
+	}
 	return true;
 }
 
@@ -61,19 +69,30 @@ static bool __list_del_entry_debug(struct list_head *entry)
 	prev = entry->prev;
 	next = entry->next;
 
-	if (WARN(next == LIST_POISON1,
-		"list_del corruption, %p->next is LIST_POISON1 (%p)\n",
-		entry, LIST_POISON1) ||
-	    WARN(prev == LIST_POISON2,
-		"list_del corruption, %p->prev is LIST_POISON2 (%p)\n",
-		entry, LIST_POISON2) ||
-	    WARN(prev->next != entry,
-		"list_del corruption. prev->next should be %p, "
-		"but was %p\n", entry, prev->next) ||
-	    WARN(next->prev != entry,
-		"list_del corruption. next->prev should be %p, "
-		"but was %p\n", entry, next->prev))
+	if (unlikely(next == LIST_POISON1)) {
+		printk(KERN_ERR "list_del corruption, %p->next is LIST_POISON1 (%p)\n",
+			entry, LIST_POISON1);
+		BUG();
+		return false;
+	}
+	if (unlikely(prev == LIST_POISON2)) {
+		printk(KERN_ERR "list_del corruption, %p->prev is LIST_POISON2 (%p)\n",
+			entry, LIST_POISON2);
+		BUG();
+		return false;
+	}
+	if (unlikely(entry->prev->next != entry)) {
+		printk(KERN_ERR "list_del corruption. prev->next should be %p, "
+			"but was %p\n", entry, prev->next);
+		BUG();
+		return false;
+	}
+	if (unlikely(entry->next->prev != entry)) {
+		printk(KERN_ERR "list_del corruption. next->prev should be %p, "
+			"but was %p\n", entry, next->prev);
+		BUG();
 		return false;
+	}
 	return true;
 }
 
diff --git a/lib/nlattr.c b/lib/nlattr.c
index fce1e9afc6d9..d44559b80147 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -278,6 +278,8 @@ int nla_memcpy(void *dest, const struct nlattr *src, int count)
 {
 	int minlen = min_t(int, count, nla_len(src));
 
+	BUG_ON(minlen < 0);
+
 	memcpy(dest, nla_data(src), minlen);
 	if (count > minlen)
 		memset(dest + minlen, 0, count - minlen);
diff --git a/lib/rbtree.c b/lib/rbtree.c
index eb8a19fee110..3cb9b612ac67 100644
--- a/lib/rbtree.c
+++ b/lib/rbtree.c
@@ -412,7 +412,9 @@ static inline void dummy_copy(struct rb_node *old, struct rb_node *new) {}
 static inline void dummy_rotate(struct rb_node *old, struct rb_node *new) {}
 
 static const struct rb_augment_callbacks dummy_callbacks = {
-	dummy_propagate, dummy_copy, dummy_rotate
+	.propagate = dummy_propagate,
+	.copy = dummy_copy,
+	.rotate = dummy_rotate
 };
 
 void rb_insert_color(struct rb_node *node, struct rb_root *root)
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 11a12c79127b..2871684ad57c 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -16,6 +16,9 @@
  * - scnprintf and vscnprintf
  */
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+#define __INCLUDED_BY_HIDESYM 1
+#endif
 #include <stdarg.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
@@ -680,7 +683,7 @@ char *symbol_string(char *buf, char *end, void *ptr,
 #ifdef CONFIG_KALLSYMS
 	if (*fmt == 'B')
 		sprint_backtrace(sym, value);
-	else if (*fmt != 'f' && *fmt != 's')
+	else if (*fmt != 'f' && *fmt != 's' && *fmt != 'X')
 		sprint_symbol(sym, value);
 	else
 		sprint_symbol_no_offset(sym, value);
@@ -1470,7 +1473,11 @@ char *flags_string(char *buf, char *end, void *flags_ptr, const char *fmt)
 	return format_flags(buf, end, flags, names);
 }
 
-int kptr_restrict __read_mostly;
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+int kptr_restrict __read_only = 1;
+#else
+int kptr_restrict __read_only;
+#endif
 
 /*
  * Show a '%p' thing.  A kernel extension is that the '%p' is followed
@@ -1481,8 +1488,10 @@ int kptr_restrict __read_mostly;
  *
  * - 'F' For symbolic function descriptor pointers with offset
  * - 'f' For simple symbolic function names without offset
+ * - 'X' For simple symbolic function names without offset approved for use with GRKERNSEC_HIDESYM
  * - 'S' For symbolic direct pointers with offset
  * - 's' For symbolic direct pointers without offset
+ * - 'A' For symbolic direct pointers with offset approved for use with GRKERNSEC_HIDESYM
  * - '[FfSs]R' as above with __builtin_extract_return_addr() translation
  * - 'B' For backtraced symbolic direct pointers with offset
  * - 'R' For decoded struct resource, e.g., [mem 0x0-0x1f 64bit pref]
@@ -1593,6 +1602,14 @@ char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 		/* Fallthrough */
 	case 'S':
 	case 's':
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+		break;
+#else
+		return symbol_string(buf, end, ptr, spec, fmt);
+#endif
+	case 'X':
+		ptr = dereference_function_descriptor(ptr);
+	case 'A':
 	case 'B':
 		return symbol_string(buf, end, ptr, spec, fmt);
 	case 'R':
@@ -1657,6 +1674,8 @@ char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 			va_end(va);
 			return buf;
 		}
+	case 'P':
+		break;
 	case 'K':
 		switch (kptr_restrict) {
 		case 0:
@@ -1686,6 +1705,9 @@ char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 			 */
 			cred = current_cred();
 			if (!has_capability_noaudit(current, CAP_SYSLOG) ||
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+			    !has_capability_noaudit(current, CAP_SYS_ADMIN) ||
+#endif
 			    !uid_eq(cred->euid, cred->uid) ||
 			    !gid_eq(cred->egid, cred->gid))
 				ptr = NULL;
@@ -1719,6 +1741,22 @@ char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 	case 'G':
 		return flags_string(buf, end, ptr, fmt);
 	}
+
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	/* 'P' = approved pointers to copy to userland,
+	   as in the /proc/kallsyms case, as we make it display nothing
+	   for non-root users, and the real contents for root users
+	   'X' = approved simple symbols
+	   Also ignore 'K' pointers, since we force their NULLing for non-root users
+	   above
+	*/
+	if ((unsigned long)ptr > TASK_SIZE && *fmt != 'P' && *fmt != 'X' && *fmt != 'K' && is_usercopy_object(buf)) {
+		printk(KERN_ALERT "grsec: kernel infoleak detected!  Please report this log to spender@grsecurity.net.\n");
+		dump_stack();
+		ptr = NULL;
+	}
+#endif
+
 	spec.flags |= SMALL;
 	if (spec.field_width == -1) {
 		spec.field_width = default_width;
diff --git a/localversion-grsec b/localversion-grsec
new file mode 100644
index 000000000000..7cd6065beb8d
--- /dev/null
+++ b/localversion-grsec
@@ -0,0 +1 @@
+-grsec
diff --git a/mm/Kconfig b/mm/Kconfig
index 980b5ea0f1fb..ab679cfb7b8f 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -344,7 +344,8 @@ config KSM
 config DEFAULT_MMAP_MIN_ADDR
 	int "Low address space to protect from user allocation"
 	depends on MMU
-	default 32768
+	default 32768 if ALPHA || ARM || PARISC || SPARC32
+	default 65536
 	help
 	  This is the portion of low virtual memory which should be protected
 	  from userspace allocation.  Keeping a user from writing to low pages
@@ -377,8 +378,9 @@ config MEMORY_FAILURE
 
 config HWPOISON_INJECT
 	tristate "HWPoison pages injector"
-	depends on MEMORY_FAILURE && DEBUG_KERNEL && PROC_FS
+	depends on MEMORY_FAILURE && DEBUG_KERNEL && PROC_FS && !GRKERNSEC
 	select PROC_PAGE_MONITOR
+	depends on !GRKERNSEC
 
 config NOMMU_INITIAL_TRIM_EXCESS
 	int "Turn on mmap() excess space trimming before booting"
@@ -548,6 +550,7 @@ config MEM_SOFT_DIRTY
 	bool "Track memory changes"
 	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
 	select PROC_PAGE_MONITOR
+	depends on !GRKERNSEC
 	help
 	  This option enables memory changes tracking by introducing a
 	  soft-dirty bit on pte-s. This bit it set when someone writes
@@ -632,6 +635,7 @@ config ZSMALLOC_STAT
 	bool "Export zsmalloc statistics"
 	depends on ZSMALLOC
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	help
 	  This option enables code in the zsmalloc to collect various
 	  statistics about whats happening in zsmalloc and exports that
diff --git a/mm/Kconfig.debug b/mm/Kconfig.debug
index afcc550877ff..ed3f09775601 100644
--- a/mm/Kconfig.debug
+++ b/mm/Kconfig.debug
@@ -10,6 +10,7 @@ config PAGE_EXTENSION
 config DEBUG_PAGEALLOC
 	bool "Debug page memory allocations"
 	depends on DEBUG_KERNEL
+	depends on !PAX_MEMORY_SANITIZE
 	depends on !HIBERNATION || ARCH_SUPPORTS_DEBUG_PAGEALLOC && !PPC && !SPARC
 	depends on !KMEMCHECK
 	select PAGE_EXTENSION
diff --git a/mm/filemap.c b/mm/filemap.c
index 9ce08e7c1336..b6f95cc39b7b 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2547,6 +2547,7 @@ inline ssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)
 	pos = iocb->ki_pos;
 
 	if (limit != RLIM_INFINITY) {
+		gr_learn_resource(current, RLIMIT_FSIZE, iocb->ki_pos, 0);
 		if (iocb->ki_pos >= limit) {
 			send_sig(SIGXFSZ, current, 0);
 			return -EFBIG;
diff --git a/mm/kmemleak.c b/mm/kmemleak.c
index d1380ed93fdf..41c63631f4a3 100644
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -369,7 +369,7 @@ static void print_unreferenced(struct seq_file *seq,
 
 	for (i = 0; i < object->trace_len; i++) {
 		void *ptr = (void *)object->trace[i];
-		seq_printf(seq, "    [<%p>] %pS\n", ptr, ptr);
+		seq_printf(seq, "    [<%pP>] %pA\n", ptr, ptr);
 	}
 }
 
@@ -2010,7 +2010,7 @@ static int __init kmemleak_late_init(void)
 		return -ENOMEM;
 	}
 
-	dentry = debugfs_create_file("kmemleak", S_IRUGO, NULL, NULL,
+	dentry = debugfs_create_file("kmemleak", S_IRUSR, NULL, NULL,
 				     &kmemleak_fops);
 	if (!dentry)
 		pr_warn("Failed to create the debugfs kmemleak file\n");
diff --git a/mm/memory.c b/mm/memory.c
index 9b25a46b0c92..e8b4bc4a0a31 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -698,7 +698,7 @@ static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,
 	/*
 	 * Choose text because data symbols depend on CONFIG_KALLSYMS_ALL=y
 	 */
-	pr_alert("file:%pD fault:%pf mmap:%pf readpage:%pf\n",
+	pr_alert("file:%pD fault:%pX mmap:%pX readpage:%pX\n",
 		 vma->vm_file,
 		 vma->vm_ops ? vma->vm_ops->fault : NULL,
 		 vma->vm_file ? vma->vm_file->f_op->mmap : NULL,
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index 29b6fa72a948..5cb985f467f0 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -1440,8 +1440,7 @@ SYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,
 	 */
 	tcred = __task_cred(task);
 	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
-	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
-	    !capable(CAP_SYS_NICE)) {
+	    !uid_eq(cred->uid,  tcred->suid) && !capable(CAP_SYS_NICE)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out_put;
@@ -1472,6 +1471,15 @@ SYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,
 		goto out;
 	}
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (mm != current->mm &&
+	    (mm->pax_flags & MF_PAX_RANDMMAP || mm->pax_flags & MF_PAX_SEGMEXEC)) {
+		mmput(mm);
+		err = -EPERM;
+		goto out;
+	}
+#endif
+
 	err = do_migrate_pages(mm, old, new,
 		capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
 
diff --git a/mm/migrate.c b/mm/migrate.c
index 66ce6b490b13..c5f0a41f7115 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -1693,8 +1693,7 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
 	 */
 	tcred = __task_cred(task);
 	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
-	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
-	    !capable(CAP_SYS_NICE)) {
+	    !uid_eq(cred->uid,  tcred->suid) && !capable(CAP_SYS_NICE)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
diff --git a/mm/mlock.c b/mm/mlock.c
index b1f0dc1be5dd..70e0033382b5 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -14,6 +14,7 @@
 #include <linux/pagevec.h>
 #include <linux/mempolicy.h>
 #include <linux/syscalls.h>
+#include <linux/security.h>
 #include <linux/sched.h>
 #include <linux/export.h>
 #include <linux/rmap.h>
@@ -704,6 +705,10 @@ static __must_check int do_mlock(unsigned long start, size_t len, vm_flags_t fla
 	}
 
 	/* check against resource limits */
+	if (locked > (ULONG_MAX >> PAGE_SHIFT))
+		gr_learn_resource(current, RLIMIT_MEMLOCK, ULONG_MAX, 1);
+	else
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 	if ((locked <= lock_limit) || capable(CAP_IPC_LOCK))
 		error = apply_vma_lock_flags(start, len, flags);
 
@@ -822,6 +827,10 @@ SYSCALL_DEFINE1(mlockall, int, flags)
 		return -EINTR;
 
 	ret = -ENOMEM;
+	if (current->mm->total_vm > (ULONG_MAX >> PAGE_SHIFT))
+		gr_learn_resource(current, RLIMIT_MEMLOCK, ULONG_MAX, 1);
+	else
+		gr_learn_resource(current, RLIMIT_MEMLOCK, current->mm->total_vm << PAGE_SHIFT, 1);
 	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
 	    capable(CAP_IPC_LOCK))
 		ret = apply_mlockall_flags(flags);
diff --git a/mm/mmap.c b/mm/mmap.c
index c591192b847c..72d400bc2d76 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -44,6 +44,7 @@
 #include <linux/userfaultfd_k.h>
 #include <linux/moduleparam.h>
 #include <linux/pkeys.h>
+#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
@@ -200,6 +201,7 @@ static int do_brk(unsigned long addr, unsigned long len);
 
 SYSCALL_DEFINE1(brk, unsigned long, brk)
 {
+	unsigned long rlim;
 	unsigned long retval;
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current->mm;
@@ -231,7 +233,13 @@ SYSCALL_DEFINE1(brk, unsigned long, brk)
 	 * segment grow beyond its set limit the in case where the limit is
 	 * not page aligned -Ram Gupta
 	 */
-	if (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm->start_brk,
+	rlim = rlimit(RLIMIT_DATA);
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	/* force a minimum 16MB brk heap on setuid/setgid binaries */
+	if (rlim < (4096 * PAGE_SIZE) && (get_dumpable(mm) != SUID_DUMP_USER) && gr_is_global_nonroot(current_uid()))
+		rlim = 4096 * PAGE_SIZE;
+#endif
+	if (check_data_rlimit(rlim, brk, mm->start_brk,
 			      mm->end_data, mm->start_data))
 		goto out;
 
@@ -1369,6 +1377,10 @@ static inline int mlock_future_check(struct mm_struct *mm,
 		locked += mm->locked_vm;
 		lock_limit = rlimit(RLIMIT_MEMLOCK);
 		lock_limit >>= PAGE_SHIFT;
+		if (locked > (ULONG_MAX >> PAGE_SHIFT))
+			gr_learn_resource(current, RLIMIT_MEMLOCK, ULONG_MAX, 1);
+		else
+			gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
 	}
@@ -1439,7 +1451,16 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 
 #ifdef CONFIG_PAX_MPROTECT
 	if (mm->pax_flags & MF_PAX_MPROTECT) {
-		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC))
+
+#ifdef CONFIG_GRKERNSEC_RWXMAP_LOG
+		if (file && !pgoff && (vm_flags & VM_EXEC) && mm->binfmt &&
+		    mm->binfmt->handle_mmap)
+			mm->binfmt->handle_mmap(file);
+#endif
+
+#ifndef CONFIG_PAX_MPROTECT_COMPAT
+		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC)) {
+			gr_log_rwxmmap(file);
 
 #ifdef CONFIG_PAX_EMUPLT
 			vm_flags &= ~VM_EXEC;
@@ -1447,8 +1468,14 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 			return -EPERM;
 #endif
 
+		}
+
 		if (!(vm_flags & VM_EXEC))
 			vm_flags &= ~VM_MAYEXEC;
+#else
+		if ((vm_flags & (VM_WRITE | VM_EXEC)) != VM_EXEC)
+			vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+#endif
 		else
 			vm_flags &= ~VM_MAYWRITE;
 	}
@@ -1546,6 +1573,9 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 			vm_flags |= VM_NORESERVE;
 	}
 
+	if (!gr_acl_handle_mmap(file, prot))
+		return -EACCES;
+	
 	addr = mmap_region(file, addr, len, vm_flags, pgoff);
 	if (!IS_ERR_VALUE(addr) &&
 	    ((vm_flags & VM_LOCKED) ||
@@ -1891,7 +1921,17 @@ unsigned long mmap_region(struct file *file, unsigned long addr,
 	return error;
 }
 
-bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len)
+#ifdef CONFIG_GRKERNSEC_RAND_THREADSTACK
+unsigned long gr_rand_threadstack_offset(const struct mm_struct *mm, const struct file *filp, unsigned long flags)
+{
+	if ((mm->pax_flags & MF_PAX_RANDMMAP) && !filp && (flags & MAP_STACK))
+		return ((prandom_u32() & 0xFF) + 1) << PAGE_SHIFT;
+
+	return 0;
+}
+#endif
+
+bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len, unsigned long offset)
 {
 	if (!vma) {
 #ifdef CONFIG_STACK_GROWSUP
@@ -1914,6 +1954,8 @@ bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr,
 	else if (vma->vm_prev && (vma->vm_prev->vm_flags & VM_GROWSUP))
 		return addr - vma->vm_prev->vm_end >= sysctl_heap_stack_gap;
 #endif
+	else if (offset)
+		return offset <= vma->vm_start - addr - len;
 
 	return true;
 }
@@ -1983,6 +2025,11 @@ unsigned long unmapped_area(const struct vm_unmapped_area_info *info)
 		gap_start += skip_heap_stack_gap(vma->vm_prev, VM_GROWSUP, gap_start, gap_end);
 		gap_end -= skip_heap_stack_gap(vma, VM_GROWSDOWN, gap_start, gap_end);
 
+		if (gap_end - gap_start > info->threadstack_offset)
+			gap_start += info->threadstack_offset;
+		else
+			gap_start = gap_end;
+
 		if (gap_end >= low_limit && gap_end - gap_start >= length)
 			goto found;
 
@@ -2090,6 +2137,11 @@ unsigned long unmapped_area_topdown(const struct vm_unmapped_area_info *info)
 		gap_start += skip_heap_stack_gap(vma->vm_prev, VM_GROWSUP, gap_start, gap_end);
 		gap_end -= skip_heap_stack_gap(vma, VM_GROWSDOWN, gap_start, gap_end);
 
+		if (gap_end - gap_start > info->threadstack_offset)
+			gap_end -= info->threadstack_offset;
+		else
+			gap_end = gap_start;
+
 		if (gap_start <= high_limit && gap_end - gap_start >= length)
 			goto found;
 
@@ -2153,6 +2205,7 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	struct vm_unmapped_area_info info;
+	unsigned long offset = gr_rand_threadstack_offset(mm, filp, flags);
 
 	if (len > TASK_SIZE - mmap_min_addr)
 		return -ENOMEM;
@@ -2168,7 +2221,7 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&
-		    check_heap_stack_gap(vma, addr, len))
+		    check_heap_stack_gap(vma, addr, len, offset))
 			return addr;
 	}
 
@@ -2177,6 +2230,7 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,
 	info.low_limit = mm->mmap_base;
 	info.high_limit = TASK_SIZE;
 	info.align_mask = 0;
+	info.threadstack_offset = offset;
 	return vm_unmapped_area(&info);
 }
 #endif
@@ -2195,6 +2249,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
 	struct mm_struct *mm = current->mm;
 	unsigned long addr = addr0;
 	struct vm_unmapped_area_info info;
+	unsigned long offset = gr_rand_threadstack_offset(mm, filp, flags);
 
 	/* requested length too big for entire address space */
 	if (len > TASK_SIZE - mmap_min_addr)
@@ -2212,7 +2267,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&
-				check_heap_stack_gap(vma, addr, len))
+				check_heap_stack_gap(vma, addr, len, offset))
 			return addr;
 	}
 
@@ -2221,6 +2276,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
 	info.low_limit = max(PAGE_SIZE, mmap_min_addr);
 	info.high_limit = mm->mmap_base;
 	info.align_mask = 0;
+	info.threadstack_offset = offset;
 	addr = vm_unmapped_area(&info);
 
 	/*
@@ -2387,6 +2443,7 @@ static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns
 
 	/* Stack limit test */
 	actual_size = size;
+	gr_learn_resource(current, RLIMIT_STACK, actual_size, 1);
 	if (actual_size > READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))
 		return -ENOMEM;
 
@@ -2397,6 +2454,10 @@ static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns
 		locked = mm->locked_vm + grow;
 		limit = READ_ONCE(rlim[RLIMIT_MEMLOCK].rlim_cur);
 		limit >>= PAGE_SHIFT;
+		if (locked > (ULONG_MAX >> PAGE_SHIFT))
+			gr_learn_resource(current, RLIMIT_MEMLOCK, ULONG_MAX, 1);
+		else
+			gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 		if (locked > limit && !capable(CAP_IPC_LOCK))
 			return -ENOMEM;
 	}
@@ -2422,6 +2483,9 @@ static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns
  * PA-RISC uses this for its stack; IA64 for its Register Backing Store.
  * vma is the last one with address > vma->vm_end.  Have to extend vma.
  */
+#ifndef CONFIG_IA64
+static
+#endif
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	struct mm_struct *mm = vma->vm_mm;
@@ -3382,6 +3446,9 @@ int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)
 	     security_vm_enough_memory_mm(mm, vma_pages(vma)))
 		return -ENOMEM;
 
+	if (security_mmap_addr(vma->vm_start))
+		return -EPERM;
+
 	/*
 	 * The vm_pgoff of a purely anonymous vma should be irrelevant
 	 * until its first write fault, when page's anon_vma and index
@@ -3539,21 +3606,31 @@ long pax_mirror_vma(struct vm_area_struct *vma_m, struct vm_area_struct *vma)
  */
 bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)
 {
+	if ((mm->total_vm + npages) > (ULONG_MAX >> PAGE_SHIFT))
+		gr_learn_resource(current, RLIMIT_AS, ULONG_MAX, 1);
+	else
+		gr_learn_resource(current, RLIMIT_AS, (mm->total_vm + npages) << PAGE_SHIFT, 1);
+
 	if (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)
 		return false;
 
-	if (is_data_mapping(flags) &&
-	    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {
-		/* Workaround for Valgrind */
-		if (rlimit(RLIMIT_DATA) == 0 &&
-		    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)
-			return true;
-		if (!ignore_rlimit_data) {
-			pr_warn_once("%s (%d): VmData %lu exceed data ulimit %lu. Update limits or use boot option ignore_rlimit_data.\n",
-				     current->comm, current->pid,
-				     (mm->data_vm + npages) << PAGE_SHIFT,
-				     rlimit(RLIMIT_DATA));
-			return false;
+	if (is_data_mapping(flags)) {
+		if ((mm->data_vm + npages) > (ULONG_MAX >> PAGE_SHIFT))
+			gr_learn_resource(current, RLIMIT_DATA, ULONG_MAX, 1);
+		else
+			gr_learn_resource(current, RLIMIT_DATA, (mm->data_vm + npages) << PAGE_SHIFT, 1);
+		if (mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {
+			/* Workaround for Valgrind */
+			if (rlimit(RLIMIT_DATA) == 0 &&
+			    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)
+				return true;
+			if (!ignore_rlimit_data) {
+				pr_warn_once("%s (%d): VmData %lu exceed data ulimit %lu. Update limits or use boot option ignore_rlimit_data.\n",
+					     current->comm, current->pid,
+					     (mm->data_vm + npages) << PAGE_SHIFT,
+					     rlimit(RLIMIT_DATA));
+				return false;
+			}
 		}
 	}
 
@@ -3663,10 +3740,15 @@ static struct vm_area_struct *__install_special_mapping(
 
 #ifdef CONFIG_PAX_MPROTECT
 	if (mm->pax_flags & MF_PAX_MPROTECT) {
+#ifndef CONFIG_PAX_MPROTECT_COMPAT
 		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC))
 			return ERR_PTR(-EPERM);
 		if (!(vm_flags & VM_EXEC))
 			vm_flags &= ~VM_MAYEXEC;
+#else
+		if ((vm_flags & (VM_WRITE | VM_EXEC)) != VM_EXEC)
+			vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+#endif
 		else
 			vm_flags &= ~VM_MAYWRITE;
 	}
diff --git a/mm/mprotect.c b/mm/mprotect.c
index a6a2dca595ec..5a4f86ea2d3b 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -576,6 +576,14 @@ static int do_mprotect_pkey(unsigned long start, size_t len,
 
 		/* newflags >> 4 shift VM_MAY% in place of VM_% */
 		if ((newflags & ~(newflags >> 4)) & (VM_READ | VM_WRITE | VM_EXEC)) {
+			if (prot & (PROT_WRITE | PROT_EXEC))
+				gr_log_rwxmprotect(vma);
+
+			error = -EACCES;
+			goto out;
+		}
+
+		if (!gr_acl_handle_mprotect(vma->vm_file, prot)) {
 			error = -EACCES;
 			goto out;
 		}
diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c
index b80063d0f24b..d763a7810196 100644
--- a/mm/process_vm_access.c
+++ b/mm/process_vm_access.c
@@ -13,6 +13,7 @@
 #include <linux/uio.h>
 #include <linux/sched.h>
 #include <linux/highmem.h>
+#include <linux/security.h>
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/syscalls.h>
@@ -202,6 +203,11 @@ static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,
 		goto free_proc_pages;
 	}
 
+	if (gr_handle_ptrace(task, vm_write ? PTRACE_POKETEXT : PTRACE_ATTACH)) {
+		rc = -EPERM;
+		goto put_task_struct;
+	}
+
 	mm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
diff --git a/mm/shmem.c b/mm/shmem.c
index 107951b11e71..054adce386fa 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -34,7 +34,7 @@
 #include <linux/uio.h>
 #include <linux/khugepaged.h>
 
-static struct vfsmount *shm_mnt;
+struct vfsmount *shm_mnt;
 
 #ifdef CONFIG_SHMEM
 /*
diff --git a/mm/slab.c b/mm/slab.c
index 64a417a8faac..d9233f3b49ec 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -116,6 +116,7 @@
 #include	<linux/kmemcheck.h>
 #include	<linux/memory.h>
 #include	<linux/prefetch.h>
+#include	<linux/vmalloc.h>
 
 #include	<net/sock.h>
 
@@ -4462,7 +4463,7 @@ static const struct file_operations proc_slabstats_operations = {
 static int __init slab_proc_init(void)
 {
 #ifdef CONFIG_DEBUG_SLAB_LEAK
-	proc_create("slab_allocators", 0, NULL, &proc_slabstats_operations);
+	proc_create("slab_allocators", S_IRUSR, NULL, &proc_slabstats_operations);
 #endif
 	return 0;
 }
@@ -4479,6 +4480,17 @@ bool is_usercopy_object(const void *ptr)
 	if (!slab_is_available())
 		return false;
 
+	if (is_vmalloc_addr(ptr)
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	    && !object_starts_on_stack(ptr)
+#endif
+	) {
+		struct vm_struct *vm = find_vm_area(ptr);
+		if (vm && (vm->flags & VM_USERCOPY))
+			return true;
+		return false;
+	}
+
 	if (!virt_addr_valid(ptr))
 		return false;
 
diff --git a/mm/slab_common.c b/mm/slab_common.c
index 58e689f9fb47..cb5d8a422244 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -490,7 +490,8 @@ struct kmem_cache *
 kmem_cache_create(const char *name, size_t size, size_t align,
 		  unsigned long flags, void (*ctor)(void *))
 {
-	return __kmem_cache_create_usercopy(name, size, align, flags, 0, 0, ctor);
+	return __kmem_cache_create_usercopy(name, size, align, flags, 0,
+		(flags & SLAB_USERCOPY) ? size : 0, ctor);
 }
 EXPORT_SYMBOL(kmem_cache_create);
 
@@ -524,7 +525,7 @@ static void release_caches(struct list_head *release, bool need_rcu_barrier)
 		rcu_barrier();
 
 	list_for_each_entry_safe(s, s2, release, list) {
-#ifdef SLAB_SUPPORTS_SYSFS
+#if defined(SLAB_SUPPORTS_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 		sysfs_slab_remove(s);
 #else
 		slab_kmem_cache_release(s);
diff --git a/mm/slob.c b/mm/slob.c
index 7ee5f36aa90f..73c02bace82d 100644
--- a/mm/slob.c
+++ b/mm/slob.c
@@ -67,6 +67,7 @@
 #include <linux/rcupdate.h>
 #include <linux/list.h>
 #include <linux/kmemleak.h>
+#include <linux/vmalloc.h>
 
 #include <trace/events/kmem.h>
 
@@ -546,6 +547,17 @@ bool is_usercopy_object(const void *ptr)
 	if (!slab_is_available())
 		return false;
 
+	if (is_vmalloc_addr(ptr)
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	    && !object_starts_on_stack(ptr)
+#endif
+	) {
+		struct vm_struct *vm = find_vm_area(ptr);
+		if (vm && (vm->flags & VM_USERCOPY))
+			return true;
+		return false;
+	}
+
 	if (!virt_addr_valid(ptr))
 		return false;
 
diff --git a/mm/slub.c b/mm/slub.c
index 0cc4317cfc31..5566ff1577f3 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -211,7 +211,7 @@ struct track {
 
 enum track_item { TRACK_ALLOC, TRACK_FREE };
 
-#ifdef CONFIG_SYSFS
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 static int sysfs_slab_add(struct kmem_cache *);
 static int sysfs_slab_alias(struct kmem_cache *, const char *);
 static void memcg_propagate_slab_attrs(struct kmem_cache *s);
@@ -237,30 +237,40 @@ static inline void stat(const struct kmem_cache *s, enum stat_item si)
  * 			Core slab cache functions
  *******************************************************************/
 
+static const unsigned long global_rand __latent_entropy;
+
 static inline void *get_freepointer(struct kmem_cache *s, void *object)
 {
-	return *(void **)(object + s->offset);
+	unsigned long freepointer_addr = (unsigned long)object + s->offset;
+	return (void *)(*(unsigned long *)freepointer_addr ^ global_rand ^ freepointer_addr);
 }
 
 static void prefetch_freepointer(const struct kmem_cache *s, void *object)
 {
-	prefetch(object + s->offset);
+	unsigned long freepointer_addr = (unsigned long)object + s->offset;
+	if (object) {
+		void **freepointer_ptr = (void **)(*(unsigned long *)freepointer_addr ^ global_rand ^ freepointer_addr);
+		prefetch(freepointer_ptr);
+	}
 }
 
 static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)
 {
+	unsigned long freepointer_addr;
 	void *p;
 
 	if (!debug_pagealloc_enabled())
 		return get_freepointer(s, object);
 
-	probe_kernel_read(&p, (void **)(object + s->offset), sizeof(p));
-	return p;
+	freepointer_addr = (unsigned long)object + s->offset;
+	probe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));
+	return (void *)((unsigned long)p ^ global_rand ^ freepointer_addr);
 }
 
 static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)
 {
-	*(void **)(object + s->offset) = fp;
+	unsigned long freepointer_addr = (unsigned long)object + s->offset;
+	*(void **)freepointer_addr = (void *)((unsigned long)fp ^ global_rand ^ freepointer_addr);
 }
 
 /* Loop over all objects in a slab */
@@ -566,7 +576,7 @@ static void print_track(const char *s, struct track *t)
 	if (!t->addr)
 		return;
 
-	pr_err("INFO: %s in %pS age=%lu cpu=%u pid=%d\n",
+	pr_err("INFO: %s in %pA age=%lu cpu=%u pid=%d\n",
 	       s, (void *)t->addr, jiffies - t->when, t->cpu, t->pid);
 #ifdef CONFIG_STACKTRACE
 	{
@@ -3815,6 +3825,17 @@ bool is_usercopy_object(const void *ptr)
 	if (!slab_is_available())
 		return false;
 
+	if (is_vmalloc_addr(ptr)
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	    && !object_starts_on_stack(ptr)
+#endif
+	) {
+		struct vm_struct *vm = find_vm_area(ptr);
+		if (vm && (vm->flags & VM_USERCOPY))
+			return true;
+		return false;
+	}
+
 	if (!virt_addr_valid(ptr))
 		return false;
 
@@ -4312,7 +4333,7 @@ void *__kmalloc_node_track_caller(size_t size, gfp_t gfpflags,
 }
 #endif
 
-#ifdef CONFIG_SYSFS
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 static int count_inuse(struct page *page)
 {
 	return page->inuse;
@@ -4593,7 +4614,11 @@ static int list_locations(struct kmem_cache *s, char *buf,
 		len += sprintf(buf + len, "%7ld ", l->count);
 
 		if (l->addr)
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+			len += sprintf(buf + len, "%pS", NULL);
+#else
 			len += sprintf(buf + len, "%pS", (void *)l->addr);
+#endif
 		else
 			len += sprintf(buf + len, "<not-available>");
 
@@ -4691,12 +4716,12 @@ static void __init resiliency_test(void)
 	validate_slab_cache(kmalloc_caches[9]);
 }
 #else
-#ifdef CONFIG_SYSFS
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 static void resiliency_test(void) {};
 #endif
 #endif
 
-#ifdef CONFIG_SYSFS
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 enum slab_stat_type {
 	SL_ALL,			/* All slabs */
 	SL_PARTIAL,		/* Only partially allocated slabs */
@@ -4933,7 +4958,11 @@ static ssize_t ctor_show(struct kmem_cache *s, char *buf)
 {
 	if (!s->ctor)
 		return 0;
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	return sprintf(buf, "%pS\n", NULL);
+#else
 	return sprintf(buf, "%pS\n", s->ctor);
+#endif
 }
 SLAB_ATTR_RO(ctor);
 
@@ -5632,6 +5661,7 @@ static char *create_unique_id(struct kmem_cache *s)
 	return name;
 }
 
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 static int sysfs_slab_add(struct kmem_cache *s)
 {
 	int err;
@@ -5703,6 +5733,7 @@ void sysfs_slab_remove(struct kmem_cache *s)
 	kobject_del(&s->kobj);
 	kobject_put(&s->kobj);
 }
+#endif
 
 /*
  * Need to buffer aliases during bootup until sysfs becomes
@@ -5716,6 +5747,7 @@ struct saved_alias {
 
 static struct saved_alias *alias_list;
 
+#if defined(CONFIG_SYSFS) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 static int sysfs_slab_alias(struct kmem_cache *s, const char *name)
 {
 	struct saved_alias *al;
@@ -5738,6 +5770,7 @@ static int sysfs_slab_alias(struct kmem_cache *s, const char *name)
 	alias_list = al;
 	return 0;
 }
+#endif
 
 static int __init slab_sysfs_init(void)
 {
diff --git a/mm/usercopy.c b/mm/usercopy.c
index 8b3fb1c5bc4e..3dfb587e0e61 100644
--- a/mm/usercopy.c
+++ b/mm/usercopy.c
@@ -94,8 +94,17 @@ static bool overlaps(const void *ptr, unsigned long n, unsigned long low,
 static inline const char *check_kernel_text_object(const void *ptr,
 						   unsigned long n)
 {
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	unsigned long textlow = ktla_ktva((unsigned long)_stext);
+#ifdef CONFIG_MODULES
+	unsigned long texthigh = (unsigned long)MODULES_EXEC_VADDR;
+#else
+	unsigned long texthigh = ktla_ktva((unsigned long)_etext);
+#endif
+#else
 	unsigned long textlow = (unsigned long)_stext;
 	unsigned long texthigh = (unsigned long)_etext;
+#endif
 	unsigned long textlow_linear, texthigh_linear;
 
 	if (overlaps(ptr, n, textlow, texthigh))
@@ -256,12 +265,10 @@ void __check_object_size(const void *ptr, unsigned long n, bool to_user)
 	switch (check_stack_object((unsigned long)ptr, n)) {
 	case NOT_STACK:
 		/* Object is not touching the current process stack. */
-#ifdef CONFIG_BROKEN_SECURITY
 		/* Check for object in kernel to avoid text exposure. */
 		err = check_kernel_text_object(ptr, n);
 		if (err)
 			break;
-#endif
 		return;
 
 	case GOOD_FRAME:
diff --git a/mm/util.c b/mm/util.c
index a4805fd7319c..344fbfb87d9d 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -134,7 +134,7 @@ void *memdup_user(const void __user *src, size_t len)
 	 * cause pagefault, which makes it pointless to use GFP_NOFS
 	 * or GFP_ATOMIC.
 	 */
-	p = kmalloc_track_caller(len, GFP_KERNEL);
+	p = kmalloc_track_caller(len, GFP_KERNEL|GFP_USERCOPY);
 	if (!p)
 		return ERR_PTR(-ENOMEM);
 
@@ -621,6 +621,9 @@ int get_cmdline(struct task_struct *task, char *buffer, int buflen)
 	if (!mm->arg_end)
 		goto out_mm;	/* Shh! No looking before we're done */
 
+	if (gr_acl_handle_procpidmem(task))
+		goto out_mm;
+
 	down_read(&mm->mmap_sem);
 	arg_start = mm->arg_start;
 	arg_end = mm->arg_end;
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index f6dfe4de0fcb..333cf4377324 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -45,6 +45,21 @@ struct vfree_deferred {
 static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);
 static DEFINE_PER_CPU(struct vfree_deferred, vunmap_deferred);
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+struct stack_deferred_llist {
+	struct llist_head list;
+	void *stack;
+	void *lowmem_stack;
+};
+
+struct stack_deferred {
+	struct stack_deferred_llist list;
+	struct work_struct wq;
+};
+
+static DEFINE_PER_CPU(struct stack_deferred, stack_deferred);
+#endif
+
 static void __vunmap(const void *, int);
 
 static void vfree_work(struct work_struct *w)
@@ -52,9 +67,9 @@ static void vfree_work(struct work_struct *w)
 	struct vfree_deferred *p = container_of(w, struct vfree_deferred, wq);
 	struct llist_node *llnode = llist_del_all(&p->list);
 	while (llnode) {
-		void *p = llnode;
+		void *x = llnode;
 		llnode = llist_next(llnode);
-		__vunmap(p, 1);
+		__vunmap(x, 1);
 	}
 }
 
@@ -63,12 +78,30 @@ static void vunmap_work(struct work_struct *w)
 	struct vfree_deferred *p = container_of(w, struct vfree_deferred, wq);
 	struct llist_node *llnode = llist_del_all(&p->list);
 	while (llnode) {
-		void *p = llnode;
+		void *x = llnode;
 		llnode = llist_next(llnode);
-		__vunmap(p, 0);
+		__vunmap(x, 0);
 	}
 }
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+static void unmap_work(struct work_struct *w)
+{
+	struct stack_deferred *p = container_of(w, struct stack_deferred, wq);
+	struct llist_node *llnode = llist_del_all(&p->list.list);
+	while (llnode) {
+		struct stack_deferred_llist *x =
+			llist_entry((struct llist_head *)llnode,
+				     struct stack_deferred_llist, list);
+		void *stack = ACCESS_ONCE(x->stack);
+		void *lowmem_stack = ACCESS_ONCE(x->lowmem_stack);
+		llnode = llist_next(llnode);
+		__vunmap(stack, 0);
+		free_pages((unsigned long)lowmem_stack, THREAD_SIZE_ORDER);
+	}
+}
+#endif
+
 /*** Page table manipulation functions ***/
 
 static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)
@@ -1278,6 +1311,9 @@ void __init vmalloc_init(void)
 	for_each_possible_cpu(i) {
 		struct vmap_block_queue *vbq;
 		struct vfree_deferred *p;
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+		struct stack_deferred *p2;
+#endif
 
 		vbq = &per_cpu(vmap_block_queue, i);
 		spin_lock_init(&vbq->lock);
@@ -1290,6 +1326,12 @@ void __init vmalloc_init(void)
 		p = &per_cpu(vunmap_deferred, i);
 		init_llist_head(&p->list);
 		INIT_WORK(&p->wq, vunmap_work);
+
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+		p2 = &per_cpu(stack_deferred, i);
+		init_llist_head(&p2->list.list);
+		INIT_WORK(&p2->wq, unmap_work);
+#endif
 	}
 
 	/* Import existing vmlist entries. */
@@ -1436,7 +1478,11 @@ static struct vm_struct *__get_vm_area_node(unsigned long size,
 	if (unlikely(!area))
 		return NULL;
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+	if (!(flags & VM_NO_GUARD) || (start >= VMALLOC_START && end <= VMALLOC_END))
+#else
 	if (!(flags & VM_NO_GUARD))
+#endif
 		size += PAGE_SIZE;
 
 	va = alloc_vmap_area(size, align, start, end, node, gfp_mask);
@@ -1620,7 +1666,6 @@ void vunmap(const void *addr)
 {
 	if (!addr)
 		return;
-
 	if (unlikely(in_interrupt())) {
 		struct vfree_deferred *p = this_cpu_ptr(&vunmap_deferred);
 		if (pax_llist_add((struct llist_node *)addr, &p->list))
@@ -1632,6 +1677,23 @@ void vunmap(const void *addr)
 }
 EXPORT_SYMBOL(vunmap);
 
+#ifdef CONFIG_GRKERNSEC_KSTACKOVERFLOW
+void unmap_process_stacks(struct task_struct *task)
+{
+	if (unlikely(in_interrupt())) {
+		struct stack_deferred *p = this_cpu_ptr(&stack_deferred);
+		struct stack_deferred_llist *list = task->stack;
+		list->stack = task->stack;
+		list->lowmem_stack = task->lowmem_stack;
+		if (llist_add((struct llist_node *)&list->list, &p->list.list))
+			schedule_work(&p->wq);
+	} else {
+		__vunmap(task->stack, 0);
+		free_pages((unsigned long)task->lowmem_stack, THREAD_SIZE_ORDER);
+	}
+}
+#endif
+
 /**
  *	vmap  -  map an array of pages into virtually contiguous space
  *	@pages:		array of page pointers
@@ -1820,6 +1882,14 @@ static void *__vmalloc_node(unsigned long size, unsigned long align,
 				gfp_mask, prot, 0, node, caller);
 }
 
+void *vmalloc_usercopy(unsigned long size)
+{
+	return __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,
+				    GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL,
+				    VM_USERCOPY, NUMA_NO_NODE,
+				    __builtin_return_address(0));
+}
+
 void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
 {
 	return __vmalloc_node(size, 1, gfp_mask, prot, NUMA_NO_NODE,
@@ -2736,7 +2806,11 @@ static int s_show(struct seq_file *m, void *p)
 		v->addr, v->addr + v->size, v->size);
 
 	if (v->caller)
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+		seq_printf(m, " %pK", v->caller);
+#else
 		seq_printf(m, " %pS", v->caller);
+#endif
 
 	if (v->nr_pages)
 		seq_printf(m, " pages=%d", v->nr_pages);
diff --git a/mm/vmstat.c b/mm/vmstat.c
index ebb9e91c2e90..6e8df6a7ef5c 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -27,6 +27,7 @@
 #include <linux/mm_inline.h>
 #include <linux/page_ext.h>
 #include <linux/page_owner.h>
+#include <linux/grsecurity.h>
 
 #include "internal.h"
 
@@ -1477,10 +1478,22 @@ static void *vmstat_start(struct seq_file *m, loff_t *pos)
 	stat_items_size += sizeof(struct vm_event_state);
 #endif
 
-	v = kmalloc(stat_items_size, GFP_KERNEL);
+	v = kzalloc(stat_items_size, GFP_KERNEL);
 	m->private = v;
 	if (!v)
 		return ERR_PTR(-ENOMEM);
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+        if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+                && !in_group_p(grsec_proc_gid)
+#endif
+        )
+		return (unsigned long *)m->private + *pos;
+#endif
+#endif
+
 	for (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)
 		v[i] = global_page_state(i);
 	v += NR_VM_ZONE_STAT_ITEMS;
@@ -1791,10 +1804,16 @@ static int __init setup_vmstat(void)
 	cpu_notifier_register_done();
 #endif
 #ifdef CONFIG_PROC_FS
-	proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
-	proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
-	proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
-	proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
+	{
+		mode_t gr_mode = S_IRUGO;
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+		gr_mode = S_IRUSR;
+#endif
+		proc_create("buddyinfo", gr_mode, NULL, &fragmentation_file_operations);
+		proc_create("pagetypeinfo", gr_mode, NULL, &pagetypeinfo_file_ops);
+		proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
+		proc_create("zoneinfo", gr_mode, NULL, &proc_zoneinfo_file_operations);
+	}
 #endif
 	return 0;
 }
diff --git a/net/appletalk/atalk_proc.c b/net/appletalk/atalk_proc.c
index af46bc49e1e9..f9adfcdfd5c9 100644
--- a/net/appletalk/atalk_proc.c
+++ b/net/appletalk/atalk_proc.c
@@ -256,7 +256,7 @@ int __init atalk_proc_init(void)
 	struct proc_dir_entry *p;
 	int rc = -ENOMEM;
 
-	atalk_proc_dir = proc_mkdir("atalk", init_net.proc_net);
+	atalk_proc_dir = proc_mkdir_restrict("atalk", init_net.proc_net);
 	if (!atalk_proc_dir)
 		goto out;
 
diff --git a/net/atm/lec.c b/net/atm/lec.c
index 5d2693826afb..fddc41a03767 100644
--- a/net/atm/lec.c
+++ b/net/atm/lec.c
@@ -111,9 +111,9 @@ static inline void lec_arp_put(struct lec_arp_table *entry)
 }
 
 static struct lane2_ops lane2_ops = {
-	lane2_resolve,		/* resolve,             spec 3.1.3 */
-	lane2_associate_req,	/* associate_req,       spec 3.1.4 */
-	NULL			/* associate indicator, spec 3.1.5 */
+	.resolve = lane2_resolve,
+	.associate_req = lane2_associate_req,
+	.associate_indicator = NULL
 };
 
 static unsigned char bus_mac[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
diff --git a/net/atm/mpoa_caches.c b/net/atm/mpoa_caches.c
index 9e60e74c807d..a89fdebeffda 100644
--- a/net/atm/mpoa_caches.c
+++ b/net/atm/mpoa_caches.c
@@ -535,33 +535,32 @@ static void eg_destroy_cache(struct mpoa_client *mpc)
 
 
 static const struct in_cache_ops ingress_ops = {
-	in_cache_add_entry,               /* add_entry       */
-	in_cache_get,                     /* get             */
-	in_cache_get_with_mask,           /* get_with_mask   */
-	in_cache_get_by_vcc,              /* get_by_vcc      */
-	in_cache_put,                     /* put             */
-	in_cache_remove_entry,            /* remove_entry    */
-	cache_hit,                        /* cache_hit       */
-	clear_count_and_expired,          /* clear_count     */
-	check_resolving_entries,          /* check_resolving */
-	refresh_entries,                  /* refresh         */
-	in_destroy_cache                  /* destroy_cache   */
+	.add_entry = in_cache_add_entry,
+	.get = in_cache_get,
+	.get_with_mask = in_cache_get_with_mask,
+	.get_by_vcc = in_cache_get_by_vcc,
+	.put = in_cache_put,
+	.remove_entry = in_cache_remove_entry,
+	.cache_hit = cache_hit,
+	.clear_count = clear_count_and_expired,
+	.check_resolving = check_resolving_entries,
+	.refresh = refresh_entries,
+	.destroy_cache = in_destroy_cache
 };
 
 static const struct eg_cache_ops egress_ops = {
-	eg_cache_add_entry,               /* add_entry        */
-	eg_cache_get_by_cache_id,         /* get_by_cache_id  */
-	eg_cache_get_by_tag,              /* get_by_tag       */
-	eg_cache_get_by_vcc,              /* get_by_vcc       */
-	eg_cache_get_by_src_ip,           /* get_by_src_ip    */
-	eg_cache_put,                     /* put              */
-	eg_cache_remove_entry,            /* remove_entry     */
-	update_eg_cache_entry,            /* update           */
-	clear_expired,                    /* clear_expired    */
-	eg_destroy_cache                  /* destroy_cache    */
+	.add_entry = eg_cache_add_entry,
+	.get_by_cache_id = eg_cache_get_by_cache_id,
+	.get_by_tag = eg_cache_get_by_tag,
+	.get_by_vcc = eg_cache_get_by_vcc,
+	.get_by_src_ip = eg_cache_get_by_src_ip,
+	.put = eg_cache_put,
+	.remove_entry = eg_cache_remove_entry,
+	.update = update_eg_cache_entry,
+	.clear_expired = clear_expired,
+	.destroy_cache = eg_destroy_cache
 };
 
-
 void atm_mpoa_init_cache(struct mpoa_client *mpc)
 {
 	mpc->in_ops = &ingress_ops;
diff --git a/net/can/bcm.c b/net/can/bcm.c
index e4f694dfcf83..62ad3135cf89 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -1699,7 +1699,7 @@ static int __init bcm_module_init(void)
 	}
 
 	/* create /proc/net/can-bcm directory */
-	proc_dir = proc_mkdir("can-bcm", init_net.proc_net);
+	proc_dir = proc_mkdir_restrict("can-bcm", init_net.proc_net);
 	return 0;
 }
 
diff --git a/net/can/proc.c b/net/can/proc.c
index 85ef7bb0f176..84c0fec26ac8 100644
--- a/net/can/proc.c
+++ b/net/can/proc.c
@@ -514,7 +514,7 @@ static void can_remove_proc_readentry(const char *name)
 void can_init_proc(void)
 {
 	/* create /proc/net/can directory */
-	can_dir = proc_mkdir("can", init_net.proc_net);
+	can_dir = proc_mkdir_restrict("can", init_net.proc_net);
 
 	if (!can_dir) {
 		pr_info("can: failed to create /proc/net/can.\n");
diff --git a/net/core/dev_ioctl.c b/net/core/dev_ioctl.c
index b94b1d293506..da3ed7c4e08e 100644
--- a/net/core/dev_ioctl.c
+++ b/net/core/dev_ioctl.c
@@ -368,8 +368,13 @@ void dev_load(struct net *net, const char *name)
 	no_module = !dev;
 	if (no_module && capable(CAP_NET_ADMIN))
 		no_module = request_module("netdev-%s", name);
-	if (no_module && capable(CAP_SYS_MODULE))
+	if (no_module && capable(CAP_SYS_MODULE)) {
+#ifdef CONFIG_GRKERNSEC_MODHARDEN
+		___request_module(true, "grsec_modharden_netdev", "%s", name);
+#else
 		request_module("%s", name);
+#endif
+	}
 }
 EXPORT_SYMBOL(dev_load);
 
diff --git a/net/core/filter.c b/net/core/filter.c
index 1e16cbf9cc52..2c5b949e871b 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -593,7 +593,11 @@ static int bpf_convert_filter(struct sock_filter *prog, int len,
 
 		/* Unknown instruction. */
 		default:
-			goto err;
+			WARN(1, KERN_ALERT "Unknown sock filter code:%u jt:%u tf:%u k:%u\n",
+				       fp->code, fp->jt, fp->jf, fp->k);
+			kfree(addrs);
+			BUG();
+			return -EINVAL;
 		}
 
 		insn++;
@@ -637,7 +641,7 @@ static int check_load_and_stores(const struct sock_filter *filter, int flen)
 	u16 *masks, memvalid = 0; /* One bit per cell, 16 cells */
 	int pc, ret = 0;
 
-	BUILD_BUG_ON(BPF_MEMWORDS > 16);
+	BUILD_BUG_ON(BPF_MEMWORDS != 16);
 
 	masks = kmalloc_array(flen, sizeof(*masks), GFP_KERNEL);
 	if (!masks)
diff --git a/net/core/net-procfs.c b/net/core/net-procfs.c
index 5518cfaee62b..f2a895f8a8bc 100644
--- a/net/core/net-procfs.c
+++ b/net/core/net-procfs.c
@@ -79,7 +79,13 @@ static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
 	struct rtnl_link_stats64 temp;
 	const struct rtnl_link_stats64 *stats = dev_get_stats(dev, &temp);
 
-	seq_printf(seq, "%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu "
+	if (gr_proc_is_restricted())
+		seq_printf(seq, "%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu "
+		   "%8llu %7llu %4llu %4llu %4llu %5llu %7llu %10llu\n",
+		   dev->name, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL,
+		   0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL);
+	else
+		seq_printf(seq, "%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu "
 		   "%8llu %7llu %4llu %4llu %4llu %5llu %7llu %10llu\n",
 		   dev->name, stats->rx_bytes, stats->rx_packets,
 		   stats->rx_errors,
@@ -167,7 +173,7 @@ static int softnet_seq_show(struct seq_file *seq, void *v)
 	return 0;
 }
 
-static const struct seq_operations dev_seq_ops = {
+const struct seq_operations dev_seq_ops = {
 	.start = dev_seq_start,
 	.next  = dev_seq_next,
 	.stop  = dev_seq_stop,
@@ -197,7 +203,7 @@ static const struct seq_operations softnet_seq_ops = {
 
 static int softnet_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &softnet_seq_ops);
+	return seq_open_restrict(file, &softnet_seq_ops);
 }
 
 static const struct file_operations softnet_seq_fops = {
@@ -284,8 +290,13 @@ static int ptype_seq_show(struct seq_file *seq, void *v)
 		else
 			seq_printf(seq, "%04x", ntohs(pt->type));
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+		seq_printf(seq, " %-8s %pf\n",
+			   pt->dev ? pt->dev->name : "", NULL);
+#else
 		seq_printf(seq, " %-8s %pf\n",
 			   pt->dev ? pt->dev->name : "", pt->func);
+#endif
 	}
 
 	return 0;
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index 306b8f0e03c1..021418787e4b 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -3867,7 +3867,7 @@ static int __net_init pg_net_init(struct net *net)
 	pn->net = net;
 	INIT_LIST_HEAD(&pn->pktgen_threads);
 	pn->pktgen_exiting = false;
-	pn->proc_dir = proc_mkdir(PG_PROC_DIR, pn->net->proc_net);
+	pn->proc_dir = proc_mkdir_restrict(PG_PROC_DIR, pn->net->proc_net);
 	if (!pn->proc_dir) {
 		pr_warn("cannot create /proc/net/%s\n", PG_PROC_DIR);
 		return -ENODEV;
diff --git a/net/core/sock.c b/net/core/sock.c
index 0a3d949c9f9c..f5adedfb636a 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -890,29 +890,30 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 		}
 		break;
 
-	case SO_ATTACH_BPF:
+	case SO_ATTACH_REUSEPORT_CBPF:
 		ret = -EINVAL;
-		if (optlen == sizeof(u32)) {
-			u32 ufd;
+		if (optlen == sizeof(struct sock_fprog)) {
+			struct sock_fprog fprog;
 
 			ret = -EFAULT;
-			if (copy_from_user(&ufd, optval, sizeof(ufd)))
+			if (copy_from_user(&fprog, optval, sizeof(fprog)))
 				break;
 
-			ret = sk_attach_bpf(ufd, sk);
+			ret = sk_reuseport_attach_filter(&fprog, sk);
 		}
 		break;
 
-	case SO_ATTACH_REUSEPORT_CBPF:
+#ifndef GRKERNSEC_BPF_HARDEN
+	case SO_ATTACH_BPF:
 		ret = -EINVAL;
-		if (optlen == sizeof(struct sock_fprog)) {
-			struct sock_fprog fprog;
+		if (optlen == sizeof(u32)) {
+			u32 ufd;
 
 			ret = -EFAULT;
-			if (copy_from_user(&fprog, optval, sizeof(fprog)))
+			if (copy_from_user(&ufd, optval, sizeof(ufd)))
 				break;
 
-			ret = sk_reuseport_attach_filter(&fprog, sk);
+			ret = sk_attach_bpf(ufd, sk);
 		}
 		break;
 
@@ -929,6 +930,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 		}
 		break;
 
+#endif
+
 	case SO_DETACH_FILTER:
 		ret = sk_detach_filter(sk);
 		break;
diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c
index 0fb5ea5d0022..7db59f71a354 100644
--- a/net/core/sysctl_net_core.c
+++ b/net/core/sysctl_net_core.c
@@ -286,7 +286,7 @@ static struct ctl_table net_core_table[] = {
 		.mode		= 0444,
 		.proc_handler	= proc_do_rss_key,
 	},
-#ifdef CONFIG_BPF_JIT
+#if defined(CONFIG_BPF_JIT) && !defined(CONFIG_GRKERNSEC_BPF_HARDEN)
 	{
 		.procname	= "bpf_jit_enable",
 		.data		= &bpf_jit_enable,
diff --git a/net/decnet/dn_dev.c b/net/decnet/dn_dev.c
index b2c26b081134..41f803e35da3 100644
--- a/net/decnet/dn_dev.c
+++ b/net/decnet/dn_dev.c
@@ -201,7 +201,7 @@ static struct dn_dev_sysctl_table {
 		.extra1 = &min_t3,
 		.extra2 = &max_t3
 	},
-	{0}
+	{ }
 	},
 };
 
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index 9744e3a0b93b..cb05c97954a5 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -69,7 +69,8 @@
 
 static struct ipv4_devconf ipv4_devconf = {
 	.data = {
-		[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,
+		[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 0,
+		[IPV4_DEVCONF_RP_FILTER - 1] = 1,
 		[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,
 		[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,
 		[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,
@@ -80,7 +81,8 @@ static struct ipv4_devconf ipv4_devconf = {
 
 static struct ipv4_devconf ipv4_devconf_dflt = {
 	.data = {
-		[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,
+		[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 0,
+		[IPV4_DEVCONF_RP_FILTER - 1] = 1,
 		[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,
 		[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,
 		[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index ca97835bfec4..4876208b469b 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/wait.h>
 #include <linux/vmalloc.h>
+#include <linux/security.h>
 
 #include <net/addrconf.h>
 #include <net/inet_connection_sock.h>
@@ -57,6 +58,8 @@ u32 sk_ehashfn(const struct sock *sk)
 			    sk->sk_daddr, sk->sk_dport);
 }
 
+extern void gr_update_task_in_ip_table(const struct inet_sock *inet);
+
 /*
  * Allocate and initialize a new local port bind bucket.
  * The bindhash mutex for snum's hash chain must be held here.
@@ -644,6 +647,9 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 	spin_unlock(&head->lock);
 	if (tw)
 		inet_twsk_deschedule_put(tw);
+
+	gr_update_task_in_ip_table(inet_sk(sk));
+
 	local_bh_enable();
 	return 0;
 }
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index d6feabb03516..9cb3988a24b4 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -148,6 +148,10 @@
 #include <linux/netlink.h>
 #include <net/dst_metadata.h>
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 /*
  *	Process Router Attention IP option (RFC 2113)
  */
@@ -223,6 +227,9 @@ static int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_b
 			if (!raw) {
 				if (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
 					__IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS);
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+					if (!grsec_enable_blackhole || (skb->dev->flags & IFF_LOOPBACK))
+#endif
 					icmp_send(skb, ICMP_DEST_UNREACH,
 						  ICMP_PROT_UNREACH, 0);
 				}
diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c
index ede4d43f4dad..f7953fe623f4 100644
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@ -593,7 +593,7 @@ static int vti_device_event(struct notifier_block *unused,
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block vti_notifier_block = {
+static notifier_block_no_const vti_notifier_block __read_only = {
 	.notifier_call = vti_device_event,
 };
 
diff --git a/net/ipv4/netfilter/ipt_CLUSTERIP.c b/net/ipv4/netfilter/ipt_CLUSTERIP.c
index 4a9e6db9df8d..06174e18b6ec 100644
--- a/net/ipv4/netfilter/ipt_CLUSTERIP.c
+++ b/net/ipv4/netfilter/ipt_CLUSTERIP.c
@@ -730,7 +730,7 @@ static int clusterip_net_init(struct net *net)
 	spin_lock_init(&cn->lock);
 
 #ifdef CONFIG_PROC_FS
-	cn->procdir = proc_mkdir("ipt_CLUSTERIP", net->proc_net);
+	cn->procdir = proc_mkdir_restrict("ipt_CLUSTERIP", net->proc_net);
 	if (!cn->procdir) {
 		pr_err("Unable to proc dir entry\n");
 		return -ENOMEM;
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index f875f6ff8f0e..fdb89dc17561 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -232,7 +232,7 @@ static const struct seq_operations rt_cache_seq_ops = {
 
 static int rt_cache_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &rt_cache_seq_ops);
+	return seq_open_restrict(file, &rt_cache_seq_ops);
 }
 
 static const struct file_operations rt_cache_seq_fops = {
@@ -323,7 +323,7 @@ static const struct seq_operations rt_cpu_seq_ops = {
 
 static int rt_cpu_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &rt_cpu_seq_ops);
+	return seq_open_restrict(file, &rt_cpu_seq_ops);
 }
 
 static const struct file_operations rt_cpu_seq_fops = {
@@ -361,7 +361,7 @@ static int rt_acct_proc_show(struct seq_file *m, void *v)
 
 static int rt_acct_proc_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rt_acct_proc_show, NULL);
+	return single_open_restrict(file, rt_acct_proc_show, NULL);
 }
 
 static const struct file_operations rt_acct_proc_fops = {
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index e76b5f31657e..948899991da1 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -288,11 +288,13 @@ static void tcp_ecn_rcv_synack(struct tcp_sock *tp, const struct tcphdr *th)
 		tp->ecn_flags &= ~TCP_ECN_OK;
 }
 
+#ifndef CONFIG_GRKERNSEC_NO_SIMULT_CONNECT
 static void tcp_ecn_rcv_syn(struct tcp_sock *tp, const struct tcphdr *th)
 {
 	if ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || !th->cwr))
 		tp->ecn_flags &= ~TCP_ECN_OK;
 }
+#endif
 
 static bool tcp_ecn_rcv_ecn_echo(const struct tcp_sock *tp, const struct tcphdr *th)
 {
@@ -5820,6 +5822,7 @@ static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,
 	    tcp_paws_reject(&tp->rx_opt, 0))
 		goto discard_and_undo;
 
+#ifndef CONFIG_GRKERNSEC_NO_SIMULT_CONNECT
 	if (th->syn) {
 		/* We see SYN without ACK. It is attempt of
 		 * simultaneous connect with crossed SYNs.
@@ -5871,6 +5874,7 @@ static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,
 		goto discard;
 #endif
 	}
+#endif
 	/* "fifth, if neither of the SYN or RST bits is set then
 	 * drop the segment and return."
 	 */
@@ -5914,7 +5918,7 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)
 			goto discard;
 
 		if (th->syn) {
-			if (th->fin)
+			if (th->fin || th->urg || th->psh)
 				goto discard;
 			/* It is possible that we process SYN packets from backlog,
 			 * so we need to make sure to disable BH right there.
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index e02355e1f069..2b781b3bb3ce 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -87,6 +87,10 @@
 int sysctl_tcp_tw_reuse __read_mostly;
 int sysctl_tcp_low_latency __read_mostly;
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 #ifdef CONFIG_TCP_MD5SIG
 static int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,
 			       __be32 daddr, __be32 saddr, const struct tcphdr *th);
@@ -1431,6 +1435,9 @@ int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
 	return 0;
 
 reset:
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!grsec_enable_blackhole)
+#endif
 	tcp_v4_send_reset(rsk, skb);
 discard:
 	kfree_skb(skb);
@@ -1641,12 +1648,19 @@ int tcp_v4_rcv(struct sk_buff *skb)
 lookup:
 	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
 			       th->dest, &refcounted);
-	if (!sk)
+	if (!sk) {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		ret = 1;
+#endif
 		goto no_tcp_socket;
-
+	}
 process:
-	if (sk->sk_state == TCP_TIME_WAIT)
+	if (sk->sk_state == TCP_TIME_WAIT) {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		ret = 2;
+#endif
 		goto do_time_wait;
+	}
 
 	if (sk->sk_state == TCP_NEW_SYN_RECV) {
 		struct request_sock *req = inet_reqsk(sk);
@@ -1736,6 +1750,10 @@ int tcp_v4_rcv(struct sk_buff *skb)
 bad_packet:
 		__TCP_INC_STATS(net, TCP_MIB_INERRS);
 	} else {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		if (!grsec_enable_blackhole || (ret == 1 &&
+		    (skb->dev->flags & IFF_LOOPBACK)))
+#endif
 		tcp_v4_send_reset(NULL, skb);
 	}
 
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 8615a6b8550f..772fcdb56aca 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -27,6 +27,10 @@
 #include <net/inet_common.h>
 #include <net/xfrm.h>
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 int sysctl_tcp_abort_on_overflow __read_mostly;
 
 struct inet_timewait_death_row tcp_death_row = {
@@ -787,7 +791,10 @@ struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
 		 * avoid becoming vulnerable to outside attack aiming at
 		 * resetting legit local connections.
 		 */
-		req->rsk_ops->send_reset(sk, skb);
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		if (!grsec_enable_blackhole)
+#endif
+			req->rsk_ops->send_reset(sk, skb);
 	} else if (fastopen) { /* received a valid RST pkt */
 		reqsk_fastopen_remove(sk, req, true);
 		tcp_reset(sk);
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index b1e65b3b4361..fafad4789eda 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -22,6 +22,10 @@
 #include <linux/gfp.h>
 #include <net/tcp.h>
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_lastack_retries;
+#endif
+
 int sysctl_tcp_thin_linear_timeouts __read_mostly;
 
 /**
@@ -232,6 +236,13 @@ static int tcp_write_timeout(struct sock *sk)
 		}
 	}
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if ((sk->sk_state == TCP_LAST_ACK) &&
+	    (grsec_lastack_retries > 0) &&
+	    (grsec_lastack_retries < retry_until))
+		retry_until = grsec_lastack_retries;
+#endif
+
 	if (retransmits_timed_out(sk, retry_until,
 				  syn_set ? 0 : icsk->icsk_user_timeout, syn_set)) {
 		/* Has it gone just too far? */
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index b2638baedc13..f5f5d03bd5c5 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -87,6 +87,7 @@
 #include <linux/types.h>
 #include <linux/fcntl.h>
 #include <linux/module.h>
+#include <linux/security.h>
 #include <linux/socket.h>
 #include <linux/sockios.h>
 #include <linux/igmp.h>
@@ -116,6 +117,10 @@
 #include <net/sock_reuseport.h>
 #include <net/addrconf.h>
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
 
@@ -615,6 +620,9 @@ static inline bool __udp_is_mcast_sock(struct net *net, struct sock *sk,
 	return true;
 }
 
+extern int gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr);
+
 /*
  * This routine is called by the ICMP module when it gets some
  * sort of error condition.  If err < 0 then the socket should
@@ -941,9 +949,18 @@ int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 		dport = usin->sin_port;
 		if (dport == 0)
 			return -EINVAL;
+
+		err = gr_search_udp_sendmsg(sk, usin);
+		if (err)
+			return err;
 	} else {
 		if (sk->sk_state != TCP_ESTABLISHED)
 			return -EDESTADDRREQ;
+
+		err = gr_search_udp_sendmsg(sk, NULL);
+		if (err)
+			return err;
+
 		daddr = inet->inet_daddr;
 		dport = inet->inet_dport;
 		/* Open fast path for connected socket.
@@ -1296,6 +1313,9 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 			goto csum_copy_err;
 	}
 
+	if (likely(!err))
+		err = gr_search_udp_recvmsg(sk, skb);
+
 	if (unlikely(err)) {
 		trace_kfree_skb(skb, udp_recvmsg);
 		if (!peeked) {
@@ -1812,6 +1832,9 @@ int __udp4_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
 		goto csum_error;
 
 	__UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!grsec_enable_blackhole || (skb->dev->flags & IFF_LOOPBACK))
+#endif
 	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
 
 	/*
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 3fcd651d5470..84104589e732 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -199,7 +199,7 @@ static struct ipv6_devconf ipv6_devconf __read_mostly = {
 	.hop_limit		= IPV6_DEFAULT_HOPLIMIT,
 	.mtu6			= IPV6_MIN_MTU,
 	.accept_ra		= 1,
-	.accept_redirects	= 1,
+	.accept_redirects	= 0,
 	.autoconf		= 1,
 	.force_mld_version	= 0,
 	.mldv1_unsolicited_report_interval = 10 * HZ,
@@ -245,7 +245,7 @@ static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
 	.hop_limit		= IPV6_DEFAULT_HOPLIMIT,
 	.mtu6			= IPV6_MIN_MTU,
 	.accept_ra		= 1,
-	.accept_redirects	= 1,
+	.accept_redirects	= 0,
 	.autoconf		= 1,
 	.force_mld_version	= 0,
 	.mldv1_unsolicited_report_interval = 10 * HZ,
@@ -4130,16 +4130,23 @@ static const struct file_operations if6_fops = {
 	.release	= seq_release_net,
 };
 
+extern void register_ipv6_seq_ops_addr(struct seq_operations *addr);
+extern void unregister_ipv6_seq_ops_addr(void);
+
 static int __net_init if6_proc_net_init(struct net *net)
 {
-	if (!proc_create("if_inet6", S_IRUGO, net->proc_net, &if6_fops))
+	register_ipv6_seq_ops_addr(&if6_seq_ops);
+	if (!proc_create("if_inet6", S_IRUGO, net->proc_net, &if6_fops)) {
+		unregister_ipv6_seq_ops_addr();
 		return -ENOMEM;
+	}
 	return 0;
 }
 
 static void __net_exit if6_proc_net_exit(struct net *net)
 {
 	remove_proc_entry("if_inet6", net->proc_net);
+	unregister_ipv6_seq_ops_addr();
 }
 
 static struct pernet_operations if6_proc_net_ops = {
diff --git a/net/ipv6/proc.c b/net/ipv6/proc.c
index 9e557127ec52..6572951aa2b8 100644
--- a/net/ipv6/proc.c
+++ b/net/ipv6/proc.c
@@ -324,7 +324,7 @@ static int __net_init ipv6_proc_init_net(struct net *net)
 	if (!proc_create("snmp6", S_IRUGO, net->proc_net, &snmp6_seq_fops))
 		goto proc_snmp6_fail;
 
-	net->mib.proc_net_devsnmp6 = proc_mkdir("dev_snmp6", net->proc_net);
+	net->mib.proc_net_devsnmp6 = proc_mkdir_restrict("dev_snmp6", net->proc_net);
 	if (!net->mib.proc_net_devsnmp6)
 		goto proc_dev_snmp6_fail;
 	return 0;
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index b2e61a0e8d0a..bf47484f180f 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -101,6 +101,10 @@ static void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)
 	}
 }
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 static __u32 tcp_v6_init_sequence(const struct sk_buff *skb)
 {
 	return secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,
@@ -1304,6 +1308,9 @@ static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
 	return 0;
 
 reset:
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!grsec_enable_blackhole)
+#endif
 	tcp_v6_send_reset(sk, skb);
 discard:
 	if (opt_skb)
@@ -1408,12 +1415,20 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 	sk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),
 				th->source, th->dest, inet6_iif(skb),
 				&refcounted);
-	if (!sk)
+	if (!sk) {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		ret = 1;
+#endif
 		goto no_tcp_socket;
+	}
 
 process:
-	if (sk->sk_state == TCP_TIME_WAIT)
+	if (sk->sk_state == TCP_TIME_WAIT) {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		ret = 2;
+#endif
 		goto do_time_wait;
+	}
 
 	if (sk->sk_state == TCP_NEW_SYN_RECV) {
 		struct request_sock *req = inet_reqsk(sk);
@@ -1503,6 +1518,10 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 bad_packet:
 		__TCP_INC_STATS(net, TCP_MIB_INERRS);
 	} else {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		if (!grsec_enable_blackhole || (ret == 1 &&
+		    (skb->dev->flags & IFF_LOOPBACK)))
+#endif
 		tcp_v6_send_reset(NULL, skb);
 	}
 
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index b4a9cc1686c4..c8715aabe216 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -78,6 +78,10 @@ static u32 udp6_ehashfn(const struct net *net,
 			       udp_ipv6_hash_secret + net_hash_mix(net));
 }
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+extern int grsec_enable_blackhole;
+#endif
+
 static u32 udp6_portaddr_hash(const struct net *net,
 			      const struct in6_addr *addr6,
 			      unsigned int port)
@@ -846,6 +850,9 @@ int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
 		goto csum_error;
 
 	__UDP6_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!grsec_enable_blackhole || (skb->dev->flags & IFF_LOOPBACK))
+#endif
 	icmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);
 
 	kfree_skb(skb);
diff --git a/net/ipx/ipx_proc.c b/net/ipx/ipx_proc.c
index c1d247ebe916..9e5949d06ef5 100644
--- a/net/ipx/ipx_proc.c
+++ b/net/ipx/ipx_proc.c
@@ -289,7 +289,7 @@ int __init ipx_proc_init(void)
 	struct proc_dir_entry *p;
 	int rc = -ENOMEM;
 
-	ipx_proc_dir = proc_mkdir("ipx", init_net.proc_net);
+	ipx_proc_dir = proc_mkdir_restrict("ipx", init_net.proc_net);
 
 	if (!ipx_proc_dir)
 		goto out;
diff --git a/net/irda/irproc.c b/net/irda/irproc.c
index b9ac598e2116..f88cc5627cf9 100644
--- a/net/irda/irproc.c
+++ b/net/irda/irproc.c
@@ -66,7 +66,7 @@ void __init irda_proc_register(void)
 {
 	int i;
 
-	proc_irda = proc_mkdir("irda", init_net.proc_net);
+	proc_irda = proc_mkdir_restrict("irda", init_net.proc_net);
 	if (proc_irda == NULL)
 		return;
 
diff --git a/net/llc/llc_proc.c b/net/llc/llc_proc.c
index 29c509c54bb2..c19322a9c8e1 100644
--- a/net/llc/llc_proc.c
+++ b/net/llc/llc_proc.c
@@ -247,7 +247,7 @@ int __init llc_proc_init(void)
 	int rc = -ENOMEM;
 	struct proc_dir_entry *p;
 
-	llc_proc_dir = proc_mkdir("llc", init_net.proc_net);
+	llc_proc_dir = proc_mkdir_restrict("llc", init_net.proc_net);
 	if (!llc_proc_dir)
 		goto out;
 
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index e8d56d9a4df2..473bc8e7adec 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -1166,6 +1166,16 @@ config NETFILTER_XT_MATCH_ESP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_GRADM
+	tristate '"gradm" match support'
+	depends on NETFILTER_XTABLES && NETFILTER_ADVANCED
+	depends on GRKERNSEC && !GRKERNSEC_NO_RBAC
+	---help---
+	  The gradm match allows to match on grsecurity RBAC being enabled.
+	  It is useful when iptables rules are applied early on bootup to
+	  prevent connections to the machine (except from a trusted host)
+	  while the RBAC system is disabled.
+
 config NETFILTER_XT_MATCH_HASHLIMIT
 	tristate '"hashlimit" match support'
 	depends on IP6_NF_IPTABLES || IP6_NF_IPTABLES=n
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index c23c3c84416f..7568d8b46d3e 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -149,6 +149,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_DEVGROUP) += xt_devgroup.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_DSCP) += xt_dscp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ECN) += xt_ecn.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ESP) += xt_esp.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_GRADM) += xt_gradm.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HASHLIMIT) += xt_hashlimit.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HELPER) += xt_helper.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HL) += xt_hl.o
diff --git a/net/netfilter/xt_gradm.c b/net/netfilter/xt_gradm.c
new file mode 100644
index 000000000000..a7cb915fe1cf
--- /dev/null
+++ b/net/netfilter/xt_gradm.c
@@ -0,0 +1,51 @@
+/*
+ *	gradm match for netfilter
+ *	Copyright (c) Zbigniew Krzystolik, 2010
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License; either version
+ *	2 or 3 as published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/grsecurity.h>
+#include <linux/netfilter/xt_gradm.h>
+
+static bool
+gradm_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct xt_gradm_mtinfo *info = par->matchinfo;
+	bool retval = false;
+	if (gr_acl_is_enabled())
+		retval = true;
+	return retval ^ info->invflags;
+}
+
+static struct xt_match gradm_mt_reg __read_mostly = {
+		.name       = "gradm",
+		.revision   = 0,
+		.family     = NFPROTO_UNSPEC,
+		.match      = gradm_mt,
+		.matchsize  = XT_ALIGN(sizeof(struct xt_gradm_mtinfo)),
+		.me         = THIS_MODULE,
+};
+
+static int __init gradm_mt_init(void)
+{
+	return xt_register_match(&gradm_mt_reg);
+}
+
+static void __exit gradm_mt_exit(void)
+{
+	xt_unregister_match(&gradm_mt_reg);
+}
+
+module_init(gradm_mt_init);
+module_exit(gradm_mt_exit);
+MODULE_AUTHOR("Zbigniew Krzystolik <zbyniu@destrukcja.pl>");
+MODULE_DESCRIPTION("Xtables: Grsecurity RBAC match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_gradm");
+MODULE_ALIAS("ip6t_gradm");
diff --git a/net/netfilter/xt_hashlimit.c b/net/netfilter/xt_hashlimit.c
index b89b688e9d01..c9383a252196 100644
--- a/net/netfilter/xt_hashlimit.c
+++ b/net/netfilter/xt_hashlimit.c
@@ -1065,11 +1065,11 @@ static int __net_init hashlimit_proc_net_init(struct net *net)
 {
 	struct hashlimit_net *hashlimit_net = hashlimit_pernet(net);
 
-	hashlimit_net->ipt_hashlimit = proc_mkdir("ipt_hashlimit", net->proc_net);
+	hashlimit_net->ipt_hashlimit = proc_mkdir_restrict("ipt_hashlimit", net->proc_net);
 	if (!hashlimit_net->ipt_hashlimit)
 		return -ENOMEM;
 #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
-	hashlimit_net->ip6t_hashlimit = proc_mkdir("ip6t_hashlimit", net->proc_net);
+	hashlimit_net->ip6t_hashlimit = proc_mkdir_restrict("ip6t_hashlimit", net->proc_net);
 	if (!hashlimit_net->ip6t_hashlimit) {
 		remove_proc_entry("ipt_hashlimit", net->proc_net);
 		return -ENOMEM;
diff --git a/net/netfilter/xt_recent.c b/net/netfilter/xt_recent.c
index e3b7a09b103e..ee271acf97c1 100644
--- a/net/netfilter/xt_recent.c
+++ b/net/netfilter/xt_recent.c
@@ -639,7 +639,7 @@ static int __net_init recent_proc_net_init(struct net *net)
 {
 	struct recent_net *recent_net = recent_pernet(net);
 
-	recent_net->xt_recent = proc_mkdir("xt_recent", net->proc_net);
+	recent_net->xt_recent = proc_mkdir_restrict("xt_recent", net->proc_net);
 	if (!recent_net->xt_recent)
 		return -ENOMEM;
 	return 0;
diff --git a/net/socket.c b/net/socket.c
index 610bc0e9bd35..1991a222de26 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -89,6 +89,7 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include <linux/xattr.h>
+#include <linux/in.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -107,6 +108,7 @@
 #include <linux/atalk.h>
 #include <net/busy_poll.h>
 #include <linux/errqueue.h>
+#include <linux/grsock.h>
 
 #ifdef CONFIG_NET_RX_BUSY_POLL
 unsigned int sysctl_net_busy_read __read_mostly;
@@ -160,7 +162,7 @@ static const struct file_operations socket_file_ops = {
  */
 
 static DEFINE_SPINLOCK(net_family_lock);
-static const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;
+const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;
 
 /*
  *	Statistics counters of the socket lists
@@ -369,7 +371,7 @@ static struct dentry *sockfs_mount(struct file_system_type *fs_type,
 				  &sockfs_dentry_operations, SOCKFS_MAGIC);
 }
 
-static struct vfsmount *sock_mnt __read_mostly;
+struct vfsmount *sock_mnt __read_mostly;
 
 static struct file_system_type sock_fs_type = {
 	.name =		"sockfs",
@@ -1108,6 +1110,8 @@ int __sock_create(struct net *net, int family, int type, int protocol,
 		return -EAFNOSUPPORT;
 	if (type < 0 || type >= SOCK_MAX)
 		return -EINVAL;
+	if (protocol < 0)
+		return -EINVAL;
 
 	/* Compatibility.
 
@@ -1124,6 +1128,20 @@ int __sock_create(struct net *net, int family, int type, int protocol,
 	if (err)
 		return err;
 
+	if(!kern && !gr_search_socket(family, type, protocol)) {
+		if (rcu_access_pointer(net_families[family]) == NULL)
+			return -EAFNOSUPPORT;
+		else
+			return -EACCES;
+	}
+
+	if (!kern && gr_handle_sock_all(family, type, protocol)) {
+		if (rcu_access_pointer(net_families[family]) == NULL)
+			return -EAFNOSUPPORT;
+		else
+			return -EACCES;
+	}
+
 	/*
 	 *	Allocate the socket and allow the family to set things up. if
 	 *	the protocol is 0, the family is instructed to select an appropriate
@@ -1375,6 +1393,14 @@ SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
 	if (sock) {
 		err = move_addr_to_kernel(umyaddr, addrlen, &address);
 		if (err >= 0) {
+			if (gr_handle_sock_server((struct sockaddr *)&address)) {
+				err = -EACCES;
+				goto error;
+			}
+			err = gr_search_bind(sock, (struct sockaddr_in *)&address);
+			if (err)
+				goto error;
+
 			err = security_socket_bind(sock,
 						   (struct sockaddr *)&address,
 						   addrlen);
@@ -1383,6 +1409,7 @@ SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
 						      (struct sockaddr *)
 						      &address, addrlen);
 		}
+error:
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
@@ -1406,10 +1433,20 @@ SYSCALL_DEFINE2(listen, int, fd, int, backlog)
 		if ((unsigned int)backlog > somaxconn)
 			backlog = somaxconn;
 
+		if (gr_handle_sock_server_other(sock->sk)) {
+			err = -EPERM;
+			goto error;
+		}
+
+		err = gr_search_listen(sock);
+		if (err)
+			goto error;
+
 		err = security_socket_listen(sock, backlog);
 		if (!err)
 			err = sock->ops->listen(sock, backlog);
 
+error:
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
@@ -1453,6 +1490,18 @@ SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
 	newsock->type = sock->type;
 	newsock->ops = sock->ops;
 
+	if (gr_handle_sock_server_other(sock->sk)) {
+		err = -EPERM;
+		sock_release(newsock);
+		goto out_put;
+	}
+
+	err = gr_search_accept(sock);
+	if (err) {
+		sock_release(newsock);
+		goto out_put;
+	}
+
 	/*
 	 * We don't need try_module_get here, as the listening socket (sock)
 	 * has the protocol module (sock->ops->owner) held.
@@ -1498,6 +1547,8 @@ SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
 	fd_install(newfd, newfile);
 	err = newfd;
 
+	gr_attach_curr_ip(newsock->sk);
+
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1530,6 +1581,7 @@ SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
 		int, addrlen)
 {
 	struct socket *sock;
+	struct sockaddr *sck;
 	struct sockaddr_storage address;
 	int err, fput_needed;
 
@@ -1540,6 +1592,17 @@ SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
 	if (err < 0)
 		goto out_put;
 
+	sck = (struct sockaddr *)&address;
+
+	if (gr_handle_sock_client(sck)) {
+		err = -EACCES;
+		goto out_put;
+	}
+
+	err = gr_search_connect(sock, (struct sockaddr_in *)sck);
+	if (err)
+		goto out_put;
+
 	err =
 	    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);
 	if (err)
@@ -1562,7 +1625,7 @@ SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
 		int __user *, usockaddr_len)
 {
 	struct socket *sock;
-	struct sockaddr_storage address;
+	struct sockaddr_storage address = { };
 	int len, err, fput_needed;
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
@@ -1593,7 +1656,7 @@ SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
 		int __user *, usockaddr_len)
 {
 	struct socket *sock;
-	struct sockaddr_storage address;
+	struct sockaddr_storage address = { };
 	int len, err, fput_needed;
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
@@ -1686,7 +1749,7 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
 	struct socket *sock;
 	struct iovec iov;
 	struct msghdr msg;
-	struct sockaddr_storage address;
+	struct sockaddr_storage address = { };
 	int err, err2;
 	int fput_needed;
 
@@ -2089,7 +2152,7 @@ static int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg,
 	ssize_t err;
 
 	/* kernel mode address */
-	struct sockaddr_storage addr;
+	struct sockaddr_storage addr = { };
 
 	/* user mode address pointers */
 	struct sockaddr __user *uaddr;
diff --git a/net/sunrpc/Kconfig b/net/sunrpc/Kconfig
index 04ce2c0b660e..b1dd1bdfa362 100644
--- a/net/sunrpc/Kconfig
+++ b/net/sunrpc/Kconfig
@@ -38,6 +38,7 @@ config SUNRPC_DEBUG
 	bool "RPC: Enable dprintk debugging"
 	depends on SUNRPC && SYSCTL
 	select DEBUG_FS
+	depends on !GRKERNSEC_KMEM
 	help
 	  This option enables a sysctl-based debugging interface
 	  that is be used by the 'rpcdebug' utility to turn on or off
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 8aabe12201f8..52b88d4fec63 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -1624,7 +1624,7 @@ static int create_cache_proc_entries(struct cache_detail *cd, struct net *net)
 	struct sunrpc_net *sn;
 
 	sn = net_generic(net, sunrpc_net_id);
-	cd->u.procfs.proc_ent = proc_mkdir(cd->name, sn->proc_net_rpc);
+	cd->u.procfs.proc_ent = proc_mkdir_restrict(cd->name, sn->proc_net_rpc);
 	if (cd->u.procfs.proc_ent == NULL)
 		goto out_nomem;
 	cd->u.procfs.channel_ent = NULL;
diff --git a/net/sunrpc/stats.c b/net/sunrpc/stats.c
index 2ecb994314c1..5afb49ff1e18 100644
--- a/net/sunrpc/stats.c
+++ b/net/sunrpc/stats.c
@@ -290,7 +290,7 @@ int rpc_proc_init(struct net *net)
 
 	dprintk("RPC:       registering /proc/net/rpc\n");
 	sn = net_generic(net, sunrpc_net_id);
-	sn->proc_net_rpc = proc_mkdir("rpc", net->proc_net);
+	sn->proc_net_rpc = proc_mkdir_restrict("rpc", net->proc_net);
 	if (sn->proc_net_rpc == NULL)
 		return -ENOMEM;
 
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 2d03d5bcb5b9..0905d718dd50 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -921,6 +921,12 @@ static struct sock *unix_find_other(struct net *net,
 		err = -ECONNREFUSED;
 		if (!S_ISSOCK(inode->i_mode))
 			goto put_fail;
+
+		if (!gr_acl_handle_unix(path.dentry, path.mnt)) {
+			err = -EACCES;
+			goto put_fail;
+		}
+
 		u = unix_find_socket_byinode(inode);
 		if (!u)
 			goto put_fail;
@@ -941,6 +947,13 @@ static struct sock *unix_find_other(struct net *net,
 		if (u) {
 			struct dentry *dentry;
 			dentry = unix_sk(u)->path.dentry;
+
+			if (!gr_handle_chroot_unix(pid_vnr(u->sk_peer_pid))) {
+				err = -EPERM;
+				sock_put(u);
+				goto fail;
+			}
+
 			if (dentry)
 				touch_atime(&unix_sk(u)->path);
 		} else
@@ -974,12 +987,19 @@ static int unix_mknod(const char *sun_path, umode_t mode, struct path *res)
 	 */
 	err = security_path_mknod(&path, dentry, mode, 0);
 	if (!err) {
+		if (!gr_acl_handle_mknod(dentry, path.dentry, path.mnt, mode)) {
+			err = -EACCES;
+			goto out;
+		}
 		err = vfs_mknod(d_inode(path.dentry), dentry, mode, 0);
 		if (!err) {
 			res->mnt = mntget(path.mnt);
 			res->dentry = dget(dentry);
+			gr_handle_create(dentry, path.mnt);
 		}
 	}
+
+out:
 	done_path_create(&path, dentry);
 	return err;
 }
@@ -995,7 +1015,7 @@ static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 	unsigned int hash;
 	struct unix_address *addr;
 	struct hlist_head *list;
-	struct path path = { NULL, NULL };
+	struct path path = { };
 
 	err = -EINVAL;
 	if (sunaddr->sun_family != AF_UNIX)
@@ -2794,9 +2814,13 @@ static int unix_seq_show(struct seq_file *seq, void *v)
 		seq_puts(seq, "Num       RefCount Protocol Flags    Type St "
 			 "Inode Path\n");
 	else {
-		struct sock *s = v;
+		struct sock *s = v, *peer;
 		struct unix_sock *u = unix_sk(s);
 		unix_state_lock(s);
+		peer = unix_peer(s);
+		unix_state_unlock(s);
+
+		unix_state_double_lock(s, peer);
 
 		seq_printf(seq, "%pK: %08X %08X %08X %04X %02X %5lu",
 			s,
@@ -2821,11 +2845,32 @@ static int unix_seq_show(struct seq_file *seq, void *v)
 				seq_putc(seq, '@');
 				i++;
 			}
-			for ( ; i < len; i++)
-				seq_putc(seq, u->addr->name->sun_path[i] ?:
-					 '@');
-		}
-		unix_state_unlock(s);
+			for ( ; i < len; i++) {
+				char c = u->addr->name->sun_path[i];
+				switch (c) {
+				case '\n':
+					seq_putc(seq, '\\');
+					seq_putc(seq, 'n');
+					break;
+				case '\t':
+					seq_putc(seq, '\\');
+					seq_putc(seq, 't');
+					break;
+				case '\\':
+					seq_putc(seq, '\\');
+					seq_putc(seq, '\\');
+					break;
+				case 0:
+					seq_putc(seq, '@');
+					break;
+				default:
+					seq_putc(seq, c);
+				}
+			}
+		} else if (peer)
+			seq_printf(seq, " P%lu", sock_i_ino(peer));
+
+		unix_state_double_unlock(s, peer);
 		seq_putc(seq, '\n');
 	}
 
diff --git a/net/vmw_vsock/vmci_transport_notify.c b/net/vmw_vsock/vmci_transport_notify.c
index fd8cf0214d51..1406db4d97d1 100644
--- a/net/vmw_vsock/vmci_transport_notify.c
+++ b/net/vmw_vsock/vmci_transport_notify.c
@@ -662,19 +662,19 @@ static void vmci_transport_notify_pkt_process_negotiate(struct sock *sk)
 
 /* Socket control packet based operations. */
 const struct vmci_transport_notify_ops vmci_transport_notify_pkt_ops = {
-	vmci_transport_notify_pkt_socket_init,
-	vmci_transport_notify_pkt_socket_destruct,
-	vmci_transport_notify_pkt_poll_in,
-	vmci_transport_notify_pkt_poll_out,
-	vmci_transport_notify_pkt_handle_pkt,
-	vmci_transport_notify_pkt_recv_init,
-	vmci_transport_notify_pkt_recv_pre_block,
-	vmci_transport_notify_pkt_recv_pre_dequeue,
-	vmci_transport_notify_pkt_recv_post_dequeue,
-	vmci_transport_notify_pkt_send_init,
-	vmci_transport_notify_pkt_send_pre_block,
-	vmci_transport_notify_pkt_send_pre_enqueue,
-	vmci_transport_notify_pkt_send_post_enqueue,
-	vmci_transport_notify_pkt_process_request,
-	vmci_transport_notify_pkt_process_negotiate,
+	.socket_init = vmci_transport_notify_pkt_socket_init,
+	.socket_destruct = vmci_transport_notify_pkt_socket_destruct,
+	.poll_in = vmci_transport_notify_pkt_poll_in,
+	.poll_out = vmci_transport_notify_pkt_poll_out,
+	.handle_notify_pkt = vmci_transport_notify_pkt_handle_pkt,
+	.recv_init = vmci_transport_notify_pkt_recv_init,
+	.recv_pre_block = vmci_transport_notify_pkt_recv_pre_block,
+	.recv_pre_dequeue = vmci_transport_notify_pkt_recv_pre_dequeue,
+	.recv_post_dequeue = vmci_transport_notify_pkt_recv_post_dequeue,
+	.send_init = vmci_transport_notify_pkt_send_init,
+	.send_pre_block = vmci_transport_notify_pkt_send_pre_block,
+	.send_pre_enqueue = vmci_transport_notify_pkt_send_pre_enqueue,
+	.send_post_enqueue = vmci_transport_notify_pkt_send_post_enqueue,
+	.process_request = vmci_transport_notify_pkt_process_request,
+	.process_negotiate = vmci_transport_notify_pkt_process_negotiate,
 };
diff --git a/net/vmw_vsock/vmci_transport_notify_qstate.c b/net/vmw_vsock/vmci_transport_notify_qstate.c
index 21e591dafb03..f3a0afc46208 100644
--- a/net/vmw_vsock/vmci_transport_notify_qstate.c
+++ b/net/vmw_vsock/vmci_transport_notify_qstate.c
@@ -420,19 +420,19 @@ vmci_transport_notify_pkt_send_pre_enqueue(
 
 /* Socket always on control packet based operations. */
 const struct vmci_transport_notify_ops vmci_transport_notify_pkt_q_state_ops = {
-	vmci_transport_notify_pkt_socket_init,
-	vmci_transport_notify_pkt_socket_destruct,
-	vmci_transport_notify_pkt_poll_in,
-	vmci_transport_notify_pkt_poll_out,
-	vmci_transport_notify_pkt_handle_pkt,
-	vmci_transport_notify_pkt_recv_init,
-	vmci_transport_notify_pkt_recv_pre_block,
-	vmci_transport_notify_pkt_recv_pre_dequeue,
-	vmci_transport_notify_pkt_recv_post_dequeue,
-	vmci_transport_notify_pkt_send_init,
-	vmci_transport_notify_pkt_send_pre_block,
-	vmci_transport_notify_pkt_send_pre_enqueue,
-	vmci_transport_notify_pkt_send_post_enqueue,
-	vmci_transport_notify_pkt_process_request,
-	vmci_transport_notify_pkt_process_negotiate,
+	.socket_init = vmci_transport_notify_pkt_socket_init,
+	.socket_destruct = vmci_transport_notify_pkt_socket_destruct,
+	.poll_in = vmci_transport_notify_pkt_poll_in,
+	.poll_out = vmci_transport_notify_pkt_poll_out,
+	.handle_notify_pkt = vmci_transport_notify_pkt_handle_pkt,
+	.recv_init = vmci_transport_notify_pkt_recv_init,
+	.recv_pre_block = vmci_transport_notify_pkt_recv_pre_block,
+	.recv_pre_dequeue = vmci_transport_notify_pkt_recv_pre_dequeue,
+	.recv_post_dequeue = vmci_transport_notify_pkt_recv_post_dequeue,
+	.send_init = vmci_transport_notify_pkt_send_init,
+	.send_pre_block = vmci_transport_notify_pkt_send_pre_block,
+	.send_pre_enqueue = vmci_transport_notify_pkt_send_pre_enqueue,
+	.send_post_enqueue = vmci_transport_notify_pkt_send_post_enqueue,
+	.process_request = vmci_transport_notify_pkt_process_request,
+	.process_negotiate = vmci_transport_notify_pkt_process_negotiate,
 };
diff --git a/net/x25/sysctl_net_x25.c b/net/x25/sysctl_net_x25.c
index 43239527a205..a06dfe143c67 100644
--- a/net/x25/sysctl_net_x25.c
+++ b/net/x25/sysctl_net_x25.c
@@ -70,7 +70,7 @@ static struct ctl_table x25_table[] = {
 		.mode = 	0644,
 		.proc_handler = proc_dointvec,
 	},
-	{ 0, },
+	{ },
 };
 
 void __init x25_register_sysctl(void)
diff --git a/net/x25/x25_proc.c b/net/x25/x25_proc.c
index 0917f047f2cf..f4e3d8c795cc 100644
--- a/net/x25/x25_proc.c
+++ b/net/x25/x25_proc.c
@@ -209,7 +209,7 @@ static const struct file_operations x25_seq_forward_fops = {
 
 int __init x25_proc_init(void)
 {
-	if (!proc_mkdir("x25", init_net.proc_net))
+	if (!proc_mkdir_restrict("x25", init_net.proc_net))
 		return -ENOMEM;
 
 	if (!proc_create("x25/route", S_IRUGO, init_net.proc_net,
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index 8e7e5f907fca..f15dad8d2fea 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -59,6 +59,10 @@ ifdef CONFIG_GCC_PLUGINS
   gcc-plugin-cflags-$(CONFIG_PAX_SIZE_OVERFLOW_EXTRA)	+= -fplugin-arg-size_overflow_plugin-check-fptrs
   gcc-plugin-cflags-$(CONFIG_PAX_SIZE_OVERFLOW_EXTRA)	+= -fplugin-arg-size_overflow_plugin-check-vars
 
+  gcc-plugin-$(CONFIG_GRKERNSEC_RANDSTRUCT)		+= randomize_layout_plugin.so
+  gcc-plugin-cflags-$(CONFIG_GRKERNSEC_RANDSTRUCT)	+= -DRANDSTRUCT_PLUGIN
+  gcc-plugin-cflags-$(CONFIG_GRKERNSEC_RANDSTRUCT_PERFORMANCE) += -fplugin-arg-randomize_layout_plugin-performance-mode
+
   gcc-plugin-$(CONFIG_PAX_MEMORY_STRUCTLEAK)		+= structleak_plugin.so
   gcc-plugin-cflags-$(CONFIG_PAX_MEMORY_STRUCTLEAK)	+= -DSTRUCTLEAK_PLUGIN
 
diff --git a/scripts/gcc-plugins/Makefile b/scripts/gcc-plugins/Makefile
index 445de5632266..ec1516ef99f1 100644
--- a/scripts/gcc-plugins/Makefile
+++ b/scripts/gcc-plugins/Makefile
@@ -26,6 +26,16 @@ $(HOSTLIBS)-y := $(foreach p,$(GCC_PLUGIN),$(if $(findstring /,$(p)),,$(p)))
 always := $($(HOSTLIBS)-y)
 $(foreach p,$($(HOSTLIBS)-y:%.so=%),$(eval $(p)-objs := $(p).o))
 
+$(obj)/randomize_layout_plugin.o: $(objtree)/$(obj)/randomize_layout_seed.h
+
+quiet_cmd_create_randomize_layout_seed = GENSEED  $@
+	cmd_create_randomize_layout_seed = \
+	$(CONFIG_SHELL) $(srctree)/$(src)/gen-random-seed.sh $@ $(objtree)/include/generated/randomize_layout_hash.h
+$(objtree)/$(obj)/randomize_layout_seed.h: FORCE
+	$(call if_changed,create_randomize_layout_seed)
+ 
+targets += randomize_layout_seed.h randomize_layout_hash.h
+
 subdir-y := $(GCC_PLUGIN_SUBDIR)
 subdir-  += $(GCC_PLUGIN_SUBDIR)
 
diff --git a/scripts/gcc-plugins/gen-random-seed.sh b/scripts/gcc-plugins/gen-random-seed.sh
new file mode 100644
index 000000000000..7514850f4815
--- /dev/null
+++ b/scripts/gcc-plugins/gen-random-seed.sh
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+if [ ! -f "$1" ]; then
+	SEED=`od -A n -t x8 -N 32 /dev/urandom | tr -d ' \n'`
+	echo "const char *randstruct_seed = \"$SEED\";" > "$1"
+	HASH=`echo -n "$SEED" | sha256sum | cut -d" " -f1 | tr -d ' \n'`
+	echo "#define RANDSTRUCT_HASHED_SEED \"$HASH\"" > "$2"
+fi
diff --git a/scripts/gcc-plugins/randomize_layout_plugin.c b/scripts/gcc-plugins/randomize_layout_plugin.c
new file mode 100644
index 000000000000..71911c828aae
--- /dev/null
+++ b/scripts/gcc-plugins/randomize_layout_plugin.c
@@ -0,0 +1,940 @@
+/*
+ * Copyright 2014-2016 by Open Source Security, Inc., Brad Spengler <spender@grsecurity.net>
+ *                   and PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * Usage:
+ * $ # for 4.5/4.6/C based 4.7
+ * $ gcc -I`gcc -print-file-name=plugin`/include -I`gcc -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o randomize_layout_plugin.so randomize_layout_plugin.c
+ * $ # for C++ based 4.7/4.8+
+ * $ g++ -I`g++ -print-file-name=plugin`/include -I`g++ -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o randomize_layout_plugin.so randomize_layout_plugin.c
+ * $ gcc -fplugin=./randomize_layout_plugin.so test.c -O2
+ */
+
+#include "gcc-common.h"
+#include "randomize_layout_seed.h"
+
+#if BUILDING_GCC_MAJOR < 4 || (BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR < 6) || \
+   (BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR == 6 && BUILDING_GCC_PATCHLEVEL < 4)
+#error "The RANDSTRUCT plugin requires GCC 4.6.4 or newer."
+#endif
+
+#define ORIG_TYPE_NAME(node) \
+	(TYPE_NAME(TYPE_MAIN_VARIANT(node)) != NULL_TREE ? ((const unsigned char *)IDENTIFIER_POINTER(TYPE_NAME(TYPE_MAIN_VARIANT(node)))) : (const unsigned char *)"anonymous")
+
+__visible int plugin_is_GPL_compatible;
+
+static int performance_mode;
+
+static struct plugin_info randomize_layout_plugin_info = {
+	.version	= "201402201816",
+	.help		= "disable\t\t\tdo not activate plugin\n"
+			  "performance-mode\tenable cacheline-aware layout randomization\n"
+};
+
+/* from old Linux dcache.h */
+static inline unsigned long
+partial_name_hash(unsigned long c, unsigned long prevhash)
+{
+	return (prevhash + (c << 4) + (c >> 4)) * 11;
+}
+static inline unsigned int
+name_hash(const unsigned char *name)
+{
+	unsigned long hash = 0;
+	unsigned int len = strlen((const char *)name);
+	while (len--)
+		hash = partial_name_hash(*name++, hash);
+	return (unsigned int)hash;
+}
+
+static tree handle_randomize_layout_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	tree type;
+
+	*no_add_attrs = true;
+	if (TREE_CODE(*node) == FUNCTION_DECL) {
+		error("%qE attribute does not apply to functions (%qF)", name, *node);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) == PARM_DECL) {
+		error("%qE attribute does not apply to function parameters (%qD)", name, *node);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) == VAR_DECL) {
+		error("%qE attribute does not apply to variables (%qD)", name, *node);
+		return NULL_TREE;
+	}
+
+	if (TYPE_P(*node)) {
+		type = *node;
+	} else {
+		gcc_assert(TREE_CODE(*node) == TYPE_DECL);
+		type = TREE_TYPE(*node);
+	}
+
+	if (TREE_CODE(type) != RECORD_TYPE) {
+		error("%qE attribute used on %qT applies to struct types only", name, type);
+		return NULL_TREE;
+	}
+
+	if (lookup_attribute(IDENTIFIER_POINTER(name), TYPE_ATTRIBUTES(type))) {
+		error("%qE attribute is already applied to the type %qT", name, type);
+		return NULL_TREE;
+	}
+
+	*no_add_attrs = false;
+
+	return NULL_TREE;
+}
+
+/* set on complete types that we don't need to inspect further at all */
+static tree handle_randomize_considered_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	*no_add_attrs = false;
+	return NULL_TREE;
+}
+
+/*
+ * set on types that we've performed a shuffle on, to prevent re-shuffling
+ * this does not preclude us from inspecting its fields for potential shuffles
+ */
+static tree handle_randomize_performed_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	*no_add_attrs = false;
+	return NULL_TREE;
+}
+
+/*
+ * 64bit variant of Bob Jenkins' public domain PRNG
+ * 256 bits of internal state
+ */
+
+typedef unsigned long long u64;
+
+typedef struct ranctx { u64 a; u64 b; u64 c; u64 d; } ranctx;
+
+#define rot(x,k) (((x)<<(k))|((x)>>(64-(k))))
+static u64 ranval(ranctx *x) {
+	u64 e = x->a - rot(x->b, 7);
+	x->a = x->b ^ rot(x->c, 13);
+	x->b = x->c + rot(x->d, 37);
+	x->c = x->d + e;
+	x->d = e + x->a;
+	return x->d;
+}
+
+static void raninit(ranctx *x, u64 *seed) {
+	int i;
+
+	x->a = seed[0];
+	x->b = seed[1];
+	x->c = seed[2];
+	x->d = seed[3];
+
+	for (i=0; i < 30; ++i)
+		(void)ranval(x);
+}
+
+static u64 shuffle_seed[4];
+
+struct partition_group {
+	tree tree_start;
+	unsigned long start;
+	unsigned long length;
+};
+
+static void partition_struct(tree *fields, unsigned long length, struct partition_group *size_groups, unsigned long *num_groups)
+{
+	unsigned long i;
+	unsigned long accum_size = 0;
+	unsigned long accum_length = 0;
+	unsigned long group_idx = 0;
+
+	gcc_assert(length < INT_MAX);
+
+	memset(size_groups, 0, sizeof(struct partition_group) * length);
+
+	for (i = 0; i < length; i++) {
+		if (size_groups[group_idx].tree_start == NULL_TREE) {
+			size_groups[group_idx].tree_start = fields[i];
+			size_groups[group_idx].start = i;
+			accum_length = 0;
+			accum_size = 0;
+		}
+		accum_size += (unsigned long)int_size_in_bytes(TREE_TYPE(fields[i]));
+		accum_length++;
+		if (accum_size >= 64) {
+			size_groups[group_idx].length = accum_length;
+			accum_length = 0;
+			group_idx++;
+		}
+	}
+
+	if (size_groups[group_idx].tree_start != NULL_TREE &&
+	    !size_groups[group_idx].length) {
+		size_groups[group_idx].length = accum_length;
+		group_idx++;
+	}
+
+	*num_groups = group_idx;
+}
+
+static void performance_shuffle(tree *newtree, unsigned long length, ranctx *prng_state)
+{
+	unsigned long i, x;
+	struct partition_group size_group[length];
+	unsigned long num_groups = 0;
+	unsigned long randnum;
+
+	partition_struct(newtree, length, (struct partition_group *)&size_group, &num_groups);
+	for (i = num_groups - 1; i > 0; i--) {
+		struct partition_group tmp;
+		randnum = ranval(prng_state) % (i + 1);
+		tmp = size_group[i];
+		size_group[i] = size_group[randnum];
+		size_group[randnum] = tmp;
+	}
+
+	for (x = 0; x < num_groups; x++) {
+		for (i = size_group[x].start + size_group[x].length - 1; i > size_group[x].start; i--) {
+			tree tmp;
+			if (DECL_BIT_FIELD_TYPE(newtree[i]))
+				continue;
+			randnum = ranval(prng_state) % (i + 1);
+			// we could handle this case differently if desired
+			if (DECL_BIT_FIELD_TYPE(newtree[randnum]))
+				continue;
+			tmp = newtree[i];
+			newtree[i] = newtree[randnum];
+			newtree[randnum] = tmp;
+		}
+	}
+}
+
+static void full_shuffle(tree *newtree, unsigned long length, ranctx *prng_state)
+{
+	unsigned long i, randnum;
+
+	for (i = length - 1; i > 0; i--) {
+		tree tmp;
+		randnum = ranval(prng_state) % (i + 1);
+		tmp = newtree[i];
+		newtree[i] = newtree[randnum];
+		newtree[randnum] = tmp;
+	}
+}
+
+/* modern in-place Fisher-Yates shuffle */
+static void shuffle(const_tree type, tree *newtree, unsigned long length)
+{
+	unsigned long i;
+	u64 seed[4];
+	ranctx prng_state;
+	const unsigned char *structname;
+
+	if (length == 0)
+		return;
+
+	gcc_assert(TREE_CODE(type) == RECORD_TYPE);
+
+	structname = ORIG_TYPE_NAME(type);
+
+#ifdef __DEBUG_PLUGIN
+	fprintf(stderr, "Shuffling struct %s %p\n", (const char *)structname, type);
+#ifdef __DEBUG_VERBOSE
+	debug_tree((tree)type);
+#endif
+#endif
+
+	for (i = 0; i < 4; i++) {
+		seed[i] = shuffle_seed[i];
+		seed[i] ^= name_hash(structname);
+	}
+
+	raninit(&prng_state, (u64 *)&seed);
+
+	if (performance_mode)
+		performance_shuffle(newtree, length, &prng_state);
+	else
+		full_shuffle(newtree, length, &prng_state);
+}
+
+static bool is_flexible_array(const_tree field)
+{
+	const_tree fieldtype;
+	const_tree typesize;
+	const_tree elemtype;
+	const_tree elemsize;
+
+	fieldtype = TREE_TYPE(field);
+	typesize = TYPE_SIZE(fieldtype);
+
+	if (TREE_CODE(fieldtype) != ARRAY_TYPE)
+		return false;
+
+	elemtype = TREE_TYPE(fieldtype);
+	elemsize = TYPE_SIZE(elemtype);
+
+	/* size of type is represented in bits */
+
+	if (typesize == NULL_TREE && TYPE_DOMAIN(fieldtype) != NULL_TREE &&
+	    TYPE_MAX_VALUE(TYPE_DOMAIN(fieldtype)) == NULL_TREE)
+		return true;
+
+	if (typesize != NULL_TREE && 
+	    (TREE_CONSTANT(typesize) && (!tree_to_uhwi(typesize) ||
+	     tree_to_uhwi(typesize) == tree_to_uhwi(elemsize))))
+		return true;
+
+	return false;
+}
+
+static int relayout_struct(tree type)
+{
+	unsigned long num_fields = (unsigned long)list_length(TYPE_FIELDS(type));
+	unsigned long shuffle_length = num_fields;
+	tree field;
+	tree newtree[num_fields];
+	unsigned long i;
+	tree list;
+	tree variant;
+	tree main_variant;
+	expanded_location xloc;
+	bool has_flexarray = false;
+
+	if (TYPE_FIELDS(type) == NULL_TREE)
+		return 0;
+
+	if (num_fields < 2)
+		return 0;
+
+	gcc_assert(TREE_CODE(type) == RECORD_TYPE);
+
+	gcc_assert(num_fields < INT_MAX);
+
+	if (lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(type)) ||
+	    lookup_attribute("no_randomize_layout", TYPE_ATTRIBUTES(TYPE_MAIN_VARIANT(type))))
+		return 0;
+
+	/* Workaround for 3rd-party VirtualBox source that we can't modify ourselves */
+	if (!strcmp((const char *)ORIG_TYPE_NAME(type), "INTNETTRUNKFACTORY") ||
+	    !strcmp((const char *)ORIG_TYPE_NAME(type), "RAWPCIFACTORY"))
+		return 0;
+
+	/* throw out any structs in uapi */
+	xloc = expand_location(DECL_SOURCE_LOCATION(TYPE_FIELDS(type)));
+
+	if (strstr(xloc.file, "/uapi/"))
+		error(G_("attempted to randomize userland API struct %s"), ORIG_TYPE_NAME(type));
+
+	for (field = TYPE_FIELDS(type), i = 0; field; field = TREE_CHAIN(field), i++) {
+		gcc_assert(TREE_CODE(field) == FIELD_DECL);
+		newtree[i] = field;
+	}
+
+	/*
+	 * enforce that we don't randomize the layout of the last
+	 * element of a struct if it's a 0 or 1-length array
+	 * or a proper flexible array
+	 */
+	if (is_flexible_array(newtree[num_fields - 1])) {
+		has_flexarray = true;
+		shuffle_length--;
+	}
+
+	shuffle(type, (tree *)newtree, shuffle_length);
+
+	/*
+	 * set up a bogus anonymous struct field designed to error out on unnamed struct initializers
+	 * as gcc provides no other way to detect such code
+	 */
+	list = make_node(FIELD_DECL);
+	TREE_CHAIN(list) = newtree[0];
+	TREE_TYPE(list) = void_type_node;
+	DECL_SIZE(list) = bitsize_zero_node;
+	DECL_NONADDRESSABLE_P(list) = 1;
+	DECL_FIELD_BIT_OFFSET(list) = bitsize_zero_node;
+	DECL_SIZE_UNIT(list) = size_zero_node;
+	DECL_FIELD_OFFSET(list) = size_zero_node;
+	DECL_CONTEXT(list) = type;
+	// to satisfy the constify plugin
+	TREE_READONLY(list) = 1;
+
+	for (i = 0; i < num_fields - 1; i++)
+		TREE_CHAIN(newtree[i]) = newtree[i+1];
+	TREE_CHAIN(newtree[num_fields - 1]) = NULL_TREE;
+
+	main_variant = TYPE_MAIN_VARIANT(type);
+	for (variant = main_variant; variant; variant = TYPE_NEXT_VARIANT(variant)) {
+		TYPE_FIELDS(variant) = list;
+		TYPE_ATTRIBUTES(variant) = copy_list(TYPE_ATTRIBUTES(variant));
+		TYPE_ATTRIBUTES(variant) = tree_cons(get_identifier("randomize_performed"), NULL_TREE, TYPE_ATTRIBUTES(variant));
+		if (has_flexarray)
+			TYPE_ATTRIBUTES(type) = tree_cons(get_identifier("has_flexarray"), NULL_TREE, TYPE_ATTRIBUTES(type));
+	}
+
+	/*
+	 * force a re-layout of the main variant
+	 * the TYPE_SIZE for all variants will be recomputed
+	 * by finalize_type_size()
+	 */
+	TYPE_SIZE(main_variant) = NULL_TREE;
+	layout_type(main_variant);
+	gcc_assert(TYPE_SIZE(main_variant) != NULL_TREE);
+
+	return 1;
+}
+
+/* from constify plugin */
+static const_tree get_field_type(const_tree field)
+{
+	return strip_array_types(TREE_TYPE(field));
+}
+
+/* from constify plugin */
+static bool is_fptr(const_tree fieldtype)
+{
+	if (TREE_CODE(fieldtype) != POINTER_TYPE)
+		return false;
+
+	return TREE_CODE(TREE_TYPE(fieldtype)) == FUNCTION_TYPE;
+}
+
+/* derived from constify plugin */
+static int is_pure_ops_struct(const_tree node)
+{
+	const_tree field;
+
+	gcc_assert(TREE_CODE(node) == RECORD_TYPE || TREE_CODE(node) == UNION_TYPE);
+
+	for (field = TYPE_FIELDS(node); field; field = TREE_CHAIN(field)) {
+		const_tree fieldtype = get_field_type(field);
+		enum tree_code code = TREE_CODE(fieldtype);
+
+		if (node == fieldtype)
+			continue;
+
+		if (!is_fptr(fieldtype))
+			return 0;
+
+		if (code != RECORD_TYPE && code != UNION_TYPE)
+			continue;
+
+		if (!is_pure_ops_struct(fieldtype))
+			return 0;
+	}
+
+	return 1;
+}
+
+static void randomize_type(tree type)
+{
+	tree variant;
+
+	gcc_assert(TREE_CODE(type) == RECORD_TYPE);
+
+	if (lookup_attribute("randomize_considered", TYPE_ATTRIBUTES(type)))
+		return;
+
+	if (lookup_attribute("randomize_layout", TYPE_ATTRIBUTES(TYPE_MAIN_VARIANT(type))) || is_pure_ops_struct(type))
+		relayout_struct(type);
+
+	for (variant = TYPE_MAIN_VARIANT(type); variant; variant = TYPE_NEXT_VARIANT(variant)) {
+		TYPE_ATTRIBUTES(type) = copy_list(TYPE_ATTRIBUTES(type));
+		TYPE_ATTRIBUTES(type) = tree_cons(get_identifier("randomize_considered"), NULL_TREE, TYPE_ATTRIBUTES(type));
+	}
+#ifdef __DEBUG_PLUGIN
+	fprintf(stderr, "Marking randomize_considered on struct %s\n", ORIG_TYPE_NAME(type));
+#ifdef __DEBUG_VERBOSE
+	debug_tree(type);
+#endif
+#endif
+}
+
+static void update_decl_size(tree decl)
+{
+	tree lastval, lastidx, field, init, type, flexsize;
+	unsigned HOST_WIDE_INT len;
+
+	type = TREE_TYPE(decl);
+
+	if (!lookup_attribute("has_flexarray", TYPE_ATTRIBUTES(type)))
+		return;
+
+	init = DECL_INITIAL(decl);
+	if (init == NULL_TREE || init == error_mark_node)
+		return;
+
+	if (TREE_CODE(init) != CONSTRUCTOR)
+		return;
+
+	len = CONSTRUCTOR_NELTS(init);
+        if (!len)
+		return;
+
+	lastval = CONSTRUCTOR_ELT(init, CONSTRUCTOR_NELTS(init) - 1)->value;
+	lastidx = CONSTRUCTOR_ELT(init, CONSTRUCTOR_NELTS(init) - 1)->index;
+
+	for (field = TYPE_FIELDS(TREE_TYPE(decl)); TREE_CHAIN(field); field = TREE_CHAIN(field))
+		;
+
+	if (lastidx != field)
+		return;
+
+	if (TREE_CODE(lastval) != STRING_CST) {
+		error("Only string constants are supported as initializers "
+		      "for randomized structures with flexible arrays");
+		return;
+	}
+
+	flexsize = bitsize_int(TREE_STRING_LENGTH(lastval) *
+		tree_to_uhwi(TYPE_SIZE(TREE_TYPE(TREE_TYPE(lastval)))));
+
+	DECL_SIZE(decl) = size_binop(PLUS_EXPR, TYPE_SIZE(type), flexsize);
+
+	return;
+}
+
+
+static void randomize_layout_finish_decl(void *event_data, void *data)
+{
+	tree decl = (tree)event_data;
+	tree type;
+
+	if (decl == NULL_TREE || decl == error_mark_node)
+		return;
+
+	type = TREE_TYPE(decl);
+
+	if (TREE_CODE(decl) != VAR_DECL)
+		return;
+
+	if (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)
+		return;
+
+	if (!lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(type)))
+		return;
+
+	DECL_SIZE(decl) = 0;
+	DECL_SIZE_UNIT(decl) = 0;
+	DECL_ALIGN(decl) = 0;
+	DECL_MODE (decl) = VOIDmode;
+	SET_DECL_RTL(decl, 0);
+	update_decl_size(decl);
+	layout_decl(decl, 0);
+}
+
+static void finish_type(void *event_data, void *data)
+{
+	tree type = (tree)event_data;
+
+	if (type == NULL_TREE || type == error_mark_node)
+		return;
+
+	if (TREE_CODE(type) != RECORD_TYPE)
+		return;
+
+	if (TYPE_FIELDS(type) == NULL_TREE)
+		return;
+
+	if (lookup_attribute("randomize_considered", TYPE_ATTRIBUTES(type)))
+		return;
+
+#ifdef __DEBUG_PLUGIN
+	fprintf(stderr, "Calling randomize_type on %s\n", ORIG_TYPE_NAME(type));
+#endif
+#ifdef __DEBUG_VERBOSE
+	debug_tree(type);
+#endif
+	randomize_type(type);
+
+	return;
+}
+
+static struct attribute_spec randomize_layout_attr = {
+	.name		= "randomize_layout",
+	// related to args
+	.min_length	= 0,
+	.max_length	= 0,
+	.decl_required	= false,
+	// need type declaration
+	.type_required	= true,
+	.function_type_required = false,
+	.handler		= handle_randomize_layout_attr,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity  = true
+#endif
+};
+
+static struct attribute_spec no_randomize_layout_attr = {
+	.name		= "no_randomize_layout",
+	// related to args
+	.min_length	= 0,
+	.max_length	= 0,
+	.decl_required	= false,
+	// need type declaration
+	.type_required	= true,
+	.function_type_required = false,
+	.handler		= handle_randomize_layout_attr,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity  = true
+#endif
+};
+
+static struct attribute_spec randomize_considered_attr = {
+	.name		= "randomize_considered",
+	// related to args
+	.min_length	= 0,
+	.max_length	= 0,
+	.decl_required	= false,
+	// need type declaration
+	.type_required	= true,
+	.function_type_required = false,
+	.handler		= handle_randomize_considered_attr,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity  = false
+#endif
+};
+
+static struct attribute_spec randomize_performed_attr = {
+	.name		= "randomize_performed",
+	// related to args
+	.min_length	= 0,
+	.max_length	= 0,
+	.decl_required	= false,
+	// need type declaration
+	.type_required	= true,
+	.function_type_required = false,
+	.handler		= handle_randomize_performed_attr,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity  = false
+#endif
+};
+
+static void register_attributes(void *event_data, void *data)
+{
+	register_attribute(&randomize_layout_attr);
+	register_attribute(&no_randomize_layout_attr);
+	register_attribute(&randomize_considered_attr);
+	register_attribute(&randomize_performed_attr);
+}
+
+static void check_bad_casts_in_constructor(tree var, tree init)
+{
+	unsigned HOST_WIDE_INT idx;
+	tree field, val;
+	tree field_type, val_type;
+
+	FOR_EACH_CONSTRUCTOR_ELT(CONSTRUCTOR_ELTS(init), idx, field, val) {
+		if (TREE_CODE(val) == CONSTRUCTOR) {
+			check_bad_casts_in_constructor(var, val);
+			continue;
+		}
+
+		/* pipacs' plugin creates franken-arrays that differ from those produced by
+		   normal code which all have valid 'field' trees. work around this */
+		if (field == NULL_TREE)
+			continue;
+		field_type = TREE_TYPE(field);
+		val_type = TREE_TYPE(val);
+
+		if (TREE_CODE(field_type) != POINTER_TYPE || TREE_CODE(val_type) != POINTER_TYPE)
+			continue;
+
+		if (field_type == val_type)
+			continue;
+
+		field_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(field_type))));
+		val_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(val_type))));
+
+		if (field_type == void_type_node)
+			continue;
+		if (field_type == val_type)
+			continue;
+		if (TREE_CODE(val_type) != RECORD_TYPE)
+			continue;
+
+		if (!lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(val_type)))
+			continue;
+		inform(DECL_SOURCE_LOCATION(var), "found mismatched struct pointer types: %qT and %qT\n", TYPE_MAIN_VARIANT(field_type), TYPE_MAIN_VARIANT(val_type));
+	}
+}
+
+/* derived from the constify plugin */
+static void check_global_variables(void *event_data, void *data)
+{
+	struct varpool_node *node;
+	tree init;
+
+	FOR_EACH_VARIABLE(node) {
+		tree var = NODE_DECL(node);
+		init = DECL_INITIAL(var);
+		if (init == NULL_TREE)
+			continue;
+
+		if (TREE_CODE(init) != CONSTRUCTOR)
+			continue;
+
+		check_bad_casts_in_constructor(var, init);
+	}
+}
+
+static bool dominated_by_is_err(const_tree rhs, basic_block bb)
+{
+	basic_block dom;
+	gimple dom_stmt;
+	gimple call_stmt;
+	const_tree dom_lhs;
+	const_tree poss_is_err_cond;
+	const_tree poss_is_err_func;
+	const_tree is_err_arg;
+
+	dom = get_immediate_dominator(CDI_DOMINATORS, bb);
+	if (!dom)
+		return false;
+
+	dom_stmt = last_stmt(dom);
+	if (!dom_stmt)
+		return false;
+
+	if (gimple_code(dom_stmt) != GIMPLE_COND)
+		return false;
+
+	if (gimple_cond_code(dom_stmt) != NE_EXPR)
+		return false;
+
+	if (!integer_zerop(gimple_cond_rhs(dom_stmt)))
+		return false;
+
+	poss_is_err_cond = gimple_cond_lhs(dom_stmt);
+
+	if (TREE_CODE(poss_is_err_cond) != SSA_NAME)
+		return false;
+
+	call_stmt = SSA_NAME_DEF_STMT(poss_is_err_cond);
+
+	if (gimple_code(call_stmt) != GIMPLE_CALL)
+		return false;
+
+	dom_lhs = gimple_get_lhs(call_stmt);
+	poss_is_err_func = gimple_call_fndecl(call_stmt);
+	if (!poss_is_err_func)
+		return false;
+	if (dom_lhs != poss_is_err_cond)
+		return false;
+	if (strcmp(DECL_NAME_POINTER(poss_is_err_func), "IS_ERR"))
+		return false;
+
+	is_err_arg = gimple_call_arg(call_stmt, 0);
+	if (!is_err_arg)
+		return false;
+
+	if (is_err_arg != rhs)
+		return false;
+
+	return true;
+}
+
+static void handle_local_var_initializers(void)
+{
+	tree var;
+	unsigned int i;
+
+	FOR_EACH_LOCAL_DECL(cfun, i, var) {
+		tree init = DECL_INITIAL(var);
+		if (!init)
+			continue;
+		if (TREE_CODE(init) != CONSTRUCTOR)
+			continue;
+		check_bad_casts_in_constructor(var, init);
+	}
+}
+
+/*
+ * iterate over all statements to find "bad" casts:
+ * those where the address of the start of a structure is cast
+ * to a pointer of a structure of a different type, or a
+ * structure pointer type is cast to a different structure pointer type
+ */
+static unsigned int find_bad_casts_execute(void)
+{
+	basic_block bb;
+
+	handle_local_var_initializers();
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+			const_tree lhs;
+			const_tree lhs_type;
+			const_tree rhs1;
+			const_tree rhs_type;
+			const_tree ptr_lhs_type;
+			const_tree ptr_rhs_type;
+			const_tree op0;
+			const_tree op0_type;
+			enum tree_code rhs_code;
+
+			stmt = gsi_stmt(gsi);
+
+#ifdef __DEBUG_PLUGIN
+#ifdef __DEBUG_VERBOSE
+			debug_gimple_stmt(stmt);
+			debug_tree(gimple_get_lhs(stmt));
+#endif
+#endif
+
+			if (gimple_code(stmt) != GIMPLE_ASSIGN)
+				continue;
+
+#ifdef __DEBUG_PLUGIN
+#ifdef __DEBUG_VERBOSE
+			debug_tree(gimple_assign_rhs1(stmt));
+#endif
+#endif
+
+			rhs_code = gimple_assign_rhs_code(stmt);
+
+			if (rhs_code != ADDR_EXPR && rhs_code != SSA_NAME)
+				continue;
+
+			lhs = gimple_get_lhs(stmt);
+			lhs_type = TREE_TYPE(lhs);
+			rhs1 = gimple_assign_rhs1(stmt);
+			rhs_type = TREE_TYPE(rhs1);
+
+			if (TREE_CODE(rhs_type) != POINTER_TYPE ||
+			    TREE_CODE(lhs_type) != POINTER_TYPE)
+				continue;
+
+			ptr_lhs_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(lhs_type))));
+			ptr_rhs_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(rhs_type))));
+
+			if (ptr_rhs_type == void_type_node)
+				continue;
+
+			if (ptr_lhs_type == void_type_node)
+				continue;
+
+			if (dominated_by_is_err(rhs1, bb))
+				continue;
+
+			if (TREE_CODE(ptr_rhs_type) != RECORD_TYPE) {
+#ifndef __DEBUG_PLUGIN
+				if (lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(ptr_lhs_type)))
+#endif
+				inform(gimple_location(stmt), "found mismatched struct pointer types: %qT and %qT\n", ptr_lhs_type, ptr_rhs_type);
+				continue;
+			}
+
+			if (rhs_code == SSA_NAME && ptr_lhs_type == ptr_rhs_type)
+				continue;
+
+			if (rhs_code == ADDR_EXPR) {
+				op0 = TREE_OPERAND(rhs1, 0);
+
+				if (op0 == NULL_TREE)
+					continue;
+
+				if (TREE_CODE(op0) != VAR_DECL)
+					continue;
+
+				op0_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(op0))));
+				if (op0_type == ptr_lhs_type)
+					continue;
+
+#ifndef __DEBUG_PLUGIN
+				if (lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(op0_type)))
+#endif
+				inform(gimple_location(stmt), "found mismatched struct pointer types: %qT and %qT\n", ptr_lhs_type, op0_type);
+			} else {
+				const_tree ssa_name_var = SSA_NAME_VAR(rhs1);
+				/* skip bogus type casts introduced by container_of */
+				if (ssa_name_var != NULL_TREE && DECL_NAME(ssa_name_var) && 
+				    !strcmp((const char *)DECL_NAME_POINTER(ssa_name_var), "__mptr"))
+					continue;
+#ifndef __DEBUG_PLUGIN
+				if (lookup_attribute("randomize_performed", TYPE_ATTRIBUTES(ptr_rhs_type)))
+#endif
+				inform(gimple_location(stmt), "found mismatched struct pointer types: %qT and %qT\n", ptr_lhs_type, ptr_rhs_type);
+			}
+
+		}
+	}
+	return 0;
+}
+
+#define PASS_NAME find_bad_casts
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+#include "gcc-generate-gimple-pass.h"
+
+__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable = true;
+	int obtained_seed = 0;
+	struct register_pass_info find_bad_casts_pass_info;
+
+	find_bad_casts_pass_info.pass			= make_find_bad_casts_pass();
+	find_bad_casts_pass_info.reference_pass_name	= "ssa";
+	find_bad_casts_pass_info.ref_pass_instance_number	= 1;
+	find_bad_casts_pass_info.pos_op			= PASS_POS_INSERT_AFTER;
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	if (strncmp(lang_hooks.name, "GNU C", 5) && !strncmp(lang_hooks.name, "GNU C+", 6)) {
+		inform(UNKNOWN_LOCATION, G_("%s supports C only, not %s"), plugin_name, lang_hooks.name);
+		enable = false;
+	}
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "disable")) {
+			enable = false;
+			continue;
+		}
+		if (!strcmp(argv[i].key, "performance-mode")) {
+			performance_mode = 1;
+			continue;
+		}
+		error(G_("unknown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	if (strlen(randstruct_seed) != 64) {
+		error(G_("invalid seed value supplied for %s plugin"), plugin_name);
+		return 1;
+	}
+	obtained_seed = sscanf(randstruct_seed, "%016llx%016llx%016llx%016llx",
+		&shuffle_seed[0], &shuffle_seed[1], &shuffle_seed[2], &shuffle_seed[3]);
+	if (obtained_seed != 4) {
+		error(G_("Invalid seed supplied for %s plugin"), plugin_name);
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &randomize_layout_plugin_info);
+	if (enable) {
+		register_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, check_global_variables, NULL);
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &find_bad_casts_pass_info);
+		register_callback(plugin_name, PLUGIN_FINISH_TYPE, finish_type, NULL);
+		register_callback(plugin_name, PLUGIN_FINISH_DECL, randomize_layout_finish_decl, NULL);
+	}
+	register_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);
+
+	return 0;
+}
diff --git a/scripts/gcc-plugins/size_overflow_plugin/e_fields.data b/scripts/gcc-plugins/size_overflow_plugin/e_fields.data
index 87b7ef5f3992..88df810cd282 100644
--- a/scripts/gcc-plugins/size_overflow_plugin/e_fields.data
+++ b/scripts/gcc-plugins/size_overflow_plugin/e_fields.data
@@ -2,6 +2,7 @@ recv_ctrl_pipe_us_data_0_fields recv_ctrl_pipe us_data 0 0 NULL
 __earlyonly_bootmem_alloc_fndecl_3_fields __earlyonly_bootmem_alloc fndecl 2-3-4 3 NULL
 size_ttm_mem_reg_8_fields size ttm_mem_reg 0 8 NULL
 char2uni_nls_table_12_fields char2uni nls_table 0 12 NULL
+nrbufs_pipe_inode_info_13_fields nrbufs pipe_inode_info 0 13 NULL
 NumPhys__EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE_17_fields NumPhys _EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE 0 17 NULL
 pci_mem_start_qed_dev_info_18_fields pci_mem_start qed_dev_info 0 18 NULL
 ext4_seek_data_fndecl_21_fields ext4_seek_data fndecl 2 21 NULL
@@ -82,10 +83,13 @@ bytesperline_sh_veu_vfmt_288_fields bytesperline sh_veu_vfmt 0 288 NULL nohashar
 vmscsi_size_delta_vardecl_storvsc_drv_c_288_fields vmscsi_size_delta vardecl_storvsc_drv.c 0 288 &bytesperline_sh_veu_vfmt_288_fields
 xfs_qm_dqread_fndecl_302_fields xfs_qm_dqread fndecl 0 302 NULL nohasharray
 num_targets_dm_table_302_fields num_targets dm_table 0 302 &xfs_qm_dqread_fndecl_302_fields
+tx_ring_size_mvneta_port_307_fields tx_ring_size mvneta_port 0 307 NULL
+omapdss_update_prop_fndecl_309_fields omapdss_update_prop fndecl 3 309 NULL
 cfpkt_create_pfx_fndecl_313_fields cfpkt_create_pfx fndecl 2 313 NULL
 MaxBufferSize_negotiate_rsp_314_fields MaxBufferSize negotiate_rsp 0 314 NULL nohasharray
 ip_num_acl_subject_label_314_fields ip_num acl_subject_label 0 314 &MaxBufferSize_negotiate_rsp_314_fields
 name_len_jffs2_raw_xattr_318_fields name_len jffs2_raw_xattr 0 318 NULL
+bo_handle_count_drm_vc4_submit_cl_326_fields bo_handle_count drm_vc4_submit_cl 0 326 NULL
 start_fb_cmap_user_333_fields start fb_cmap_user 0 333 NULL
 block_size_se_dev_attrib_334_fields block_size se_dev_attrib 0 334 NULL
 xfs_file_iomap_begin_fndecl_341_fields xfs_file_iomap_begin fndecl 2-3 341 NULL
@@ -219,13 +223,15 @@ amt_complete_orangefs_io_response_925_fields amt_complete orangefs_io_response 0
 isofs_bread_fndecl_929_fields isofs_bread fndecl 2 929 NULL
 xpnet_dev_change_mtu_fndecl_932_fields xpnet_dev_change_mtu fndecl 2 932 NULL
 nfrags_pkt_gl_937_fields nfrags pkt_gl 0 937 NULL
-size_skl_algo_data_942_fields size skl_algo_data 0 942 NULL
+size_skl_algo_data_942_fields size skl_algo_data 0 942 NULL nohasharray
+num_spis_alpine_msix_data_942_fields num_spis alpine_msix_data 0 942 &size_skl_algo_data_942_fields
 pci_num_vf_fndecl_952_fields pci_num_vf fndecl 0 952 NULL
 ssid_len_wireless_dev_954_fields ssid_len wireless_dev 0 954 NULL
 length_ndis_80211_bssid_ex_955_fields length ndis_80211_bssid_ex 0 955 NULL
 xfs_bmap_rtalloc_fndecl_958_fields xfs_bmap_rtalloc fndecl 0 958 NULL
 size_wl3501_md_ind_961_fields size wl3501_md_ind 0 961 NULL
 avc_tuner_tuneqpsk_fndecl_978_fields avc_tuner_tuneqpsk fndecl 0 978 NULL
+tx_ring_size_tx_queue_982_fields tx_ring_size tx_queue 0 982 NULL
 em28xx_alloc_urbs_fndecl_983_fields em28xx_alloc_urbs fndecl 5-6 983 NULL nohasharray
 s_blocks_count_hi_ext4_super_block_983_fields s_blocks_count_hi ext4_super_block 0 983 &em28xx_alloc_urbs_fndecl_983_fields
 nd_integrity_init_fndecl_985_fields nd_integrity_init fndecl 2 985 NULL nohasharray
@@ -273,6 +279,7 @@ rx_ring_count_e1000_adapter_1107_fields rx_ring_count e1000_adapter 0 1107 NULL
 cmd_sg_entries_vardecl_ib_srp_c_1108_fields cmd_sg_entries vardecl_ib_srp.c 0 1108 NULL
 ResponseDataLength__MPI2_SMP_PASSTHROUGH_REPLY_1113_fields ResponseDataLength _MPI2_SMP_PASSTHROUGH_REPLY 0 1113 NULL
 io_free_memtype_fndecl_1116_fields io_free_memtype fndecl 1-2 1116 NULL
+gb_operation_get_payload_size_max_fndecl_1118_fields gb_operation_get_payload_size_max fndecl 0 1118 NULL
 rxkad_decrypt_ticket_fndecl_1120_fields rxkad_decrypt_ticket fndecl 3 1120 NULL
 ctl_in_pipe_brcmf_usbdev_info_1124_fields ctl_in_pipe brcmf_usbdev_info 0 1124 NULL
 forw_xfs_dir3_icleaf_hdr_1136_fields forw xfs_dir3_icleaf_hdr 0 1136 NULL
@@ -335,6 +342,7 @@ found_index_locate_info_1355_fields found_index locate_info 0 1355 NULL
 MemReadHSCX_fndecl_1364_fields MemReadHSCX fndecl 0 1364 NULL
 len_btrfs_ordered_sum_1365_fields len btrfs_ordered_sum 0 1365 NULL nohasharray
 ssram_size_telemetry_unit_config_1365_fields ssram_size telemetry_unit_config 0 1365 &len_btrfs_ordered_sum_1365_fields
+tx_ring_count_xgbe_prv_data_1366_fields tx_ring_count xgbe_prv_data 0 1366 NULL
 len_orinoco_scan_data_1370_fields len orinoco_scan_data 0 1370 NULL nohasharray
 dlen_hci_sco_hdr_1370_fields dlen hci_sco_hdr 0 1370 &len_orinoco_scan_data_1370_fields
 v_total_aty128_crtc_1375_fields v_total aty128_crtc 0 1375 NULL
@@ -446,6 +454,7 @@ offset_scrub_nocow_inode_1762_fields offset scrub_nocow_inode 0 1762 NULL
 __es_insert_extent_fndecl_1764_fields __es_insert_extent fndecl 0 1764 NULL
 nentries_hfi1_user_sdma_comp_q_1768_fields nentries hfi1_user_sdma_comp_q 0 1768 NULL
 eqe_size_mlx4_caps_1775_fields eqe_size mlx4_caps 0 1775 NULL
+overlay_num_mmp_path_info_1781_fields overlay_num mmp_path_info 0 1781 NULL
 key_length_mwifiex_wep_key_1784_fields key_length mwifiex_wep_key 0 1784 NULL
 __of_translate_address_fndecl_1786_fields __of_translate_address fndecl 0 1786 NULL
 pitch_radeonfb_info_1792_fields pitch radeonfb_info 0 1792 NULL
@@ -503,6 +512,7 @@ vga_vram_base_vardecl_vgacon_c_2024_fields vga_vram_base vardecl_vgacon.c 0 2024
 max_write_fuse_conn_2028_fields max_write fuse_conn 0 2028 NULL
 process_adv_report_fndecl_2030_fields process_adv_report fndecl 9 2030 NULL
 ib_umem_odp_map_dma_single_page_fndecl_2040_fields ib_umem_odp_map_dma_single_page fndecl 0 2040 NULL
+num_phy_chans_d40_base_2049_fields num_phy_chans d40_base 0 2049 NULL
 gss_encrypt_xdr_buf_fndecl_2050_fields gss_encrypt_xdr_buf fndecl 3 2050 NULL
 set_sock_size_fndecl_2051_fields set_sock_size fndecl 3 2051 NULL
 fscrypt_zeroout_range_fndecl_2052_fields fscrypt_zeroout_range fndecl 3 2052 NULL
@@ -529,6 +539,7 @@ count_skge_ring_2140_fields count skge_ring 0 2140 NULL
 xfs_do_writepage_fndecl_2144_fields xfs_do_writepage fndecl 0 2144 NULL nohasharray
 capacity_p9_fcall_2144_fields capacity p9_fcall 0 2144 &xfs_do_writepage_fndecl_2144_fields
 multi_ios_hda_gen_spec_2147_fields multi_ios hda_gen_spec 0 2147 NULL
+ioc_len_obd_ioctl_hdr_2148_fields ioc_len obd_ioctl_hdr 0 2148 NULL
 mpc_new_length_vardecl_mpparse_c_2163_fields mpc_new_length vardecl_mpparse.c 0 2163 NULL nohasharray
 block_size__drive_info_struct_2163_fields block_size _drive_info_struct 0 2163 &mpc_new_length_vardecl_mpparse_c_2163_fields
 read_size_perf_event_2173_fields read_size perf_event 0 2173 NULL
@@ -628,6 +639,7 @@ len_patch_info_2583_fields len patch_info 0 2583 NULL
 nr_pages_scif_pinned_pages_2586_fields nr_pages scif_pinned_pages 0 2586 NULL
 page_cache_tree_insert_fndecl_2600_fields page_cache_tree_insert fndecl 0 2600 NULL
 maxfrsize_bfa_fcs_rport_s_2601_fields maxfrsize bfa_fcs_rport_s 0 2601 NULL
+ld_active_tgt_count_lov_desc_2613_fields ld_active_tgt_count lov_desc 0 2613 NULL
 dst_maxburst_dma_slave_config_2619_fields dst_maxburst dma_slave_config 0 2619 NULL
 len_whc_std_2626_fields len whc_std 0 2626 NULL
 ptn3460_read_bytes_fndecl_2627_fields ptn3460_read_bytes fndecl 4 2627 NULL
@@ -792,6 +804,7 @@ rx_buffer_len_ixgb_adapter_3217_fields rx_buffer_len ixgb_adapter 0 3217 NULL no
 cw1200_sdio_memcpy_fromio_fndecl_3217_fields cw1200_sdio_memcpy_fromio fndecl 4 3217 &rx_buffer_len_ixgb_adapter_3217_fields
 mad_size_ib_mad_private_3230_fields mad_size ib_mad_private 0 3230 NULL
 sq_num_entries_c4iw_qp_attributes_3234_fields sq_num_entries c4iw_qp_attributes 0 3234 NULL
+uniforms_size_drm_vc4_submit_cl_3245_fields uniforms_size drm_vc4_submit_cl 0 3245 NULL
 max_wqe_ocrdma_dev_attr_3246_fields max_wqe ocrdma_dev_attr 0 3246 NULL
 s_max_sge_rvt_qp_3248_fields s_max_sge rvt_qp 0 3248 NULL
 of_property_match_string_fndecl_3250_fields of_property_match_string fndecl 0 3250 NULL
@@ -858,6 +871,8 @@ namelen_xfs_dir2_sf_entry_3481_fields namelen xfs_dir2_sf_entry 0 3481 NULL noha
 chip_send_contexts_hfi1_devdata_3481_fields chip_send_contexts hfi1_devdata 0 3481 &namelen_xfs_dir2_sf_entry_3481_fields
 xfer_len_nvme_trans_io_cdb_3486_fields xfer_len nvme_trans_io_cdb 0 3486 NULL
 from_dio_submit_3494_fields from dio_submit 0 3494 NULL
+hs_bkt_bits_cfs_hash_3509_fields hs_bkt_bits cfs_hash 0 3509 NULL
+statesize_hash_alg_common_3517_fields statesize hash_alg_common 0 3517 NULL
 gru_vtop_fndecl_3522_fields gru_vtop fndecl 2 3522 NULL
 cipso_v4_gentag_rng_fndecl_3532_fields cipso_v4_gentag_rng fndecl 0 3532 NULL
 cl_out_max_entry_size_mvumi_hs_page1_3540_fields cl_out_max_entry_size mvumi_hs_page1 0 3540 NULL
@@ -867,7 +882,8 @@ mult_count_ide_drive_s_3550_fields mult_count ide_drive_s 0 3550 NULL
 ocfs2_read_xattr_bucket_fndecl_3553_fields ocfs2_read_xattr_bucket fndecl 2 3553 NULL
 sg_copy_from_buffer_fndecl_3557_fields sg_copy_from_buffer fndecl 0-4 3557 NULL
 mt2063_write_fndecl_3567_fields mt2063_write fndecl 4 3567 NULL
-page_cache_sync_readahead_fndecl_3569_fields page_cache_sync_readahead fndecl 4 3569 NULL
+page_cache_sync_readahead_fndecl_3569_fields page_cache_sync_readahead fndecl 4 3569 NULL nohasharray
+nr_clk_ids_samsung_cmu_info_3569_fields nr_clk_ids samsung_cmu_info 0 3569 &page_cache_sync_readahead_fndecl_3569_fields
 encode_diropargs3_fndecl_3574_fields encode_diropargs3 fndecl 4 3574 NULL
 pkcs7_view_content_fndecl_3589_fields pkcs7_view_content fndecl 3 3589 NULL nohasharray
 ddr_av_base_mthca_av_table_3589_fields ddr_av_base mthca_av_table 0 3589 &pkcs7_view_content_fndecl_3589_fields
@@ -1105,6 +1121,7 @@ qdepth_uas_dev_info_4551_fields qdepth uas_dev_info 0 4551 NULL
 __collapse_huge_page_swapin_fndecl_4553_fields __collapse_huge_page_swapin fndecl 3 4553 NULL nohasharray
 data_len_o2net_msg_4553_fields data_len o2net_msg 0 4553 &__collapse_huge_page_swapin_fndecl_4553_fields
 hwcursor_size_sis_video_info_4560_fields hwcursor_size sis_video_info 0 4560 NULL
+channels_snd_korg1212_4562_fields channels snd_korg1212 0 4562 NULL
 usbvision_rvmalloc_fndecl_4564_fields usbvision_rvmalloc fndecl 1 4564 NULL
 word1_pkt_stat_desc_4565_fields word1 pkt_stat_desc 0 4565 NULL
 far_copies_geom_4570_fields far_copies geom 0 4570 NULL
@@ -1119,7 +1136,8 @@ btrfs_del_inode_extref_fndecl_4607_fields btrfs_del_inode_extref fndecl 4 4607 N
 max_event_log_size_iwl_base_params_4612_fields max_event_log_size iwl_base_params 0 4612 NULL
 sxgbe_change_mtu_fndecl_4613_fields sxgbe_change_mtu fndecl 2 4613 NULL
 cksumlength_gss_krb5_enctype_4630_fields cksumlength gss_krb5_enctype 0 4630 NULL
-tcam_size_mc5_4631_fields tcam_size mc5 0 4631 NULL
+tcam_size_mc5_4631_fields tcam_size mc5 0 4631 NULL nohasharray
+size_minus_one_mxt_object_4631_fields size_minus_one mxt_object 0 4631 &tcam_size_mc5_4631_fields
 total_bytes__osd_req_data_segment_4634_fields total_bytes _osd_req_data_segment 0 4634 NULL
 setup_efi_state_fndecl_4639_fields setup_efi_state fndecl 5-2-4-3 4639 NULL
 irq_nvecs_bnx2_4644_fields irq_nvecs bnx2 0 4644 NULL
@@ -1209,6 +1227,7 @@ radeon_align_pitch_fndecl_4969_fields radeon_align_pitch fndecl 0-2 4969 NULL
 len_htc_record_hdr_4978_fields len htc_record_hdr 0 4978 NULL
 len_i40iw_sge_4979_fields len i40iw_sge 0 4979 NULL
 t_data_nents_se_cmd_4981_fields t_data_nents se_cmd 0 4981 NULL
+buffer_size_most_channel_config_4986_fields buffer_size most_channel_config 0 4986 NULL
 scif_send_fndecl_4988_fields scif_send fndecl 3 4988 NULL
 __mt7601u_dma_fw_fndecl_4994_fields __mt7601u_dma_fw fndecl 4 4994 NULL
 kmem_cache_create_fndecl_5007_fields kmem_cache_create fndecl 2-3 5007 NULL
@@ -1331,7 +1350,8 @@ __tipc_sendmsg_fndecl_5510_fields __tipc_sendmsg fndecl 3 5510 NULL
 vmw_execbuf_submit_cmdbuf_fndecl_5516_fields vmw_execbuf_submit_cmdbuf fndecl 3 5516 NULL
 line_slgt_info_5527_fields line slgt_info 0 5527 NULL
 ceph_tcp_sendpage_fndecl_5531_fields ceph_tcp_sendpage fndecl 0-4 5531 NULL
-batadv_arp_get_type_fndecl_5538_fields batadv_arp_get_type fndecl 3 5538 NULL
+batadv_arp_get_type_fndecl_5538_fields batadv_arp_get_type fndecl 3 5538 NULL nohasharray
+__vmalloc_node_range_fndecl_5538_fields __vmalloc_node_range fndecl 1-3 5538 &batadv_arp_get_type_fndecl_5538_fields
 vector_acpi_hest_notify_5540_fields vector acpi_hest_notify 0 5540 NULL
 logical_ext4_allocation_request_5548_fields logical ext4_allocation_request 0 5548 NULL
 __netdev_alloc_skb_fndecl_5552_fields __netdev_alloc_skb fndecl 2 5552 NULL
@@ -1375,6 +1395,7 @@ lbtf_cmd_async_fndecl_5691_fields lbtf_cmd_async fndecl 4 5691 NULL
 s_blocks_count_ext2_super_block_5695_fields s_blocks_count ext2_super_block 0 5695 NULL
 write_bytes_to_xdr_buf_fndecl_5702_fields write_bytes_to_xdr_buf fndecl 4-2 5702 NULL
 virtnet_change_mtu_fndecl_5709_fields virtnet_change_mtu fndecl 2 5709 NULL
+zm_wmfw_adsp1_alg_hdr_5710_fields zm wmfw_adsp1_alg_hdr 0 5710 NULL
 sys_fcntl_fndecl_5712_fields sys_fcntl fndecl 3 5712 NULL
 vt_hdr_vxfs_typed_5715_fields vt_hdr vxfs_typed 0 5715 NULL
 hfsplus_get_block_fndecl_5725_fields hfsplus_get_block fndecl 2 5725 NULL
@@ -1448,6 +1469,7 @@ status_register_read_fndecl_6023_fields status_register_read fndecl 4 6023 &max_
 wqe_cnt_mlx5_ib_wq_6024_fields wqe_cnt mlx5_ib_wq 0 6024 NULL
 flags_rtl8180_rx_desc_6025_fields flags rtl8180_rx_desc 0 6025 NULL
 xlog_bwrite_fndecl_6028_fields xlog_bwrite fndecl 2 6028 NULL
+size_drm_vc4_create_shader_bo_6033_fields size drm_vc4_create_shader_bo 0 6033 NULL
 msix_map_region_fndecl_6035_fields msix_map_region fndecl 2 6035 NULL
 push_pipe_fndecl_6041_fields push_pipe fndecl 2-0 6041 NULL nohasharray
 ceph_create_snap_context_fndecl_6041_fields ceph_create_snap_context fndecl 1 6041 &push_pipe_fndecl_6041_fields
@@ -1457,6 +1479,7 @@ scif_rb_space_fndecl_6052_fields scif_rb_space fndecl 0 6052 NULL
 dmi_len_vardecl_dmi_scan_c_6054_fields dmi_len vardecl_dmi_scan.c 0 6054 NULL nohasharray
 ext4_inode_table_fndecl_6054_fields ext4_inode_table fndecl 0 6054 &dmi_len_vardecl_dmi_scan_c_6054_fields
 map_base_tpm_inf_dev_6056_fields map_base tpm_inf_dev 0 6056 NULL
+reqsize_kpp_alg_6064_fields reqsize kpp_alg 0 6064 NULL
 length_hci_ev_le_advertising_info_6074_fields length hci_ev_le_advertising_info 0 6074 NULL
 elog_len_extlog_l1_head_6075_fields elog_len extlog_l1_head 0 6075 NULL
 ioctx_alloc_fndecl_6081_fields ioctx_alloc fndecl 1 6081 NULL
@@ -1464,6 +1487,7 @@ __get_user_pages_unlocked_fndecl_6088_fields __get_user_pages_unlocked fndecl 3
 remote_miu_nfc_llcp_sock_6088_fields remote_miu nfc_llcp_sock 0 6088 &__get_user_pages_unlocked_fndecl_6088_fields nohasharray
 pcifront_scan_root_fndecl_6088_fields pcifront_scan_root fndecl 3 6088 &remote_miu_nfc_llcp_sock_6088_fields
 channel_num_ad9523_channel_spec_6095_fields channel_num ad9523_channel_spec 0 6095 NULL
+__gfs2_xattr_set_fndecl_6098_fields __gfs2_xattr_set fndecl 4 6098 NULL
 alloc_irdadev_fndecl_6103_fields alloc_irdadev fndecl 1 6103 NULL
 rate_min_snd_pcm_hardware_6109_fields rate_min snd_pcm_hardware 0 6109 NULL nohasharray
 blkdev_issue_discard_fndecl_6109_fields blkdev_issue_discard fndecl 0-3-2 6109 &rate_min_snd_pcm_hardware_6109_fields
@@ -1472,6 +1496,7 @@ ilf_blkno_xfs_inode_log_format_6118_fields ilf_blkno xfs_inode_log_format 0 6118
 hblank_panel_info_6122_fields hblank panel_info 0 6122 NULL
 max_gs_mlx5_ib_wq_6148_fields max_gs mlx5_ib_wq 0 6148 NULL
 bytes_per_sector_mspro_devinfo_6149_fields bytes_per_sector mspro_devinfo 0 6149 NULL
+fts_ieee80211_device_6153_fields fts ieee80211_device 0 6153 NULL
 name_len_f2fs_dir_entry_6154_fields name_len f2fs_dir_entry 0 6154 NULL
 buf_size_rte_log_le_6160_fields buf_size rte_log_le 0 6160 NULL nohasharray
 udf_read_tagged_fndecl_6160_fields udf_read_tagged fndecl 2 6160 &buf_size_rte_log_le_6160_fields
@@ -1582,6 +1607,7 @@ jffs2_security_setxattr_fndecl_6550_fields jffs2_security_setxattr fndecl 6 6550
 xlog_do_log_recovery_fndecl_6557_fields xlog_do_log_recovery fndecl 3 6557 NULL
 cxgbit_xmit_pdu_fndecl_6562_fields cxgbit_xmit_pdu fndecl 5 6562 NULL
 verity_verify_io_fndecl_6564_fields verity_verify_io fndecl 0 6564 NULL
+num_x_edt_ft5x06_ts_data_6566_fields num_x edt_ft5x06_ts_data 0 6566 NULL
 i915_gem_object_ggtt_pin_fndecl_6569_fields i915_gem_object_ggtt_pin fndecl 3-5 6569 NULL
 ath6kl_wmi_connect_cmd_fndecl_6571_fields ath6kl_wmi_connect_cmd fndecl 2 6571 NULL
 rts51x_write_mem_fndecl_6573_fields rts51x_write_mem fndecl 4 6573 NULL
@@ -1658,6 +1684,7 @@ ctrl_dma_acm_6806_fields ctrl_dma acm 0 6806 NULL
 ip6ip6_err_fndecl_6807_fields ip6ip6_err fndecl 5 6807 NULL
 nfc_digital_allocate_device_fndecl_6810_fields nfc_digital_allocate_device fndecl 4 6810 NULL
 tx_pipe_at76_priv_6815_fields tx_pipe at76_priv 0 6815 NULL
+hs_rehash_bits_cfs_hash_6820_fields hs_rehash_bits cfs_hash 0 6820 NULL
 bfs_iget_fndecl_6821_fields bfs_iget fndecl 2 6821 NULL
 chip_rcv_contexts_hfi1_devdata_6824_fields chip_rcv_contexts hfi1_devdata 0 6824 NULL
 centre_vertically_fndecl_6833_fields centre_vertically fndecl 2 6833 NULL
@@ -1795,6 +1822,7 @@ v_tot_disp_crtc_7400_fields v_tot_disp crtc 0 7400 NULL
 calipso_genopt_fndecl_7401_fields calipso_genopt fndecl 0 7401 NULL
 ext4_ext_zeroout_fndecl_7404_fields ext4_ext_zeroout fndecl 0 7404 NULL
 fw_sent_bcm203x_data_7405_fields fw_sent bcm203x_data 0 7405 NULL
+ln_namelen_lu_name_7408_fields ln_namelen lu_name 0 7408 NULL
 __ip_append_data_fndecl_7411_fields __ip_append_data fndecl 9-8 7411 NULL
 default_value_cx88_ctrl_7412_fields default_value cx88_ctrl 0 7412 NULL
 htotal_psb_pipe_7415_fields htotal psb_pipe 0 7415 NULL nohasharray
@@ -1833,7 +1861,8 @@ tuple_size_blk_integrity_7585_fields tuple_size blk_integrity 0 7585 NULL
 length_sctp_chunkhdr_7587_fields length sctp_chunkhdr 0 7587 NULL
 ftdi_elan_edset_input_fndecl_7588_fields ftdi_elan_edset_input fndecl 0 7588 NULL
 data_size_efi_setvariable_7593_fields data_size efi_setvariable 0 7593 NULL
-scan_index_iio_chan_spec_7597_fields scan_index iio_chan_spec 0 7597 NULL
+scan_index_iio_chan_spec_7597_fields scan_index iio_chan_spec 0 7597 NULL nohasharray
+num_regions_wm_adsp_fw_caps_7597_fields num_regions wm_adsp_fw_caps 0 7597 &scan_index_iio_chan_spec_7597_fields
 q_blkno_xfs_dquot_7601_fields q_blkno xfs_dquot 0 7601 NULL
 pathmtu_sctp_transport_7603_fields pathmtu sctp_transport 0 7603 NULL
 fuse_listxattr_fndecl_7605_fields fuse_listxattr fndecl 3 7605 NULL
@@ -1879,6 +1908,7 @@ maxcmd_nvme_ctrl_7774_fields maxcmd nvme_ctrl 0 7774 NULL
 t_data_nents_orig_se_cmd_7775_fields t_data_nents_orig se_cmd 0 7775 NULL
 mode_size_cyttsp4_sysinfo_ofs_7780_fields mode_size cyttsp4_sysinfo_ofs 0 7780 NULL
 mmu_private_affs_inode_info_7785_fields mmu_private affs_inode_info 0 7785 NULL
+read_index_wm_adsp_compr_buf_7788_fields read_index wm_adsp_compr_buf 0 7788 NULL
 qxl_framebuffer_surface_dirty_fndecl_7791_fields qxl_framebuffer_surface_dirty fndecl 6 7791 NULL
 inode_getblk_fndecl_7794_fields inode_getblk fndecl 2-0 7794 NULL
 __clk_speculate_rates_fndecl_7795_fields __clk_speculate_rates fndecl 2 7795 NULL
@@ -1950,7 +1980,8 @@ sd_complete_frame_fndecl_8096_fields sd_complete_frame fndecl 3 8096 NULL
 batchcount_kmem_cache_8098_fields batchcount kmem_cache 0 8098 NULL
 sddr55_read_data_fndecl_8099_fields sddr55_read_data fndecl 4-3 8099 NULL
 rx_cmp_meta_data_rx_cmp_ext_8103_fields rx_cmp_meta_data rx_cmp_ext 0 8103 NULL
-tgt_count_blogic_adapter_8109_fields tgt_count blogic_adapter 0 8109 NULL
+tgt_count_blogic_adapter_8109_fields tgt_count blogic_adapter 0 8109 NULL nohasharray
+nr_relocs_drm_etnaviv_gem_submit_8109_fields nr_relocs drm_etnaviv_gem_submit 0 8109 &tgt_count_blogic_adapter_8109_fields
 speed_channel_8113_fields speed channel 0 8113 NULL
 up_dnode_8116_fields up dnode 0 8116 NULL
 __copy_user_nocache_fndecl_8122_fields __copy_user_nocache fndecl 0 8122 NULL
@@ -1971,7 +2002,8 @@ tidoffset_user_sdma_request_8166_fields tidoffset user_sdma_request 0 8166 NULL
 ubifs_scanned_corruption_fndecl_8170_fields ubifs_scanned_corruption fndecl 3 8170 NULL
 tx_ring_count_igb_adapter_8171_fields tx_ring_count igb_adapter 0 8171 NULL
 jumpshot_write_data_fndecl_8172_fields jumpshot_write_data fndecl 4 8172 NULL
-blksz_mmc_data_8174_fields blksz mmc_data 0 8174 NULL
+blksz_mmc_data_8174_fields blksz mmc_data 0 8174 NULL nohasharray
+ptr_mask_efx_tx_queue_8174_fields ptr_mask efx_tx_queue 0 8174 &blksz_mmc_data_8174_fields
 avail_ubifs_wbuf_8176_fields avail ubifs_wbuf 0 8176 NULL
 pdu_read_fndecl_8183_fields pdu_read fndecl 3 8183 NULL
 nsftids_tid_info_8187_fields nsftids tid_info 0 8187 NULL
@@ -1993,12 +2025,15 @@ vmw_cursor_update_dmabuf_fndecl_8254_fields vmw_cursor_update_dmabuf fndecl 4-3
 default_erasesize_fndecl_8255_fields default_erasesize fndecl 0 8255 NULL
 address_acpi_table_bert_8260_fields address acpi_table_bert 0 8260 NULL
 xfs_unmap_extent_fndecl_8261_fields xfs_unmap_extent fndecl 2 8261 NULL
+buf_size_ispstat_buffer_8262_fields buf_size ispstat_buffer 0 8262 NULL
 datablkcnt_capi_register_params_8263_fields datablkcnt capi_register_params 0 8263 NULL
 cow_file_range_inline_fndecl_8264_fields cow_file_range_inline fndecl 4-3 8264 NULL
+num_u3_ports_xhci_hcd_mtk_8272_fields num_u3_ports xhci_hcd_mtk 0 8272 NULL
 datablklen_capi_register_params_8275_fields datablklen capi_register_params 0 8275 NULL
 cdc_ncm_check_tx_max_fndecl_8278_fields cdc_ncm_check_tx_max fndecl 0-2 8278 NULL
 msg_len_rndis_message_8281_fields msg_len rndis_message 0 8281 NULL
-__sg_free_table_fndecl_8283_fields __sg_free_table fndecl 2 8283 NULL
+__sg_free_table_fndecl_8283_fields __sg_free_table fndecl 2 8283 NULL nohasharray
+expectedlen_drbg_testvec_8283_fields expectedlen drbg_testvec 0 8283 &__sg_free_table_fndecl_8283_fields
 rxrpc_kernel_recv_data_fndecl_8286_fields rxrpc_kernel_recv_data fndecl 4 8286 NULL
 tail_len_cfg80211_beacon_data_8293_fields tail_len cfg80211_beacon_data 0 8293 NULL
 ns_blocks_per_segment_the_nilfs_8295_fields ns_blocks_per_segment the_nilfs 0 8295 NULL nohasharray
@@ -2123,6 +2158,7 @@ my_skb_align_fndecl_8755_fields my_skb_align fndecl 2 8755 NULL
 snd_pcm_hw_param_set_fndecl_8761_fields snd_pcm_hw_param_set fndecl 4 8761 NULL
 length_acpi_nfit_system_address_8762_fields length acpi_nfit_system_address 0 8762 NULL
 max_swap_info_struct_8767_fields max swap_info_struct 0 8767 NULL
+max_pfn_radeon_vm_manager_8768_fields max_pfn radeon_vm_manager 0 8768 NULL
 amdtp_stream_set_parameters_fndecl_8769_fields amdtp_stream_set_parameters fndecl 3 8769 NULL
 gfs2_adjust_quota_fndecl_8777_fields gfs2_adjust_quota fndecl 2 8777 NULL
 data_dma_powermate_device_8783_fields data_dma powermate_device 0 8783 NULL
@@ -2199,7 +2235,8 @@ keys_bset_9063_fields keys bset 0 9063 &_drbd_bm_find_next_fndecl_9063_fields no
 tx_buf_sz_iadev_priv_9063_fields tx_buf_sz iadev_priv 0 9063 &keys_bset_9063_fields nohasharray
 send_mpa_reply_fndecl_9063_fields send_mpa_reply fndecl 3 9063 &tx_buf_sz_iadev_priv_9063_fields
 buflen_compat_xfs_fsop_attrlist_handlereq_9071_fields buflen compat_xfs_fsop_attrlist_handlereq 0 9071 NULL
-current_sg_offset_msb_data_9075_fields current_sg_offset msb_data 0 9075 NULL
+current_sg_offset_msb_data_9075_fields current_sg_offset msb_data 0 9075 NULL nohasharray
+nr_inport_coresight_platform_data_9075_fields nr_inport coresight_platform_data 0 9075 &current_sg_offset_msb_data_9075_fields
 nilfs_dat_read_fndecl_9076_fields nilfs_dat_read fndecl 2 9076 NULL
 advertised_mtu_tipc_link_9077_fields advertised_mtu tipc_link 0 9077 NULL
 out_int_pipe_usbtest_dev_9078_fields out_int_pipe usbtest_dev 0 9078 NULL
@@ -2258,6 +2295,7 @@ nsid_nvmet_ns_9259_fields nsid nvmet_ns 0 9259 NULL
 buffer_size_snd_rawmidi_runtime_9267_fields buffer_size snd_rawmidi_runtime 0 9267 NULL
 netlbl_bitmap_walk_fndecl_9270_fields netlbl_bitmap_walk fndecl 0-3 9270 NULL
 wl1251_sdio_write_fndecl_9274_fields wl1251_sdio_write fndecl 4 9274 NULL
+lsm_stripe_count_lov_stripe_md_9277_fields lsm_stripe_count lov_stripe_md 0 9277 NULL
 ResponseDataLength__MSG_SMP_PASSTHROUGH_REPLY_9278_fields ResponseDataLength _MSG_SMP_PASSTHROUGH_REPLY 0 9278 NULL
 nr_pages_start_info_9283_fields nr_pages start_info 0 9283 NULL nohasharray
 regmap_encx24j600_write_fndecl_9283_fields regmap_encx24j600_write fndecl 3 9283 &nr_pages_start_info_9283_fields
@@ -2323,6 +2361,7 @@ mpage_add_bh_to_extent_fndecl_9577_fields mpage_add_bh_to_extent fndecl 2 9577 N
 mode_buf_len_udl_device_9578_fields mode_buf_len udl_device 0 9578 NULL
 cfg80211_rx_mgmt_fndecl_9583_fields cfg80211_rx_mgmt fndecl 5 9583 NULL
 crtc_vblank_start_drm_display_mode_9587_fields crtc_vblank_start drm_display_mode 0 9587 NULL
+per_vf_tids_qed_tm_iids_9589_fields per_vf_tids qed_tm_iids 0 9589 NULL
 tool_setup_mw_fndecl_9597_fields tool_setup_mw fndecl 3 9597 NULL
 xlog_grant_head_wait_fndecl_9598_fields xlog_grant_head_wait fndecl 0 9598 NULL
 ileb_len_ubifs_info_9607_fields ileb_len ubifs_info 0 9607 NULL
@@ -2357,6 +2396,7 @@ pkt_len_virtio_vsock_pkt_info_9698_fields pkt_len virtio_vsock_pkt_info 0 9698 N
 phys_addr_ntb_transport_mw_9704_fields phys_addr ntb_transport_mw 0 9704 NULL
 payload_len_cfg80211_wowlan_tcp_9706_fields payload_len cfg80211_wowlan_tcp 0 9706 NULL
 sr_write_async_fndecl_9707_fields sr_write_async fndecl 3 9707 NULL
+reloc_count_flat_hdr_9712_fields reloc_count flat_hdr 0 9712 NULL
 xprt_rdma_max_inline_write_vardecl_transport_c_9715_fields xprt_rdma_max_inline_write vardecl_transport.c 0 9715 NULL
 page_size_dataflash_9722_fields page_size dataflash 0 9722 NULL
 setup_port_fndecl_9724_fields setup_port fndecl 5-4 9724 NULL nohasharray
@@ -2410,6 +2450,7 @@ __ceph_do_getattr_fndecl_9918_fields __ceph_do_getattr fndecl 0 9918 NULL
 audit_log_n_string_fndecl_9930_fields audit_log_n_string fndecl 3 9930 NULL
 len_load_info_9931_fields len load_info 0 9931 NULL
 r_rcv_len_rvt_qp_9940_fields r_rcv_len rvt_qp 0 9940 NULL
+num_chan_pl330_config_9943_fields num_chan pl330_config 0 9943 NULL
 buffer_len_bnad_debug_info_9948_fields buffer_len bnad_debug_info 0 9948 NULL
 error_dm_crypt_io_9949_fields error dm_crypt_io 0 9949 NULL
 ath6kl_wmi_send_probe_response_cmd_fndecl_9955_fields ath6kl_wmi_send_probe_response_cmd fndecl 6-2 9955 NULL
@@ -2516,8 +2557,10 @@ iomem_base_myri10ge_priv_10393_fields iomem_base myri10ge_priv 0 10393 NULL
 tg3_run_loopback_fndecl_10398_fields tg3_run_loopback fndecl 2 10398 NULL nohasharray
 generic_write_checks_fndecl_10398_fields generic_write_checks fndecl 0 10398 &tg3_run_loopback_fndecl_10398_fields
 ihead_offs_ubifs_info_10400_fields ihead_offs ubifs_info 0 10400 NULL
+length_p_header95_10401_fields length p_header95 0 10401 NULL
 romfs_blk_strnlen_fndecl_10402_fields romfs_blk_strnlen fndecl 3-2-0 10402 NULL
-_osd_req_sizeof_alist_header_fndecl_10405_fields _osd_req_sizeof_alist_header fndecl 0 10405 NULL
+_osd_req_sizeof_alist_header_fndecl_10405_fields _osd_req_sizeof_alist_header fndecl 0 10405 NULL nohasharray
+num_vss_cfgs_wm8994_pdata_10405_fields num_vss_cfgs wm8994_pdata 0 10405 &_osd_req_sizeof_alist_header_fndecl_10405_fields
 zap_vma_ptes_fndecl_10406_fields zap_vma_ptes fndecl 3-2 10406 NULL
 jfs_xattr_set_fndecl_10409_fields jfs_xattr_set fndecl 6 10409 NULL
 addr_page_req_dsc_10411_fields addr page_req_dsc 0 10411 NULL
@@ -2538,7 +2581,8 @@ page_shift_nand_chip_10453_fields page_shift nand_chip 0 10453 NULL
 length_acpi_mem_space_context_10460_fields length acpi_mem_space_context 0 10460 NULL
 vxlan_change_mtu_fndecl_10464_fields vxlan_change_mtu fndecl 2 10464 NULL nohasharray
 __btt_map_write_fndecl_10464_fields __btt_map_write fndecl 0 10464 &vxlan_change_mtu_fndecl_10464_fields
-wNdpOutDivisor_usb_cdc_ncm_ntb_parameters_10467_fields wNdpOutDivisor usb_cdc_ncm_ntb_parameters 0 10467 NULL
+wNdpOutDivisor_usb_cdc_ncm_ntb_parameters_10467_fields wNdpOutDivisor usb_cdc_ncm_ntb_parameters 0 10467 NULL nohasharray
+notesize_fndecl_10467_fields notesize fndecl 0 10467 &wNdpOutDivisor_usb_cdc_ncm_ntb_parameters_10467_fields
 devnum_usb_device_10474_fields devnum usb_device 0 10474 NULL
 signature_mspro_attribute_10483_fields signature mspro_attribute 0 10483 NULL
 out_min_chans_snd_card_asihpi_10490_fields out_min_chans snd_card_asihpi 0 10490 NULL nohasharray
@@ -2684,6 +2728,7 @@ l2cap_build_conf_rsp_fndecl_10988_fields l2cap_build_conf_rsp fndecl 0 10988 NUL
 msize_vardecl_pmc551_c_10989_fields msize vardecl_pmc551.c 0 10989 NULL nohasharray
 vxfs_blkiget_fndecl_10989_fields vxfs_blkiget fndecl 3-2 10989 &msize_vardecl_pmc551_c_10989_fields
 height_v4l2_rect_10995_fields height v4l2_rect 0 10995 NULL
+bitmap_size_dma_iommu_mapping_10997_fields bitmap_size dma_iommu_mapping 0 10997 NULL
 l2nbperpage_jfs_sb_info_11000_fields l2nbperpage jfs_sb_info 0 11000 NULL
 il4965_tx_agg_stop_fndecl_11004_fields il4965_tx_agg_stop fndecl 4 11004 NULL
 xfs_bmap_add_extent_unwritten_real_fndecl_11006_fields xfs_bmap_add_extent_unwritten_real fndecl 0 11006 NULL
@@ -2790,7 +2835,8 @@ ieee80211_send_bar_fndecl_11472_fields ieee80211_send_bar fndecl 3 11472 NULL
 hsync_len_videomode_11474_fields hsync_len videomode 0 11474 NULL
 iov_shorten_fndecl_11481_fields iov_shorten fndecl 3 11481 NULL nohasharray
 c_cpos_ocfs2_write_cluster_desc_11481_fields c_cpos ocfs2_write_cluster_desc 0 11481 &iov_shorten_fndecl_11481_fields
-num_crtc_drm_mode_config_11484_fields num_crtc drm_mode_config 0 11484 NULL
+num_crtc_drm_mode_config_11484_fields num_crtc drm_mode_config 0 11484 NULL nohasharray
+wReportDescLength_gb_hid_desc_response_11484_fields wReportDescLength gb_hid_desc_response 0 11484 &num_crtc_drm_mode_config_11484_fields
 get_ablock_fndecl_11495_fields get_ablock fndecl 2 11495 NULL nohasharray
 length_RioCommand_11495_fields length RioCommand 0 11495 &get_ablock_fndecl_11495_fields
 batadv_max_header_len_fndecl_11496_fields batadv_max_header_len fndecl 0 11496 NULL
@@ -2814,6 +2860,7 @@ brcmf_fil_iovar_data_get_fndecl_11579_fields brcmf_fil_iovar_data_get fndecl 4 1
 next_index_jfs_inode_info_11588_fields next_index jfs_inode_info 0 11588 NULL
 add_advertising_fndecl_11602_fields add_advertising fndecl 4 11602 NULL
 prev_free_msdos_sb_info_11603_fields prev_free msdos_sb_info 0 11603 NULL
+desc_num_hnae_ring_11610_fields desc_num hnae_ring 0 11610 NULL
 frame_length_spi_message_11612_fields frame_length spi_message 0 11612 NULL
 batadv_tt_hash_find_fndecl_11619_fields batadv_tt_hash_find fndecl 3 11619 NULL
 word1_atl1e_recv_ret_status_11620_fields word1 atl1e_recv_ret_status 0 11620 NULL
@@ -2879,6 +2926,7 @@ idetape_queue_rw_tail_fndecl_11881_fields idetape_queue_rw_tail fndecl 3 11881 N
 bochs_dispi_read_fndecl_11885_fields bochs_dispi_read fndecl 0 11885 NULL nohasharray
 leaf_dealloc_fndecl_11885_fields leaf_dealloc fndecl 4-3 11885 &bochs_dispi_read_fndecl_11885_fields
 num_channels_iw_scan_req_11889_fields num_channels iw_scan_req 0 11889 NULL
+gb_operation_message_alloc_fndecl_11891_fields gb_operation_message_alloc fndecl 3 11891 NULL
 vfs_read_fndecl_11892_fields vfs_read fndecl 0-3 11892 NULL
 llcp_tlv16_fndecl_11893_fields llcp_tlv16 fndecl 0 11893 NULL
 flaglen_ring_desc_ex_11894_fields flaglen ring_desc_ex 0 11894 NULL
@@ -2890,12 +2938,14 @@ residual_length_atto_vda_scsi_rsp_11918_fields residual_length atto_vda_scsi_rsp
 p9_fd_read_fndecl_11921_fields p9_fd_read fndecl 0-3 11921 NULL
 tx_buffer_count_hso_serial_11927_fields tx_buffer_count hso_serial 0 11927 NULL
 orig_start_move_extent_11928_fields orig_start move_extent 0 11928 NULL
+length_p_header100_11933_fields length p_header100 0 11933 NULL
 ext4_move_extents_fndecl_11935_fields ext4_move_extents fndecl 5-3-4 11935 NULL
 alloc_low_pages_fndecl_11940_fields alloc_low_pages fndecl 1 11940 NULL
 mss_request_sock_11943_fields mss request_sock 0 11943 NULL
 choose_data_offset_fndecl_11950_fields choose_data_offset fndecl 0 11950 NULL
 max_rdma_atomic_rvt_driver_params_11957_fields max_rdma_atomic rvt_driver_params 0 11957 NULL
 qla4_82xx_pci_set_window_fndecl_11958_fields qla4_82xx_pci_set_window fndecl 0-2 11958 NULL
+per_vf_cids_qed_tm_iids_11959_fields per_vf_cids qed_tm_iids 0 11959 NULL
 red_left_pad_kmem_cache_11964_fields red_left_pad kmem_cache 0 11964 NULL
 i_xattr_nid_f2fs_inode_info_11976_fields i_xattr_nid f2fs_inode_info 0 11976 NULL
 ath10k_htt_rx_crypto_param_len_fndecl_11982_fields ath10k_htt_rx_crypto_param_len fndecl 0 11982 NULL
@@ -2911,6 +2961,7 @@ br_send_bpdu_fndecl_12022_fields br_send_bpdu fndecl 3 12022 NULL nohasharray
 rfcomm_sock_sendmsg_fndecl_12022_fields rfcomm_sock_sendmsg fndecl 3 12022 &br_send_bpdu_fndecl_12022_fields
 yres_fb_var_screeninfo_12023_fields yres fb_var_screeninfo 0 12023 NULL
 xfs_dir2_sf_addname_easy_fndecl_12024_fields xfs_dir2_sf_addname_easy fndecl 4 12024 NULL
+arm_iommu_create_mapping_fndecl_12027_fields arm_iommu_create_mapping fndecl 3 12027 NULL
 sisusb_write_mem_bulk_fndecl_12029_fields sisusb_write_mem_bulk fndecl 4 12029 NULL
 scsi_cmds_max_iscsi_session_12037_fields scsi_cmds_max iscsi_session 0 12037 NULL
 rf_suballoc_bit_ocfs2_refcount_block_12038_fields rf_suballoc_bit ocfs2_refcount_block 0 12038 NULL
@@ -3251,6 +3302,7 @@ xfs_iomap_write_unwritten_fndecl_13278_fields xfs_iomap_write_unwritten fndecl 3
 num_ofld_uld_adapter_13281_fields num_ofld_uld adapter 0 13281 NULL
 status_usb_iso_packet_descriptor_13287_fields status usb_iso_packet_descriptor 0 13287 NULL
 num_bytes_sigma_fw_chunk_control_13289_fields num_bytes sigma_fw_chunk_control 0 13289 NULL
+ioc_plen1_libcfs_ioctl_data_13297_fields ioc_plen1 libcfs_ioctl_data 0 13297 NULL
 alloc_page_buffers_fndecl_13304_fields alloc_page_buffers fndecl 2 13304 NULL
 __vhost_get_user_fndecl_13313_fields __vhost_get_user fndecl 3 13313 NULL
 token_size_iw_ioctl_description_13319_fields token_size iw_ioctl_description 0 13319 NULL nohasharray
@@ -3333,7 +3385,7 @@ retrans_out_tcp_sock_13559_fields retrans_out tcp_sock 0 13559 NULL nohasharray
 __devcgroup_inode_permission_fndecl_13559_fields __devcgroup_inode_permission fndecl 0 13559 &retrans_out_tcp_sock_13559_fields nohasharray
 iomap_apply_fndecl_13559_fields iomap_apply fndecl 0 13559 &__devcgroup_inode_permission_fndecl_13559_fields
 capture_periodsize_rme96_13564_fields capture_periodsize rme96 0 13564 NULL
-edt_ft5x06_ts_readwrite_fndecl_13570_fields edt_ft5x06_ts_readwrite fndecl 2-4 13570 NULL
+edt_ft5x06_ts_readwrite_fndecl_13570_fields edt_ft5x06_ts_readwrite fndecl 2-4-0 13570 NULL
 avc_tuner_dsd_dvb_t_fndecl_13571_fields avc_tuner_dsd_dvb_t fndecl 0 13571 NULL
 pitch_drm_mode_create_dumb_13574_fields pitch drm_mode_create_dumb 0 13574 NULL
 fd_do_prot_fill_fndecl_13583_fields fd_do_prot_fill fndecl 5-3 13583 NULL
@@ -3487,6 +3539,7 @@ size_uhid_input2_req_14140_fields size uhid_input2_req 0 14140 NULL
 cros_ec_spi_receive_packet_fndecl_14142_fields cros_ec_spi_receive_packet fndecl 2 14142 NULL
 short_len_fat_ioctl_filldir_callback_14151_fields short_len fat_ioctl_filldir_callback 0 14151 NULL
 page_size_at24_platform_data_14152_fields page_size at24_platform_data 0 14152 NULL
+num_ratios_coreclk_soc_desc_14154_fields num_ratios coreclk_soc_desc 0 14154 NULL
 range_min_regmap_range_node_14166_fields range_min regmap_range_node 0 14166 NULL
 ocfs2_read_blocks_sync_fndecl_14169_fields ocfs2_read_blocks_sync fndecl 2 14169 NULL
 cmd_len_scsi_cmnd_14171_fields cmd_len scsi_cmnd 0 14171 NULL nohasharray
@@ -3607,6 +3660,7 @@ alb_send_lp_vid_fndecl_14613_fields alb_send_lp_vid fndecl 4 14613 NULL
 recv_bulk_pipe_us_data_14615_fields recv_bulk_pipe us_data 0 14615 NULL
 node_scif_dev_14623_fields node scif_dev 0 14623 NULL
 vmw_execbuf_cmdbuf_fndecl_14639_fields vmw_execbuf_cmdbuf fndecl 4 14639 NULL
+length_comedi_lrange_14641_fields length comedi_lrange 0 14641 NULL
 SSIDsize_bss_info_14644_fields SSIDsize bss_info 0 14644 NULL
 dln2_gpio_get_pin_count_fndecl_14646_fields dln2_gpio_get_pin_count fndecl 0 14646 NULL
 endpoint_usbdevfs_urb_14649_fields endpoint usbdevfs_urb 0 14649 NULL
@@ -3651,6 +3705,7 @@ td_fill_fndecl_14788_fields td_fill fndecl 3 14788 NULL
 brcmf_sdio_verifymemory_fndecl_14795_fields brcmf_sdio_verifymemory fndecl 4-2 14795 NULL nohasharray
 snd_ssthresh_tcp_sock_14795_fields snd_ssthresh tcp_sock 0 14795 &brcmf_sdio_verifymemory_fndecl_14795_fields
 mthca_map_user_db_fndecl_14796_fields mthca_map_user_db fndecl 5 14796 NULL
+alloc_component_match_14799_fields alloc component_match 0 14799 NULL
 sb_max_fwd_alloc_hpfs_sb_info_14807_fields sb_max_fwd_alloc hpfs_sb_info 0 14807 NULL
 nr_sectors_fat_floppy_defaults_14809_fields nr_sectors fat_floppy_defaults 0 14809 NULL
 read_fn_xusb_udc_14819_fields read_fn xusb_udc 0 14819 NULL
@@ -3819,7 +3874,8 @@ index_btframe_15545_fields index btframe 0 15545 NULL
 data_length_mts_transfer_context_15546_fields data_length mts_transfer_context 0 15546 NULL
 lowpan_xmit_fragment_fndecl_15552_fields lowpan_xmit_fragment fndecl 4-6 15552 NULL
 ep_in_kingsun_cb_15553_fields ep_in kingsun_cb 0 15553 NULL
-diff_usnic_uiom_reg_15554_fields diff usnic_uiom_reg 0 15554 NULL
+diff_usnic_uiom_reg_15554_fields diff usnic_uiom_reg 0 15554 NULL nohasharray
+num_odfs_clkgen_pll_data_15554_fields num_odfs clkgen_pll_data 0 15554 &diff_usnic_uiom_reg_15554_fields
 video_buffer_size_vivid_dev_15556_fields video_buffer_size vivid_dev 0 15556 NULL
 max_sges_qedr_qp_hwq_info_15558_fields max_sges qedr_qp_hwq_info 0 15558 NULL
 swiotlb_late_init_with_tbl_fndecl_15566_fields swiotlb_late_init_with_tbl fndecl 2 15566 NULL nohasharray
@@ -3839,6 +3895,7 @@ udf_compute_nr_groups_fndecl_15617_fields udf_compute_nr_groups fndecl 0 15617 N
 ch_r_head_jsm_channel_15625_fields ch_r_head jsm_channel 0 15625 NULL
 nents_sg_table_15627_fields nents sg_table 0 15627 NULL nohasharray
 drm_addmap_core_fndecl_15627_fields drm_addmap_core fndecl 3-2 15627 &nents_sg_table_15627_fields
+lov_alloc_memmd_fndecl_15630_fields lov_alloc_memmd fndecl 2 15630 NULL
 mcs_wrap_mir_skb_fndecl_15633_fields mcs_wrap_mir_skb fndecl 0 15633 NULL
 end_bttv_vbi_fmt_15637_fields end bttv_vbi_fmt 0 15637 NULL
 dma_in_redrat3_dev_15639_fields dma_in redrat3_dev 0 15639 NULL
@@ -3949,6 +4006,7 @@ nsec_seg_buf_16050_fields nsec seg_buf 0 16050 NULL
 nouveau_bo_new_fndecl_16051_fields nouveau_bo_new fndecl 2 16051 NULL
 len_ahc_dma_seg_16052_fields len ahc_dma_seg 0 16052 NULL
 ue_phys_ocfs2_unwritten_extent_16054_fields ue_phys ocfs2_unwritten_extent 0 16054 NULL
+n_insns_comedi_insnlist_16056_fields n_insns comedi_insnlist 0 16056 NULL
 xfs_alloc_fix_freelist_fndecl_16057_fields xfs_alloc_fix_freelist fndecl 0 16057 NULL
 ts_packet_size_cx231xx_tsport_16063_fields ts_packet_size cx231xx_tsport 0 16063 NULL
 ddp_ppod_init_idata_fndecl_16064_fields ddp_ppod_init_idata fndecl 4 16064 NULL
@@ -3962,6 +4020,7 @@ pci_add_resource_offset_fndecl_16095_fields pci_add_resource_offset fndecl 3 160
 w_mode_size_16096_fields w mode_size 0 16096 NULL
 param_len_mgmt_pending_cmd_16099_fields param_len mgmt_pending_cmd 0 16099 NULL
 grow_dev_page_fndecl_16100_fields grow_dev_page fndecl 4-5-3 16100 NULL
+instances_minus_one_mxt_object_16107_fields instances_minus_one mxt_object 0 16107 NULL
 find_extend_vma_fndecl_16110_fields find_extend_vma fndecl 2 16110 NULL
 brcmf_usb_dl_send_bulk_fndecl_16113_fields brcmf_usb_dl_send_bulk fndecl 3 16113 NULL nohasharray
 xillybus_llseek_fndecl_16113_fields xillybus_llseek fndecl 2 16113 &brcmf_usb_dl_send_bulk_fndecl_16113_fields
@@ -4005,11 +4064,13 @@ mmio_size_sis_video_info_16284_fields mmio_size sis_video_info 0 16284 NULL
 find_ibft_region_fndecl_16285_fields find_ibft_region fndecl 0 16285 NULL
 num_queues_qede_dev_16291_fields num_queues qede_dev 0 16291 NULL
 isdn_tty_countDLE_fndecl_16304_fields isdn_tty_countDLE fndecl 0 16304 NULL
-len_ieee80211_vendor_radiotap_16308_fields len ieee80211_vendor_radiotap 0 16308 NULL
+len_ieee80211_vendor_radiotap_16308_fields len ieee80211_vendor_radiotap 0 16308 NULL nohasharray
+wm_adsp_compr_copy_fndecl_16308_fields wm_adsp_compr_copy fndecl 3 16308 &len_ieee80211_vendor_radiotap_16308_fields
 aac_fib_send_fndecl_16315_fields aac_fib_send fndecl 3 16315 NULL
 memblock_mark_mirror_fndecl_16321_fields memblock_mark_mirror fndecl 2-1 16321 NULL
 major_tty_driver_16323_fields major tty_driver 0 16323 NULL
 AscGetMaxDmaCount_fndecl_16326_fields AscGetMaxDmaCount fndecl 0 16326 NULL
+len_gb_raw_send_request_16340_fields len gb_raw_send_request 0 16340 NULL
 sys_dup2_fndecl_16343_fields sys_dup2 fndecl 2 16343 NULL nohasharray
 max_vfs_be_resources_16343_fields max_vfs be_resources 0 16343 &sys_dup2_fndecl_16343_fields
 page_offset_mlx5_srq_attr_16345_fields page_offset mlx5_srq_attr 0 16345 NULL
@@ -4029,7 +4090,8 @@ controller_number_mspro_sys_info_16408_fields controller_number mspro_sys_info 0
 romfs_dev_read_fndecl_16412_fields romfs_dev_read fndecl 2-4 16412 NULL
 bcnt_aoeif_16414_fields bcnt aoeif 0 16414 NULL
 n_sectors_hpfs_super_block_16421_fields n_sectors hpfs_super_block 0 16421 NULL
-bNrInPins_uac_selector_unit_descriptor_16423_fields bNrInPins uac_selector_unit_descriptor 0 16423 NULL
+bNrInPins_uac_selector_unit_descriptor_16423_fields bNrInPins uac_selector_unit_descriptor 0 16423 NULL nohasharray
+per_vf_cids_qed_cdu_iids_16423_fields per_vf_cids qed_cdu_iids 0 16423 &bNrInPins_uac_selector_unit_descriptor_16423_fields
 vm_start_usb_memory_16438_fields vm_start usb_memory 0 16438 NULL
 numa_emulation_fndecl_16441_fields numa_emulation fndecl 2 16441 NULL
 ep_in_usbtest_info_16442_fields ep_in usbtest_info 0 16442 NULL
@@ -4054,7 +4116,8 @@ size_i40iw_chunk_16517_fields size i40iw_chunk 0 16517 NULL
 btrfs_block_rsv_add_fndecl_16520_fields btrfs_block_rsv_add fndecl 0 16520 NULL
 blocks_available_dio_submit_16522_fields blocks_available dio_submit 0 16522 NULL
 xb_suballoc_loc_ocfs2_xattr_block_16523_fields xb_suballoc_loc ocfs2_xattr_block 0 16523 NULL
-io_throttle_count_vnic_snic_config_16529_fields io_throttle_count vnic_snic_config 0 16529 NULL
+io_throttle_count_vnic_snic_config_16529_fields io_throttle_count vnic_snic_config 0 16529 NULL nohasharray
+gb_raw_send_fndecl_16529_fields gb_raw_send fndecl 2 16529 &io_throttle_count_vnic_snic_config_16529_fields
 hfi1_max_qp_wrs_vardecl_16533_fields hfi1_max_qp_wrs vardecl 0 16533 NULL nohasharray
 comm_size_perf_comm_event_16533_fields comm_size perf_comm_event 0 16533 &hfi1_max_qp_wrs_vardecl_16533_fields
 lpt_lebs_ubifs_info_16535_fields lpt_lebs ubifs_info 0 16535 NULL
@@ -4103,6 +4166,7 @@ pcm_buf_host_rw_ofs_snd_card_asihpi_pcm_16719_fields pcm_buf_host_rw_ofs snd_car
 opcfg_ofsl_cyttsp4_sysinfo_data_16723_fields opcfg_ofsl cyttsp4_sysinfo_data 0 16723 NULL
 multi_io_quirk_mmc_host_ops_16729_fields multi_io_quirk mmc_host_ops 0 16729 NULL
 fat_length_fat_boot_sector_16730_fields fat_length fat_boot_sector 0 16730 NULL
+shader_rec_size_drm_vc4_submit_cl_16731_fields shader_rec_size drm_vc4_submit_cl 0 16731 NULL
 width_qxl_head_16734_fields width qxl_head 0 16734 NULL
 nchannels_twl6030_gpadc_platform_data_16736_fields nchannels twl6030_gpadc_platform_data 0 16736 NULL
 udf_add_extendedattr_fndecl_16737_fields udf_add_extendedattr fndecl 2 16737 NULL
@@ -4117,7 +4181,8 @@ cfg80211_classify8021d_fndecl_16771_fields cfg80211_classify8021d fndecl 0 16771
 key_len_iw_encode_ext_16773_fields key_len iw_encode_ext 0 16773 NULL
 security_inode_need_killpriv_fndecl_16777_fields security_inode_need_killpriv fndecl 0 16777 NULL
 qxl_draw_opaque_fb_fndecl_16781_fields qxl_draw_opaque_fb fndecl 2 16781 NULL
-u132_hcd_giveback_urb_fndecl_16783_fields u132_hcd_giveback_urb fndecl 4 16783 NULL
+u132_hcd_giveback_urb_fndecl_16783_fields u132_hcd_giveback_urb fndecl 4 16783 NULL nohasharray
+extra_prefix_len_ieee80211_crypto_ops_16783_fields extra_prefix_len ieee80211_crypto_ops 0 16783 &u132_hcd_giveback_urb_fndecl_16783_fields
 iscsit_build_text_rsp_fndecl_16784_fields iscsit_build_text_rsp fndecl 0 16784 NULL nohasharray
 num_pfns_virtio_balloon_16784_fields num_pfns virtio_balloon 0 16784 &iscsit_build_text_rsp_fndecl_16784_fields
 efi_memmap_init_late_fndecl_16787_fields efi_memmap_init_late fndecl 2-1 16787 NULL
@@ -4218,6 +4283,7 @@ mtu_vnic_enet_config_17176_fields mtu vnic_enet_config 0 17176 NULL nohasharray
 ip_options_get_finish_fndecl_17176_fields ip_options_get_finish fndecl 4 17176 &mtu_vnic_enet_config_17176_fields
 start_block_swap_extent_17179_fields start_block swap_extent 0 17179 NULL
 read_normal_summaries_fndecl_17185_fields read_normal_summaries fndecl 2 17185 NULL
+num_component_match_17187_fields num component_match 0 17187 NULL
 sys_pread64_fndecl_17210_fields sys_pread64 fndecl 3 17210 NULL
 logical_blk_num_osst_tape_17216_fields logical_blk_num osst_tape 0 17216 NULL
 ud_clear_fndecl_17219_fields ud_clear fndecl 6-4-5-3 17219 NULL nohasharray
@@ -4287,6 +4353,7 @@ cipso_v4_map_lvl_hton_fndecl_17481_fields cipso_v4_map_lvl_hton fndecl 0 17481 N
 sddr09_write_inplace_fndecl_17484_fields sddr09_write_inplace fndecl 4-3 17484 NULL nohasharray
 replace_fd_fndecl_17484_fields replace_fd fndecl 1 17484 &sddr09_write_inplace_fndecl_17484_fields
 e_block_mb_cache_entry_17485_fields e_block mb_cache_entry 0 17485 NULL
+len_tmc_drvdata_17487_fields len tmc_drvdata 0 17487 NULL
 mlx4_ib_reg_user_mr_fndecl_17492_fields mlx4_ib_reg_user_mr fndecl 3-2 17492 NULL
 qp_memcpy_from_queue_fndecl_17500_fields qp_memcpy_from_queue fndecl 5-4 17500 NULL
 invalidate_fndecl_17509_fields invalidate fndecl 4-3 17509 NULL
@@ -4317,6 +4384,7 @@ ent_bread_fatent_operations_17603_fields ent_bread fatent_operations 0 17603 &ql
 isoc_ep_stk_camera_17604_fields isoc_ep stk_camera 0 17604 NULL
 nr_planes_nvm_dev_17609_fields nr_planes nvm_dev 0 17609 NULL
 min_alloc_order_gen_pool_17628_fields min_alloc_order gen_pool 0 17628 NULL
+num_peri_pl330_config_17630_fields num_peri pl330_config 0 17630 NULL
 video_linelength_sis_video_info_17642_fields video_linelength sis_video_info 0 17642 NULL
 wl12xx_sdio_raw_read_fndecl_17648_fields wl12xx_sdio_raw_read fndecl 4 17648 NULL
 buf_len_ceph_none_authorizer_17652_fields buf_len ceph_none_authorizer 0 17652 NULL
@@ -4437,6 +4505,7 @@ _osdv2_req_encode_common_fndecl_18086_fields _osdv2_req_encode_common fndecl 2 1
 bits_per_pixel_drm_framebuffer_18087_fields bits_per_pixel drm_framebuffer 0 18087 NULL
 di_nextents_xfs_icdinode_18090_fields di_nextents xfs_icdinode 0 18090 NULL
 inode2sd_fndecl_18094_fields inode2sd fndecl 3 18094 NULL
+stack_size_flat_hdr_18108_fields stack_size flat_hdr 0 18108 NULL
 btrfs_qgroup_reserve_data_fndecl_18109_fields btrfs_qgroup_reserve_data fndecl 0-3-2 18109 NULL
 addr_width_fsl_edma_slave_config_18115_fields addr_width fsl_edma_slave_config 0 18115 NULL
 befs_read_datastream_fndecl_18116_fields befs_read_datastream fndecl 3 18116 NULL
@@ -4519,7 +4588,8 @@ hlen_hfi1_packet_18431_fields hlen hfi1_packet 0 18431 NULL
 fb_find_mode_fndecl_18438_fields fb_find_mode fndecl 7 18438 NULL
 device_pci_device_id_18441_fields device pci_device_id 0 18441 NULL
 count_iov_iter_18447_fields count iov_iter 0 18447 NULL
-data_len_hfa384x_tx_frame_18449_fields data_len hfa384x_tx_frame 0 18449 NULL
+data_len_hfa384x_tx_frame_18449_fields data_len hfa384x_tx_frame 0 18449 NULL nohasharray
+mp_tx_agg_buf_size_sdio_mmc_card_18449_fields mp_tx_agg_buf_size sdio_mmc_card 0 18449 &data_len_hfa384x_tx_frame_18449_fields
 copy_range_nfulnl_instance_18460_fields copy_range nfulnl_instance 0 18460 NULL nohasharray
 max_entries_bpf_map_18460_fields max_entries bpf_map 0 18460 &copy_range_nfulnl_instance_18460_fields
 bsize_jfs_sb_info_18477_fields bsize jfs_sb_info 0 18477 NULL
@@ -4572,10 +4642,13 @@ num_ccells_per_conn_iscsi_kwqe_init1_18665_fields num_ccells_per_conn iscsi_kwqe
 nilfs_move_2nd_super_fndecl_18666_fields nilfs_move_2nd_super fndecl 2 18666 NULL
 len_xdr_netobj_18672_fields len xdr_netobj 0 18672 NULL
 pn_recvmsg_fndecl_18676_fields pn_recvmsg fndecl 3 18676 NULL
+nr_clk_regs_samsung_cmu_info_18678_fields nr_clk_regs samsung_cmu_info 0 18678 NULL
+ocd_max_easize_obd_connect_data_18682_fields ocd_max_easize obd_connect_data 0 18682 NULL
 i2c_wr_max_cx24120_config_18687_fields i2c_wr_max cx24120_config 0 18687 NULL
 num_tc_net_device_18703_fields num_tc net_device 0 18703 NULL
 size_rxdone_entry_desc_18704_fields size rxdone_entry_desc 0 18704 NULL
-den_step_snd_ratnum_18705_fields den_step snd_ratnum 0 18705 NULL
+den_step_snd_ratnum_18705_fields den_step snd_ratnum 0 18705 NULL nohasharray
+num_dup_tsns_sctp_tsnmap_18705_fields num_dup_tsns sctp_tsnmap 0 18705 &den_step_snd_ratnum_18705_fields
 ent_get_fatent_operations_18715_fields ent_get fatent_operations 0 18715 NULL
 read_reg_isar_hw_18717_fields read_reg isar_hw 0 18717 NULL
 feature_len_mic_device_desc_18719_fields feature_len mic_device_desc 0 18719 NULL
@@ -4618,6 +4691,7 @@ num_entries_compat_ipt_replace_18835_fields num_entries compat_ipt_replace 0 188
 xfs_inobt_insert_rec_fndecl_18839_fields xfs_inobt_insert_rec fndecl 4 18839 NULL
 rsn_ie_len_hostap_bss_info_18840_fields rsn_ie_len hostap_bss_info 0 18840 NULL
 number_snd_card_18845_fields number snd_card 0 18845 NULL
+exynos_drm_gem_init_fndecl_18846_fields exynos_drm_gem_init fndecl 2 18846 NULL
 process_measurement_fndecl_18847_fields process_measurement fndecl 3 18847 NULL nohasharray
 n_targets_rsxx_cardinfo_18847_fields n_targets rsxx_cardinfo 0 18847 &process_measurement_fndecl_18847_fields
 taglen_nfsd4_compoundargs_18849_fields taglen nfsd4_compoundargs 0 18849 NULL nohasharray
@@ -4824,13 +4898,15 @@ pcfg_ofsh_cyttsp4_sysinfo_data_19644_fields pcfg_ofsh cyttsp4_sysinfo_data 0 196
 memory_maker_code_mspro_sys_info_19650_fields memory_maker_code mspro_sys_info 0 19650 NULL
 get_rq_pas_size_fndecl_19651_fields get_rq_pas_size fndecl 0 19651 NULL
 af9033_rd_regs_fndecl_19652_fields af9033_rd_regs fndecl 4 19652 NULL
+hr_itemcount_hsm_request_19657_fields hr_itemcount hsm_request 0 19657 NULL
 configfs_dir_lseek_fndecl_19658_fields configfs_dir_lseek fndecl 2 19658 NULL
 peer_fwd_cnt_virtio_vsock_sock_19661_fields peer_fwd_cnt virtio_vsock_sock 0 19661 NULL
 videobuf_vmalloc_to_sg_fndecl_19671_fields videobuf_vmalloc_to_sg fndecl 2 19671 NULL
 recv_intr_pipe_us_data_19678_fields recv_intr_pipe us_data 0 19678 NULL
 depth_em28xx_fmt_19696_fields depth em28xx_fmt 0 19696 NULL nohasharray
 size_pkt_hdr_19696_fields size pkt_hdr 0 19696 &depth_em28xx_fmt_19696_fields nohasharray
-pcnt_bits_ubifs_info_19696_fields pcnt_bits ubifs_info 0 19696 &size_pkt_hdr_19696_fields
+pcnt_bits_ubifs_info_19696_fields pcnt_bits ubifs_info 0 19696 &size_pkt_hdr_19696_fields nohasharray
+prealloc_bufsz_comedi_async_19696_fields prealloc_bufsz comedi_async 0 19696 &pcnt_bits_ubifs_info_19696_fields
 st_fixed_buffer_size_vardecl_st_c_19699_fields st_fixed_buffer_size vardecl_st.c 0 19699 NULL
 gfs2_file_splice_write_fndecl_19705_fields gfs2_file_splice_write fndecl 4 19705 NULL
 max_blksize_sdio_func_19715_fields max_blksize sdio_func 0 19715 NULL
@@ -4849,6 +4925,7 @@ vram_base_qxl_device_19773_fields vram_base qxl_device 0 19773 NULL
 onenand_read_ops_nolock_fndecl_19774_fields onenand_read_ops_nolock fndecl 2 19774 NULL
 gss_decrypt_xdr_buf_fndecl_19786_fields gss_decrypt_xdr_buf fndecl 3 19786 NULL
 rcvbuf_size_rds_tcp_net_19796_fields rcvbuf_size rds_tcp_net 0 19796 NULL
+num_u2_ports_xhci_hcd_mtk_19801_fields num_u2_ports xhci_hcd_mtk 0 19801 NULL
 fromlen_nfs3_symlinkargs_19803_fields fromlen nfs3_symlinkargs 0 19803 NULL
 btrfs_test_inodes_fndecl_19807_fields btrfs_test_inodes fndecl 1-2 19807 NULL
 len_rpcsec_gss_oid_19814_fields len rpcsec_gss_oid 0 19814 NULL
@@ -4910,6 +4987,7 @@ id_len_netdev_phys_item_id_20043_fields id_len netdev_phys_item_id 0 20043 &bata
 max_rqst_sz_nfs4_channel_attrs_20083_fields max_rqst_sz nfs4_channel_attrs 0 20083 NULL
 rxsize_grcan_device_config_20087_fields rxsize grcan_device_config 0 20087 NULL
 bnx2_set_rx_ring_size_fndecl_20092_fields bnx2_set_rx_ring_size fndecl 2 20092 NULL
+r8712_read32_fndecl_20095_fields r8712_read32 fndecl 0 20095 NULL
 reg_count_cs_extent_def_20096_fields reg_count cs_extent_def 0 20096 NULL
 dm_bufio_get_block_number_fndecl_20097_fields dm_bufio_get_block_number fndecl 0 20097 NULL
 qla82xx_pci_mem_write_direct_fndecl_20099_fields qla82xx_pci_mem_write_direct fndecl 2 20099 NULL
@@ -4918,7 +4996,8 @@ minimum_v4l2_ctrl_20103_fields minimum v4l2_ctrl 0 20103 NULL
 precopy_buffers_fndecl_20104_fields precopy_buffers fndecl 3 20104 NULL
 max_acl_len_hci_rp_read_data_block_size_20119_fields max_acl_len hci_rp_read_data_block_size 0 20119 NULL
 d_nhash_vxfs_dirblk_20122_fields d_nhash vxfs_dirblk 0 20122 NULL
-source_sctphdr_20129_fields source sctphdr 0 20129 NULL
+source_sctphdr_20129_fields source sctphdr 0 20129 NULL nohasharray
+ao_chans_pci224_board_20129_fields ao_chans pci224_board 0 20129 &source_sctphdr_20129_fields
 btrfs_punch_hole_fndecl_20130_fields btrfs_punch_hole fndecl 3-2 20130 NULL
 in_ep_snd_usb_midi_endpoint_info_20132_fields in_ep snd_usb_midi_endpoint_info 0 20132 NULL
 data_sectors_per_block_partition_20138_fields data_sectors_per_block partition 0 20138 NULL
@@ -5100,6 +5179,7 @@ num_mlx4_resource_20869_fields num mlx4_resource 0 20869 NULL
 length_iwl_ucode_tlv_20871_fields length iwl_ucode_tlv 0 20871 NULL
 btrfs_prealloc_file_range_fndecl_20872_fields btrfs_prealloc_file_range fndecl 3-4 20872 NULL
 nr_hotspot_blocks_smq_policy_20876_fields nr_hotspot_blocks smq_policy 0 20876 NULL
+max_q_per_vf_rcb_common_cb_20877_fields max_q_per_vf rcb_common_cb 0 20877 NULL
 usb_stor_intr_transfer_fndecl_20883_fields usb_stor_intr_transfer fndecl 3 20883 NULL
 cl_local_node_o2nm_cluster_20896_fields cl_local_node o2nm_cluster 0 20896 NULL
 idiag_info_size_inet_diag_handler_20898_fields idiag_info_size inet_diag_handler 0 20898 NULL
@@ -5246,7 +5326,8 @@ stripes_stripe_c_21457_fields stripes stripe_c 0 21457 NULL
 indirect2direct_fndecl_21459_fields indirect2direct fndecl 6 21459 NULL
 ezusb_access_ltv_fndecl_21485_fields ezusb_access_ltv fndecl 3 21485 NULL
 mmio_start_fb_fix_screeninfo_21486_fields mmio_start fb_fix_screeninfo 0 21486 NULL
-fuse_do_ioctl_fndecl_21491_fields fuse_do_ioctl fndecl 2 21491 NULL
+fuse_do_ioctl_fndecl_21491_fields fuse_do_ioctl fndecl 2 21491 NULL nohasharray
+num_channels_ep93xx_dma_platform_data_21491_fields num_channels ep93xx_dma_platform_data 0 21491 &fuse_do_ioctl_fndecl_21491_fields
 hpfs_ea_ext_remove_fndecl_21492_fields hpfs_ea_ext_remove fndecl 4-2 21492 NULL
 memsize_vgastate_21493_fields memsize vgastate 0 21493 NULL nohasharray
 num_iac_hci_cp_write_current_iac_lap_21493_fields num_iac hci_cp_write_current_iac_lap 0 21493 &memsize_vgastate_21493_fields
@@ -5257,7 +5338,8 @@ fifo_size_hscx_hw_21522_fields fifo_size hscx_hw 0 21522 NULL nohasharray
 c67x00_urb_dequeue_fndecl_21522_fields c67x00_urb_dequeue fndecl 3 21522 &fifo_size_hscx_hw_21522_fields
 data_offset_mdp_superblock_1_21524_fields data_offset mdp_superblock_1 0 21524 NULL
 xennet_max_queues_vardecl_xen_netfront_c_21530_fields xennet_max_queues vardecl_xen-netfront.c 0 21530 NULL
-hfsplus_find_init_fndecl_21533_fields hfsplus_find_init fndecl 0 21533 NULL
+hfsplus_find_init_fndecl_21533_fields hfsplus_find_init fndecl 0 21533 NULL nohasharray
+nr_bos_drm_msm_gem_submit_21533_fields nr_bos drm_msm_gem_submit 0 21533 &hfsplus_find_init_fndecl_21533_fields
 zr364xx_read_fndecl_21537_fields zr364xx_read fndecl 3 21537 NULL
 pcm_snd_oxfw_stream_formation_21546_fields pcm snd_oxfw_stream_formation 0 21546 NULL
 ql_get_full_dup_fndecl_21549_fields ql_get_full_dup fndecl 0 21549 NULL
@@ -5325,6 +5407,7 @@ __ceph_setxattr_fndecl_21751_fields __ceph_setxattr fndecl 4 21751 NULL nohashar
 length_ena_eth_io_rx_cdesc_base_21751_fields length ena_eth_io_rx_cdesc_base 0 21751 &__ceph_setxattr_fndecl_21751_fields
 bufsiz_mousedev_client_21759_fields bufsiz mousedev_client 0 21759 NULL
 width_tm6000_fh_21761_fields width tm6000_fh 0 21761 NULL
+req_lim_delta_srp_login_rsp_21762_fields req_lim_delta srp_login_rsp 0 21762 NULL
 next_checkpoint_r5l_log_21765_fields next_checkpoint r5l_log 0 21765 NULL
 br_startblock_xfs_bmbt_irec_21769_fields br_startblock xfs_bmbt_irec 0 21769 NULL
 byte_len_spi_eeprom_21786_fields byte_len spi_eeprom 0 21786 NULL
@@ -5332,6 +5415,7 @@ tpg_alloc_fndecl_21789_fields tpg_alloc fndecl 2 21789 NULL
 find_group_dir_fndecl_21790_fields find_group_dir fndecl 0 21790 NULL
 idetape_chrdev_read_fndecl_21794_fields idetape_chrdev_read fndecl 3 21794 NULL
 reg_stride_regmap_21801_fields reg_stride regmap 0 21801 NULL
+num_vss_hpf_cfgs_wm8994_pdata_21802_fields num_vss_hpf_cfgs wm8994_pdata 0 21802 NULL
 __svc_create_fndecl_21804_fields __svc_create fndecl 2 21804 NULL
 hwi_ws_sz_hba_parameters_21815_fields hwi_ws_sz hba_parameters 0 21815 NULL
 numacb_vardecl_21828_fields numacb vardecl 0 21828 NULL
@@ -5453,12 +5537,14 @@ num_udav_mthca_profile_22243_fields num_udav mthca_profile 0 22243 NULL
 ieee80211_check_pending_bar_fndecl_22244_fields ieee80211_check_pending_bar fndecl 3 22244 NULL
 rf_suballoc_loc_ocfs2_refcount_block_22248_fields rf_suballoc_loc ocfs2_refcount_block 0 22248 NULL
 hfsplus_asc2uni_fndecl_22252_fields hfsplus_asc2uni fndecl 0 22252 NULL
+receive_data_fndecl_22256_fields receive_data fndecl 2 22256 NULL
 bbio_error_fndecl_22264_fields bbio_error fndecl 3 22264 NULL
 usCRTC_V_Total__ATOM_MODE_TIMING_22265_fields usCRTC_V_Total _ATOM_MODE_TIMING 0 22265 NULL
 mangle_contents_fndecl_22272_fields mangle_contents fndecl 4-6 22272 NULL
 gtt_total_entries__intel_private_22281_fields gtt_total_entries _intel_private 0 22281 NULL nohasharray
 reord_tcp_sacktag_state_22281_fields reord tcp_sacktag_state 0 22281 &gtt_total_entries__intel_private_22281_fields
 scif_get_phys_fndecl_22295_fields scif_get_phys fndecl 0-1 22295 NULL
+gfs2_listxattr_fndecl_22298_fields gfs2_listxattr fndecl 3 22298 NULL
 read_head_n_tty_data_22317_fields read_head n_tty_data 0 22317 NULL
 swiotlb_late_init_with_default_size_fndecl_22319_fields swiotlb_late_init_with_default_size fndecl 1 22319 NULL
 be_fill_queue_fndecl_22320_fields be_fill_queue fndecl 2 22320 NULL
@@ -5531,7 +5617,8 @@ fsync_file_operations_22566_fields fsync file_operations 0 22566 NULL
 burst_fsl_edma_slave_config_22570_fields burst fsl_edma_slave_config 0 22570 NULL
 adc12138_mode_programming_fndecl_22579_fields adc12138_mode_programming fndecl 4 22579 NULL
 id_rfcomm_dev_22580_fields id rfcomm_dev 0 22580 NULL
-qlcnic_pci_sriov_configure_fndecl_22588_fields qlcnic_pci_sriov_configure fndecl 2 22588 NULL
+qlcnic_pci_sriov_configure_fndecl_22588_fields qlcnic_pci_sriov_configure fndecl 2 22588 NULL nohasharray
+rx_queue_size_pxa168_eth_platform_data_22588_fields rx_queue_size pxa168_eth_platform_data 0 22588 &qlcnic_pci_sriov_configure_fndecl_22588_fields
 scif_rb_get_next_fndecl_22601_fields scif_rb_get_next fndecl 3 22601 NULL
 tx_data_max_size_sst_generic_ipc_22604_fields tx_data_max_size sst_generic_ipc 0 22604 NULL
 brcmf_fil_cmd_data_get_fndecl_22605_fields brcmf_fil_cmd_data_get fndecl 4 22605 NULL
@@ -5546,6 +5633,7 @@ length_obj_key_22626_fields length obj_key 0 22626 NULL
 n_compat_sel_arg_struct_22628_fields n compat_sel_arg_struct 0 22628 NULL
 hci_si_event_fndecl_22639_fields hci_si_event fndecl 3 22639 NULL
 scif_vwriteto_fndecl_22640_fields scif_vwriteto fndecl 3-4 22640 NULL
+num_rcv_bufs_visornic_devdata_22643_fields num_rcv_bufs visornic_devdata 0 22643 NULL
 queue_size_snd_timer_params_22646_fields queue_size snd_timer_params 0 22646 NULL
 do_msgsnd_fndecl_22648_fields do_msgsnd fndecl 4 22648 NULL
 isight_decode_fndecl_22650_fields isight_decode fndecl 4 22650 NULL
@@ -5560,6 +5648,7 @@ vidioc_s_input_fndecl_22689_fields vidioc_s_input fndecl 3 22689 NULL
 qca_recv_fndecl_22690_fields qca_recv fndecl 3 22690 NULL
 ctl_dma_yealink_dev_22696_fields ctl_dma yealink_dev 0 22696 NULL
 len_vring_desc_22700_fields len vring_desc 0 22700 NULL
+supplies_count_gb_power_supplies_22705_fields supplies_count gb_power_supplies 0 22705 NULL
 alloc_vudc_device_fndecl_22709_fields alloc_vudc_device fndecl 1 22709 NULL
 brcmf_sdio_read_control_fndecl_22712_fields brcmf_sdio_read_control fndecl 3 22712 NULL
 scif_rb_write_fndecl_22718_fields scif_rb_write fndecl 0-3 22718 NULL
@@ -5574,6 +5663,7 @@ __blk_bios_map_sg_fndecl_22734_fields __blk_bios_map_sg fndecl 0 22734 NULL
 xprt_alloc_fndecl_22736_fields xprt_alloc fndecl 4-3 22736 NULL
 num_fcoe_qps_i40e_pf_22740_fields num_fcoe_qps i40e_pf 0 22740 NULL
 iwlagn_pass_packet_to_mac80211_fndecl_22746_fields iwlagn_pass_packet_to_mac80211 fndecl 3 22746 NULL
+iov_iter_revert_fndecl_22771_fields iov_iter_revert fndecl 2 22771 NULL
 rambase_brcmf_chip_22773_fields rambase brcmf_chip 0 22773 NULL
 efi_memmap_alloc_fndecl_22776_fields efi_memmap_alloc fndecl 1-0 22776 NULL
 ndr_mappings_nd_region_22782_fields ndr_mappings nd_region 0 22782 NULL
@@ -5611,6 +5701,7 @@ snap_names_len_rbd_image_header_ondisk_22898_fields snap_names_len rbd_image_hea
 ima_post_read_file_fndecl_22903_fields ima_post_read_file fndecl 3 22903 NULL nohasharray
 lpfc_fcp_io_channel_init_fndecl_22903_fields lpfc_fcp_io_channel_init fndecl 2 22903 &ima_post_read_file_fndecl_22903_fields
 count_ioctl_gntdev_map_grant_ref_22904_fields count ioctl_gntdev_map_grant_ref 0 22904 NULL
+num_y_edt_ft5x06_ts_data_22905_fields num_y edt_ft5x06_ts_data 0 22905 NULL
 membase_phys_efx_nic_22907_fields membase_phys efx_nic 0 22907 NULL
 vmalloc_32_fndecl_22908_fields vmalloc_32 fndecl 1 22908 NULL
 cfg80211_report_obss_beacon_fndecl_22910_fields cfg80211_report_obss_beacon fndecl 3 22910 NULL
@@ -5667,6 +5758,7 @@ l2_len_ovs_frag_data_23095_fields l2_len ovs_frag_data 0 23095 NULL nohasharray
 s_cluster_ratio_ext4_sb_info_23095_fields s_cluster_ratio ext4_sb_info 0 23095 &l2_len_ovs_frag_data_23095_fields
 qla27xx_fwdt_template_default_size_fndecl_23103_fields qla27xx_fwdt_template_default_size fndecl 0 23103 NULL
 __minimum_chunk_size_fndecl_23105_fields __minimum_chunk_size fndecl 0 23105 NULL
+aim_vdev_read_fndecl_23120_fields aim_vdev_read fndecl 3 23120 NULL
 xfs_rmap_unmap_fndecl_23123_fields xfs_rmap_unmap fndecl 0 23123 NULL nohasharray
 sq_max_sges_c4iw_qp_attributes_23123_fields sq_max_sges c4iw_qp_attributes 0 23123 &xfs_rmap_unmap_fndecl_23123_fields
 numchips_nand_chip_23137_fields numchips nand_chip 0 23137 NULL
@@ -5678,6 +5770,7 @@ max_tx_urbs_kvaser_usb_23152_fields max_tx_urbs kvaser_usb 0 23152 NULL
 memblock_free_fndecl_23154_fields memblock_free fndecl 2-1 23154 NULL
 oxu_create_fndecl_23159_fields oxu_create fndecl 3-2 23159 NULL
 isdn_audio_xlaw2adpcm_fndecl_23162_fields isdn_audio_xlaw2adpcm fndecl 0 23162 NULL
+gfs2_xattr_set_fndecl_23165_fields gfs2_xattr_set fndecl 6 23165 NULL
 width_linux_logo_23166_fields width linux_logo 0 23166 NULL
 memblock_alloc_base_fndecl_23169_fields memblock_alloc_base fndecl 2-1-0-3 23169 NULL nohasharray
 MaxIoCommands_aac_init_23169_fields MaxIoCommands aac_init 0 23169 &memblock_alloc_base_fndecl_23169_fields
@@ -5686,6 +5779,7 @@ x_res_vbe_mode_ib_23177_fields x_res vbe_mode_ib 0 23177 NULL
 udf_current_aext_fndecl_23183_fields udf_current_aext fndecl 0 23183 NULL
 __reuseport_alloc_fndecl_23190_fields __reuseport_alloc fndecl 1 23190 NULL
 seq_lseek_fndecl_23197_fields seq_lseek fndecl 2 23197 NULL
+offs_aim_fh_23201_fields offs aim_fh 0 23201 NULL
 read_swap_header_fndecl_23222_fields read_swap_header fndecl 0 23222 NULL
 clk_core_get_rate_fndecl_23225_fields clk_core_get_rate fndecl 0 23225 NULL nohasharray
 vid_hdr_offset_ubi_device_23225_fields vid_hdr_offset ubi_device 0 23225 &clk_core_get_rate_fndecl_23225_fields
@@ -5751,6 +5845,7 @@ offset_ttm_bus_placement_23475_fields offset ttm_bus_placement 0 23475 NULL
 coda_psdev_write_fndecl_23484_fields coda_psdev_write fndecl 3 23484 NULL
 control_skge_rx_desc_23486_fields control skge_rx_desc 0 23486 NULL
 mxt_read_and_process_messages_fndecl_23502_fields mxt_read_and_process_messages fndecl 2-0 23502 NULL
+pf_tids_total_qed_tm_iids_23535_fields pf_tids_total qed_tm_iids 0 23535 NULL
 offset_crypto_cts_reqctx_23536_fields offset crypto_cts_reqctx 0 23536 NULL
 ieee80211_new_mesh_header_fndecl_23538_fields ieee80211_new_mesh_header fndecl 0 23538 NULL
 ring_size_per_user_data_23539_fields ring_size per_user_data 0 23539 NULL
@@ -5887,6 +5982,7 @@ minimum_pcc_memory_resource_24022_fields minimum pcc_memory_resource 0 24022 NUL
 btt_map_write_fndecl_24029_fields btt_map_write fndecl 0 24029 NULL nohasharray
 fill_user_desc_fndecl_24029_fields fill_user_desc fndecl 2 24029 &btt_map_write_fndecl_24029_fields
 bpp__sisbios_mode_24033_fields bpp _sisbios_mode 0 24033 NULL
+mbo_offs_aim_channel_24035_fields mbo_offs aim_channel 0 24035 NULL
 __radix_tree_preload_fndecl_24036_fields __radix_tree_preload fndecl 0 24036 NULL nohasharray
 namelen_cramfs_inode_24036_fields namelen cramfs_inode 0 24036 &__radix_tree_preload_fndecl_24036_fields
 obj_size_request_sock_ops_24037_fields obj_size request_sock_ops 0 24037 NULL
@@ -6066,6 +6162,7 @@ compat_sys_fcntl_fndecl_24629_fields compat_sys_fcntl fndecl 3 24629 NULL
 elan_i2c_read_block_fndecl_24636_fields elan_i2c_read_block fndecl 4 24636 NULL
 desc_count_orangefs_bufmap_24642_fields desc_count orangefs_bufmap 0 24642 NULL nohasharray
 len_n_flags_il_rx_pkt_24642_fields len_n_flags il_rx_pkt 0 24642 &desc_count_orangefs_bufmap_24642_fields
+data_mcp_cmd_response_24644_fields data mcp_cmd_response 0 24644 NULL
 array_len_xdr_array2_desc_24652_fields array_len xdr_array2_desc 0 24652 NULL
 cur_sg_ore_per_dev_state_24654_fields cur_sg ore_per_dev_state 0 24654 NULL
 offset_musb_qh_24658_fields offset musb_qh 0 24658 NULL
@@ -6116,6 +6213,7 @@ array_resync_offset_dm_raid_superblock_24815_fields array_resync_offset dm_raid_
 HBP_kyrofb_info_24818_fields HBP kyrofb_info 0 24818 NULL
 insert_state_fndecl_24820_fields insert_state fndecl 0-4-3 24820 NULL
 readahead_cached_dev_24826_fields readahead cached_dev 0 24826 NULL
+param_size_preview_update_24836_fields param_size preview_update 0 24836 NULL
 alloc_fddidev_fndecl_24837_fields alloc_fddidev fndecl 1 24837 NULL
 ceph_osdc_notify_ack_fndecl_24848_fields ceph_osdc_notify_ack fndecl 7 24848 NULL
 cx88_alsa_dma_init_fndecl_24851_fields cx88_alsa_dma_init fndecl 2 24851 NULL nohasharray
@@ -6146,7 +6244,8 @@ current_area_pstore_24931_fields current_area pstore 0 24931 &__mutex_lock_killa
 max_sectors_per_io_vardecl_megaraid_c_24934_fields max_sectors_per_io vardecl_megaraid.c 0 24934 NULL
 rtl_download_firmware_fndecl_24937_fields rtl_download_firmware fndecl 3 24937 NULL
 key_len_cfg80211_connect_params_24952_fields key_len cfg80211_connect_params 0 24952 NULL
-vmalloc_fndecl_24955_fields vmalloc fndecl 1 24955 NULL
+vmalloc_fndecl_24955_fields vmalloc fndecl 1 24955 NULL nohasharray
+size_video_still_picture_24955_fields size video_still_picture 0 24955 &vmalloc_fndecl_24955_fields
 pkts_acked_ack_sample_24969_fields pkts_acked ack_sample 0 24969 NULL
 pppol2tp_sendmsg_fndecl_24975_fields pppol2tp_sendmsg fndecl 3 24975 NULL nohasharray
 system_dir_blkno_ocfs2_super_24975_fields system_dir_blkno ocfs2_super 0 24975 &pppol2tp_sendmsg_fndecl_24975_fields nohasharray
@@ -6230,6 +6329,7 @@ validate_checkpoint_fndecl_25229_fields validate_checkpoint fndecl 2 25229 NULL
 show_configfs_attribute_25232_fields show configfs_attribute 0 25232 NULL
 spy_number_iw_spy_data_25234_fields spy_number iw_spy_data 0 25234 NULL
 offset_zatm_pool_info_25250_fields offset zatm_pool_info 0 25250 NULL
+fpnum_omap3isp_ccdc_fpc_25254_fields fpnum omap3isp_ccdc_fpc 0 25254 NULL
 btrfs_submit_direct_fndecl_25259_fields btrfs_submit_direct fndecl 3 25259 NULL
 ar5523_cmd_fndecl_25261_fields ar5523_cmd fndecl 4 25261 NULL
 start_page_swap_extent_25262_fields start_page swap_extent 0 25262 NULL nohasharray
@@ -6274,6 +6374,7 @@ atom_size_pcpu_alloc_info_25396_fields atom_size pcpu_alloc_info 0 25396 NULL
 brcmf_pcie_read_tcm16_fndecl_25401_fields brcmf_pcie_read_tcm16 fndecl 0 25401 NULL
 metromem_dma_metronomefb_par_25407_fields metromem_dma metronomefb_par 0 25407 NULL
 memblock_virt_alloc_try_nid_fndecl_25409_fields memblock_virt_alloc_try_nid fndecl 2-3-4 25409 NULL
+nr_valid_peri_dma_pl330_platdata_25412_fields nr_valid_peri dma_pl330_platdata 0 25412 NULL
 entries_size_ebt_replace_kernel_25413_fields entries_size ebt_replace_kernel 0 25413 NULL
 image_len_gspca_dev_25419_fields image_len gspca_dev 0 25419 NULL
 remap_pci_mem_fndecl_25421_fields remap_pci_mem fndecl 2-1 25421 NULL nohasharray
@@ -6408,6 +6509,7 @@ vchnl_vf_send_add_hmc_objs_req_fndecl_25963_fields vchnl_vf_send_add_hmc_objs_re
 len_xsd_sockmsg_25963_fields len xsd_sockmsg 0 25963 &vchnl_vf_send_add_hmc_objs_req_fndecl_25963_fields
 ieee802154_hdr_get_sechdr_fndecl_25965_fields ieee802154_hdr_get_sechdr fndecl 0 25965 NULL
 memblock_remove_range_fndecl_25969_fields memblock_remove_range fndecl 3-2 25969 NULL
+vscnprintf_fndecl_25984_fields vscnprintf fndecl 0 25984 NULL
 ns_blocksize_bits_the_nilfs_25985_fields ns_blocksize_bits the_nilfs 0 25985 NULL
 split_state_fndecl_25992_fields split_state fndecl 0-4 25992 NULL
 vga_vram_size_vardecl_vgacon_c_25995_fields vga_vram_size vardecl_vgacon.c 0 25995 NULL
@@ -6476,6 +6578,7 @@ simple_io_fndecl_26280_fields simple_io fndecl 4 26280 NULL nohasharray
 xlate_dev_mem_ptr_fndecl_26280_fields xlate_dev_mem_ptr fndecl 1 26280 &simple_io_fndecl_26280_fields
 send_write_fndecl_26285_fields send_write fndecl 6-0-5 26285 NULL
 tx_data_length_hso_serial_26287_fields tx_data_length hso_serial 0 26287 NULL
+size_rsn_ie_t_26289_fields size rsn_ie_t 0 26289 NULL
 hub_port_connect_fndecl_26292_fields hub_port_connect fndecl 2 26292 NULL nohasharray
 sc_max_sge_svcxprt_rdma_26292_fields sc_max_sge svcxprt_rdma 0 26292 &hub_port_connect_fndecl_26292_fields
 members_count_dlm_space_26293_fields members_count dlm_space 0 26293 NULL
@@ -6511,6 +6614,7 @@ dict_size_comp_opts_26391_fields dict_size comp_opts 0 26391 NULL
 maximum_num_physicals_aac_dev_26393_fields maximum_num_physicals aac_dev 0 26393 NULL
 lcd_write_fndecl_26394_fields lcd_write fndecl 3 26394 NULL
 transcnt_elsa_hw_26395_fields transcnt elsa_hw 0 26395 NULL
+ea_init_fndecl_26400_fields ea_init fndecl 5 26400 NULL
 gbuffers_vardecl_meye_c_26402_fields gbuffers vardecl_meye.c 0 26402 NULL
 xhci_giveback_urb_in_irq_fndecl_26403_fields xhci_giveback_urb_in_irq fndecl 3 26403 NULL nohasharray
 bad_peb_limit_ubi_device_26403_fields bad_peb_limit ubi_device 0 26403 &xhci_giveback_urb_in_irq_fndecl_26403_fields
@@ -6566,6 +6670,7 @@ smbios_entry_point_size_vardecl_dmi_scan_c_26579_fields smbios_entry_point_size
 read_tree_block_fndecl_26587_fields read_tree_block fndecl 2 26587 NULL nohasharray
 initial_ssthresh_vardecl_tcp_cubic_c_26587_fields initial_ssthresh vardecl_tcp_cubic.c 0 26587 &read_tree_block_fndecl_26587_fields
 rates_len_add_sta_param_26593_fields rates_len add_sta_param 0 26593 NULL
+tx_desc_count_xgbe_prv_data_26603_fields tx_desc_count xgbe_prv_data 0 26603 NULL
 UMAsize_sis_video_info_26611_fields UMAsize sis_video_info 0 26611 NULL
 width_drm_vmw_size_26615_fields width drm_vmw_size 0 26615 NULL
 control_blocks_gru_create_context_req_26616_fields control_blocks gru_create_context_req 0 26616 NULL
@@ -6594,6 +6699,7 @@ front_len_ceph_msgpool_26653_fields front_len ceph_msgpool 0 26653 NULL
 pmcraid_get_minor_fndecl_26656_fields pmcraid_get_minor fndecl 0 26656 NULL
 nr_recvmsg_fndecl_26658_fields nr_recvmsg fndecl 3 26658 NULL
 jbd2_journal_begin_ordered_truncate_fndecl_26661_fields jbd2_journal_begin_ordered_truncate fndecl 3 26661 NULL
+qed_qm_pf_mem_size_fndecl_26667_fields qed_qm_pf_mem_size fndecl 0 26667 NULL
 hdlc_change_mtu_fndecl_26672_fields hdlc_change_mtu fndecl 2 26672 NULL
 oobsize_mtd_info_26683_fields oobsize mtd_info 0 26683 NULL
 swap_cgroup_swapon_fndecl_26685_fields swap_cgroup_swapon fndecl 2 26685 NULL
@@ -6676,6 +6782,7 @@ bt_sock_recvmsg_fndecl_26967_fields bt_sock_recvmsg fndecl 3 26967 NULL
 brk_mm_struct_26976_fields brk mm_struct 0 26976 NULL nohasharray
 init_allocator_fndecl_26976_fields init_allocator fndecl 3 26976 &brk_mm_struct_26976_fields
 ctrl_out_pipe_hfcusb_data_26981_fields ctrl_out_pipe hfcusb_data 0 26981 NULL
+num_waitchks_drm_tegra_submit_26983_fields num_waitchks drm_tegra_submit 0 26983 NULL
 skd_skreq_prep_buffering_fndecl_26987_fields skd_skreq_prep_buffering fndecl 3 26987 NULL
 __tipc_send_stream_fndecl_26990_fields __tipc_send_stream fndecl 3 26990 NULL
 address_length_acpi_address64_attribute_26992_fields address_length acpi_address64_attribute 0 26992 NULL
@@ -6739,6 +6846,7 @@ netup_unidvb_dma_init_fndecl_27199_fields netup_unidvb_dma_init fndecl 2 27199 N
 tpm_tis_spi_read_bytes_fndecl_27206_fields tpm_tis_spi_read_bytes fndecl 3 27206 NULL
 ath6kl_wmi_scanparams_cmd_fndecl_27208_fields ath6kl_wmi_scanparams_cmd fndecl 2 27208 NULL
 __ext4_read_dirblock_fndecl_27210_fields __ext4_read_dirblock fndecl 2 27210 NULL
+nr_bos_drm_etnaviv_gem_submit_27211_fields nr_bos drm_etnaviv_gem_submit 0 27211 NULL
 block_size_scsi_tape_27212_fields block_size scsi_tape 0 27212 NULL
 num_prior_parent_snaps_ceph_mds_snap_realm_27215_fields num_prior_parent_snaps ceph_mds_snap_realm 0 27215 NULL
 sdio_memcpy_fromio_fndecl_27218_fields sdio_memcpy_fromio fndecl 4 27218 NULL
@@ -6866,6 +6974,7 @@ bsize_videobuf_buffer_27645_fields bsize videobuf_buffer 0 27645 NULL
 period_frames_usb_stream_config_27656_fields period_frames usb_stream_config 0 27656 NULL
 WriteRegs_fndecl_27658_fields WriteRegs fndecl 4 27658 NULL
 xen_get_pages_limit_fndecl_27661_fields xen_get_pages_limit fndecl 0 27661 NULL
+gb_operation_create_common_fndecl_27662_fields gb_operation_create_common fndecl 4 27662 NULL
 ceph_osdc_wait_request_fndecl_27663_fields ceph_osdc_wait_request fndecl 0 27663 NULL
 efx_ef10_mem_map_size_fndecl_27664_fields efx_ef10_mem_map_size fndecl 0 27664 NULL
 size_compat_ip6t_replace_27672_fields size compat_ip6t_replace 0 27672 NULL
@@ -6940,6 +7049,7 @@ ext4_seek_hole_fndecl_27990_fields ext4_seek_hole fndecl 2 27990 NULL
 write_mei_hw_ops_27991_fields write mei_hw_ops 0 27991 NULL
 credits_send_context_27993_fields credits send_context 0 27993 NULL nohasharray
 alloc_ccbs_blogic_adapter_27993_fields alloc_ccbs blogic_adapter 0 27993 &credits_send_context_27993_fields
+cumulative_size_wm_adsp_buffer_region_27998_fields cumulative_size wm_adsp_buffer_region 0 27998 NULL
 page_count_scrub_block_28000_fields page_count scrub_block 0 28000 NULL nohasharray
 ubifs_end_scan_fndecl_28000_fields ubifs_end_scan fndecl 4 28000 &page_count_scrub_block_28000_fields
 max_x_fb_monspecs_28003_fields max_x fb_monspecs 0 28003 NULL
@@ -6960,6 +7070,7 @@ cl_nodelen_rpc_clnt_28055_fields cl_nodelen rpc_clnt 0 28055 NULL
 xfs_end_io_direct_write_fndecl_28060_fields xfs_end_io_direct_write fndecl 3-2 28060 NULL
 s_imap_blocks_minix_sb_info_28062_fields s_imap_blocks minix_sb_info 0 28062 NULL
 gfs2_llseek_fndecl_28067_fields gfs2_llseek fndecl 2 28067 NULL
+nr_cmds_drm_msm_gem_submit_28071_fields nr_cmds drm_msm_gem_submit 0 28071 NULL
 rsi_prepare_skb_fndecl_28075_fields rsi_prepare_skb fndecl 4-3 28075 NULL
 qla4_82xx_pci_mem_write_direct_fndecl_28076_fields qla4_82xx_pci_mem_write_direct fndecl 2 28076 NULL
 abituguru_detect_fndecl_28078_fields abituguru_detect fndecl 0 28078 NULL
@@ -7003,13 +7114,15 @@ wil_seq_hexdump_fndecl_28225_fields wil_seq_hexdump fndecl 3 28225 &s_blocksize_
 space_slots_btrfs_ioctl_space_args_28231_fields space_slots btrfs_ioctl_space_args 0 28231 NULL
 mux_device_request_fndecl_28235_fields mux_device_request fndecl 7 28235 NULL nohasharray
 l2cap_mtu_vardecl_core_c_28235_fields l2cap_mtu vardecl_core.c 0 28235 &mux_device_request_fndecl_28235_fields
+bits_mpidr_hash_28236_fields bits mpidr_hash 0 28236 NULL
 old_addr_inmem_pages_28238_fields old_addr inmem_pages 0 28238 NULL
 loop_end_patch_info_28242_fields loop_end patch_info 0 28242 NULL
 btrfs_qgroup_free_data_fndecl_28246_fields btrfs_qgroup_free_data fndecl 2-3 28246 NULL nohasharray
 ino_bfs_dirent_28246_fields ino bfs_dirent 0 28246 &btrfs_qgroup_free_data_fndecl_28246_fields
 baud_base_serial_struct_28251_fields baud_base serial_struct 0 28251 NULL
 bcm_tx_send_fndecl_28258_fields bcm_tx_send fndecl 4 28258 NULL
-count_e1000_tx_ring_28261_fields count e1000_tx_ring 0 28261 NULL
+count_e1000_tx_ring_28261_fields count e1000_tx_ring 0 28261 NULL nohasharray
+ea_set_i_fndecl_28261_fields ea_set_i fndecl 5 28261 &count_e1000_tx_ring_28261_fields
 flags_rxe_bth_28263_fields flags rxe_bth 0 28263 NULL
 x1_osd_cmd_s_28266_fields x1 osd_cmd_s 0 28266 NULL
 mt7601u_rx_process_seg_fndecl_28268_fields mt7601u_rx_process_seg fndecl 3 28268 NULL
@@ -7085,6 +7198,7 @@ len_s3fwrn5_fw_header_28556_fields len s3fwrn5_fw_header 0 28556 NULL
 ci_ll_init_fndecl_28561_fields ci_ll_init fndecl 3 28561 NULL nohasharray
 num_pads_uvc_entity_28561_fields num_pads uvc_entity 0 28561 &ci_ll_init_fndecl_28561_fields
 PRO_RATE_DEFAULT_vardecl_ice1712_c_28563_fields PRO_RATE_DEFAULT vardecl_ice1712.c 0 28563 NULL
+wm_adsp_write_data_word_fndecl_28566_fields wm_adsp_write_data_word fndecl 0 28566 NULL
 size_vhost_iotlb_msg_28568_fields size vhost_iotlb_msg 0 28568 NULL
 nvme_npages_fndecl_28569_fields nvme_npages fndecl 0-1 28569 NULL
 out_max_chans_snd_card_asihpi_28574_fields out_max_chans snd_card_asihpi 0 28574 NULL
@@ -7147,7 +7261,8 @@ items_max_vxge_hw_mempool_28806_fields items_max vxge_hw_mempool 0 28806 NULL no
 brcmf_fil_bsscfg_data_set_fndecl_28806_fields brcmf_fil_bsscfg_data_set fndecl 4 28806 &items_max_vxge_hw_mempool_28806_fields
 e820_remove_range_fndecl_28810_fields e820_remove_range fndecl 1-2 28810 NULL
 sisusb_send_bridge_packet_fndecl_28818_fields sisusb_send_bridge_packet fndecl 2 28818 NULL
-ceph_build_auth_fndecl_28825_fields ceph_build_auth fndecl 0 28825 NULL
+ceph_build_auth_fndecl_28825_fields ceph_build_auth fndecl 0 28825 NULL nohasharray
+oid_printf_vargs_fndecl_28825_fields oid_printf_vargs fndecl 0 28825 &ceph_build_auth_fndecl_28825_fields
 sdio_memcpy_toio_fndecl_28828_fields sdio_memcpy_toio fndecl 4 28828 NULL
 vram_end_radeon_mc_28831_fields vram_end radeon_mc 0 28831 NULL
 right_qxl_urect_28833_fields right qxl_urect 0 28833 NULL nohasharray
@@ -7156,7 +7271,8 @@ dm_table_add_target_fndecl_28838_fields dm_table_add_target fndecl 4-3 28838 NUL
 dsp_buffer_alloc_fndecl_28855_fields dsp_buffer_alloc fndecl 2 28855 NULL
 pf_cids_qed_src_iids_28859_fields pf_cids qed_src_iids 0 28859 NULL
 mt9t031_set_params_fndecl_28862_fields mt9t031_set_params fndecl 4-3 28862 NULL
-tx_pending_ethtool_ringparam_28864_fields tx_pending ethtool_ringparam 0 28864 NULL
+tx_pending_ethtool_ringparam_28864_fields tx_pending ethtool_ringparam 0 28864 NULL nohasharray
+size_pmk_list_t_28864_fields size pmk_list_t 0 28864 &tx_pending_ethtool_ringparam_28864_fields
 ie_length_brcmf_bss_info_le_28867_fields ie_length brcmf_bss_info_le 0 28867 NULL
 usb_stor_access_xfer_buf_fndecl_28868_fields usb_stor_access_xfer_buf fndecl 0-2 28868 NULL
 i2c_master_recv_fndecl_28869_fields i2c_master_recv fndecl 0-3 28869 NULL
@@ -7192,7 +7308,8 @@ aper_size_agp_kern_info_28990_fields aper_size agp_kern_info 0 28990 NULL
 klen_WepKeyRid_28997_fields klen WepKeyRid 0 28997 NULL
 handle_unit_fndecl_29000_fields handle_unit fndecl 0-1 29000 NULL nohasharray
 rawsize_nd_namespace_label_29000_fields rawsize nd_namespace_label 0 29000 &handle_unit_fndecl_29000_fields
-len_p54p_desc_29001_fields len p54p_desc 0 29001 NULL
+len_p54p_desc_29001_fields len p54p_desc 0 29001 NULL nohasharray
+buf_read_ptr_comedi_async_29001_fields buf_read_ptr comedi_async 0 29001 &len_p54p_desc_29001_fields
 nl80211_send_mgmt_fndecl_29002_fields nl80211_send_mgmt fndecl 7 29002 NULL
 num_lns_csio_hw_29004_fields num_lns csio_hw 0 29004 NULL
 __kfifo_out_peek_fndecl_29010_fields __kfifo_out_peek fndecl 0-3 29010 NULL
@@ -7217,6 +7334,7 @@ ath6kl_wmi_deletekey_cmd_fndecl_29086_fields ath6kl_wmi_deletekey_cmd fndecl 2 2
 len_scifioctl_unreg_29093_fields len scifioctl_unreg 0 29093 NULL
 dlm_lowcomms_get_buffer_fndecl_29111_fields dlm_lowcomms_get_buffer fndecl 2 29111 NULL
 bttv_read_fndecl_29115_fields bttv_read fndecl 3 29115 NULL
+size_tmc_drvdata_29121_fields size tmc_drvdata 0 29121 NULL
 start_dm_verity_fec_29127_fields start dm_verity_fec 0 29127 NULL
 ioctl_code_usbdevfs_ioctl_29134_fields ioctl_code usbdevfs_ioctl 0 29134 NULL
 y1_virtio_gpu_framebuffer_29147_fields y1 virtio_gpu_framebuffer 0 29147 NULL
@@ -7363,6 +7481,7 @@ i40e_pci_sriov_configure_fndecl_29688_fields i40e_pci_sriov_configure fndecl 2 2
 size_tool_mw_29693_fields size tool_mw 0 29693 NULL
 osd_req_write_sg_kern_fndecl_29697_fields osd_req_write_sg_kern fndecl 5 29697 NULL
 qlcnic_pci_sriov_enable_fndecl_29700_fields qlcnic_pci_sriov_enable fndecl 2 29700 NULL
+lmm_stripe_count_lov_user_md_v1_29706_fields lmm_stripe_count lov_user_md_v1 0 29706 NULL
 get_vm_area_caller_fndecl_29708_fields get_vm_area_caller fndecl 1 29708 NULL
 ocfs2_add_refcounted_extent_fndecl_29709_fields ocfs2_add_refcounted_extent fndecl 6-7-5 29709 NULL
 ieee80211_stop_tx_ba_cb_irqsafe_fndecl_29711_fields ieee80211_stop_tx_ba_cb_irqsafe fndecl 3 29711 NULL
@@ -7409,6 +7528,7 @@ residual_st_cmdstatus_29897_fields residual st_cmdstatus 0 29897 NULL
 be_pci_sriov_configure_fndecl_29900_fields be_pci_sriov_configure fndecl 2 29900 NULL
 edge_write_fndecl_29911_fields edge_write fndecl 4 29911 NULL
 io_error_dio_29914_fields io_error dio 0 29914 NULL
+size_exynos_drm_gem_29915_fields size exynos_drm_gem 0 29915 NULL
 fw_imem_len_rt_firmware_29916_fields fw_imem_len rt_firmware 0 29916 NULL
 size_ipt_replace_29921_fields size ipt_replace 0 29921 NULL
 nr_frags_skb_shared_info_29925_fields nr_frags skb_shared_info 0 29925 NULL
@@ -7486,6 +7606,7 @@ prism2_ap_get_sta_qual_fndecl_30181_fields prism2_ap_get_sta_qual fndecl 0 30181
 in_ep_num_rtl_hal_usbint_cfg_30182_fields in_ep_num rtl_hal_usbint_cfg 0 30182 NULL
 alloc_pci_root_info_fndecl_30198_fields alloc_pci_root_info fndecl 2-1 30198 NULL
 buf_len_uvesafb_task_30200_fields buf_len uvesafb_task 0 30200 NULL
+pipe_size_renesas_usbhs_driver_param_30206_fields pipe_size renesas_usbhs_driver_param 0 30206 NULL
 len_header_msg_30207_fields len header_msg 0 30207 NULL
 bm_bits_bm_xfer_ctx_30221_fields bm_bits bm_xfer_ctx 0 30221 NULL nohasharray
 rd_offset_nfsd4_read_30221_fields rd_offset nfsd4_read 0 30221 &bm_bits_bm_xfer_ctx_30221_fields
@@ -7584,7 +7705,8 @@ ext4_collapse_range_fndecl_30598_fields ext4_collapse_range fndecl 3-2 30598 NUL
 offset_drm_i915_gem_pread_30601_fields offset drm_i915_gem_pread 0 30601 NULL
 update_backups_fndecl_30602_fields update_backups fndecl 2 30602 NULL
 add_ino_fndecl_30603_fields add_ino fndecl 4 30603 NULL
-total_data_placed_lpfc_wcqe_complete_30612_fields total_data_placed lpfc_wcqe_complete 0 30612 NULL
+total_data_placed_lpfc_wcqe_complete_30612_fields total_data_placed lpfc_wcqe_complete 0 30612 NULL nohasharray
+blk_sz_os_dat_entry_s_30612_fields blk_sz os_dat_entry_s 0 30612 &total_data_placed_lpfc_wcqe_complete_30612_fields
 ieee802_11_parse_elems_crc_fndecl_30615_fields ieee802_11_parse_elems_crc fndecl 2 30615 NULL
 size_cmdQ_30622_fields size cmdQ 0 30622 NULL
 msc_buffer_win_alloc_fndecl_30624_fields msc_buffer_win_alloc fndecl 2 30624 NULL
@@ -7603,6 +7725,7 @@ mac_drv_rx_complete_fndecl_30692_fields mac_drv_rx_complete fndecl 4 30692 NULL
 keybytes_gss_krb5_enctype_30694_fields keybytes gss_krb5_enctype 0 30694 NULL
 status_urb_30696_fields status urb 0 30696 NULL
 hdsp_spdif_sample_rate_fndecl_30700_fields hdsp_spdif_sample_rate fndecl 0 30700 NULL
+bin_cl_size_drm_vc4_submit_cl_30710_fields bin_cl_size drm_vc4_submit_cl 0 30710 NULL
 numPhys_PVSCSIConfigPageController_30726_fields numPhys PVSCSIConfigPageController 0 30726 NULL
 num_descriptors_pmc_ctx_30735_fields num_descriptors pmc_ctx 0 30735 NULL
 nci_hci_send_data_fndecl_30741_fields nci_hci_send_data fndecl 5 30741 NULL
@@ -7701,6 +7824,7 @@ pci_sriov_get_totalvfs_fndecl_31059_fields pci_sriov_get_totalvfs fndecl 0 31059
 t4_max_qp_depth_c4iw_hw_queue_31059_fields t4_max_qp_depth c4iw_hw_queue 0 31059 &pci_sriov_get_totalvfs_fndecl_31059_fields
 drbd_bm_bits_fndecl_31061_fields drbd_bm_bits fndecl 0 31061 NULL
 si_lf_eblk_bfs_sb_info_31064_fields si_lf_eblk bfs_sb_info 0 31064 NULL
+gb_operation_response_alloc_fndecl_31065_fields gb_operation_response_alloc fndecl 2 31065 NULL
 hdr_offset_xfrm_type_31067_fields hdr_offset xfrm_type 0 31067 NULL
 bulk_in_endpointAddress_usb_serial_port_31069_fields bulk_in_endpointAddress usb_serial_port 0 31069 NULL
 segsize_musb_qh_31074_fields segsize musb_qh 0 31074 NULL
@@ -7759,6 +7883,7 @@ irq_pcmcia_device_31283_fields irq pcmcia_device 0 31283 NULL
 mmap_base_kioctx_31285_fields mmap_base kioctx 0 31285 NULL
 igb_enable_sriov_fndecl_31288_fields igb_enable_sriov fndecl 2 31288 NULL
 nfs_readdir_page_filler_fndecl_31292_fields nfs_readdir_page_filler fndecl 5 31292 NULL
+avail_wm_adsp_compr_buf_31294_fields avail wm_adsp_compr_buf 0 31294 NULL
 fs_shift_hfsplus_sb_info_31309_fields fs_shift hfsplus_sb_info 0 31309 NULL
 rxblen_brcmf_sdio_31317_fields rxblen brcmf_sdio 0 31317 NULL
 bio_integrity_add_page_fndecl_31320_fields bio_integrity_add_page fndecl 3-4 31320 NULL
@@ -7818,6 +7943,7 @@ kernel_physical_mapping_init_fndecl_31561_fields kernel_physical_mapping_init fn
 qlcnic_validate_ringparam_fndecl_31569_fields qlcnic_validate_ringparam fndecl 0 31569 NULL
 can_change_mtu_fndecl_31583_fields can_change_mtu fndecl 2 31583 NULL
 dvb_dvr_set_buffer_size_fndecl_31587_fields dvb_dvr_set_buffer_size fndecl 2 31587 NULL
+num_txq_bna_attr_31588_fields num_txq bna_attr 0 31588 NULL
 emac_receive_skb_fndecl_31589_fields emac_receive_skb fndecl 3 31589 NULL
 v_max_out_saa7146_standard_31591_fields v_max_out saa7146_standard 0 31591 NULL
 nbchannel_capi_profile_31592_fields nbchannel capi_profile 0 31592 NULL
@@ -8007,6 +8133,7 @@ khugepaged_scan_pmd_fndecl_32330_fields khugepaged_scan_pmd fndecl 3 32330 NULL
 bochs_ttm_tt_create_fndecl_32333_fields bochs_ttm_tt_create fndecl 2 32333 NULL nohasharray
 datablock_size_btrfsic_state_32333_fields datablock_size btrfsic_state 0 32333 &bochs_ttm_tt_create_fndecl_32333_fields
 mem_start_net_device_32337_fields mem_start net_device 0 32337 NULL
+exynos_drm_gem_create_fndecl_32344_fields exynos_drm_gem_create fndecl 3 32344 NULL
 scrub_raid56_parity_fndecl_32354_fields scrub_raid56_parity fndecl 5 32354 NULL nohasharray
 brcmf_fws_hdrpull_fndecl_32354_fields brcmf_fws_hdrpull fndecl 2 32354 &scrub_raid56_parity_fndecl_32354_fields
 end_crash_mem_range_32361_fields end crash_mem_range 0 32361 NULL
@@ -8117,6 +8244,7 @@ nfc_allocate_device_fndecl_32805_fields nfc_allocate_device fndecl 3 32805 &pipe
 info_len_ib_ucm_info_32807_fields info_len ib_ucm_info 0 32807 NULL
 m_len_f2fs_map_blocks_32808_fields m_len f2fs_map_blocks 0 32808 NULL
 l_start_xfs_flock64_32809_fields l_start xfs_flock64 0 32809 NULL
+lights_count_gb_lights_32813_fields lights_count gb_lights 0 32813 NULL
 length_ppp_option_data_32814_fields length ppp_option_data 0 32814 NULL
 namelen_jfs_ea_32820_fields namelen jfs_ea 0 32820 NULL
 xfs_btree_compute_maxlevels_fndecl_32823_fields xfs_btree_compute_maxlevels fndecl 0 32823 NULL
@@ -8233,6 +8361,7 @@ udf_load_partdesc_fndecl_33239_fields udf_load_partdesc fndecl 2 33239 NULL
 mfs_fc_lport_33249_fields mfs fc_lport 0 33249 NULL
 metadata_size_ecryptfs_crypt_stat_33252_fields metadata_size ecryptfs_crypt_stat 0 33252 NULL
 val_sz_orangefs_getxattr_response_33253_fields val_sz orangefs_getxattr_response 0 33253 NULL
+size_reserved_mem_33254_fields size reserved_mem 0 33254 NULL
 wb_offset_nfs_page_33255_fields wb_offset nfs_page 0 33255 NULL
 handle_bytes_file_handle_33261_fields handle_bytes file_handle 0 33261 NULL
 ip_vs_prepare_tunneled_skb_fndecl_33269_fields ip_vs_prepare_tunneled_skb fndecl 3 33269 NULL
@@ -8261,6 +8390,7 @@ lpfc_sg_seg_cnt_init_fndecl_33371_fields lpfc_sg_seg_cnt_init fndecl 2 33371 NUL
 ib_qib_max_srq_wrs_vardecl_33376_fields ib_qib_max_srq_wrs vardecl 0 33376 NULL
 sbitmap_resize_fndecl_33380_fields sbitmap_resize fndecl 2 33380 NULL
 xfs_buf_ioerror_fndecl_33390_fields xfs_buf_ioerror fndecl 2 33390 NULL
+stream_size_drm_etnaviv_gem_submit_33393_fields stream_size drm_etnaviv_gem_submit 0 33393 NULL
 data_offset_rndis_packet_33403_fields data_offset rndis_packet 0 33403 NULL
 lbmRead_fndecl_33420_fields lbmRead fndecl 2 33420 NULL
 dreq_gss_dccp_request_sock_33423_fields dreq_gss dccp_request_sock 0 33423 NULL
@@ -8280,6 +8410,7 @@ mt7601u_mcu_msg_alloc_fndecl_33453_fields mt7601u_mcu_msg_alloc fndecl 3 33453 N
 ocfs2_divide_xattr_bucket_fndecl_33455_fields ocfs2_divide_xattr_bucket fndecl 3-4 33455 NULL
 max_recv_send_sge_ocrdma_mbx_query_config_33459_fields max_recv_send_sge ocrdma_mbx_query_config 0 33459 NULL
 tx_pipe_usbpn_dev_33474_fields tx_pipe usbpn_dev 0 33474 NULL
+data_start_flat_hdr_33476_fields data_start flat_hdr 0 33476 NULL
 packets_out_tcp_sock_33478_fields packets_out tcp_sock 0 33478 NULL
 __nbd_ioctl_fndecl_33480_fields __nbd_ioctl fndecl 4 33480 NULL
 ath6kl_buf_alloc_fndecl_33483_fields ath6kl_buf_alloc fndecl 1 33483 NULL
@@ -8310,6 +8441,7 @@ qed_sriov_enable_fndecl_33587_fields qed_sriov_enable fndecl 2 33587 NULL
 hdr_info_bnxt_tpa_info_33589_fields hdr_info bnxt_tpa_info 0 33589 NULL
 i2c_readregs_fndecl_33590_fields i2c_readregs fndecl 5 33590 NULL
 hci_mgmt_cmd_fndecl_33591_fields hci_mgmt_cmd fndecl 4 33591 NULL
+lde_namelen_lu_dirent_33595_fields lde_namelen lu_dirent 0 33595 NULL
 fsl_spi_bufs_fndecl_33599_fields fsl_spi_bufs fndecl 0 33599 NULL
 max_header_size_iriap_cb_33603_fields max_header_size iriap_cb 0 33603 NULL
 drm_prime_pages_to_sg_fndecl_33612_fields drm_prime_pages_to_sg fndecl 2 33612 NULL
@@ -8323,6 +8455,7 @@ s_want_extra_isize_ext4_sb_info_33648_fields s_want_extra_isize ext4_sb_info 0 3
 check_header_fndecl_33649_fields check_header fndecl 2 33649 NULL
 xfs_alloc_ag_vextent_fndecl_33660_fields xfs_alloc_ag_vextent fndecl 0 33660 NULL
 savage_init_hw_fndecl_33678_fields savage_init_hw fndecl 0 33678 NULL
+size_drm_exynos_gem_create_33679_fields size drm_exynos_gem_create 0 33679 NULL
 data_size_vxge_rx_priv_33684_fields data_size vxge_rx_priv 0 33684 NULL
 len_scif_copy_work_33687_fields len scif_copy_work 0 33687 NULL
 mb_find_order_for_block_fndecl_33691_fields mb_find_order_for_block fndecl 0 33691 NULL
@@ -8351,11 +8484,13 @@ wmi_send_fndecl_33768_fields wmi_send fndecl 4 33768 NULL
 status_ffs_ep_33781_fields status ffs_ep 0 33781 NULL
 cx2341x_ctrl_new_std_fndecl_33782_fields cx2341x_ctrl_new_std fndecl 3-6 33782 NULL
 max_gpios_rdc321x_gpio_pdata_33783_fields max_gpios rdc321x_gpio_pdata 0 33783 NULL
-do_jit_fndecl_33785_fields do_jit fndecl 0 33785 NULL
+do_jit_fndecl_33785_fields do_jit fndecl 0 33785 NULL nohasharray
+fm_mapped_extents_ll_user_fiemap_33785_fields fm_mapped_extents ll_user_fiemap 0 33785 &do_jit_fndecl_33785_fields
 sis190_try_rx_copy_fndecl_33790_fields sis190_try_rx_copy fndecl 3 33790 NULL
 sd_write_data_fndecl_33792_fields sd_write_data fndecl 5 33792 NULL
 icv_truncbits_xfrm_algo_auth_info_33798_fields icv_truncbits xfrm_algo_auth_info 0 33798 NULL
 __ip_tun_to_nlattr_fndecl_33801_fields __ip_tun_to_nlattr fndecl 4 33801 NULL
+edt_ft5x06_register_read_fndecl_33803_fields edt_ft5x06_register_read fndecl 0 33803 NULL
 page_size_vmw_cmdbuf_alloc_info_33815_fields page_size vmw_cmdbuf_alloc_info 0 33815 NULL
 custom_length_iscsi_stats_33819_fields custom_length iscsi_stats 0 33819 NULL
 mult_usb_ep_33831_fields mult usb_ep 0 33831 NULL
@@ -8373,11 +8508,13 @@ tolen_nfs_linkargs_33881_fields tolen nfs_linkargs 0 33881 NULL nohasharray
 walk_system_ram_res_fndecl_33881_fields walk_system_ram_res fndecl 2-1 33881 &tolen_nfs_linkargs_33881_fields
 len_gsm_control_33882_fields len gsm_control 0 33882 NULL
 reiserfs_xattr_get_fndecl_33887_fields reiserfs_xattr_get fndecl 0 33887 NULL
+size_gb_operation_msg_hdr_33890_fields size gb_operation_msg_hdr 0 33890 NULL
 src_len_ccp_xts_aes_engine_33899_fields src_len ccp_xts_aes_engine 0 33899 NULL
 init_stripe_fndecl_33902_fields init_stripe fndecl 2 33902 NULL
 xfs_bmbt_maxrecs_fndecl_33906_fields xfs_bmbt_maxrecs fndecl 0 33906 NULL
 _install_special_mapping_fndecl_33907_fields _install_special_mapping fndecl 2-3 33907 NULL
 create_monitor_ctrl_command_fndecl_33909_fields create_monitor_ctrl_command fndecl 4 33909 NULL
+rx_desc_count_xgbe_prv_data_33915_fields rx_desc_count xgbe_prv_data 0 33915 NULL
 w83627hf_device_add_fndecl_33919_fields w83627hf_device_add fndecl 1 33919 NULL
 wil_vring_alloc_skb_fndecl_33924_fields wil_vring_alloc_skb fndecl 4 33924 NULL
 size_cmdline_vardecl_dma_contiguous_c_33925_fields size_cmdline vardecl_dma-contiguous.c 0 33925 NULL
@@ -8427,6 +8564,7 @@ len_hdlcdrv_hdlcrx_34043_fields len hdlcdrv_hdlcrx 0 34043 NULL
 dma_size_nx_host_rds_ring_34047_fields dma_size nx_host_rds_ring 0 34047 NULL
 sys_mmap_pgoff_fndecl_34056_fields sys_mmap_pgoff fndecl 2 34056 NULL
 cdc_ncm_change_mtu_fndecl_34062_fields cdc_ncm_change_mtu fndecl 2 34062 NULL
+lov_get_stripecnt_fndecl_34066_fields lov_get_stripecnt fndecl 0 34066 NULL
 gsm_control_modem_fndecl_34068_fields gsm_control_modem fndecl 3 34068 NULL
 wb_bytes_nfs_page_34071_fields wb_bytes nfs_page 0 34071 NULL nohasharray
 memmap_exclude_ranges_fndecl_34071_fields memmap_exclude_ranges fndecl 3-4 34071 &wb_bytes_nfs_page_34071_fields nohasharray
@@ -8658,6 +8796,7 @@ s35390a_get_reg_fndecl_34971_fields s35390a_get_reg fndecl 4 34971 NULL
 cw1200_queue_stats_init_fndecl_34973_fields cw1200_queue_stats_init fndecl 2 34973 NULL nohasharray
 items_snd_soc_tplg_enum_control_34973_fields items snd_soc_tplg_enum_control 0 34973 &cw1200_queue_stats_init_fndecl_34973_fields
 gcr_base_intel_pmc_ipc_dev_34977_fields gcr_base intel_pmc_ipc_dev 0 34977 NULL
+wm_adsp_buffer_capture_block_fndecl_35001_fields wm_adsp_buffer_capture_block fndecl 2-0 35001 NULL
 rx_ring_count_ixgbe_adapter_35004_fields rx_ring_count ixgbe_adapter 0 35004 NULL
 amb_len_i5k_amb_data_35007_fields amb_len i5k_amb_data 0 35007 NULL nohasharray
 platform_get_irq_byname_fndecl_35007_fields platform_get_irq_byname fndecl 0 35007 &amb_len_i5k_amb_data_35007_fields
@@ -8684,6 +8823,7 @@ inbuf_dma_ati_remote_35083_fields inbuf_dma ati_remote 0 35083 NULL
 ieee80211_add_rx_radiotap_header_fndecl_35086_fields ieee80211_add_rx_radiotap_header fndecl 4 35086 NULL nohasharray
 reclaim_pages_fndecl_35086_fields reclaim_pages fndecl 3 35086 &ieee80211_add_rx_radiotap_header_fndecl_35086_fields
 ubi_calc_data_len_fndecl_35092_fields ubi_calc_data_len fndecl 0-3 35092 NULL
+er_data_len_gfs2_ea_request_35098_fields er_data_len gfs2_ea_request 0 35098 NULL
 num_vf_qps_i40e_pf_35102_fields num_vf_qps i40e_pf 0 35102 NULL
 prot_length_se_device_35103_fields prot_length se_device 0 35103 NULL
 dma_common_get_sgtable_fndecl_35105_fields dma_common_get_sgtable fndecl 5 35105 NULL
@@ -8693,6 +8833,7 @@ ath6kl_wmi_set_bitrate_mask_fndecl_35108_fields ath6kl_wmi_set_bitrate_mask fnde
 pn_raw_send_fndecl_35113_fields pn_raw_send fndecl 2 35113 NULL
 max_uc_mac_be_resources_35119_fields max_uc_mac be_resources 0 35119 NULL
 vxfs_bmap_indir_fndecl_35120_fields vxfs_bmap_indir fndecl 2-0-4 35120 NULL
+alloc_vm_area_fndecl_35121_fields alloc_vm_area fndecl 1 35121 NULL
 advance_dma_data_fndecl_35124_fields advance_dma_data fndecl 2 35124 NULL
 sm501_alloc_mem_fndecl_35125_fields sm501_alloc_mem fndecl 4 35125 NULL
 bch_empty_fifo_fndecl_35126_fields bch_empty_fifo fndecl 2 35126 NULL
@@ -8781,7 +8922,8 @@ ocfs2_prepare_refcount_change_for_del_fndecl_35442_fields ocfs2_prepare_refcount
 pcf2123_read_fndecl_35443_fields pcf2123_read fndecl 4 35443 NULL
 wake_len_cfg80211_wowlan_tcp_35448_fields wake_len cfg80211_wowlan_tcp 0 35448 NULL nohasharray
 len_he_buff_35448_fields len he_buff 0 35448 &wake_len_cfg80211_wowlan_tcp_35448_fields
-ocfs2_truncate_file_fndecl_35455_fields ocfs2_truncate_file fndecl 3 35455 NULL
+ocfs2_truncate_file_fndecl_35455_fields ocfs2_truncate_file fndecl 3 35455 NULL nohasharray
+properties_count_gb_power_supply_35455_fields properties_count gb_power_supply 0 35455 &ocfs2_truncate_file_fndecl_35455_fields
 octeon_create_droq_fndecl_35457_fields octeon_create_droq fndecl 4-3 35457 NULL
 bytes_to_read_mpt3_diag_read_buffer_35460_fields bytes_to_read mpt3_diag_read_buffer 0 35460 NULL
 drbd_send_fndecl_35461_fields drbd_send fndecl 4 35461 NULL
@@ -8898,7 +9040,8 @@ snd_pcm_format_physical_width_fndecl_35858_fields snd_pcm_format_physical_width
 ipw_write_packet_sent_callback_fndecl_35859_fields ipw_write_packet_sent_callback fndecl 2 35859 NULL
 check_acl_fndecl_35867_fields check_acl fndecl 0 35867 NULL
 usb_stor_bulk_transfer_sglist_fndecl_35871_fields usb_stor_bulk_transfer_sglist fndecl 2-5-4 35871 NULL
-pcol_add_page_fndecl_35872_fields pcol_add_page fndecl 3 35872 NULL
+pcol_add_page_fndecl_35872_fields pcol_add_page fndecl 3 35872 NULL nohasharray
+processed_length_mbo_35872_fields processed_length mbo 0 35872 &pcol_add_page_fndecl_35872_fields
 snd_hdsp_midi_output_possible_fndecl_35873_fields snd_hdsp_midi_output_possible fndecl 0 35873 NULL
 shared_out_nid_ca0132_spec_35876_fields shared_out_nid ca0132_spec 0 35876 NULL
 st_sensors_spi_read_fndecl_35890_fields st_sensors_spi_read fndecl 4 35890 NULL
@@ -8909,6 +9052,7 @@ max_sq_desc_sz_mlx4_caps_35905_fields max_sq_desc_sz mlx4_caps 0 35905 &fe_group
 lirc_base_dev_vardecl_lirc_dev_c_35907_fields lirc_base_dev vardecl_lirc_dev.c 0 35907 NULL
 right_vardecl_matroxfb_base_c_35916_fields right vardecl_matroxfb_base.c 0 35916 NULL
 softback_end_vardecl_fbcon_c_35923_fields softback_end vardecl_fbcon.c 0 35923 NULL
+n_algs_wmfw_adsp1_id_hdr_35926_fields n_algs wmfw_adsp1_id_hdr 0 35926 NULL
 ieee802154_hdr_minlen_fndecl_35927_fields ieee802154_hdr_minlen fndecl 0 35927 NULL
 drm_rect_calc_vscale_fndecl_35928_fields drm_rect_calc_vscale fndecl 0 35928 NULL
 bytes_written_cq_fcp_rq_desc_35931_fields bytes_written cq_fcp_rq_desc 0 35931 NULL
@@ -8978,6 +9122,7 @@ vm_mmap_fndecl_36168_fields vm_mmap fndecl 3-0 36168 NULL
 qd2offset_fndecl_36177_fields qd2offset fndecl 0 36177 NULL nohasharray
 member_cnt_tipc_mon_domain_36177_fields member_cnt tipc_mon_domain 0 36177 &qd2offset_fndecl_36177_fields
 length_octeon_droq_info_36178_fields length octeon_droq_info 0 36178 NULL
+nr_ion_platform_data_36179_fields nr ion_platform_data 0 36179 NULL
 i915_gem_get_ggtt_size_fndecl_36180_fields i915_gem_get_ggtt_size fndecl 0-2 36180 NULL
 len_ib_ucm_mra_36185_fields len ib_ucm_mra 0 36185 NULL
 flash_size_jffs2_sb_info_36187_fields flash_size jffs2_sb_info 0 36187 NULL
@@ -9018,7 +9163,8 @@ fat_dump_len_be_adapter_36296_fields fat_dump_len be_adapter 0 36296 NULL
 mru_ovs_skb_cb_36300_fields mru ovs_skb_cb 0 36300 NULL
 command_size_drm_vmw_execbuf_arg_36305_fields command_size drm_vmw_execbuf_arg 0 36305 NULL
 size_kernfs_elem_attr_36307_fields size kernfs_elem_attr 0 36307 NULL
-snd_dma_alloc_pages_fndecl_36308_fields snd_dma_alloc_pages fndecl 3 36308 NULL
+snd_dma_alloc_pages_fndecl_36308_fields snd_dma_alloc_pages fndecl 3 36308 NULL nohasharray
+len_etd_priv_36308_fields len etd_priv 0 36308 &snd_dma_alloc_pages_fndecl_36308_fields
 max_transfer_snd_usb_midi_out_endpoint_36311_fields max_transfer snd_usb_midi_out_endpoint 0 36311 NULL
 chunk_size_mdp_superblock_s_36313_fields chunk_size mdp_superblock_s 0 36313 NULL
 dpdData_size_wsm_configuration_36315_fields dpdData_size wsm_configuration 0 36315 NULL
@@ -9119,6 +9265,7 @@ __kfifo_dma_in_prepare_r_fndecl_36659_fields __kfifo_dma_in_prepare_r fndecl 4-5
 shmem_alloc_page_fndecl_36659_fields shmem_alloc_page fndecl 3 36659 &__kfifo_dma_in_prepare_r_fndecl_36659_fields
 __tty_alloc_driver_fndecl_36660_fields __tty_alloc_driver fndecl 1 36660 NULL
 dac_channels_mixer_oxygen_model_36662_fields dac_channels_mixer oxygen_model 0 36662 NULL
+regmap_raw_write_fndecl_36664_fields regmap_raw_write fndecl 0 36664 NULL
 i_file_acl_lo_ext4_inode_36684_fields i_file_acl_lo ext4_inode 0 36684 NULL
 size_drm_map_36685_fields size drm_map 0 36685 NULL
 size_drm_agp_buffer_36687_fields size drm_agp_buffer 0 36687 NULL
@@ -9148,6 +9295,7 @@ sector_stripe_head_36797_fields sector stripe_head 0 36797 NULL
 v4l_bufsize_vardecl_36803_fields v4l_bufsize vardecl 0 36803 NULL
 idetape_chrdev_write_fndecl_36811_fields idetape_chrdev_write fndecl 3 36811 NULL
 mthca_reg_user_mr_fndecl_36815_fields mthca_reg_user_mr fndecl 3-2 36815 NULL
+size_drm_armada_gem_pwrite_36816_fields size drm_armada_gem_pwrite 0 36816 NULL
 mthca_setup_cmd_doorbells_fndecl_36817_fields mthca_setup_cmd_doorbells fndecl 2 36817 NULL
 card_type_nozomi_36822_fields card_type nozomi 0 36822 NULL
 ir_pre_altera_jtag_36823_fields ir_pre altera_jtag 0 36823 NULL
@@ -9181,6 +9329,7 @@ reserved_kmem_cache_36976_fields reserved kmem_cache 0 36976 NULL
 rx_bufsize_ath_common_36977_fields rx_bufsize ath_common 0 36977 NULL
 usbvision_frames_alloc_fndecl_36983_fields usbvision_frames_alloc fndecl 0-2 36983 NULL
 v_sync_strt_wid_aty128_crtc_36987_fields v_sync_strt_wid aty128_crtc 0 36987 NULL
+size_gb_audio_get_topology_size_response_36992_fields size gb_audio_get_topology_size_response 0 36992 NULL
 lbmAllocate_fndecl_36995_fields lbmAllocate fndecl 2 36995 NULL
 exp_len_ccp_rsa_engine_36998_fields exp_len ccp_rsa_engine 0 36998 NULL
 fp_num_tx_qede_dev_37007_fields fp_num_tx qede_dev 0 37007 NULL
@@ -9272,7 +9421,8 @@ rc_len_whcrc_37363_fields rc_len whcrc 0 37363 NULL
 gsm_change_mtu_fndecl_37364_fields gsm_change_mtu fndecl 2 37364 NULL
 alauda_read_data_fndecl_37367_fields alauda_read_data fndecl 3-2 37367 NULL
 peer_addr_len_drbd_connection_37371_fields peer_addr_len drbd_connection 0 37371 NULL
-virtscsi_add_cmd_fndecl_37379_fields virtscsi_add_cmd fndecl 3-4 37379 NULL
+virtscsi_add_cmd_fndecl_37379_fields virtscsi_add_cmd fndecl 3-4 37379 NULL nohasharray
+size_list_size_vc4_bo_cache_37379_fields size_list_size vc4_bo_cache 0 37379 &virtscsi_add_cmd_fndecl_37379_fields
 gotoxay_fndecl_37380_fields gotoxay fndecl 2-3 37380 NULL
 nvkm_ramht_new_fndecl_37381_fields nvkm_ramht_new fndecl 2 37381 NULL
 size_pnp_mem_37384_fields size pnp_mem 0 37384 NULL
@@ -9304,6 +9454,7 @@ ks8851_rdfifo_fndecl_37510_fields ks8851_rdfifo fndecl 3 37510 NULL
 inode_newsize_ok_fndecl_37511_fields inode_newsize_ok fndecl 0-2 37511 NULL
 etherMtu_mac_eeprom_port_cfg_37523_fields etherMtu_mac eeprom_port_cfg 0 37523 NULL nohasharray
 __data_len_request_37523_fields __data_len request 0 37523 &etherMtu_mac_eeprom_port_cfg_37523_fields
+line_max_gb_gpio_controller_37526_fields line_max gb_gpio_controller 0 37526 NULL
 efx_realloc_channels_fndecl_37528_fields efx_realloc_channels fndecl 2-3 37528 NULL
 num_txd_netxen_adapter_37529_fields num_txd netxen_adapter 0 37529 NULL
 ieee80211_bss_info_update_fndecl_37537_fields ieee80211_bss_info_update fndecl 4 37537 NULL
@@ -9333,8 +9484,10 @@ lsave_sz_ubifs_info_37672_fields lsave_sz ubifs_info 0 37672 NULL
 len_ethtool_eeprom_37676_fields len ethtool_eeprom 0 37676 NULL
 eeprom_blob_size_iwl_priv_37680_fields eeprom_blob_size iwl_priv 0 37680 NULL
 lastextent_efs_inode_info_37681_fields lastextent efs_inode_info 0 37681 NULL
+zm_wmfw_adsp2_alg_hdr_37694_fields zm wmfw_adsp2_alg_hdr 0 37694 NULL
 usb_ftdi_elan_edset_setup_fndecl_37695_fields usb_ftdi_elan_edset_setup fndecl 0 37695 NULL
 orig_video_points_screen_info_37702_fields orig_video_points screen_info 0 37702 NULL
+num_tx_ring_sh_eth_private_37717_fields num_tx_ring sh_eth_private 0 37717 NULL
 regset_tls_get_fndecl_37721_fields regset_tls_get fndecl 3 37721 NULL
 zap_bt_entries_mapping_fndecl_37722_fields zap_bt_entries_mapping fndecl 3-4-2 37722 NULL
 bfad_debugfs_lseek_fndecl_37724_fields bfad_debugfs_lseek fndecl 2 37724 NULL
@@ -9344,6 +9497,7 @@ sk_wmem_queued_sock_37733_fields sk_wmem_queued sock 0 37733 NULL
 ieee80211_aes_gcm_encrypt_fndecl_37737_fields ieee80211_aes_gcm_encrypt fndecl 5 37737 NULL
 len_cap_mon_bin_hdr_37739_fields len_cap mon_bin_hdr 0 37739 NULL
 cryptlen_skcipher_request_37750_fields cryptlen skcipher_request 0 37750 NULL
+num_enh_eq_cfgs_wm8994_pdata_37752_fields num_enh_eq_cfgs wm8994_pdata 0 37752 NULL
 vmw_kms_ldu_do_dmabuf_dirty_fndecl_37757_fields vmw_kms_ldu_do_dmabuf_dirty fndecl 6 37757 NULL
 ath6kl_dbg_dump_fndecl_37760_fields ath6kl_dbg_dump fndecl 5 37760 NULL
 length_acpi_object_buffer_37768_fields length acpi_object_buffer 0 37768 NULL
@@ -9383,6 +9537,7 @@ xfs_buf_get_uncached_fndecl_37894_fields xfs_buf_get_uncached fndecl 2 37894 NUL
 bulk_in_ipheth_device_37894_fields bulk_in ipheth_device 0 37894 &xfs_buf_get_uncached_fndecl_37894_fields
 prod_xfs_alloc_arg_37897_fields prod xfs_alloc_arg 0 37897 NULL
 calc_send_wqe_fndecl_37899_fields calc_send_wqe fndecl 0 37899 NULL
+vc4_get_cache_list_for_size_fndecl_37902_fields vc4_get_cache_list_for_size fndecl 2 37902 NULL
 datalen_user_key_payload_37906_fields datalen user_key_payload 0 37906 NULL
 pasid_kfd_process_37907_fields pasid kfd_process 0 37907 NULL
 mlx5_set_port_qetcr_reg_fndecl_37932_fields mlx5_set_port_qetcr_reg fndecl 3 37932 NULL
@@ -9481,6 +9636,7 @@ ftid_base_tid_info_38313_fields ftid_base tid_info 0 38313 NULL
 __bestmult_fndecl_38314_fields __bestmult fndecl 2 38314 NULL
 t37_nodes_mxt_dbg_38317_fields t37_nodes mxt_dbg 0 38317 NULL
 nr_siblings_perf_event_38320_fields nr_siblings perf_event 0 38320 NULL
+shader_rec_count_drm_vc4_submit_cl_38324_fields shader_rec_count drm_vc4_submit_cl 0 38324 NULL
 raydium_i2c_read_fndecl_38332_fields raydium_i2c_read fndecl 4 38332 NULL
 ext_lfb_base_screen_info_38337_fields ext_lfb_base screen_info 0 38337 NULL nohasharray
 iov_len_sg_iovec_38337_fields iov_len sg_iovec 0 38337 &ext_lfb_base_screen_info_38337_fields
@@ -9494,6 +9650,7 @@ xfs_dir3_free_get_buf_fndecl_38355_fields xfs_dir3_free_get_buf fndecl 2 38355 N
 rate_snd_soc_dai_38358_fields rate snd_soc_dai 0 38358 NULL
 pci_sriov_resource_alignment_fndecl_38365_fields pci_sriov_resource_alignment fndecl 0 38365 NULL
 flush_buffer_fndecl_38367_fields flush_buffer fndecl 2 38367 NULL
+ri_length_gfs2_rindex_38375_fields ri_length gfs2_rindex 0 38375 NULL
 wsm_handle_exception_fndecl_38377_fields wsm_handle_exception fndecl 3 38377 NULL
 options_len_ip_tunnel_info_38380_fields options_len ip_tunnel_info 0 38380 NULL nohasharray
 offset_ttm_buffer_object_38380_fields offset ttm_buffer_object 0 38380 &options_len_ip_tunnel_info_38380_fields
@@ -9612,6 +9769,7 @@ vlan_tci_sk_buff_38825_fields vlan_tci sk_buff 0 38825 NULL
 algorithm_r5conf_38831_fields algorithm r5conf 0 38831 NULL
 memblock_alloc_fndecl_38847_fields memblock_alloc fndecl 2-1-0 38847 NULL
 datablob_len_encrypted_key_payload_38850_fields datablob_len encrypted_key_payload 0 38850 NULL
+srs_nslot_sptlrpc_rule_set_38854_fields srs_nslot sptlrpc_rule_set 0 38854 NULL
 srp_map_sg_dma_fndecl_38856_fields srp_map_sg_dma fndecl 0 38856 NULL
 count_ixgbevf_ring_38867_fields count ixgbevf_ring 0 38867 NULL
 sectors_per_track_mspro_devinfo_38870_fields sectors_per_track mspro_devinfo 0 38870 NULL
@@ -9772,6 +9930,7 @@ tx_count_ethtool_channels_39384_fields tx_count ethtool_channels 0 39384 &from_o
 lfb_depth_screen_info_39385_fields lfb_depth screen_info 0 39385 NULL
 read16_ssb_bus_ops_39388_fields read16 ssb_bus_ops 0 39388 NULL
 round_rate_clk_ops_39390_fields round_rate clk_ops 0 39390 NULL
+pf_cids_qed_tm_iids_39393_fields pf_cids qed_tm_iids 0 39393 NULL
 __page_set_anon_rmap_fndecl_39401_fields __page_set_anon_rmap fndecl 3 39401 NULL
 userptr_radeon_ttm_tt_39408_fields userptr radeon_ttm_tt 0 39408 NULL
 total_vfs_fm10k_iov_info_39412_fields total_vfs fm10k_iov_info 0 39412 NULL
@@ -9803,6 +9962,7 @@ max_count_octeon_droq_39475_fields max_count octeon_droq 0 39475 NULL
 address_length_acpi_resource_fixed_memory32_39483_fields address_length acpi_resource_fixed_memory32 0 39483 NULL
 iov_iter_bvec_fndecl_39493_fields iov_iter_bvec fndecl 5 39493 NULL
 network_header_len_dwceqos_tx_39500_fields network_header_len dwceqos_tx 0 39500 NULL
+gb_operation_message_init_fndecl_39512_fields gb_operation_message_init fndecl 4 39512 NULL
 ppp_read_fndecl_39514_fields ppp_read fndecl 3 39514 NULL
 ceph_osdc_call_fndecl_39526_fields ceph_osdc_call fndecl 8 39526 NULL
 txsize_grcan_device_config_39527_fields txsize grcan_device_config 0 39527 NULL nohasharray
@@ -9852,6 +10012,7 @@ rdma_read_chunk_frmr_fndecl_39676_fields rdma_read_chunk_frmr fndecl 7 39676 NUL
 priv_size_Qdisc_ops_39692_fields priv_size Qdisc_ops 0 39692 NULL nohasharray
 fd_block_size_fd_dev_39692_fields fd_block_size fd_dev 0 39692 &priv_size_Qdisc_ops_39692_fields
 length_rvt_swqe_39694_fields length rvt_swqe 0 39694 NULL
+nb_ace_cci_nb_ports_39699_fields nb_ace cci_nb_ports 0 39699 NULL
 badblockpos_nand_chip_39700_fields badblockpos nand_chip 0 39700 NULL
 tid_ieee80211_ra_tid_39703_fields tid ieee80211_ra_tid 0 39703 NULL
 xfs_growfs_get_hdr_buf_fndecl_39706_fields xfs_growfs_get_hdr_buf fndecl 2-3 39706 NULL
@@ -9974,6 +10135,7 @@ pvr2_ctrl_get_min_fndecl_40204_fields pvr2_ctrl_get_min fndecl 0 40204 NULL
 num_amgms_mlx4_caps_40207_fields num_amgms mlx4_caps 0 40207 NULL
 ipwireless_tty_received_fndecl_40209_fields ipwireless_tty_received fndecl 3 40209 NULL
 kbuf_alloc_2_sgl_fndecl_40216_fields kbuf_alloc_2_sgl fndecl 1 40216 NULL
+len_p80211ioctl_req_40220_fields len p80211ioctl_req 0 40220 NULL
 bochs_bo_create_fndecl_40223_fields bochs_bo_create fndecl 2 40223 NULL
 size_fuse_getxattr_out_40231_fields size fuse_getxattr_out 0 40231 NULL
 do_jffs2_getxattr_fndecl_40233_fields do_jffs2_getxattr fndecl 0 40233 NULL
@@ -10004,6 +10166,7 @@ reg_list_format_size_bytes_rlc_firmware_header_v2_0_40357_fields reg_list_format
 cblock_dm_cache_migration_40361_fields cblock dm_cache_migration 0 40361 NULL
 cfpkt_setlen_fndecl_40364_fields cfpkt_setlen fndecl 2 40364 NULL nohasharray
 max_wrs_rds_ib_device_40364_fields max_wrs rds_ib_device 0 40364 &cfpkt_setlen_fndecl_40364_fields
+len_raw_data_40368_fields len raw_data 0 40368 NULL
 align_kmem_cache_40377_fields align kmem_cache 0 40377 NULL
 cfg0_size_pcie_port_40380_fields cfg0_size pcie_port 0 40380 NULL
 ilm_len_mt76_fw_header_40389_fields ilm_len mt76_fw_header 0 40389 NULL
@@ -10012,6 +10175,7 @@ file_secno_bplus_leaf_node_40394_fields file_secno bplus_leaf_node 0 40394 NULL
 sb_root_hpfs_sb_info_40394_fields sb_root hpfs_sb_info 0 40394 &file_secno_bplus_leaf_node_40394_fields
 snd_ak4113_external_rate_fndecl_40404_fields snd_ak4113_external_rate fndecl 0 40404 NULL nohasharray
 max_scaled_height_bttv_crop_40404_fields max_scaled_height bttv_crop 0 40404 &snd_ak4113_external_rate_fndecl_40404_fields
+arm_clear_user_fndecl_40410_fields arm_clear_user fndecl 0 40410 NULL
 level3cnt_capi_register_params_40411_fields level3cnt capi_register_params 0 40411 NULL
 bulk_out_epnum_usb_cardstate_40412_fields bulk_out_epnum usb_cardstate 0 40412 NULL
 vm_end_vm_area_struct_40413_fields vm_end vm_area_struct 0 40413 NULL nohasharray
@@ -10088,7 +10252,8 @@ ctrl_out_pipe_hfcsusb_40706_fields ctrl_out_pipe hfcsusb 0 40706 NULL
 __x86_set_memory_region_fndecl_40708_fields __x86_set_memory_region fndecl 4 40708 NULL nohasharray
 nTxBlock_vardecl_jfs_txnmgr_c_40708_fields nTxBlock vardecl_jfs_txnmgr.c 0 40708 &__x86_set_memory_region_fndecl_40708_fields
 lfb_linelength_screen_info_40728_fields lfb_linelength screen_info 0 40728 NULL
-cryptlen_aead_request_40734_fields cryptlen aead_request 0 40734 NULL
+cryptlen_aead_request_40734_fields cryptlen aead_request 0 40734 NULL nohasharray
+page_order_ring_buffer_40734_fields page_order ring_buffer 0 40734 &cryptlen_aead_request_40734_fields
 NumberOfLogBlock_ms_lib_ctrl_40736_fields NumberOfLogBlock ms_lib_ctrl 0 40736 NULL
 do_splice_to_fndecl_40737_fields do_splice_to fndecl 0 40737 NULL
 sisfb_getheapstart_fndecl_40740_fields sisfb_getheapstart fndecl 0 40740 NULL nohasharray
@@ -10140,6 +10305,7 @@ fuse_send_write_fndecl_40936_fields fuse_send_write fndecl 0-4 40936 NULL
 len_set_config_param_40942_fields len set_config_param 0 40942 NULL
 s_log_groups_per_flex_ext4_sb_info_40945_fields s_log_groups_per_flex ext4_sb_info 0 40945 NULL
 az6007_write_fndecl_40948_fields az6007_write fndecl 6 40948 NULL
+srq_count_qed_cxt_mngr_40961_fields srq_count qed_cxt_mngr 0 40961 NULL
 ext4_fill_fiemap_extents_fndecl_40966_fields ext4_fill_fiemap_extents fndecl 2-3 40966 NULL
 bottom_qxl_urect_40968_fields bottom qxl_urect 0 40968 NULL
 arena_read_bytes_fndecl_40973_fields arena_read_bytes fndecl 0 40973 NULL
@@ -10216,6 +10382,7 @@ block_start_extent_map_41316_fields block_start extent_map 0 41316 &cma_declare_
 pc_len_s_pcon_41324_fields pc_len s_pcon 0 41324 NULL
 max_fcoe_exchanges_cnic_dev_41335_fields max_fcoe_exchanges cnic_dev 0 41335 NULL
 last_alloc_physical_block_ext2_block_alloc_info_41336_fields last_alloc_physical_block ext2_block_alloc_info 0 41336 NULL
+size_gb_loopback_41339_fields size gb_loopback 0 41339 NULL
 sc_max_req_size_svcxprt_rdma_41343_fields sc_max_req_size svcxprt_rdma 0 41343 NULL
 key_len_wmi_vdev_install_key_arg_41347_fields key_len wmi_vdev_install_key_arg 0 41347 NULL
 ocfs2_read_xattr_block_fndecl_41350_fields ocfs2_read_xattr_block fndecl 0-2 41350 NULL nohasharray
@@ -10239,6 +10406,7 @@ l1_size_vardecl_acpi_extlog_c_41440_fields l1_size vardecl_acpi_extlog.c 0 41440
 vram_remap_vardecl_vesafb_c_41441_fields vram_remap vardecl_vesafb.c 0 41441 NULL
 onenand_write_oob_nolock_fndecl_41451_fields onenand_write_oob_nolock fndecl 2 41451 NULL
 rf_blkno_ocfs2_refcount_tree_41452_fields rf_blkno ocfs2_refcount_tree 0 41452 NULL
+dm_wmfw_adsp1_alg_hdr_41454_fields dm wmfw_adsp1_alg_hdr 0 41454 NULL
 s_inodes_per_block_ext4_sb_info_41457_fields s_inodes_per_block ext4_sb_info 0 41457 NULL nohasharray
 mem_lseek_fndecl_41457_fields mem_lseek fndecl 2 41457 &s_inodes_per_block_ext4_sb_info_41457_fields
 cxgbi_ddp_reserve_fndecl_41468_fields cxgbi_ddp_reserve fndecl 4 41468 NULL nohasharray
@@ -10323,6 +10491,7 @@ sisusb_num_columns_sisusb_usb_data_41814_fields sisusb_num_columns sisusb_usb_da
 nports_cxgb4_lld_info_41815_fields nports cxgb4_lld_info 0 41815 NULL
 vmw_cmdbuf_alloc_space_fndecl_41823_fields vmw_cmdbuf_alloc_space fndecl 3 41823 NULL
 n_ssids_wmi_start_scan_arg_41826_fields n_ssids wmi_start_scan_arg 0 41826 NULL
+data_end_flat_hdr_41827_fields data_end flat_hdr 0 41827 NULL
 fcs_del_mlx4_en_rx_ring_41830_fields fcs_del mlx4_en_rx_ring 0 41830 NULL
 convert_initialized_extent_fndecl_41833_fields convert_initialized_extent fndecl 0-5 41833 NULL
 wdt87xx_get_string_fndecl_41835_fields wdt87xx_get_string fndecl 4 41835 NULL
@@ -10347,7 +10516,8 @@ mem_unit_sysinfo_41901_fields mem_unit sysinfo 0 41901 NULL
 length_zoran_sync_41909_fields length zoran_sync 0 41909 NULL
 raw_decoder_line_size_vbi_info_41920_fields raw_decoder_line_size vbi_info 0 41920 NULL
 ext4_xattr_security_set_fndecl_41924_fields ext4_xattr_security_set fndecl 6 41924 NULL nohasharray
-wil_pmc_llseek_fndecl_41924_fields wil_pmc_llseek fndecl 2 41924 &ext4_xattr_security_set_fndecl_41924_fields
+wil_pmc_llseek_fndecl_41924_fields wil_pmc_llseek fndecl 2 41924 &ext4_xattr_security_set_fndecl_41924_fields nohasharray
+num_descriptors_wmi_p2p_noa_info_41924_fields num_descriptors wmi_p2p_noa_info 0 41924 &wil_pmc_llseek_fndecl_41924_fields
 regmap_encx24j600_sfr_read_fndecl_41930_fields regmap_encx24j600_sfr_read fndecl 4 41930 NULL
 whci_n_caps_fndecl_41932_fields whci_n_caps fndecl 0 41932 NULL
 ss_nblocks_nilfs_segment_summary_41935_fields ss_nblocks nilfs_segment_summary 0 41935 NULL
@@ -10428,6 +10598,7 @@ nr_map_efi_memory_map_42232_fields nr_map efi_memory_map 0 42232 NULL
 chunksize_mdp_superblock_1_42236_fields chunksize mdp_superblock_1 0 42236 NULL nohasharray
 max_data_size_irda_sock_42236_fields max_data_size irda_sock 0 42236 &chunksize_mdp_superblock_1_42236_fields
 scrollback_phys_max_vardecl_fbcon_c_42241_fields scrollback_phys_max vardecl_fbcon.c 0 42241 NULL
+buf_write_ptr_comedi_async_42247_fields buf_write_ptr comedi_async 0 42247 NULL
 if_sdio_read_scratch_fndecl_42279_fields if_sdio_read_scratch fndecl 0 42279 NULL
 rx_pending_ethtool_ringparam_42280_fields rx_pending ethtool_ringparam 0 42280 NULL nohasharray
 cfg_sriov_nr_virtfn_lpfc_hba_42280_fields cfg_sriov_nr_virtfn lpfc_hba 0 42280 &rx_pending_ethtool_ringparam_42280_fields
@@ -10451,8 +10622,10 @@ acc_len_rcv_sli3_42370_fields acc_len rcv_sli3 0 42370 NULL
 keyspan_pda_setbaud_fndecl_42374_fields keyspan_pda_setbaud fndecl 0-2 42374 NULL
 ext4_ext_get_access_fndecl_42377_fields ext4_ext_get_access fndecl 0 42377 NULL
 placement_offset_bnx2x_agg_info_42380_fields placement_offset bnx2x_agg_info 0 42380 NULL
+num_srqs_qed_rdma_pf_params_42382_fields num_srqs qed_rdma_pf_params 0 42382 NULL
 __spi_validate_fndecl_42385_fields __spi_validate fndecl 0 42385 NULL
 remote_payload_max_nfc_digital_dev_42391_fields remote_payload_max nfc_digital_dev 0 42391 NULL
+channel_count_gb_lights_get_light_config_response_42395_fields channel_count gb_lights_get_light_config_response 0 42395 NULL
 no_of_vpath_vxgedev_42396_fields no_of_vpath vxgedev 0 42396 NULL
 module_alloc_fndecl_42397_fields module_alloc fndecl 1 42397 NULL
 xen_blkif_max_queues_vardecl_xen_blkfront_c_42404_fields xen_blkif_max_queues vardecl_xen-blkfront.c 0 42404 NULL
@@ -10524,7 +10697,8 @@ dm_set_device_limits_fndecl_42632_fields dm_set_device_limits fndecl 3 42632 NUL
 lbs_cmd_async_fndecl_42634_fields lbs_cmd_async fndecl 4 42634 NULL
 valid_ide_tape_obj_42635_fields valid ide_tape_obj 0 42635 NULL
 find_rsb_dir_fndecl_42636_fields find_rsb_dir fndecl 3 42636 NULL
-snd_emu10k1_create_fndecl_42637_fields snd_emu10k1_create fndecl 5 42637 NULL
+snd_emu10k1_create_fndecl_42637_fields snd_emu10k1_create fndecl 5 42637 NULL nohasharray
+n_algs_wmfw_adsp2_id_hdr_42637_fields n_algs wmfw_adsp2_id_hdr 0 42637 &snd_emu10k1_create_fndecl_42637_fields
 len_ceph_string_42640_fields len ceph_string 0 42640 NULL
 brcmf_sdio_download_nvram_fndecl_42648_fields brcmf_sdio_download_nvram fndecl 3 42648 NULL
 fuse_getxattr_fndecl_42649_fields fuse_getxattr fndecl 0-4 42649 NULL
@@ -10539,7 +10713,8 @@ ext4_trim_extent_fndecl_42684_fields ext4_trim_extent fndecl 3-4-2-0 42684 NULL
 n_sections_pefile_context_42684_fields n_sections pefile_context 0 42684 &ext4_trim_extent_fndecl_42684_fields
 BufferLength_respQ_e_42691_fields BufferLength respQ_e 0 42691 NULL
 base_baud_pciserial_board_42697_fields base_baud pciserial_board 0 42697 NULL
-nvme_submit_user_cmd_fndecl_42701_fields nvme_submit_user_cmd fndecl 4 42701 NULL
+nvme_submit_user_cmd_fndecl_42701_fields nvme_submit_user_cmd fndecl 4 42701 NULL nohasharray
+vm_map_ram_fndecl_42701_fields vm_map_ram fndecl 2 42701 &nvme_submit_user_cmd_fndecl_42701_fields
 nvme_rdma_create_qp_fndecl_42709_fields nvme_rdma_create_qp fndecl 2 42709 NULL
 len_nfs4_layoutdriver_data_42714_fields len nfs4_layoutdriver_data 0 42714 NULL nohasharray
 reordering_tcp_sock_42714_fields reordering tcp_sock 0 42714 &len_nfs4_layoutdriver_data_42714_fields
@@ -10567,6 +10742,7 @@ cmd_idx_rtsx_ucr_42770_fields cmd_idx rtsx_ucr 0 42770 &ie_len_wmi_start_scan_ar
 fw_len_mwifiex_fw_image_42772_fields fw_len mwifiex_fw_image 0 42772 NULL
 sync_maxlen_ipvs_sync_daemon_cfg_42773_fields sync_maxlen ipvs_sync_daemon_cfg 0 42773 NULL
 hsr_get_max_mtu_fndecl_42776_fields hsr_get_max_mtu fndecl 0 42776 NULL
+lov_tgt_size_lov_obd_42782_fields lov_tgt_size lov_obd 0 42782 NULL
 rx_data_length_hso_serial_42783_fields rx_data_length hso_serial 0 42783 NULL
 usbnet_change_mtu_fndecl_42784_fields usbnet_change_mtu fndecl 2 42784 NULL
 offset_fuse_page_desc_42785_fields offset fuse_page_desc 0 42785 NULL
@@ -10596,6 +10772,7 @@ lineevent_read_fndecl_42885_fields lineevent_read fndecl 3 42885 NULL
 snic_req_init_fndecl_42890_fields snic_req_init fndecl 2 42890 NULL
 pixel_overlap_mipi_config_42900_fields pixel_overlap mipi_config 0 42900 NULL
 memblock_find_in_range_node_fndecl_42905_fields memblock_find_in_range_node fndecl 0-2-1-3-4 42905 NULL
+name_length_spar_controlvm_parameters_header_42909_fields name_length spar_controlvm_parameters_header 0 42909 NULL
 vd_vblocknr_nilfs_vdesc_42910_fields vd_vblocknr nilfs_vdesc 0 42910 NULL
 rts51x_bulk_transport_fndecl_42911_fields rts51x_bulk_transport fndecl 6 42911 NULL
 xfs_rmap_alloc_extent_fndecl_42916_fields xfs_rmap_alloc_extent fndecl 4-3-5 42916 NULL
@@ -10616,6 +10793,7 @@ udf_get_block_fndecl_42965_fields udf_get_block fndecl 2 42965 &gpio_count_async
 __pskb_copy_fclone_fndecl_42969_fields __pskb_copy_fclone fndecl 2 42969 NULL
 periods_max_snd_pcm_hardware_42979_fields periods_max snd_pcm_hardware 0 42979 NULL
 brcmf_sdiod_send_buf_fndecl_42982_fields brcmf_sdiod_send_buf fndecl 3 42982 NULL
+max_pfn_amdgpu_vm_manager_42989_fields max_pfn amdgpu_vm_manager 0 42989 NULL
 len_kvaser_msg_42994_fields len kvaser_msg 0 42994 NULL
 num_mappings_nd_region_desc_42998_fields num_mappings nd_region_desc 0 42998 NULL
 buf_size_ivtv_stream_43002_fields buf_size ivtv_stream 0 43002 NULL
@@ -10643,6 +10821,7 @@ s_reserved_gdt_blocks_ext4_super_block_43054_fields s_reserved_gdt_blocks ext4_s
 acpi_dev_get_ioresource_fndecl_43062_fields acpi_dev_get_ioresource fndecl 3-2 43062 NULL
 tcp_tso_segs_fndecl_43064_fields tcp_tso_segs fndecl 0-2 43064 NULL nohasharray
 len_ib_ucm_rep_43064_fields len ib_ucm_rep 0 43064 &tcp_tso_segs_fndecl_43064_fields
+len_srp_direct_buf_43066_fields len srp_direct_buf 0 43066 NULL
 fat_fallocate_fndecl_43080_fields fat_fallocate fndecl 4-3 43080 NULL
 raw_skid_size_pkcs7_parse_context_43081_fields raw_skid_size pkcs7_parse_context 0 43081 NULL
 bttv_prepare_buffer_fndecl_43088_fields bttv_prepare_buffer fndecl 6-5 43088 NULL
@@ -10732,6 +10911,7 @@ XRES_kyrofb_info_43436_fields XRES kyrofb_info 0 43436 NULL
 memblock_alloc_nid_fndecl_43439_fields memblock_alloc_nid fndecl 2-1 43439 NULL
 ems_pcmcia_add_card_fndecl_43440_fields ems_pcmcia_add_card fndecl 2 43440 NULL
 per_txdl_space_vxge_hw_fifo_attr_43441_fields per_txdl_space vxge_hw_fifo_attr 0 43441 NULL
+len_imgchunk_43445_fields len imgchunk 0 43445 NULL
 max_pkt_tipc_sock_43446_fields max_pkt tipc_sock 0 43446 NULL
 wReportDescLength_i2c_hid_desc_43447_fields wReportDescLength i2c_hid_desc 0 43447 NULL
 vfs_fsync_range_fndecl_43448_fields vfs_fsync_range fndecl 0 43448 NULL
@@ -10842,7 +11022,8 @@ unlink1_fndecl_43840_fields unlink1 fndecl 2-3 43840 NULL
 ath6kl_wmi_enable_sched_scan_cmd_fndecl_43841_fields ath6kl_wmi_enable_sched_scan_cmd fndecl 2 43841 NULL
 initrd_start_vardecl_43848_fields initrd_start vardecl 0 43848 NULL
 xen_set_nslabs_fndecl_43849_fields xen_set_nslabs fndecl 0-1 43849 NULL
-wlcore_scan_fndecl_43850_fields wlcore_scan fndecl 4 43850 NULL
+wlcore_scan_fndecl_43850_fields wlcore_scan fndecl 4 43850 NULL nohasharray
+wm_adsp_read_data_block_fndecl_43850_fields wm_adsp_read_data_block fndecl 0 43850 &wlcore_scan_fndecl_43850_fields
 indat_endpoint_keyspan_device_details_43860_fields indat_endpoint keyspan_device_details 0 43860 NULL
 s_l2bsize_jfs_superblock_43870_fields s_l2bsize jfs_superblock 0 43870 NULL
 bulk_in_endpointAddr_hdpvr_device_43874_fields bulk_in_endpointAddr hdpvr_device 0 43874 NULL
@@ -10873,6 +11054,7 @@ dce_pvc_count_frad_state_43946_fields dce_pvc_count frad_state 0 43946 NULL
 sddr09_readX_fndecl_43951_fields sddr09_readX fndecl 5 43951 NULL
 brcmf_fil_cmd_data_set_fndecl_43952_fields brcmf_fil_cmd_data_set fndecl 4 43952 NULL
 size_soundfont_sample_info_43957_fields size soundfont_sample_info 0 43957 NULL
+num_drc_cfgs_wm8904_pdata_43963_fields num_drc_cfgs wm8904_pdata 0 43963 NULL
 rx_ring_count_igb_adapter_43964_fields rx_ring_count igb_adapter 0 43964 NULL
 s_firstdatazone_isofs_sb_info_43968_fields s_firstdatazone isofs_sb_info 0 43968 NULL
 csum_start_virtio_net_hdr_43969_fields csum_start virtio_net_hdr 0 43969 NULL
@@ -10904,6 +11086,7 @@ max_rdma_ctxs_ib_qp_cap_44123_fields max_rdma_ctxs ib_qp_cap 0 44123 NULL
 base_nforce2_smbus_44136_fields base nforce2_smbus 0 44136 NULL
 key_maxval_mcs_platform_data_44139_fields key_maxval mcs_platform_data 0 44139 NULL
 submit_extent_page_fndecl_44155_fields submit_extent_page fndecl 7-8-6 44155 NULL
+gb_operation_sync_timeout_fndecl_44156_fields gb_operation_sync_timeout fndecl 6 44156 NULL
 octeon_setup_droq_fndecl_44160_fields octeon_setup_droq fndecl 4-3 44160 NULL
 recvmsg_proto_ops_44163_fields recvmsg proto_ops 0 44163 NULL
 y_len_ccp_ecc_point_44168_fields y_len ccp_ecc_point 0 44168 NULL
@@ -10944,6 +11127,7 @@ rq_num_entries_c4iw_qp_attributes_44321_fields rq_num_entries c4iw_qp_attributes
 produce_size_qp_entry_44325_fields produce_size qp_entry 0 44325 NULL
 encode_op_hdr_fndecl_44327_fields encode_op_hdr fndecl 3 44327 NULL
 size_drm_radeon_gem_userptr_44334_fields size drm_radeon_gem_userptr 0 44334 NULL
+arm_copy_from_user_fndecl_44337_fields arm_copy_from_user fndecl 0 44337 NULL
 tail_circ_buf_44346_fields tail circ_buf 0 44346 NULL nohasharray
 count_v4l2_ext_controls_44346_fields count v4l2_ext_controls 0 44346 &tail_circ_buf_44346_fields
 brcmf_sdio_txpkt_prep_sg_fndecl_44354_fields brcmf_sdio_txpkt_prep_sg fndecl 4-0 44354 NULL
@@ -11082,6 +11266,7 @@ h4_recv_fndecl_44866_fields h4_recv fndecl 3 44866 &crypt_extent_fndecl_44866_fi
 alloc_rc_map_44870_fields alloc rc_map 0 44870 NULL
 romfs_blk_read_fndecl_44875_fields romfs_blk_read fndecl 4-2 44875 NULL
 ppp_tx_cp_fndecl_44879_fields ppp_tx_cp fndecl 5-2 44879 NULL
+num_resources_platform_device_44886_fields num_resources platform_device 0 44886 NULL
 __cookie_v4_check_fndecl_44887_fields __cookie_v4_check fndecl 0 44887 NULL nohasharray
 jffs2_do_unlink_fndecl_44887_fields jffs2_do_unlink fndecl 4 44887 &__cookie_v4_check_fndecl_44887_fields
 code_length_lirc_driver_44888_fields code_length lirc_driver 0 44888 NULL
@@ -11182,6 +11367,7 @@ base_erst_erange_45255_fields base erst_erange 0 45255 NULL
 rpcrdma_count_chunks_fndecl_45258_fields rpcrdma_count_chunks fndecl 0 45258 NULL
 nameLen_nw_info_struct_45260_fields nameLen nw_info_struct 0 45260 NULL
 check_sectors_in_chain_fndecl_45261_fields check_sectors_in_chain fndecl 2 45261 NULL
+num_rx_ring_sh_eth_private_45262_fields num_rx_ring sh_eth_private 0 45262 NULL
 alloc_buf_fndecl_45267_fields alloc_buf fndecl 2 45267 NULL
 generic_writepages_fndecl_45268_fields generic_writepages fndecl 0 45268 NULL nohasharray
 vmw_dmabuf_init_fndecl_45268_fields vmw_dmabuf_init fndecl 3 45268 &generic_writepages_fndecl_45268_fields
@@ -11194,7 +11380,8 @@ rcvhdrcnt_qib_devdata_45297_fields rcvhdrcnt qib_devdata 0 45297 NULL
 rcvhdrcnt_vardecl_init_c_45302_fields rcvhdrcnt vardecl_init.c 0 45302 NULL
 hugetlbfs_read_actor_fndecl_45304_fields hugetlbfs_read_actor fndecl 0-4-2 45304 NULL
 atl1_change_mtu_fndecl_45313_fields atl1_change_mtu fndecl 2 45313 NULL nohasharray
-rx_count_ethtool_channels_45313_fields rx_count ethtool_channels 0 45313 &atl1_change_mtu_fndecl_45313_fields
+rx_count_ethtool_channels_45313_fields rx_count ethtool_channels 0 45313 &atl1_change_mtu_fndecl_45313_fields nohasharray
+rx_ring_count_xgbe_prv_data_45313_fields rx_ring_count xgbe_prv_data 0 45313 &rx_count_ethtool_channels_45313_fields
 tipc_buf_acquire_fndecl_45318_fields tipc_buf_acquire fndecl 1 45318 NULL
 rx_data_fndecl_45321_fields rx_data fndecl 4 45321 NULL
 fec_decode_bufs_fndecl_45322_fields fec_decode_bufs fndecl 3-5 45322 NULL nohasharray
@@ -11227,6 +11414,7 @@ qcaspi_netdev_change_mtu_fndecl_45450_fields qcaspi_netdev_change_mtu fndecl 2 4
 start_bdi_bd_transfer_45454_fields start_bdi bd_transfer 0 45454 NULL
 wTotalLength_usb_bos_descriptor_45455_fields wTotalLength usb_bos_descriptor 0 45455 NULL
 cfrfml_create_fndecl_45463_fields cfrfml_create fndecl 3 45463 NULL
+nents_sg_splitter_45469_fields nents sg_splitter 0 45469 NULL
 sockaddr_len_audit_context_45471_fields sockaddr_len audit_context 0 45471 NULL
 elf_load_addr_kimage_arch_45472_fields elf_load_addr kimage_arch 0 45472 NULL
 i_pos_fat_slot_info_45481_fields i_pos fat_slot_info 0 45481 NULL
@@ -11268,6 +11456,7 @@ tcfv_push_vid_tcf_vlan_45639_fields tcfv_push_vid tcf_vlan 0 45639 NULL
 ecc_strength_ds_nand_chip_45651_fields ecc_strength_ds nand_chip 0 45651 NULL
 inftl_writeblock_fndecl_45653_fields inftl_writeblock fndecl 2 45653 NULL
 size_core_name_45656_fields size core_name 0 45656 NULL
+b_public_size_kpp_testvec_45660_fields b_public_size kpp_testvec 0 45660 NULL
 blockmask_alauda_media_info_45662_fields blockmask alauda_media_info 0 45662 NULL
 dmi_base_vardecl_dmi_scan_c_45673_fields dmi_base vardecl_dmi_scan.c 0 45673 NULL
 _snd_pcm_hw_param_min_fndecl_45677_fields _snd_pcm_hw_param_min fndecl 3 45677 NULL
@@ -11288,10 +11477,12 @@ width_cx23885_dev_45714_fields width cx23885_dev 0 45714 NULL
 ocfs2_xattr_set_fndecl_45720_fields ocfs2_xattr_set fndecl 5 45720 NULL
 num_cqs_mlx4_caps_45727_fields num_cqs mlx4_caps 0 45727 NULL
 ena_calc_queue_size_fndecl_45731_fields ena_calc_queue_size fndecl 0 45731 NULL
+len_bnx2x_fw_file_section_45732_fields len bnx2x_fw_file_section 0 45732 NULL
 tx_len_mrvl_data_45733_fields tx_len mrvl_data 0 45733 NULL
 sys_ptrace_fndecl_45738_fields sys_ptrace fndecl 3 45738 NULL
 get_args_iw_priv_args_45748_fields get_args iw_priv_args 0 45748 NULL
 vslen_vardecl_matroxfb_base_c_45755_fields vslen vardecl_matroxfb_base.c 0 45755 NULL
+extra_postfix_len_ieee80211_crypto_ops_45763_fields extra_postfix_len ieee80211_crypto_ops 0 45763 NULL
 cc2520_write_txfifo_fndecl_45771_fields cc2520_write_txfifo fndecl 4 45771 NULL nohasharray
 size_entry_mwt_fndecl_45771_fields size_entry_mwt fndecl 0 45771 &cc2520_write_txfifo_fndecl_45771_fields
 len_ch_mem_range_45781_fields len ch_mem_range 0 45781 NULL
@@ -11377,7 +11568,8 @@ wSamplesPerFrame_uac_format_type_ii_ext_descriptor_46084_fields wSamplesPerFrame
 dm_startblk_adfs_discmap_46088_fields dm_startblk adfs_discmap 0 46088 NULL
 num_type_reg_regmap_irq_chip_46090_fields num_type_reg regmap_irq_chip 0 46090 NULL
 len_sfi_table_header_46097_fields len sfi_table_header 0 46097 NULL
-jbd2_journal_write_metadata_buffer_fndecl_46103_fields jbd2_journal_write_metadata_buffer fndecl 4 46103 NULL
+jbd2_journal_write_metadata_buffer_fndecl_46103_fields jbd2_journal_write_metadata_buffer fndecl 4 46103 NULL nohasharray
+ym_wmfw_adsp2_alg_hdr_46103_fields ym wmfw_adsp2_alg_hdr 0 46103 &jbd2_journal_write_metadata_buffer_fndecl_46103_fields
 bs_vardecl_null_blk_c_46104_fields bs vardecl_null_blk.c 0 46104 NULL
 len_eeprom_private_46124_fields len eeprom_private 0 46124 NULL
 height_saa7134_dev_46126_fields height saa7134_dev 0 46126 NULL nohasharray
@@ -11505,6 +11697,7 @@ sc18is602_check_transfer_fndecl_46545_fields sc18is602_check_transfer fndecl 0 4
 erasesize_shift_mtd_info_46565_fields erasesize_shift mtd_info 0 46565 NULL nohasharray
 xt_compat_init_offsets_fndecl_46565_fields xt_compat_init_offsets fndecl 2 46565 &erasesize_shift_mtd_info_46565_fields
 max_msix_vectors_vardecl_mpt3sas_base_c_46566_fields max_msix_vectors vardecl_mpt3sas_base.c 0 46566 NULL
+ndivs_divs_data_46571_fields ndivs divs_data 0 46571 NULL
 xfs_trans_log_finish_rmap_update_fndecl_46574_fields xfs_trans_log_finish_rmap_update fndecl 7 46574 NULL
 sock_sendpage_fndecl_46581_fields sock_sendpage fndecl 4 46581 NULL
 back_xfs_attr3_icleaf_hdr_46595_fields back xfs_attr3_icleaf_hdr 0 46595 NULL
@@ -11571,6 +11764,7 @@ tveeprom_read_fndecl_46846_fields tveeprom_read fndecl 3 46846 NULL nohasharray
 vt596_smba_vardecl_i2c_viapro_c_46846_fields vt596_smba vardecl_i2c-viapro.c 0 46846 &tveeprom_read_fndecl_46846_fields
 __bread_gfp_fndecl_46858_fields __bread_gfp fndecl 3-2 46858 NULL
 xwrite_fndecl_46865_fields xwrite fndecl 3 46865 NULL
+nb_ace_lite_cci_nb_ports_46870_fields nb_ace_lite cci_nb_ports 0 46870 NULL
 sbitmap_queue_resize_fndecl_46887_fields sbitmap_queue_resize fndecl 2 46887 NULL
 len_nfsd3_readlinkres_46888_fields len nfsd3_readlinkres 0 46888 NULL
 cb_break_head_afs_server_46900_fields cb_break_head afs_server 0 46900 NULL
@@ -11597,15 +11791,18 @@ f71882fg_find_fndecl_46975_fields f71882fg_find fndecl 0 46975 NULL
 size_dwc3_trb_46986_fields size dwc3_trb 0 46986 NULL
 gru_alloc_gts_fndecl_46987_fields gru_alloc_gts fndecl 6 46987 NULL nohasharray
 ri_max_frmr_depth_rpcrdma_ia_46987_fields ri_max_frmr_depth rpcrdma_ia 0 46987 &gru_alloc_gts_fndecl_46987_fields
+tx_queue_size_pxa168_eth_platform_data_46988_fields tx_queue_size pxa168_eth_platform_data 0 46988 NULL
 msb_cache_write_fndecl_46992_fields msb_cache_write fndecl 6-2 46992 NULL
 lrg_buffer_len_ql3_adapter_46994_fields lrg_buffer_len ql3_adapter 0 46994 NULL
 buflen_cdrom_generic_command_47000_fields buflen cdrom_generic_command 0 47000 NULL
 no_seek_end_llseek_fndecl_47002_fields no_seek_end_llseek fndecl 2 47002 NULL
 do_ip6t_set_ctl_fndecl_47003_fields do_ip6t_set_ctl fndecl 4 47003 NULL
+n_input_formats_malidp_hw_regmap_47006_fields n_input_formats malidp_hw_regmap 0 47006 NULL
 vmw_kms_update_proxy_fndecl_47016_fields vmw_kms_update_proxy fndecl 3 47016 NULL nohasharray
 va_start_vmap_area_47016_fields va_start vmap_area 0 47016 &vmw_kms_update_proxy_fndecl_47016_fields
 bytesused_uvc_buffer_47017_fields bytesused uvc_buffer 0 47017 NULL
 length_ixgb_rx_desc_47027_fields length ixgb_rx_desc 0 47027 NULL
+desc_size_shdma_dev_47035_fields desc_size shdma_dev 0 47035 NULL
 xfs_fs_map_blocks_fndecl_47038_fields xfs_fs_map_blocks fndecl 2-3 47038 NULL nohasharray
 minor_index_cardstate_47038_fields minor_index cardstate 0 47038 &xfs_fs_map_blocks_fndecl_47038_fields
 ttm_bo_kmap_fndecl_47045_fields ttm_bo_kmap fndecl 3-2 47045 NULL
@@ -11706,6 +11903,7 @@ ufs_frag_map_fndecl_47442_fields ufs_frag_map fndecl 0 47442 &depth_bttv_format_
 __ieee80211_stop_tx_ba_session_fndecl_47449_fields __ieee80211_stop_tx_ba_session fndecl 2 47449 NULL
 __irq_domain_alloc_irqs_fndecl_47462_fields __irq_domain_alloc_irqs fndecl 0-2 47462 NULL nohasharray
 part_bits_mtd_blktrans_ops_47462_fields part_bits mtd_blktrans_ops 0 47462 &__irq_domain_alloc_irqs_fndecl_47462_fields
+len_wmfw_region_47463_fields len wmfw_region 0 47463 NULL
 memblock_alloc_try_nid_fndecl_47470_fields memblock_alloc_try_nid fndecl 2-1 47470 NULL
 compat_do_ipt_set_ctl_fndecl_47473_fields compat_do_ipt_set_ctl fndecl 4 47473 NULL
 maxDataSize__mpt_ioctl_header_47477_fields maxDataSize _mpt_ioctl_header 0 47477 NULL
@@ -11719,6 +11917,7 @@ cifs_write_from_iter_fndecl_47501_fields cifs_write_from_iter fndecl 2-1 47501 N
 gr_ep_init_fndecl_47502_fields gr_ep_init fndecl 4 47502 NULL
 try_unmap_single_bt_fndecl_47503_fields try_unmap_single_bt fndecl 2-3 47503 NULL
 btrfs_cont_expand_fndecl_47505_fields btrfs_cont_expand fndecl 3-2 47505 NULL
+nr_outport_coresight_platform_data_47506_fields nr_outport coresight_platform_data 0 47506 NULL
 romfs_blk_strcmp_fndecl_47510_fields romfs_blk_strcmp fndecl 4-2 47510 NULL nohasharray
 ucNumEntries__ATOM_Tonga_MCLK_Dependency_Table_47510_fields ucNumEntries _ATOM_Tonga_MCLK_Dependency_Table 0 47510 &romfs_blk_strcmp_fndecl_47510_fields
 num_connector_drm_mode_config_47518_fields num_connector drm_mode_config 0 47518 NULL nohasharray
@@ -11851,6 +12050,7 @@ size_nfs_fh_48014_fields size nfs_fh 0 48014 NULL
 temp_end_applesmc_registers_48016_fields temp_end applesmc_registers 0 48016 NULL
 original_mtu_slave_48025_fields original_mtu slave 0 48025 NULL
 hmac_len_sctp_hmac_48030_fields hmac_len sctp_hmac 0 48030 NULL
+aim_write_fndecl_48032_fields aim_write fndecl 3 48032 NULL
 rxkad_verify_packet_2_fndecl_48035_fields rxkad_verify_packet_2 fndecl 4-3 48035 NULL
 rm_namelen_nfsd4_remove_48040_fields rm_namelen nfsd4_remove 0 48040 NULL
 s_reserved_affs_sb_info_48043_fields s_reserved affs_sb_info 0 48043 NULL
@@ -11858,6 +12058,7 @@ sb_size_md_rdev_48046_fields sb_size md_rdev 0 48046 NULL
 num_pages_ttm_buffer_object_48047_fields num_pages ttm_buffer_object 0 48047 NULL
 num_privcmd_mmapbatch_v2_48051_fields num privcmd_mmapbatch_v2 0 48051 NULL
 ioctl_datasize_ips_ha_48058_fields ioctl_datasize ips_ha 0 48058 NULL
+nr_channels_at_dma_platform_data_48060_fields nr_channels at_dma_platform_data 0 48060 NULL
 lso_max_fc_lport_48064_fields lso_max fc_lport 0 48064 NULL
 zonesize_alauda_media_info_48068_fields zonesize alauda_media_info 0 48068 NULL
 sc16is7xx_alloc_line_fndecl_48075_fields sc16is7xx_alloc_line fndecl 0 48075 NULL
@@ -11978,6 +12179,7 @@ max_num_vdevs_ath10k_48584_fields max_num_vdevs ath10k 0 48584 NULL nohasharray
 pagf_freeblks_xfs_perag_48584_fields pagf_freeblks xfs_perag 0 48584 &max_num_vdevs_ath10k_48584_fields nohasharray
 tx_ring_size_bnx2x_48584_fields tx_ring_size bnx2x 0 48584 &pagf_freeblks_xfs_perag_48584_fields
 backup_size_vmw_resource_48590_fields backup_size vmw_resource 0 48590 NULL
+arm_copy_to_user_fndecl_48602_fields arm_copy_to_user fndecl 0 48602 NULL
 datalen_atp_info_48607_fields datalen atp_info 0 48607 NULL
 count_e8390_pkt_hdr_48610_fields count e8390_pkt_hdr 0 48610 NULL
 mmc_test_prepare_mrq_fndecl_48612_fields mmc_test_prepare_mrq fndecl 7-6-4 48612 NULL
@@ -12042,7 +12244,7 @@ sharpness_sd_gl860_48824_fields sharpness sd_gl860 0 48824 NULL
 endpoint_pvr2_stream_48828_fields endpoint pvr2_stream 0 48828 NULL
 xbofs_irda_skb_cb_48831_fields xbofs irda_skb_cb 0 48831 NULL nohasharray
 num_vring_48831_fields num vring 0 48831 &xbofs_irda_skb_cb_48831_fields
-osst_init_aux_fndecl_48837_fields osst_init_aux fndecl 6 48837 NULL
+osst_init_aux_fndecl_48837_fields osst_init_aux fndecl 6-5 48837 NULL
 busnum_usb_bus_48843_fields busnum usb_bus 0 48843 NULL
 pcim_iomap_fndecl_48845_fields pcim_iomap fndecl 3 48845 NULL
 adf7242_read_fbuf_fndecl_48847_fields adf7242_read_fbuf fndecl 3 48847 NULL
@@ -12103,7 +12305,8 @@ optrom_region_size_qla_hw_data_49087_fields optrom_region_size qla_hw_data 0 490
 ocfs2_find_leaf_fndecl_49090_fields ocfs2_find_leaf fndecl 0 49090 NULL nohasharray
 bi_vcnt_bio_49090_fields bi_vcnt bio 0 49090 &ocfs2_find_leaf_fndecl_49090_fields
 ocfs2_mv_xattr_bucket_cross_cluster_fndecl_49091_fields ocfs2_mv_xattr_bucket_cross_cluster fndecl 5-6 49091 NULL
-end_sector_dev_info_49096_fields end_sector dev_info 0 49096 NULL
+end_sector_dev_info_49096_fields end_sector dev_info 0 49096 NULL nohasharray
+misc_sbp_command_block_orb_49096_fields misc sbp_command_block_orb 0 49096 &end_sector_dev_info_49096_fields
 u132_hcd_interrupt_recv_fndecl_49098_fields u132_hcd_interrupt_recv fndecl 4 49098 NULL
 xdr_align_pages_fndecl_49102_fields xdr_align_pages fndecl 0-2 49102 NULL
 n_sz_rsa_key_49103_fields n_sz rsa_key 0 49103 NULL
@@ -12121,8 +12324,10 @@ max_dev_mdp_superblock_1_49148_fields max_dev mdp_superblock_1 0 49148 NULL
 ecryptfs_inode_newsize_ok_fndecl_49153_fields ecryptfs_inode_newsize_ok fndecl 2 49153 NULL
 tx_tr_cfv_info_49171_fields tx_tr cfv_info 0 49171 NULL
 addr_len_pnfs_ff_netaddr_49177_fields addr_len pnfs_ff_netaddr 0 49177 NULL
+page_size_nvme_ctrl_49190_fields page_size nvme_ctrl 0 49190 NULL
 len_fb_cmap_user_49195_fields len fb_cmap_user 0 49195 NULL
-fsl_edma_prep_dma_cyclic_fndecl_49197_fields fsl_edma_prep_dma_cyclic fndecl 4-2 49197 NULL
+fsl_edma_prep_dma_cyclic_fndecl_49197_fields fsl_edma_prep_dma_cyclic fndecl 4-2 49197 NULL nohasharray
+ielen_wps_status_t_49197_fields ielen wps_status_t 0 49197 &fsl_edma_prep_dma_cyclic_fndecl_49197_fields
 offset_page_chunk_49201_fields offset page_chunk 0 49201 NULL
 key_size_dh_49210_fields key_size dh 0 49210 NULL
 osst_read_fndecl_49214_fields osst_read fndecl 3 49214 NULL
@@ -12144,6 +12349,7 @@ rate_floppy_struct_49273_fields rate floppy_struct 0 49273 NULL
 name_len_audit_names_49277_fields name_len audit_names 0 49277 NULL
 of_irq_parse_raw_fndecl_49280_fields of_irq_parse_raw fndecl 0 49280 NULL
 ib_get_mad_data_offset_fndecl_49283_fields ib_get_mad_data_offset fndecl 0 49283 NULL
+header_length_ipr_ucode_image_header_49294_fields header_length ipr_ucode_image_header 0 49294 NULL
 iomap_write_failed_fndecl_49298_fields iomap_write_failed fndecl 2-3 49298 NULL
 bTransferSegment_wa_xfer_result_49303_fields bTransferSegment wa_xfer_result 0 49303 NULL
 splice_direct_to_actor_fndecl_49310_fields splice_direct_to_actor fndecl 0 49310 NULL
@@ -12213,6 +12419,7 @@ num_eps_bdc_49525_fields num_eps bdc 0 49525 NULL
 consume_bytes_snd_fw_async_midi_port_49542_fields consume_bytes snd_fw_async_midi_port 0 49542 NULL
 disk_offset_pnfs_block_dev_map_49546_fields disk_offset pnfs_block_dev_map 0 49546 NULL
 ioremap_wt_fndecl_49562_fields ioremap_wt fndecl 2-1 49562 NULL
+nrs_num_pols_ptlrpc_nrs_49564_fields nrs_num_pols ptlrpc_nrs 0 49564 NULL
 vfs_readv_fndecl_49565_fields vfs_readv fndecl 0 49565 NULL nohasharray
 nilfs_mdt_delete_block_fndecl_49565_fields nilfs_mdt_delete_block fndecl 2 49565 &vfs_readv_fndecl_49565_fields
 max_cm_mtu_ipoib_cm_dev_priv_49566_fields max_cm_mtu ipoib_cm_dev_priv 0 49566 NULL
@@ -12356,6 +12563,7 @@ gbufsize_vardecl_meye_c_50205_fields gbufsize vardecl_meye.c 0 50205 NULL
 s_zmap_blocks_minix_sb_info_50206_fields s_zmap_blocks minix_sb_info 0 50206 NULL
 crtc_x_drm_plane_state_50214_fields crtc_x drm_plane_state 0 50214 NULL
 sched_priority_sched_attr_50220_fields sched_priority sched_attr 0 50220 NULL
+length_dfw_binrec_50222_fields length dfw_binrec 0 50222 NULL
 qla4_82xx_pci_mem_read_direct_fndecl_50235_fields qla4_82xx_pci_mem_read_direct fndecl 2 50235 NULL
 efi_memmap_size_efi_info_50236_fields efi_memmap_size efi_info 0 50236 NULL
 fnic_trace_max_pages_vardecl_50246_fields fnic_trace_max_pages vardecl 0 50246 NULL
@@ -12381,6 +12589,7 @@ ucNumEntries__ATOM_PPLIB_CAC_Leakage_Table_50326_fields ucNumEntries _ATOM_PPLIB
 pos_r5l_recovery_ctx_50328_fields pos r5l_recovery_ctx 0 50328 NULL
 __vmalloc_node_fndecl_50335_fields __vmalloc_node fndecl 1 50335 NULL nohasharray
 size_nand_ecc_ctrl_50335_fields size nand_ecc_ctrl 0 50335 &__vmalloc_node_fndecl_50335_fields
+aim_read_fndecl_50336_fields aim_read fndecl 3 50336 NULL
 __copy_from_user_nocache_fndecl_50340_fields __copy_from_user_nocache fndecl 0 50340 NULL
 nextindex_xtheader_50354_fields nextindex xtheader 0 50354 NULL
 wimax_msg_alloc_fndecl_50364_fields wimax_msg_alloc fndecl 4 50364 NULL
@@ -12484,6 +12693,7 @@ cluster_bits_msdos_sb_info_50763_fields cluster_bits msdos_sb_info 0 50763 NULL
 usb_hcd_map_urb_for_dma_fndecl_50765_fields usb_hcd_map_urb_for_dma fndecl 0 50765 NULL
 cifs_readpages_read_into_pages_fndecl_50770_fields cifs_readpages_read_into_pages fndecl 3 50770 NULL
 hpfs_get_sector_fndecl_50776_fields hpfs_get_sector fndecl 2 50776 NULL
+vmap_fndecl_50778_fields vmap fndecl 2 50778 NULL
 cmd_size_blk_mq_tag_set_50782_fields cmd_size blk_mq_tag_set 0 50782 NULL
 readdir_nfs_rpc_ops_50783_fields readdir nfs_rpc_ops 0 50783 NULL
 remove_pmkid_fndecl_50793_fields remove_pmkid fndecl 4 50793 NULL
@@ -12608,6 +12818,7 @@ size_autofs_dev_ioctl_51298_fields size autofs_dev_ioctl 0 51298 NULL
 iscsi_ping_comp_event_fndecl_51300_fields iscsi_ping_comp_event fndecl 5 51300 NULL
 xfs_qm_dqrepair_fndecl_51301_fields xfs_qm_dqrepair fndecl 0 51301 NULL
 y2_virtio_gpu_framebuffer_51309_fields y2 virtio_gpu_framebuffer 0 51309 NULL
+count_gb_gpio_line_count_response_51314_fields count gb_gpio_line_count_response 0 51314 NULL
 drv_sds_rings_qlcnic_adapter_51319_fields drv_sds_rings qlcnic_adapter 0 51319 NULL
 size_bts_phys_51332_fields size bts_phys 0 51332 NULL
 sync_dma_snd_usb_endpoint_51333_fields sync_dma snd_usb_endpoint 0 51333 NULL
@@ -12633,7 +12844,8 @@ max_header_size_irnet_socket_51423_fields max_header_size irnet_socket 0 51423 N
 base_memblock_region_51424_fields base memblock_region 0 51424 NULL
 num_rx_queues_ixgbevf_adapter_51428_fields num_rx_queues ixgbevf_adapter 0 51428 NULL
 gre_parse_header_fndecl_51433_fields gre_parse_header fndecl 0-5 51433 NULL
-nethctrl_vf_resources_51438_fields nethctrl vf_resources 0 51438 NULL
+nethctrl_vf_resources_51438_fields nethctrl vf_resources 0 51438 NULL nohasharray
+size_omap3isp_ccdc_lsc_config_51438_fields size omap3isp_ccdc_lsc_config 0 51438 &nethctrl_vf_resources_51438_fields
 max_cmds_ipr_ioa_cfg_51439_fields max_cmds ipr_ioa_cfg 0 51439 NULL
 xfs_free_file_space_fndecl_51452_fields xfs_free_file_space fndecl 2-3 51452 NULL
 pcpu_fc_free_fndecl_51456_fields pcpu_fc_free fndecl 2 51456 NULL
@@ -12671,9 +12883,13 @@ va_for_temp_scif_window_51603_fields va_for_temp scif_window 0 51603 NULL
 cur_vfio_pci_fill_info_51616_fields cur vfio_pci_fill_info 0 51616 NULL nohasharray
 data_transfer_length_vmscsi_request_51616_fields data_transfer_length vmscsi_request 0 51616 &cur_vfio_pci_fill_info_51616_fields
 alloc_ltalkdev_fndecl_51620_fields alloc_ltalkdev fndecl 1 51620 NULL
+ioc_plen1_obd_ioctl_data_51625_fields ioc_plen1 obd_ioctl_data 0 51625 NULL
 btuart_write_fndecl_51627_fields btuart_write fndecl 0 51627 NULL
 nodesize_btrfs_root_51633_fields nodesize btrfs_root 0 51633 NULL
+SsidLength_ndis_802_11_ssid_51638_fields SsidLength ndis_802_11_ssid 0 51638 NULL
 remap_cell_to_cache_dirty_fndecl_51640_fields remap_cell_to_cache_dirty fndecl 4 51640 NULL
+imm_count_jit_ctx_51643_fields imm_count jit_ctx 0 51643 NULL
+tx_ring_size_gfar_priv_tx_q_51655_fields tx_ring_size gfar_priv_tx_q 0 51655 NULL
 o2hb_read_slots_fndecl_51658_fields o2hb_read_slots fndecl 2 51658 NULL
 phys_mdio_mux_mmioreg_state_51673_fields phys mdio_mux_mmioreg_state 0 51673 NULL
 tcf_csum_ipv4_udp_fndecl_51674_fields tcf_csum_ipv4_udp fndecl 3 51674 NULL nohasharray
@@ -12772,6 +12988,7 @@ immediate_data_length_iscsi_build_list_52017_fields immediate_data_length iscsi_
 size_fuse_write_out_52017_fields size fuse_write_out 0 52017 &immediate_data_length_iscsi_build_list_52017_fields
 batadv_iv_ogm_aggregate_new_fndecl_52022_fields batadv_iv_ogm_aggregate_new fndecl 2 52022 NULL
 dev_set_mtu_fndecl_52028_fields dev_set_mtu fndecl 2 52028 NULL
+bounce_buf_len_xhci_ring_52035_fields bounce_buf_len xhci_ring 0 52035 NULL
 oobavail_mtd_info_52037_fields oobavail mtd_info 0 52037 NULL
 gfs2_setattr_size_fndecl_52038_fields gfs2_setattr_size fndecl 2 52038 NULL nohasharray
 mapbase_priv_52038_fields mapbase priv 0 52038 &gfs2_setattr_size_fndecl_52038_fields
@@ -12833,7 +13050,8 @@ lpc_sch_get_io_fndecl_52232_fields lpc_sch_get_io fndecl 5 52232 NULL
 nfs3_proc_readlink_fndecl_52235_fields nfs3_proc_readlink fndecl 4-3 52235 NULL
 devm_nvdimm_memremap_fndecl_52240_fields devm_nvdimm_memremap fndecl 3-2 52240 NULL
 num_ports_mthca_limits_52246_fields num_ports mthca_limits 0 52246 NULL
-paddr_drm_gem_cma_object_52250_fields paddr drm_gem_cma_object 0 52250 NULL
+paddr_drm_gem_cma_object_52250_fields paddr drm_gem_cma_object 0 52250 NULL nohasharray
+size_elf_note_info_52250_fields size elf_note_info 0 52250 &paddr_drm_gem_cma_object_52250_fields
 ceph_osdc_alloc_messages_fndecl_52252_fields ceph_osdc_alloc_messages fndecl 0 52252 NULL
 get_count_order_long_fndecl_52255_fields get_count_order_long fndecl 0 52255 NULL
 bufsize_brcmf_console_52266_fields bufsize brcmf_console 0 52266 NULL
@@ -12876,6 +13094,7 @@ rh_string_fndecl_52376_fields rh_string fndecl 0-4 52376 NULL
 bMaxBurst_usb_ss_ep_comp_descriptor_52382_fields bMaxBurst usb_ss_ep_comp_descriptor 0 52382 NULL
 ath6kl_wmi_set_ie_cmd_fndecl_52383_fields ath6kl_wmi_set_ie_cmd fndecl 6-2 52383 NULL nohasharray
 sg_pgoffset_sg_page_iter_52383_fields sg_pgoffset sg_page_iter 0 52383 &ath6kl_wmi_set_ie_cmd_fndecl_52383_fields
+raw_bufsize_edt_ft5x06_ts_data_52390_fields raw_bufsize edt_ft5x06_ts_data 0 52390 NULL
 jffs2_write_dirent_fndecl_52396_fields jffs2_write_dirent fndecl 5 52396 NULL
 u132_hcd_initial_input_recv_fndecl_52397_fields u132_hcd_initial_input_recv fndecl 4 52397 NULL
 srp_map_idb_fndecl_52402_fields srp_map_idb fndecl 0-5 52402 NULL
@@ -12965,6 +13184,7 @@ dd_fcrport_size_fc_function_template_52753_fields dd_fcrport_size fc_function_te
 num_btns_cyttsp4_sysinfo_ofs_52758_fields num_btns cyttsp4_sysinfo_ofs 0 52758 NULL
 dr_blkno_ocfs2_dx_root_block_52759_fields dr_blkno ocfs2_dx_root_block 0 52759 NULL
 playback_frlog_rme96_52763_fields playback_frlog rme96 0 52763 NULL
+iov_iter_fault_in_readable_fndecl_52767_fields iov_iter_fault_in_readable fndecl 2 52767 NULL
 wIDIbytesPerSector_ms_bootblock_idi_52770_fields wIDIbytesPerSector ms_bootblock_idi 0 52770 NULL
 size_drm_i915_gem_create_52771_fields size drm_i915_gem_create 0 52771 NULL
 maxBuf_TCP_Server_Info_52774_fields maxBuf TCP_Server_Info 0 52774 NULL
@@ -12974,6 +13194,7 @@ tcp_mss_split_point_fndecl_52791_fields tcp_mss_split_point fndecl 0 52791 &qxl_
 batadv_get_vid_fndecl_52792_fields batadv_get_vid fndecl 2 52792 NULL
 __wa_seg_calculate_isoc_frame_count_fndecl_52795_fields __wa_seg_calculate_isoc_frame_count fndecl 0 52795 NULL
 buffer_size_vardecl_ethoc_c_52796_fields buffer_size vardecl_ethoc.c 0 52796 NULL
+xhci_ring_alloc_fndecl_52799_fields xhci_ring_alloc fndecl 5 52799 NULL
 payload_len_bfa_bsg_data_52800_fields payload_len bfa_bsg_data 0 52800 NULL
 postcopy_buffers_fndecl_52806_fields postcopy_buffers fndecl 3 52806 NULL
 ule_sndu_type_dvb_net_priv_52811_fields ule_sndu_type dvb_net_priv 0 52811 NULL
@@ -13106,6 +13327,8 @@ sys_send_fndecl_53330_fields sys_send fndecl 3 53330 NULL
 __drm_gem_cma_create_fndecl_53334_fields __drm_gem_cma_create fndecl 2 53334 NULL
 s_inode_readahead_blks_ext4_sb_info_53337_fields s_inode_readahead_blks ext4_sb_info 0 53337 NULL
 v9fs_xattr_set_fndecl_53342_fields v9fs_xattr_set fndecl 4 53342 NULL
+ioc_len_libcfs_ioctl_hdr_53352_fields ioc_len libcfs_ioctl_hdr 0 53352 NULL
+frag_size_hwbm_pool_53355_fields frag_size hwbm_pool 0 53355 NULL
 ali1563_smba_vardecl_i2c_ali1563_c_53362_fields ali1563_smba vardecl_i2c-ali1563.c 0 53362 NULL
 __xdr_inline_decode_fndecl_53363_fields __xdr_inline_decode fndecl 2 53363 NULL
 rsize_hid_device_53365_fields rsize hid_device 0 53365 NULL
@@ -13171,8 +13394,11 @@ btt_flog_write_fndecl_53628_fields btt_flog_write fndecl 0 53628 NULL
 num_channels_mlx5e_params_53632_fields num_channels mlx5e_params 0 53632 NULL
 remote_nentries_xpc_openclose_args_53643_fields remote_nentries xpc_openclose_args 0 53643 NULL
 ticket2_len_rxk5_key_53644_fields ticket2_len rxk5_key 0 53644 NULL
+ioc_plen2_obd_ioctl_data_53648_fields ioc_plen2 obd_ioctl_data 0 53648 NULL
 extra_tx_headroom_rt2x00_dev_53650_fields extra_tx_headroom rt2x00_dev 0 53650 NULL
 ceph_buffer_new_fndecl_53653_fields ceph_buffer_new fndecl 1 53653 NULL
+dlist_count_vc4_plane_state_53658_fields dlist_count vc4_plane_state 0 53658 NULL
+hr_data_len_hsm_request_53666_fields hr_data_len hsm_request 0 53666 NULL
 num_sge_ib_uverbs_send_wr_53667_fields num_sge ib_uverbs_send_wr 0 53667 NULL
 cpu_addr_of_pci_range_53670_fields cpu_addr of_pci_range 0 53670 NULL
 xen_foreach_remap_area_fndecl_53678_fields xen_foreach_remap_area fndecl 0 53678 NULL nohasharray
@@ -13195,6 +13421,7 @@ xdr_inline_decode_fndecl_53721_fields xdr_inline_decode fndecl 2 53721 NULL
 sys_init_module_fndecl_53724_fields sys_init_module fndecl 2 53724 NULL nohasharray
 onenand_write_ops_nolock_fndecl_53724_fields onenand_write_ops_nolock fndecl 2 53724 &sys_init_module_fndecl_53724_fields
 btt_rw_integrity_fndecl_53727_fields btt_rw_integrity fndecl 0 53727 NULL
+xhci_alloc_stream_info_fndecl_53732_fields xhci_alloc_stream_info fndecl 4 53732 NULL
 adp5588_build_gpiomap_fndecl_53733_fields adp5588_build_gpiomap fndecl 0 53733 NULL nohasharray
 dnode_scif_peer_dev_53733_fields dnode scif_peer_dev 0 53733 &adp5588_build_gpiomap_fndecl_53733_fields
 max_data_size_vardecl_hsi_char_c_53736_fields max_data_size vardecl_hsi_char.c 0 53736 NULL
@@ -13251,7 +13478,8 @@ usb_stor_sg_tablesize_fndecl_53929_fields usb_stor_sg_tablesize fndecl 0 53929 N
 osd_req_op_extent_dup_last_fndecl_53929_fields osd_req_op_extent_dup_last fndecl 3 53929 &usb_stor_sg_tablesize_fndecl_53929_fields
 chip_sdma_engines_hfi1_devdata_53934_fields chip_sdma_engines hfi1_devdata 0 53934 NULL
 depth_tm6000_fmt_53938_fields depth tm6000_fmt 0 53938 NULL
-ip4ip6_err_fndecl_53943_fields ip4ip6_err fndecl 5 53943 NULL
+ip4ip6_err_fndecl_53943_fields ip4ip6_err fndecl 5 53943 NULL nohasharray
+_find_first_zero_bit_be_fndecl_53943_fields _find_first_zero_bit_be fndecl 0 53943 &ip4ip6_err_fndecl_53943_fields
 llc_mac_header_len_fndecl_53947_fields llc_mac_header_len fndecl 0 53947 NULL
 buffer_end_nm256_53949_fields buffer_end nm256 0 53949 NULL
 swiotlb_nr_tbl_fndecl_53950_fields swiotlb_nr_tbl fndecl 0 53950 NULL
@@ -13261,6 +13489,7 @@ vmw_sou_backing_alloc_fndecl_53962_fields vmw_sou_backing_alloc fndecl 3 53962 N
 c_srate_f_uac2_opts_53962_fields c_srate f_uac2_opts 0 53962 &vmw_sou_backing_alloc_fndecl_53962_fields
 recover_orphan_inode_fndecl_53969_fields recover_orphan_inode fndecl 2 53969 NULL
 dests_size_fs_fte_53973_fields dests_size fs_fte 0 53973 NULL
+key_len_wpa_key_t_53980_fields key_len wpa_key_t 0 53980 NULL
 rx_buf_sz_cp_private_53982_fields rx_buf_sz cp_private 0 53982 NULL
 assoc_resp_len_wmi_connect_event_53983_fields assoc_resp_len wmi_connect_event 0 53983 NULL
 nfs_proc_mknod_fndecl_53987_fields nfs_proc_mknod fndecl 4 53987 NULL
@@ -13273,6 +13502,7 @@ nonstatic_find_io_fndecl_54015_fields nonstatic_find_io fndecl 4 54015 NULL
 rsi_setblocklength_fndecl_54024_fields rsi_setblocklength fndecl 2 54024 NULL
 xz_dec_lzma2_create_fndecl_54034_fields xz_dec_lzma2_create fndecl 2 54034 NULL
 sum_size_jffs2_summary_54035_fields sum_size jffs2_summary 0 54035 NULL
+gb_operation_create_core_fndecl_54045_fields gb_operation_create_core fndecl 4 54045 NULL
 sierra_write_fndecl_54049_fields sierra_write fndecl 4 54049 NULL
 copy_page_to_iter_pipe_fndecl_54059_fields copy_page_to_iter_pipe fndecl 2-3-0 54059 NULL
 storvsc_ringbuffer_size_vardecl_storvsc_drv_c_54060_fields storvsc_ringbuffer_size vardecl_storvsc_drv.c 0 54060 NULL
@@ -13303,6 +13533,7 @@ carl9170_exec_cmd_fndecl_54141_fields carl9170_exec_cmd fndecl 3 54141 &change_p
 netvsc_change_mtu_fndecl_54142_fields netvsc_change_mtu fndecl 2 54142 NULL
 f2fs_do_collapse_fndecl_54143_fields f2fs_do_collapse fndecl 3-2 54143 NULL
 brcmf_usb_dl_writeimage_fndecl_54144_fields brcmf_usb_dl_writeimage fndecl 3 54144 NULL
+hs_cur_bits_cfs_hash_54147_fields hs_cur_bits cfs_hash 0 54147 NULL
 sp2_write_i2c_fndecl_54157_fields sp2_write_i2c fndecl 4 54157 NULL
 num_qp_mthca_profile_54160_fields num_qp mthca_profile 0 54160 NULL
 buf_len_lpfc_sli_config_mse_54165_fields buf_len lpfc_sli_config_mse 0 54165 NULL
@@ -13405,6 +13636,7 @@ initial_height_vmw_private_54479_fields initial_height vmw_private 0 54479 NULL
 adf7242_write_fbuf_fndecl_54479_fields adf7242_write_fbuf fndecl 3 54479 &initial_height_vmw_private_54479_fields
 ceph_auth_entity_name_encode_fndecl_54483_fields ceph_auth_entity_name_encode fndecl 0 54483 NULL
 spi_write_buf_fndecl_54490_fields spi_write_buf fndecl 2 54490 NULL
+n_chan_comedi_subdevice_54496_fields n_chan comedi_subdevice 0 54496 NULL
 dev_start_strip_zone_54501_fields dev_start strip_zone 0 54501 NULL
 max_fds_fdtable_54502_fields max_fds fdtable 0 54502 NULL
 mwifiex_set_gen_ie_helper_fndecl_54506_fields mwifiex_set_gen_ie_helper fndecl 3 54506 NULL
@@ -13515,6 +13747,7 @@ iscsit_build_pdu_and_seq_lists_fndecl_54916_fields iscsit_build_pdu_and_seq_list
 line_length_fb_fix_screeninfo_54923_fields line_length fb_fix_screeninfo 0 54923 NULL nohasharray
 ipr_copy_ucode_buffer_fndecl_54923_fields ipr_copy_ucode_buffer fndecl 3 54923 &line_length_fb_fix_screeninfo_54923_fields
 sector_dm_io_region_54924_fields sector dm_io_region 0 54924 NULL
+addr_ihex_binrec_54928_fields addr ihex_binrec 0 54928 NULL
 __clone_blkaddrs_fndecl_54943_fields __clone_blkaddrs fndecl 5-6 54943 NULL
 blk_queue_logical_block_size_fndecl_54946_fields blk_queue_logical_block_size fndecl 2 54946 NULL
 page_add_anon_rmap_fndecl_54950_fields page_add_anon_rmap fndecl 3 54950 NULL
@@ -13522,6 +13755,7 @@ encx24j600_cmdn_fndecl_54953_fields encx24j600_cmdn fndecl 4 54953 NULL nohashar
 per_rxd_space_vxge_hw_ring_attr_54953_fields per_rxd_space vxge_hw_ring_attr 0 54953 &encx24j600_cmdn_fndecl_54953_fields
 log_blocks_per_seg_f2fs_super_block_54960_fields log_blocks_per_seg f2fs_super_block 0 54960 NULL
 pci_enable_sriov_fndecl_54962_fields pci_enable_sriov fndecl 2 54962 NULL
+gb_operation_create_flags_fndecl_54976_fields gb_operation_create_flags fndecl 4 54976 NULL
 offset_usb_iso_packet_descriptor_54977_fields offset usb_iso_packet_descriptor 0 54977 NULL
 v4l2_src_w_yuv_playback_info_54979_fields v4l2_src_w yuv_playback_info 0 54979 NULL
 len_cn_msg_54981_fields len cn_msg 0 54981 NULL
@@ -13560,6 +13794,7 @@ scatterwalk_ffwd_fndecl_55110_fields scatterwalk_ffwd fndecl 3 55110 NULL
 y_zoran_overlay_settings_55113_fields y zoran_overlay_settings 0 55113 NULL
 unpack_to_rootfs_fndecl_55124_fields unpack_to_rootfs fndecl 2 55124 NULL
 length_dw_radeon_cs_chunk_55128_fields length_dw radeon_cs_chunk 0 55128 NULL
+ea_data_len_gfs2_ea_header_55134_fields ea_data_len gfs2_ea_header 0 55134 NULL
 ___ieee80211_stop_rx_ba_session_fndecl_55145_fields ___ieee80211_stop_rx_ba_session fndecl 2 55145 NULL
 namelen_dlm_lock_params_55146_fields namelen dlm_lock_params 0 55146 NULL
 gigaset_isowbuf_getbytes_fndecl_55147_fields gigaset_isowbuf_getbytes fndecl 0-2 55147 NULL
@@ -13595,6 +13830,7 @@ sgoffset_cxgbi_task_data_55277_fields sgoffset cxgbi_task_data 0 55277 &bSubfram
 apic_phys_vardecl_apic_c_55279_fields apic_phys vardecl_apic.c 0 55279 NULL nohasharray
 ext2_acl_from_disk_fndecl_55279_fields ext2_acl_from_disk fndecl 2 55279 &apic_phys_vardecl_apic_c_55279_fields
 xfs_refcount_find_left_extents_fndecl_55280_fields xfs_refcount_find_left_extents fndecl 4-5 55280 NULL
+ld_default_stripe_count_lov_desc_55281_fields ld_default_stripe_count lov_desc 0 55281 NULL
 copy_to_urb_fndecl_55284_fields copy_to_urb fndecl 5-4 55284 NULL
 hdrlen_ipv6_rt_hdr_55289_fields hdrlen ipv6_rt_hdr 0 55289 NULL
 c_can_read_msg_object_fndecl_55291_fields c_can_read_msg_object fndecl 3 55291 NULL
@@ -13662,6 +13898,7 @@ blkdev_max_hw_sectors_vardecl_dev_c_55533_fields blkdev_max_hw_sectors vardecl_d
 irq_intel_lpss_platform_info_55538_fields irq intel_lpss_platform_info 0 55538 NULL
 crtcs_psb_ops_55540_fields crtcs psb_ops 0 55540 NULL
 rf_blkno_ocfs2_refcount_block_55545_fields rf_blkno ocfs2_refcount_block 0 55545 NULL
+tmp_afs_call_55554_fields tmp afs_call 0 55554 NULL
 usVSyncOffset__ATOM_DTD_FORMAT_55558_fields usVSyncOffset _ATOM_DTD_FORMAT 0 55558 NULL nohasharray
 max_i2s_channels_hdmi_codec_pdata_55558_fields max_i2s_channels hdmi_codec_pdata 0 55558 &usVSyncOffset__ATOM_DTD_FORMAT_55558_fields
 read_reg_fndecl_55560_fields read_reg fndecl 0 55560 NULL
@@ -13669,6 +13906,7 @@ iv_len_ieee80211_key_conf_55561_fields iv_len ieee80211_key_conf 0 55561 NULL
 io_tlb_overflow_vardecl_swiotlb_c_55570_fields io_tlb_overflow vardecl_swiotlb.c 0 55570 NULL
 if_sdio_read_rx_len_fndecl_55579_fields if_sdio_read_rx_len fndecl 0 55579 NULL
 index_vardecl_pcsp_c_55582_fields index vardecl_pcsp.c 0 55582 NULL
+coh_page_bufsize_cl_object_header_55585_fields coh_page_bufsize cl_object_header 0 55585 NULL
 rcvtid_size_ctxt_eager_bufs_55589_fields rcvtid_size ctxt_eager_bufs 0 55589 NULL
 split_by_ceph_inode_frag_55595_fields split_by ceph_inode_frag 0 55595 NULL
 ext4_punch_hole_fndecl_55604_fields ext4_punch_hole fndecl 3-2 55604 NULL
@@ -13818,6 +14056,7 @@ ath10k_htt_tx_fetch_resp_fndecl_56215_fields ath10k_htt_tx_fetch_resp fndecl 5 5
 sample_stack_user_perf_event_attr_56220_fields sample_stack_user perf_event_attr 0 56220 NULL
 offset_cifs_writedata_56222_fields offset cifs_writedata 0 56222 NULL nohasharray
 reg_cache_size_snd_soc_codec_driver_56222_fields reg_cache_size snd_soc_codec_driver 0 56222 &offset_cifs_writedata_56222_fields
+reg_cache_size_omap_mcbsp_56223_fields reg_cache_size omap_mcbsp 0 56223 NULL
 depth_s2255_fmt_56229_fields depth s2255_fmt 0 56229 NULL
 psn_mask_rvt_driver_params_56230_fields psn_mask rvt_driver_params 0 56230 NULL
 ocfs2_mv_xattr_buckets_fndecl_56231_fields ocfs2_mv_xattr_buckets fndecl 6-3-5-4 56231 NULL
@@ -13862,7 +14101,8 @@ buf_count_drm_device_dma_56399_fields buf_count drm_device_dma 0 56399 NULL
 ccw_clear_fndecl_56408_fields ccw_clear fndecl 3-5-6-4 56408 NULL
 f2fs_llseek_fndecl_56409_fields f2fs_llseek fndecl 2 56409 NULL
 ieee80211_auth_challenge_fndecl_56418_fields ieee80211_auth_challenge fndecl 3 56418 NULL
-notify_change_fndecl_56420_fields notify_change fndecl 0 56420 NULL
+notify_change_fndecl_56420_fields notify_change fndecl 0 56420 NULL nohasharray
+hd_priv_size_gb_hd_driver_56420_fields hd_priv_size gb_hd_driver 0 56420 &notify_change_fndecl_56420_fields
 max_recv_wr_ib_qp_cap_56426_fields max_recv_wr ib_qp_cap 0 56426 NULL
 llc_ui_sendmsg_fndecl_56432_fields llc_ui_sendmsg fndecl 3 56432 NULL
 ath6kl_wmi_cancel_remain_on_chnl_cmd_fndecl_56434_fields ath6kl_wmi_cancel_remain_on_chnl_cmd fndecl 2 56434 NULL nohasharray
@@ -13906,6 +14146,7 @@ sctp_tsnmap_grow_fndecl_56579_fields sctp_tsnmap_grow fndecl 2 56579 NULL
 buf_bytes_mmc_blk_ioc_data_56589_fields buf_bytes mmc_blk_ioc_data 0 56589 NULL
 qt2_write_fndecl_56603_fields qt2_write fndecl 4 56603 NULL
 cb_irq_yenta_socket_56604_fields cb_irq yenta_socket 0 56604 NULL
+q_num_hnae_handle_56609_fields q_num hnae_handle 0 56609 NULL
 security_size_rxrpc_connection_56613_fields security_size rxrpc_connection 0 56613 NULL
 pci_map_size_iadev_priv_56617_fields pci_map_size iadev_priv 0 56617 NULL
 ieee80211_tdls_mgmt_fndecl_56618_fields ieee80211_tdls_mgmt fndecl 10 56618 NULL
@@ -13941,6 +14182,7 @@ ext4_get_group_number_fndecl_56720_fields ext4_get_group_number fndecl 0 56720 N
 rcvegrbuf_size_qib_ctxtdata_56720_fields rcvegrbuf_size qib_ctxtdata 0 56720 &ext4_get_group_number_fndecl_56720_fields
 opcnt_nfsd4_compoundargs_56722_fields opcnt nfsd4_compoundargs 0 56722 NULL
 offset_cw1200_txpriv_56729_fields offset cw1200_txpriv 0 56729 NULL
+tx_ring_size_mvpp2_port_56735_fields tx_ring_size mvpp2_port 0 56735 NULL
 search_empty_fndecl_56737_fields search_empty fndecl 2 56737 NULL
 drm_gem_cma_create_fndecl_56742_fields drm_gem_cma_create fndecl 2 56742 NULL nohasharray
 val_len_ceph_inode_xattr_56742_fields val_len ceph_inode_xattr 0 56742 &drm_gem_cma_create_fndecl_56742_fields
@@ -14072,6 +14314,7 @@ ext4_meta_bg_first_block_no_fndecl_57235_fields ext4_meta_bg_first_block_no fnde
 header_asix_rx_fixup_info_57237_fields header asix_rx_fixup_info 0 57237 NULL nohasharray
 li_namelen_nfsd4_link_57237_fields li_namelen nfsd4_link 0 57237 &header_asix_rx_fixup_info_57237_fields
 iomap_write_end_fndecl_57238_fields iomap_write_end fndecl 0-4-2-3 57238 NULL
+offset_ion_test_rw_data_57241_fields offset ion_test_rw_data 0 57241 NULL
 pkg_size_raydium_data_57243_fields pkg_size raydium_data 0 57243 NULL
 sys_dup3_fndecl_57246_fields sys_dup3 fndecl 2 57246 NULL
 maxlen_xfs_alloc_arg_57260_fields maxlen xfs_alloc_arg 0 57260 NULL
@@ -14202,6 +14445,7 @@ b_io_error_xfs_buf_57771_fields b_io_error xfs_buf 0 57771 NULL
 minor_media_devnode_57774_fields minor media_devnode 0 57774 NULL
 height_fb_copyarea_57780_fields height fb_copyarea 0 57780 NULL nohasharray
 end_numa_memblk_57780_fields end numa_memblk 0 57780 &height_fb_copyarea_57780_fields
+mp_rx_agg_buf_size_sdio_mmc_card_57794_fields mp_rx_agg_buf_size sdio_mmc_card 0 57794 NULL
 pos_lzma_header_57804_fields pos lzma_header 0 57804 NULL
 nic_num_sqs_en_fndecl_57805_fields nic_num_sqs_en fndecl 0-2 57805 NULL
 ri_blockcount_xfs_refcount_intent_57815_fields ri_blockcount xfs_refcount_intent 0 57815 NULL
@@ -14209,7 +14453,8 @@ get_user_pages_remote_fndecl_57819_fields get_user_pages_remote fndecl 0-3 57819
 blocks_mmc_data_57821_fields blocks mmc_data 0 57821 NULL
 force_size_vardecl_pcmciamtd_c_57827_fields force_size vardecl_pcmciamtd.c 0 57827 NULL
 cmd_len_cmd_57830_fields cmd_len cmd 0 57830 NULL nohasharray
-ecc_bits_nand_onfi_params_57830_fields ecc_bits nand_onfi_params 0 57830 &cmd_len_cmd_57830_fields
+ecc_bits_nand_onfi_params_57830_fields ecc_bits nand_onfi_params 0 57830 &cmd_len_cmd_57830_fields nohasharray
+ioc_count_obd_ioctl_data_57830_fields ioc_count obd_ioctl_data 0 57830 &ecc_bits_nand_onfi_params_57830_fields
 vxfs_bmap_ext4_fndecl_57831_fields vxfs_bmap_ext4 fndecl 0-2 57831 NULL nohasharray
 iscsi_complete_pdu_fndecl_57831_fields iscsi_complete_pdu fndecl 4 57831 &vxfs_bmap_ext4_fndecl_57831_fields
 i_pos_hi_fat_fid_57850_fields i_pos_hi fat_fid 0 57850 NULL
@@ -14233,6 +14478,7 @@ mpwqe_log_stride_sz_mlx5e_params_57934_fields mpwqe_log_stride_sz mlx5e_params 0
 memblock_set_current_limit_fndecl_57935_fields memblock_set_current_limit fndecl 1 57935 NULL
 eeprom_size_rt2x00_ops_57953_fields eeprom_size rt2x00_ops 0 57953 NULL
 i2c_read_fndecl_57956_fields i2c_read fndecl 0 57956 NULL
+ticket_len_rxkad_response_57960_fields ticket_len rxkad_response 0 57960 NULL
 filemap_check_errors_fndecl_57965_fields filemap_check_errors fndecl 0 57965 NULL
 init_speed_hci_uart_57987_fields init_speed hci_uart 0 57987 NULL
 hpfs_map_anode_fndecl_57993_fields hpfs_map_anode fndecl 2 57993 NULL
@@ -14343,6 +14589,7 @@ di_anextents_xfs_icdinode_58455_fields di_anextents xfs_icdinode 0 58455 NULL
 caif_seqpkt_sendmsg_fndecl_58458_fields caif_seqpkt_sendmsg fndecl 3 58458 NULL
 NumProtectionFields_cfi_pri_intelext_58461_fields NumProtectionFields cfi_pri_intelext 0 58461 NULL
 btrfs_clone_fndecl_58462_fields btrfs_clone fndecl 5-3-6 58462 NULL
+pgsize_bitmap_iommu_domain_58464_fields pgsize_bitmap iommu_domain 0 58464 NULL
 usermodehelper_read_trylock_fndecl_58469_fields usermodehelper_read_trylock fndecl 0 58469 NULL
 jbd2_journal_inode_add_write_fndecl_58489_fields jbd2_journal_inode_add_write fndecl 0 58489 NULL
 try_lock_extent_fndecl_58490_fields try_lock_extent fndecl 3-2 58490 NULL nohasharray
@@ -14436,6 +14683,7 @@ address_fault_env_58869_fields address fault_env 0 58869 NULL
 hfp_ast_vbios_enhtable_58872_fields hfp ast_vbios_enhtable 0 58872 NULL
 gbuffers_vardecl_bttv_driver_c_58873_fields gbuffers vardecl_bttv-driver.c 0 58873 NULL
 addr_nvme_sgl_desc_58875_fields addr nvme_sgl_desc 0 58875 NULL
+xm_wmfw_adsp2_alg_hdr_58884_fields xm wmfw_adsp2_alg_hdr 0 58884 NULL
 rx_buf_sz_fe_priv_58888_fields rx_buf_sz fe_priv 0 58888 NULL
 max_xfer_nd_cmd_get_config_size_58894_fields max_xfer nd_cmd_get_config_size 0 58894 NULL
 usb_stor_bulk_transfer_sg_fndecl_58896_fields usb_stor_bulk_transfer_sg fndecl 2-4 58896 NULL
@@ -14501,6 +14749,7 @@ rcvidx_hscx_hw_59100_fields rcvidx hscx_hw 0 59100 NULL
 ctrl_dma_ims_pcu_59106_fields ctrl_dma ims_pcu 0 59106 NULL
 remap_and_issue_shared_cell_fndecl_59114_fields remap_and_issue_shared_cell fndecl 3 59114 NULL
 sec_per_clus_fat_floppy_defaults_59119_fields sec_per_clus fat_floppy_defaults 0 59119 NULL
+omapdss_count_strings_fndecl_59120_fields omapdss_count_strings fndecl 0 59120 NULL
 npages_for_summary_flush_fndecl_59124_fields npages_for_summary_flush fndecl 0 59124 NULL
 xfs_read_agi_fndecl_59127_fields xfs_read_agi fndecl 3 59127 NULL nohasharray
 width_em28xx_v4l2_59127_fields width em28xx_v4l2 0 59127 &xfs_read_agi_fndecl_59127_fields
@@ -14540,6 +14789,7 @@ size_vhost_umem_node_59230_fields size vhost_umem_node 0 59230 NULL
 __iptunnel_pull_header_fndecl_59234_fields __iptunnel_pull_header fndecl 2 59234 NULL
 sierra_net_skb_clone_fndecl_59236_fields sierra_net_skb_clone fndecl 3 59236 NULL
 clear_record_extent_bits_fndecl_59239_fields clear_record_extent_bits fndecl 2-3 59239 NULL
+num_mbc_cfgs_wm8994_pdata_59240_fields num_mbc_cfgs wm8994_pdata 0 59240 NULL
 length_acpi_pcct_hw_reduced_59242_fields length acpi_pcct_hw_reduced 0 59242 NULL nohasharray
 nlp_maxframe_lpfc_nodelist_59242_fields nlp_maxframe lpfc_nodelist 0 59242 &length_acpi_pcct_hw_reduced_59242_fields
 save_microcode_fndecl_59254_fields save_microcode fndecl 3 59254 NULL
@@ -14554,6 +14804,7 @@ nentries_afs_dir_pagehdr_59283_fields nentries afs_dir_pagehdr 0 59283 NULL
 used_snd_array_59285_fields used snd_array 0 59285 NULL
 written_coredump_params_59286_fields written coredump_params 0 59286 NULL
 hpfs_write_end_fndecl_59287_fields hpfs_write_end fndecl 5 59287 NULL
+nr_regs_omap_prcm_irq_setup_59292_fields nr_regs omap_prcm_irq_setup 0 59292 NULL
 range_oid_t_59299_fields range oid_t 0 59299 NULL
 jffs2_write_dnode_fndecl_59301_fields jffs2_write_dnode fndecl 5 59301 NULL
 next_segno_curseg_info_59302_fields next_segno curseg_info 0 59302 NULL
@@ -14667,6 +14918,7 @@ ocfs2_read_dx_leaves_fndecl_59744_fields ocfs2_read_dx_leaves fndecl 2 59744 NUL
 fq_resize_fndecl_59744_fields fq_resize fndecl 2 59744 &ocfs2_read_dx_leaves_fndecl_59744_fields
 nx_fw_cmd_set_phy_fndecl_59745_fields nx_fw_cmd_set_phy fndecl 3 59745 NULL
 mt_count_mtop_59746_fields mt_count mtop 0 59746 NULL
+seedsize_rng_alg_59748_fields seedsize rng_alg 0 59748 NULL
 xlog_write_calc_vec_length_fndecl_59749_fields xlog_write_calc_vec_length fndecl 0 59749 NULL
 request_size_afs_call_59750_fields request_size afs_call 0 59750 NULL
 addr_phys_netup_dma_59759_fields addr_phys netup_dma 0 59759 NULL
@@ -14841,6 +15093,7 @@ minimum_cx88_ctrl_60444_fields minimum cx88_ctrl 0 60444 NULL
 digestsize_hash_alg_common_60446_fields digestsize hash_alg_common 0 60446 NULL
 create_kmalloc_cache_usercopy_fndecl_60447_fields create_kmalloc_cache_usercopy fndecl 2 60447 NULL
 count_hscx_hw_60448_fields count hscx_hw 0 60448 NULL
+bss_end_flat_hdr_60449_fields bss_end flat_hdr 0 60449 NULL
 lib80211_tkip_decrypt_fndecl_60450_fields lib80211_tkip_decrypt fndecl 2 60450 NULL
 maxsgentries_ctlr_info_60455_fields maxsgentries ctlr_info 0 60455 NULL
 osd_req_op_cls_request_data_pages_fndecl_60457_fields osd_req_op_cls_request_data_pages fndecl 4 60457 NULL
@@ -15001,6 +15254,7 @@ pvr2_buffer_set_buffer_fndecl_61176_fields pvr2_buffer_set_buffer fndecl 3 61176
 register_sound_mixer_fndecl_61179_fields register_sound_mixer fndecl 2 61179 NULL
 __ocfs2_move_extent_fndecl_61183_fields __ocfs2_move_extent fndecl 4-5-6-3 61183 NULL
 osd_req_op_extent_init_fndecl_61188_fields osd_req_op_extent_init fndecl 5 61188 NULL
+channels_vendor_data_61194_fields channels vendor_data 0 61194 NULL
 pos_dir_context_61195_fields pos dir_context 0 61195 NULL
 port_id_ssp_device_61196_fields port_id ssp_device 0 61196 NULL
 size_bcma_sflash_61197_fields size bcma_sflash 0 61197 NULL
@@ -15045,6 +15299,7 @@ handle_response_icmp_fndecl_61366_fields handle_response_icmp fndecl 7 61366 NUL
 tx_headroom_libipw_device_61370_fields tx_headroom libipw_device 0 61370 NULL
 sync_dirty_buffer_fndecl_61371_fields sync_dirty_buffer fndecl 0 61371 NULL
 data_dma_usb_onetouch_61372_fields data_dma usb_onetouch 0 61372 NULL
+num_of_phy_chans_stedma40_platform_data_61373_fields num_of_phy_chans stedma40_platform_data 0 61373 NULL
 devs_max_btrfs_raid_attr_61376_fields devs_max btrfs_raid_attr 0 61376 NULL
 bfa_cb_ioim_done_fndecl_61381_fields bfa_cb_ioim_done fndecl 7 61381 NULL
 xfs_dir3_data_read_fndecl_61387_fields xfs_dir3_data_read fndecl 3 61387 NULL
@@ -15190,6 +15445,7 @@ hsu_dma_active_desc_size_fndecl_61956_fields hsu_dma_active_desc_size fndecl 0 6
 indirect_size_srp_target_port_61962_fields indirect_size srp_target_port 0 61962 NULL
 s_maxbytes_super_block_61963_fields s_maxbytes super_block 0 61963 NULL
 periods_min_snd_pcm_hardware_61965_fields periods_min snd_pcm_hardware 0 61965 NULL
+wm_adsp_compr_read_fndecl_61972_fields wm_adsp_compr_read fndecl 3 61972 NULL
 nfs_set_pgio_error_fndecl_61975_fields nfs_set_pgio_error fndecl 3 61975 NULL
 physical_for_dev_replace_scrub_page_61977_fields physical_for_dev_replace scrub_page 0 61977 NULL
 x25_pacsize_to_bytes_fndecl_61983_fields x25_pacsize_to_bytes fndecl 0 61983 NULL
@@ -15202,6 +15458,7 @@ sisusb_write_fndecl_62001_fields sisusb_write fndecl 3 62001 NULL
 sc_reader_svcxprt_rdma_62004_fields sc_reader svcxprt_rdma 0 62004 NULL
 __add_discard_entry_fndecl_62006_fields __add_discard_entry fndecl 4-5 62006 NULL
 ext4_ext_convert_to_initialized_fndecl_62009_fields ext4_ext_convert_to_initialized fndecl 0 62009 NULL
+length_snd_efw_transaction_62012_fields length snd_efw_transaction 0 62012 NULL
 memblock_setclr_flag_fndecl_62013_fields memblock_setclr_flag fndecl 2-1 62013 NULL
 srp_map_sg_fr_fndecl_62023_fields srp_map_sg_fr fndecl 0 62023 NULL
 size_mtd_blktrans_dev_62024_fields size mtd_blktrans_dev 0 62024 NULL
@@ -15253,6 +15510,7 @@ max_pkt_size_em28xx_62196_fields max_pkt_size em28xx 0 62196 NULL
 snd_cwnd_clamp_tcp_sock_62197_fields snd_cwnd_clamp tcp_sock 0 62197 NULL
 maxframe_caifsock_62201_fields maxframe caifsock 0 62201 NULL
 at24_eeprom_write_smbus_block_fndecl_62212_fields at24_eeprom_write_smbus_block fndecl 3-4 62212 NULL
+size_max_gb_loopback_device_62219_fields size_max gb_loopback_device 0 62219 NULL
 generic_file_direct_write_fndecl_62226_fields generic_file_direct_write fndecl 0 62226 NULL
 datainterval_snd_usb_endpoint_62227_fields datainterval snd_usb_endpoint 0 62227 NULL
 svm_create_vcpu_fndecl_62239_fields svm_create_vcpu fndecl 2 62239 NULL
@@ -15316,6 +15574,7 @@ npods_cxgbi_task_tag_info_62453_fields npods cxgbi_task_tag_info 0 62453 NULL
 lower_offset_skb_seq_state_62465_fields lower_offset skb_seq_state 0 62465 NULL
 ipx_recvmsg_fndecl_62469_fields ipx_recvmsg fndecl 3 62469 NULL
 ram_alignment_fndecl_62470_fields ram_alignment fndecl 0 62470 NULL
+payload_bytes_controlvm_message_header_62474_fields payload_bytes controlvm_message_header 0 62474 NULL
 page_size_mspro_block_data_62479_fields page_size mspro_block_data 0 62479 NULL
 fw_stats_bus_myri10ge_slice_state_62482_fields fw_stats_bus myri10ge_slice_state 0 62482 NULL
 rx_ring_tail_sc92031_priv_62486_fields rx_ring_tail sc92031_priv 0 62486 NULL
@@ -15354,6 +15613,7 @@ min_pkt_size_pktgen_dev_62629_fields min_pkt_size pktgen_dev 0 62629 NULL
 virtio_gpu_ttm_tt_create_fndecl_62636_fields virtio_gpu_ttm_tt_create fndecl 2 62636 NULL nohasharray
 wil_change_mtu_fndecl_62636_fields wil_change_mtu fndecl 2 62636 &virtio_gpu_ttm_tt_create_fndecl_62636_fields
 ath6kl_wmi_get_stats_cmd_fndecl_62638_fields ath6kl_wmi_get_stats_cmd fndecl 2 62638 NULL
+fts_rtllib_device_62643_fields fts rtllib_device 0 62643 NULL
 cfg_sg_seg_cnt_lpfc_hba_62646_fields cfg_sg_seg_cnt lpfc_hba 0 62646 NULL
 curr_len_max3421_hcd_62658_fields curr_len max3421_hcd 0 62658 NULL
 irq_max_tg3_62664_fields irq_max tg3 0 62664 NULL
@@ -15374,6 +15634,7 @@ curwidth_usb_usbvision_62710_fields curwidth usb_usbvision 0 62710 NULL
 mtu_ring_info_62721_fields mtu ring_info 0 62721 NULL
 jffs2_write_begin_fndecl_62728_fields jffs2_write_begin fndecl 3 62728 NULL nohasharray
 limit_tc_sfq_qopt_62728_fields limit tc_sfq_qopt 0 62728 &jffs2_write_begin_fndecl_62728_fields
+total_len_android_wifi_priv_cmd_62735_fields total_len android_wifi_priv_cmd 0 62735 NULL
 smi_read_eeprom_fndecl_62737_fields smi_read_eeprom fndecl 4 62737 NULL
 xfs_da_read_buf_fndecl_62739_fields xfs_da_read_buf fndecl 3 62739 NULL nohasharray
 mlx5_pci_enable_sriov_fndecl_62739_fields mlx5_pci_enable_sriov fndecl 2 62739 &xfs_da_read_buf_fndecl_62739_fields
@@ -15415,7 +15676,8 @@ midi_in_ports_snd_efw_62902_fields midi_in_ports snd_efw 0 62902 NULL
 xfs_init_local_fork_fndecl_62904_fields xfs_init_local_fork fndecl 4 62904 NULL
 arg2__cdrp_cmd_62906_fields arg2 _cdrp_cmd 0 62906 NULL
 length_uvc_buffer_62907_fields length uvc_buffer 0 62907 NULL
-buflen_xdr_buf_62914_fields buflen xdr_buf 0 62914 NULL
+buflen_xdr_buf_62914_fields buflen xdr_buf 0 62914 NULL nohasharray
+n_subdevices_comedi_device_62914_fields n_subdevices comedi_device 0 62914 &buflen_xdr_buf_62914_fields
 uar_size_mthca_dev_lim_62925_fields uar_size mthca_dev_lim 0 62925 NULL
 teiup_create_fndecl_62930_fields teiup_create fndecl 3 62930 NULL nohasharray
 queue_size_srp_target_port_62930_fields queue_size srp_target_port 0 62930 &teiup_create_fndecl_62930_fields
@@ -15517,6 +15779,7 @@ ep_image_mts_desc_63258_fields ep_image mts_desc 0 63258 NULL
 pdu_write_u_fndecl_63261_fields pdu_write_u fndecl 3 63261 NULL
 sch56xx_device_add_fndecl_63264_fields sch56xx_device_add fndecl 1 63264 NULL
 _fc_frame_alloc_fndecl_63267_fields _fc_frame_alloc fndecl 1 63267 NULL
+version_size_ks_wlan_private_63280_fields version_size ks_wlan_private 0 63280 NULL
 s_mb_last_start_ext4_sb_info_63283_fields s_mb_last_start ext4_sb_info 0 63283 NULL
 num_counters_ebt_replace_63286_fields num_counters ebt_replace 0 63286 NULL
 xprt_rdma_slot_table_entries_vardecl_transport_c_63290_fields xprt_rdma_slot_table_entries vardecl_transport.c 0 63290 NULL
@@ -15530,7 +15793,8 @@ doorbell_start_offset_kgd2kfd_shared_resources_63332_fields doorbell_start_offse
 gf100_vm_create_fndecl_63335_fields gf100_vm_create fndecl 3-2 63335 NULL
 bulk_out_endpointAddress_usb_serial_port_63340_fields bulk_out_endpointAddress usb_serial_port 0 63340 NULL
 clipcount_out_vivid_dev_63343_fields clipcount_out vivid_dev 0 63343 NULL
-len_n_flags_iwl_rx_packet_63345_fields len_n_flags iwl_rx_packet 0 63345 NULL
+len_n_flags_iwl_rx_packet_63345_fields len_n_flags iwl_rx_packet 0 63345 NULL nohasharray
+pf_cids_qed_cdu_iids_63345_fields pf_cids qed_cdu_iids 0 63345 &len_n_flags_iwl_rx_packet_63345_fields
 src_offset_scif_copy_work_63353_fields src_offset scif_copy_work 0 63353 NULL
 x_zoran_overlay_settings_63359_fields x zoran_overlay_settings 0 63359 NULL
 lbq_buf_size_rx_ring_63363_fields lbq_buf_size rx_ring 0 63363 NULL
@@ -15607,7 +15871,8 @@ rx_mtu_p54_common_63619_fields rx_mtu p54_common 0 63619 NULL
 len_fscrypt_str_63626_fields len fscrypt_str 0 63626 NULL
 buf_len_mwifiex_sdio_mpa_rx_63636_fields buf_len mwifiex_sdio_mpa_rx 0 63636 NULL nohasharray
 find_run_fndecl_63636_fields find_run fndecl 0 63636 &buf_len_mwifiex_sdio_mpa_rx_63636_fields
-be_v_offset_pnfs_block_extent_63637_fields be_v_offset pnfs_block_extent 0 63637 NULL
+be_v_offset_pnfs_block_extent_63637_fields be_v_offset pnfs_block_extent 0 63637 NULL nohasharray
+rx_ring_size_gfar_priv_rx_q_63637_fields rx_ring_size gfar_priv_rx_q 0 63637 &be_v_offset_pnfs_block_extent_63637_fields
 snic_queue_wq_desc_fndecl_63639_fields snic_queue_wq_desc fndecl 3 63639 NULL
 nfs_writepage_setup_fndecl_63682_fields nfs_writepage_setup fndecl 3-4 63682 NULL
 height_ssd1307fb_par_63688_fields height ssd1307fb_par 0 63688 NULL
@@ -15696,7 +15961,8 @@ iomap_end_iomap_ops_63997_fields iomap_end iomap_ops 0 63997 NULL
 vram_start_amdgpu_mc_63998_fields vram_start amdgpu_mc 0 63998 NULL
 iscsi_conn_send_pdu_fndecl_64002_fields iscsi_conn_send_pdu fndecl 4 64002 NULL
 pvr2_send_request_ex_fndecl_64004_fields pvr2_send_request_ex fndecl 5-7 64004 NULL
-max_wr_qedr_qp_hwq_info_64005_fields max_wr qedr_qp_hwq_info 0 64005 NULL
+max_wr_qedr_qp_hwq_info_64005_fields max_wr qedr_qp_hwq_info 0 64005 NULL nohasharray
+ndescs_clk_corediv_soc_desc_64005_fields ndescs clk_corediv_soc_desc 0 64005 &max_wr_qedr_qp_hwq_info_64005_fields
 field_count_audit_krule_64007_fields field_count audit_krule 0 64007 NULL
 rx_ring_size_fe_priv_64012_fields rx_ring_size fe_priv 0 64012 NULL
 wBlocks_usb_rpipe_descriptor_64014_fields wBlocks usb_rpipe_descriptor 0 64014 NULL
@@ -15930,6 +16196,7 @@ pci_iov_virtfn_bus_fndecl_64949_fields pci_iov_virtfn_bus fndecl 0-2 64949 NULL
 ieee80211_tdls_add_ies_fndecl_64954_fields ieee80211_tdls_add_ies fndecl 8 64954 NULL
 qed_ll2_acquire_connection_tx_fndecl_64955_fields qed_ll2_acquire_connection_tx fndecl 3 64955 NULL
 status_spi_message_64956_fields status spi_message 0 64956 NULL
+op_max_pages_md_op_data_64968_fields op_max_pages md_op_data 0 64968 NULL
 len_ctrl_queue_64975_fields len ctrl_queue 0 64975 NULL
 print_pkt_fndecl_64981_fields print_pkt fndecl 2 64981 NULL
 rp2_alloc_ports_fndecl_64987_fields rp2_alloc_ports fndecl 0-1 64987 NULL nohasharray
@@ -15956,6 +16223,7 @@ len_scifioctl_reg_65083_fields len scifioctl_reg 0 65083 NULL
 frame_size_pwc_device_65084_fields frame_size pwc_device 0 65084 NULL
 fcoe_len_fcoe_rport_65085_fields fcoe_len fcoe_rport 0 65085 NULL
 width_cx88_core_65086_fields width cx88_core 0 65086 NULL
+size_ion_test_rw_data_65088_fields size ion_test_rw_data 0 65088 NULL
 queue_depth_se_node_acl_65089_fields queue_depth se_node_acl 0 65089 NULL
 sco_send_frame_fndecl_65092_fields sco_send_frame fndecl 3 65092 NULL
 fat_write_end_fndecl_65095_fields fat_write_end fndecl 5 65095 NULL
@@ -16013,6 +16281,7 @@ update_stat_data_fndecl_65289_fields update_stat_data fndecl 3 65289 NULL
 ntfs_bmap_fndecl_65300_fields ntfs_bmap fndecl 2 65300 NULL
 memory_lseek_fndecl_65306_fields memory_lseek fndecl 2 65306 NULL
 ext4_dio_get_block_unwritten_sync_fndecl_65307_fields ext4_dio_get_block_unwritten_sync fndecl 2 65307 NULL
+in_param_mlx4_vhcr_65311_fields in_param mlx4_vhcr 0 65311 NULL
 mt312_read_fndecl_65312_fields mt312_read fndecl 4 65312 NULL
 max_pfn_vardecl_65317_fields max_pfn vardecl 0 65317 NULL
 ExtPageLength__MPI2_CONFIG_REPLY_65319_fields ExtPageLength _MPI2_CONFIG_REPLY 0 65319 NULL
diff --git a/scripts/gcc-plugins/size_overflow_plugin/e_fns.data b/scripts/gcc-plugins/size_overflow_plugin/e_fns.data
index 2798cd6d950d..077b4339b9bc 100644
--- a/scripts/gcc-plugins/size_overflow_plugin/e_fns.data
+++ b/scripts/gcc-plugins/size_overflow_plugin/e_fns.data
@@ -58,6 +58,7 @@ xfs_buf_get_map_fndecl_729_fns xfs_buf_get_map fndecl 3 729 NULL
 sdp1length__SpiCfgData_813_fns sdp1length _SpiCfgData 0 813 NULL
 request_key_auth_read_fndecl_830_fns request_key_auth_read fndecl 3 830 NULL
 pipeline_post_proc_swi_read_fndecl_831_fns pipeline_post_proc_swi_read fndecl 3 831 NULL
+_picolcd_flash_write_fndecl_853_fns _picolcd_flash_write fndecl 4 853 NULL
 irnet_ctrl_write_fndecl_856_fns irnet_ctrl_write fndecl 3 856 NULL
 dvb_register_media_device_fndecl_878_fns dvb_register_media_device fndecl 4 878 NULL
 field_count_audit_rule_data_886_fns field_count audit_rule_data 0 886 NULL
@@ -65,6 +66,7 @@ octeon_read_device_mem64_fndecl_892_fns octeon_read_device_mem64 fndecl 0 892 NU
 tcpprobe_sprint_fndecl_909_fns tcpprobe_sprint fndecl 0 909 NULL
 max_reply_bytes_mpt3_ioctl_command_918_fns max_reply_bytes mpt3_ioctl_command 0 918 NULL
 vmsplice_to_pipe_fndecl_937_fns vmsplice_to_pipe fndecl 3 937 NULL
+icmp_len_batadv_socket_packet_944_fns icmp_len batadv_socket_packet 0 944 NULL
 pcpu_embed_first_chunk_fndecl_947_fns pcpu_embed_first_chunk fndecl 1-2-3 947 NULL
 sel_read_bool_fndecl_959_fns sel_read_bool fndecl 3 959 NULL
 compat_sys_preadv64_fndecl_968_fns compat_sys_preadv64 fndecl 3 968 NULL
@@ -78,8 +80,10 @@ line__mgslpc_info_1070_fns line _mgslpc_info 0 1070 NULL
 b_cnt_mon_reader_bin_1106_fns b_cnt mon_reader_bin 0 1106 NULL
 create_attr_set_fndecl_1118_fns create_attr_set fndecl 1 1118 NULL
 mdc800_device_read_fndecl_1123_fns mdc800_device_read fndecl 3 1123 NULL
+ion_handle_test_kernel_fndecl_1127_fns ion_handle_test_kernel fndecl 3-4 1127 NULL
 xstateregs_set_fndecl_1159_fns xstateregs_set fndecl 4 1159 NULL
 nfs4_acl_bytes_fndecl_1168_fns nfs4_acl_bytes fndecl 0-1 1168 NULL
+vme_get_size_fndecl_1191_fns vme_get_size fndecl 0 1191 NULL
 tx_frag_key_not_found_read_fndecl_1192_fns tx_frag_key_not_found_read fndecl 3 1192 NULL
 pcpu_mem_zalloc_fndecl_1207_fns pcpu_mem_zalloc fndecl 1 1207 NULL
 gtp_hashtable_new_fndecl_1236_fns gtp_hashtable_new fndecl 2 1236 NULL
@@ -91,6 +95,7 @@ viafb_dvp0_proc_write_fndecl_1276_fns viafb_dvp0_proc_write fndecl 3 1276 NULL
 agp_alloc_page_array_fndecl_1289_fns agp_alloc_page_array fndecl 1 1289 NULL
 vd_cbr_au_count_gru_vma_data_1314_fns vd_cbr_au_count gru_vma_data 0 1314 NULL
 ccp_set_dm_area_fndecl_1351_fns ccp_set_dm_area fndecl 4 1351 NULL
+cfs_expr_list_values_fndecl_1371_fns cfs_expr_list_values fndecl 0 1371 NULL
 sctp_setsockopt_connectx_old_fndecl_1396_fns sctp_setsockopt_connectx_old fndecl 3 1396 NULL
 wl1271_rx_filter_get_fields_size_fndecl_1405_fns wl1271_rx_filter_get_fields_size fndecl 0 1405 NULL
 call_netdevice_notifiers_fndecl_1411_fns call_netdevice_notifiers fndecl 0 1411 NULL
@@ -102,21 +107,26 @@ idma64_alloc_desc_fndecl_1433_fns idma64_alloc_desc fndecl 1 1433 NULL
 nr_cpusets_fndecl_1442_fns nr_cpusets fndecl 0 1442 NULL
 memcg_update_list_lru_node_fndecl_1454_fns memcg_update_list_lru_node fndecl 3 1454 NULL
 sys_ppoll_fndecl_1459_fns sys_ppoll fndecl 2 1459 NULL
+iio_debugfs_write_reg_fndecl_1477_fns iio_debugfs_write_reg fndecl 3 1477 NULL
 cx18_copy_buf_to_user_fndecl_1500_fns cx18_copy_buf_to_user fndecl 4 1500 NULL
 qlcnic_sriov_init_fndecl_1529_fns qlcnic_sriov_init fndecl 2 1529 NULL
 i2cdev_write_fndecl_1565_fns i2cdev_write fndecl 3 1565 NULL
+libcfs_kvzalloc_fndecl_1568_fns libcfs_kvzalloc fndecl 1 1568 NULL
 page_readlink_fndecl_1569_fns page_readlink fndecl 3 1569 NULL
 error_error_frame_non_ctrl_read_fndecl_1589_fns error_error_frame_non_ctrl_read fndecl 3 1589 NULL
 size_icp_qat_uof_batch_init_1600_fns size icp_qat_uof_batch_init 0 1600 NULL
 skl_get_module_param_size_fndecl_1615_fns skl_get_module_param_size fndecl 0 1615 NULL
 copied_rpc_pipe_msg_1658_fns copied rpc_pipe_msg 0 1658 NULL
 hidraw_send_report_fndecl_1674_fns hidraw_send_report fndecl 3 1674 NULL
+gb_hid_alloc_buffers_fndecl_1705_fns gb_hid_alloc_buffers fndecl 2 1705 NULL
 linear_conf_fndecl_1710_fns linear_conf fndecl 2 1710 NULL
+aead_edesc_alloc_fndecl_1730_fns aead_edesc_alloc fndecl 2 1730 NULL
 devm_iio_device_alloc_fndecl_1732_fns devm_iio_device_alloc fndecl 2 1732 NULL
 skl_set_module_params_fndecl_1736_fns skl_set_module_params fndecl 3 1736 NULL
 compat_filldir_fndecl_1746_fns compat_filldir fndecl 3 1746 NULL
 it_context_mask_fw_ohci_1753_fns it_context_mask fw_ohci 0 1753 NULL
 ima_show_measurements_count_fndecl_1763_fns ima_show_measurements_count fndecl 3 1763 NULL
+libcfs_kkuc_group_add_fndecl_1809_fns libcfs_kkuc_group_add fndecl 5 1809 NULL
 num_vectors_e1000_adapter_1827_fns num_vectors e1000_adapter 0 1827 NULL
 __add_prelim_ref_fndecl_1828_fns __add_prelim_ref fndecl 2 1828 NULL
 ntfs_ucstonls_fndecl_1834_fns ntfs_ucstonls fndecl 3-5 1834 NULL
@@ -140,13 +150,17 @@ response_length_mlx5_ib_create_rwq_ind_tbl_resp_1977_fns response_length mlx5_ib
 alauda_read_block_fndecl_2008_fns alauda_read_block fndecl 4 2008 NULL
 xlog_recovery_process_trans_fndecl_2013_fns xlog_recovery_process_trans fndecl 4 2013 NULL
 diva_get_trace_filter_fndecl_2021_fns diva_get_trace_filter fndecl 0 2021 NULL
+kmalloc_order_trace_fndecl_2063_fns kmalloc_order_trace fndecl 1 2063 NULL
 dvb_generic_ioctl_fndecl_2081_fns dvb_generic_ioctl fndecl 2 2081 NULL
 min_odd_fndecl_2105_fns min_odd fndecl 0-1-2 2105 NULL
+qsfp1_debugfs_read_fndecl_2107_fns qsfp1_debugfs_read fndecl 3 2107 NULL
 oom_adj_read_fndecl_2116_fns oom_adj_read fndecl 3 2116 NULL
+lmv_mds_md_stripe_count_get_fndecl_2118_fns lmv_mds_md_stripe_count_get fndecl 0 2118 NULL
 gen_unique_name_fndecl_2127_fns gen_unique_name fndecl 0 2127 NULL
 synic_set_msr_fndecl_2149_fns synic_set_msr fndecl 3 2149 NULL
 __kfifo_dma_out_prepare_fndecl_2165_fns __kfifo_dma_out_prepare fndecl 4 2165 NULL
 qsfp_1_read_fndecl_2184_fns qsfp_1_read fndecl 3 2184 NULL
+ldlm_lock_create_fndecl_2195_fns ldlm_lock_create fndecl 7 2195 NULL
 SYSC_prctl_fndecl_2255_fns SYSC_prctl fndecl 4 2255 NULL
 compat_rw_copy_check_uvector_fndecl_2274_fns compat_rw_copy_check_uvector fndecl 3 2274 NULL nohasharray
 rxpipe_descr_host_int_trig_rx_data_read_fndecl_2274_fns rxpipe_descr_host_int_trig_rx_data_read fndecl 3 2274 &compat_rw_copy_check_uvector_fndecl_2274_fns
@@ -160,15 +174,19 @@ smtcfb_write_fndecl_2433_fns smtcfb_write fndecl 3 2433 NULL nohasharray
 qedr_alloc_mr_fndecl_2433_fns qedr_alloc_mr fndecl 3 2433 &smtcfb_write_fndecl_2433_fns
 tomoyo_read_control_fndecl_2465_fns tomoyo_read_control fndecl 3 2465 NULL
 regmap_register_patch_fndecl_2466_fns regmap_register_patch fndecl 3 2466 NULL
-proc_maps_open_fndecl_2468_fns proc_maps_open fndecl 4 2468 NULL
+proc_maps_open_fndecl_2468_fns proc_maps_open fndecl 4 2468 NULL nohasharray
+rtllib_alloc_txb_fndecl_2468_fns rtllib_alloc_txb fndecl 1 2468 &proc_maps_open_fndecl_2468_fns
 evdev_ioctl_handler_fndecl_2522_fns evdev_ioctl_handler fndecl 2 2522 NULL
+lprocfs_wr_import_fndecl_2547_fns lprocfs_wr_import fndecl 3 2547 NULL
 __kmem_cache_alias_fndecl_2551_fns __kmem_cache_alias fndecl 3 2551 NULL
 dma_maxpq_fndecl_2555_fns dma_maxpq fndecl 0 2555 NULL
 __tun_chr_ioctl_fndecl_2575_fns __tun_chr_ioctl fndecl 4 2575 NULL
 of_phandle_iterator_init_fndecl_2614_fns of_phandle_iterator_init fndecl 0 2614 NULL
+crc_size_vardecl_pm_check_c_2624_fns crc_size vardecl_pm-check.c 0 2624 NULL
 alloc_large_system_hash_fndecl_2660_fns alloc_large_system_hash fndecl 2 2660 NULL
 evdev_ioctl_fndecl_2672_fns evdev_ioctl fndecl 2 2672 NULL
 queue_reply_fndecl_2691_fns queue_reply fndecl 3 2691 NULL
+aic_common_of_init_fndecl_2752_fns aic_common_of_init fndecl 4 2752 NULL
 cache_write_procfs_fndecl_2760_fns cache_write_procfs fndecl 3 2760 NULL
 qib_user_sdma_alloc_header_fndecl_2761_fns qib_user_sdma_alloc_header fndecl 2 2761 NULL
 ieee80211_alloc_hw_nm_fndecl_2774_fns ieee80211_alloc_hw_nm fndecl 1 2774 NULL
@@ -186,12 +204,14 @@ bpw_len_pch_spi_data_3026_fns bpw_len pch_spi_data 0 3026 NULL
 fat_compat_ioctl_filldir_fndecl_3037_fns fat_compat_ioctl_filldir fndecl 3 3037 NULL
 add_res_tree_fndecl_3044_fns add_res_tree fndecl 7 3044 NULL
 compat_process_vm_rw_fndecl_3069_fns compat_process_vm_rw fndecl 5-3 3069 NULL
-npages_mthca_db_table_3090_fns npages mthca_db_table 0 3090 NULL
+npages_mthca_db_table_3090_fns npages mthca_db_table 0 3090 NULL nohasharray
+ad7280_write_fndecl_3090_fns ad7280_write fndecl 0 3090 &npages_mthca_db_table_3090_fns
 fb_prepare_logo_fndecl_3092_fns fb_prepare_logo fndecl 0 3092 NULL
 loopstart_soundfont_sample_info_3093_fns loopstart soundfont_sample_info 0 3093 NULL
 rx_pkt_map_sz_tg3_3106_fns rx_pkt_map_sz tg3 0 3106 NULL
 mt76_init_sband_fndecl_3112_fns mt76_init_sband fndecl 6 3112 NULL
 compat_filldir64_fndecl_3119_fns compat_filldir64 fndecl 3 3119 NULL
+ds9490r_write_block_fndecl_3142_fns ds9490r_write_block fndecl 3 3142 NULL
 sys_sendto_fndecl_3162_fns sys_sendto fndecl 6 3162 NULL
 fill_elf_header_fndecl_3182_fns fill_elf_header fndecl 2 3182 NULL
 wl1271_format_buffer_fndecl_3185_fns wl1271_format_buffer fndecl 2 3185 NULL
@@ -199,6 +219,7 @@ uvc_alloc_entity_fndecl_3191_fns uvc_alloc_entity fndecl 4 3191 NULL
 nvme_trans_supported_vpd_pages_fndecl_3196_fns nvme_trans_supported_vpd_pages fndecl 4 3196 NULL
 p9_tag_alloc_fndecl_3198_fns p9_tag_alloc fndecl 3 3198 NULL
 import_iovec_fndecl_3201_fns import_iovec fndecl 3 3201 NULL
+cfs_cpt_table_create_fndecl_3207_fns cfs_cpt_table_create fndecl 1 3207 NULL
 nportcntrs_hfi1_devdata_3218_fns nportcntrs hfi1_devdata 0 3218 NULL
 command_setexposure_fndecl_3231_fns command_setexposure fndecl 0 3231 NULL
 lbs_rdbbp_write_fndecl_3237_fns lbs_rdbbp_write fndecl 3 3237 NULL
@@ -214,6 +235,7 @@ alg_setsockopt_fndecl_3306_fns alg_setsockopt fndecl 5 3306 NULL
 snd_rme9652_playback_copy_fndecl_3321_fns snd_rme9652_playback_copy fndecl 5 3321 NULL
 length_ima_digest_data_3329_fns length ima_digest_data 0 3329 NULL
 hidraw_report_event_fndecl_3332_fns hidraw_report_event fndecl 3 3332 NULL
+add_desc_fndecl_3339_fns add_desc fndecl 3 3339 NULL
 memcg_update_list_lru_fndecl_3349_fns memcg_update_list_lru fndecl 3 3349 NULL
 fast_user_write_fndecl_3357_fns fast_user_write fndecl 5 3357 NULL
 amd_create_gatt_pages_fndecl_3370_fns amd_create_gatt_pages fndecl 1 3370 NULL
@@ -222,9 +244,11 @@ scsi_report_opcode_fndecl_3412_fns scsi_report_opcode fndecl 3 3412 NULL
 udf_getblk_fndecl_3436_fns udf_getblk fndecl 2 3436 NULL
 command_setcolourbalance_fndecl_3441_fns command_setcolourbalance fndecl 0 3441 NULL
 copy_arg_to_user_fndecl_3464_fns copy_arg_to_user fndecl 3 3464 NULL
+stm32_dma_prep_dma_cyclic_fndecl_3466_fns stm32_dma_prep_dma_cyclic fndecl 4-3 3466 NULL
 qib_qsfp_write_fndecl_3477_fns qib_qsfp_write fndecl 2-4-0 3477 NULL
 rx_buf_size__mgslpc_info_3490_fns rx_buf_size _mgslpc_info 0 3490 NULL
 kfifo_copy_to_user_fndecl_3509_fns kfifo_copy_to_user fndecl 3-4 3509 NULL
+fifo_size_qcom_smd_channel_3531_fns fifo_size qcom_smd_channel 0 3531 NULL
 snd_hdsp_playback_copy_fndecl_3543_fns snd_hdsp_playback_copy fndecl 5 3543 NULL
 dvb_dmxdev_buffer_read_fndecl_3545_fns dvb_dmxdev_buffer_read fndecl 4 3545 NULL
 security_context_to_sid_force_fndecl_3559_fns security_context_to_sid_force fndecl 2 3559 NULL
@@ -232,6 +256,7 @@ _snd_pcm_new_fndecl_3575_fns _snd_pcm_new fndecl 4-5 3575 NULL
 len_capiloaddatapart_3577_fns len capiloaddatapart 0 3577 NULL
 pcpu_page_first_chunk_fndecl_3579_fns pcpu_page_first_chunk fndecl 1 3579 NULL
 asq_buf_size_i40e_adminq_info_3582_fns asq_buf_size i40e_adminq_info 0 3582 NULL
+bcm2835_dma_prep_dma_cyclic_fndecl_3588_fns bcm2835_dma_prep_dma_cyclic fndecl 4-3 3588 NULL
 net_rx_queue_update_kobjects_fndecl_3617_fns net_rx_queue_update_kobjects fndecl 0 3617 NULL
 do_msg_fill_fndecl_3624_fns do_msg_fill fndecl 3 3624 NULL
 add_res_range_fndecl_3629_fns add_res_range fndecl 4 3629 NULL
@@ -241,6 +266,8 @@ c_plan_ahead_disk_conf_3660_fns c_plan_ahead disk_conf 0 3660 NULL
 pcpu_chunk_struct_size_vardecl_percpu_c_3673_fns pcpu_chunk_struct_size vardecl_percpu.c 0 3673 NULL
 alloc_orinocodev_fndecl_3688_fns alloc_orinocodev fndecl 1 3688 NULL
 read_file_bool_bmps_fndecl_3699_fns read_file_bool_bmps fndecl 3 3699 NULL
+srp_max_rsp_size_srpt_port_attrib_3700_fns srp_max_rsp_size srpt_port_attrib 0 3700 NULL
+allocate_cmdlines_buffer_fndecl_3704_fns allocate_cmdlines_buffer fndecl 1 3704 NULL
 ip_getsockopt_fndecl_3711_fns ip_getsockopt fndecl 0 3711 NULL
 diva_get_driver_dbg_mask_fndecl_3716_fns diva_get_driver_dbg_mask fndecl 0 3716 NULL
 SYSC_rt_sigpending_fndecl_3728_fns SYSC_rt_sigpending fndecl 2 3728 NULL
@@ -272,6 +299,7 @@ virtio_gpu_get_capsets_fndecl_3928_fns virtio_gpu_get_capsets fndecl 2 3928 NULL
 ath6kl_send_go_probe_resp_fndecl_3946_fns ath6kl_send_go_probe_resp fndecl 3 3946 NULL
 _efx_mcdi_rpc_async_fndecl_3948_fns _efx_mcdi_rpc_async fndecl 4-5 3948 NULL
 make_le_item_head_fndecl_3961_fns make_le_item_head fndecl 5 3961 NULL
+max_ti_iu_len_srp_rdma_ch_3984_fns max_ti_iu_len srp_rdma_ch 0 3984 NULL
 nv50_chan_create_fndecl_3986_fns nv50_chan_create fndecl 6 3986 NULL
 format_supported_num_psb_intel_sdvo_connector_4007_fns format_supported_num psb_intel_sdvo_connector 0 4007 NULL
 bioset_create_nobvec_fndecl_4015_fns bioset_create_nobvec fndecl 1 4015 NULL
@@ -281,6 +309,7 @@ cx18_v4l2_read_fndecl_4063_fns cx18_v4l2_read fndecl 3 4063 NULL
 input_ff_create_fndecl_4075_fns input_ff_create fndecl 2 4075 NULL
 ring_overflow_per_user_data_4076_fns ring_overflow per_user_data 0 4076 NULL
 mlx4_en_get_num_flows_fndecl_4078_fns mlx4_en_get_num_flows fndecl 0 4078 NULL
+read_ftrace_buffer_info_4082_fns read ftrace_buffer_info 0 4082 NULL
 kvm_vcpu_read_guest_page_fndecl_4083_fns kvm_vcpu_read_guest_page fndecl 2-5 4083 NULL
 __rvt_alloc_mr_fndecl_4129_fns __rvt_alloc_mr fndecl 1 4129 NULL
 struct_size_rmi_register_descriptor_4163_fns struct_size rmi_register_descriptor 0 4163 NULL
@@ -291,20 +320,25 @@ irda_setsockopt_fndecl_4195_fns irda_setsockopt fndecl 5 4195 &stm_char_write_fn
 vfs_getxattr_fndecl_4203_fns vfs_getxattr fndecl 0 4203 NULL
 dlm_lock_fndecl_4225_fns dlm_lock fndecl 6 4225 NULL nohasharray
 nilfs_segbuf_map_fndecl_4225_fns nilfs_segbuf_map fndecl 2 4225 &dlm_lock_fndecl_4225_fns
+num_lut_dmm_4228_fns num_lut dmm 0 4228 NULL
 cfg80211_mlme_register_mgmt_fndecl_4255_fns cfg80211_mlme_register_mgmt fndecl 5 4255 NULL
-qlcnic_sysfs_read_pci_config_fndecl_4270_fns qlcnic_sysfs_read_pci_config fndecl 6 4270 NULL
+qlcnic_sysfs_read_pci_config_fndecl_4270_fns qlcnic_sysfs_read_pci_config fndecl 6 4270 NULL nohasharray
+xgbe_init_ring_fndecl_4270_fns xgbe_init_ring fndecl 3 4270 &qlcnic_sysfs_read_pci_config_fndecl_4270_fns
 mangle_name_fndecl_4288_fns mangle_name fndecl 0 4288 NULL
 connector_count_drm_fb_helper_4290_fns connector_count drm_fb_helper 0 4290 NULL
 cgroup_task_count_fndecl_4297_fns cgroup_task_count fndecl 0 4297 NULL
 key_size_pkcs1pad_ctx_4303_fns key_size pkcs1pad_ctx 0 4303 NULL
+raid56_alloc_missing_rbio_fndecl_4316_fns raid56_alloc_missing_rbio fndecl 4 4316 NULL
 ps_upsd_max_apturn_read_fndecl_4317_fns ps_upsd_max_apturn_read fndecl 3 4317 NULL
 ax25_send_frame_fndecl_4335_fns ax25_send_frame fndecl 2 4335 NULL
 stripe_len_btrfs_raid_bio_4340_fns stripe_len btrfs_raid_bio 0 4340 NULL
+pxad_prep_dma_cyclic_fndecl_4411_fns pxad_prep_dma_cyclic fndecl 4-3 4411 NULL
 nfc_llcp_build_tlv_fndecl_4419_fns nfc_llcp_build_tlv fndecl 3 4419 NULL
 batadv_tvlv_container_register_fndecl_4435_fns batadv_tvlv_container_register fndecl 5 4435 NULL
 jfs_fsync_fndecl_4436_fns jfs_fsync fndecl 2-3 4436 NULL
 nfsd_read_fndecl_4451_fns nfsd_read fndecl 5 4451 NULL
 compress_raw_buf_fndecl_4453_fns compress_raw_buf fndecl 0 4453 NULL
+n_comedi_insn_4458_fns n comedi_insn 0 4458 NULL
 bm_status_read_fndecl_4460_fns bm_status_read fndecl 3 4460 NULL
 sftid_base_tid_info_4462_fns sftid_base tid_info 0 4462 NULL
 rx_ring_size_altera_tse_private_4470_fns rx_ring_size altera_tse_private 0 4470 NULL
@@ -316,6 +350,7 @@ nr_chans_solo_dev_4552_fns nr_chans solo_dev 0 4552 NULL
 acpi_read_slow_fndecl_4554_fns acpi_read_slow fndecl 3-2 4554 NULL
 LoadBitmap_fndecl_4569_fns LoadBitmap fndecl 2 4569 NULL
 ptr_ring_resize_multiple_fndecl_4573_fns ptr_ring_resize_multiple fndecl 2-3 4573 NULL
+wilc_spi_tx_fndecl_4583_fns wilc_spi_tx fndecl 3 4583 NULL
 hdr_dwords_verbs_txreq_4608_fns hdr_dwords verbs_txreq 0 4608 NULL
 tm6000_i2c_send_regs_fndecl_4617_fns tm6000_i2c_send_regs fndecl 5 4617 NULL
 mbox_test_message_write_fndecl_4627_fns mbox_test_message_write fndecl 3 4627 NULL
@@ -330,11 +365,13 @@ tx_tx_burst_programmed_read_fndecl_4723_fns tx_tx_burst_programmed_read fndecl 3
 smk_set_cipso_fndecl_4744_fns smk_set_cipso fndecl 3 4744 NULL
 acpi_rs_set_resource_source_fndecl_4776_fns acpi_rs_set_resource_source fndecl 0-2 4776 NULL
 __kfifo_from_user_fndecl_4796_fns __kfifo_from_user fndecl 3 4796 NULL
+axi_dmac_alloc_desc_fndecl_4833_fns axi_dmac_alloc_desc fndecl 1 4833 NULL
 read_buf_fndecl_4838_fns read_buf fndecl 2 4838 NULL
 btrfs_get_32_fndecl_4847_fns btrfs_get_32 fndecl 0 4847 NULL
 max_tgts_snic_fw_info_4861_fns max_tgts snic_fw_info 0 4861 NULL
 attach_hdlc_protocol_fndecl_4865_fns attach_hdlc_protocol fndecl 3 4865 NULL
 gfn_to_hva_memslot_prot_fndecl_4867_fns gfn_to_hva_memslot_prot fndecl 2 4867 NULL
+mlx5_ib_alloc_mr_fndecl_4870_fns mlx5_ib_alloc_mr fndecl 3 4870 NULL
 op_remote_addr_rm_atomic_op_4890_fns op_remote_addr rm_atomic_op 0 4890 NULL
 mlx4_get_eqs_per_port_fndecl_4892_fns mlx4_get_eqs_per_port fndecl 0 4892 NULL
 credits_send_context_info_4894_fns credits send_context_info 0 4894 NULL
@@ -342,19 +379,23 @@ SYSC_fgetxattr_fndecl_4904_fns SYSC_fgetxattr fndecl 4 4904 NULL
 build_verbs_ulp_payload_fndecl_4906_fns build_verbs_ulp_payload fndecl 3 4906 NULL
 diva_um_idi_read_fndecl_4912_fns diva_um_idi_read fndecl 0 4912 NULL
 tree_mod_log_eb_move_fndecl_4920_fns tree_mod_log_eb_move fndecl 5 4920 NULL
+aat2870_reg_write_file_fndecl_4965_fns aat2870_reg_write_file fndecl 3 4965 NULL
 fuse_conn_limit_read_fndecl_4967_fns fuse_conn_limit_read fndecl 3 4967 NULL
 team_options_register_fndecl_4968_fns team_options_register fndecl 3 4968 NULL
 reiserfs_dir_fsync_fndecl_4971_fns reiserfs_dir_fsync fndecl 2-3 4971 NULL
 stripe_unit_ore_layout_4991_fns stripe_unit ore_layout 0 4991 NULL
 tx_tx_retry_per_rate_read_fndecl_5009_fns tx_tx_retry_per_rate_read fndecl 3 5009 NULL
 bulk_in_size_usb_idmouse_5017_fns bulk_in_size usb_idmouse 0 5017 NULL
+ldebugfs_fid_write_common_fndecl_5049_fns ldebugfs_fid_write_common fndecl 2 5049 NULL
 jffs2_fsync_fndecl_5052_fns jffs2_fsync fndecl 2-3 5052 NULL
 offset_SVGAGuestPtr_5056_fns offset SVGAGuestPtr 0 5056 NULL
 kvm_vcpu_gfn_to_pfn_atomic_fndecl_5062_fns kvm_vcpu_gfn_to_pfn_atomic fndecl 2 5062 NULL
 tomoyo_commit_ok_fndecl_5076_fns tomoyo_commit_ok fndecl 2 5076 NULL
+read_flush_pipefs_fndecl_5080_fns read_flush_pipefs fndecl 3 5080 NULL
 ceph_alloc_page_vector_fndecl_5125_fns ceph_alloc_page_vector fndecl 1 5125 NULL
 ccp_init_sg_workarea_fndecl_5128_fns ccp_init_sg_workarea fndecl 4 5128 NULL
 fnic_stats_debugfs_read_fndecl_5139_fns fnic_stats_debugfs_read fndecl 3 5139 NULL
+echo_client_prep_commit_fndecl_5142_fns echo_client_prep_commit fndecl 8 5142 NULL
 lps_per_blk_nvm_dev_5145_fns lps_per_blk nvm_dev 0 5145 NULL
 o2hb_debug_create_fndecl_5163_fns o2hb_debug_create fndecl 4 5163 NULL
 wep_packets_read_fndecl_5164_fns wep_packets_read fndecl 3 5164 NULL
@@ -366,6 +407,7 @@ drm_ht_create_fndecl_5302_fns drm_ht_create fndecl 2 5302 NULL
 sctp_setsockopt_events_fndecl_5309_fns sctp_setsockopt_events fndecl 3 5309 NULL
 thermal_tx_stop_read_fndecl_5310_fns thermal_tx_stop_read fndecl 3 5310 NULL
 devm_mdiobus_alloc_size_fndecl_5317_fns devm_mdiobus_alloc_size fndecl 2 5317 NULL
+comedi_isadma_alloc_fndecl_5342_fns comedi_isadma_alloc fndecl 2 5342 NULL
 read_user_buf_avail_tomoyo_io_buffer_5361_fns read_user_buf_avail tomoyo_io_buffer 0 5361 NULL
 mangle_packet_fndecl_5371_fns mangle_packet fndecl 7-9 5371 NULL
 regset_tls_set_fndecl_5384_fns regset_tls_set fndecl 4 5384 NULL
@@ -374,6 +416,7 @@ snd_hda_get_connections_fndecl_5398_fns snd_hda_get_connections fndecl 0 5398 NU
 rq_size_i40iw_puda_rsrc_info_5413_fns rq_size i40iw_puda_rsrc_info 0 5413 NULL
 value_xen_pci_op_5416_fns value xen_pci_op 0 5416 NULL
 wilc_add_wep_key_bss_sta_fndecl_5436_fns wilc_add_wep_key_bss_sta fndecl 3 5436 NULL
+wiidebug_eeprom_read_fndecl_5523_fns wiidebug_eeprom_read fndecl 3 5523 NULL
 smk_write_rules_list_fndecl_5526_fns smk_write_rules_list fndecl 3 5526 NULL
 debug_output_fndecl_5532_fns debug_output fndecl 3 5532 NULL nohasharray
 tool_dbfn_read_fndecl_5532_fns tool_dbfn_read fndecl 3 5532 &debug_output_fndecl_5532_fns
@@ -389,6 +432,7 @@ xfs_cui_init_fndecl_5632_fns xfs_cui_init fndecl 2 5632 NULL nohasharray
 wbcir_tx_fndecl_5632_fns wbcir_tx fndecl 3 5632 &xfs_cui_init_fndecl_5632_fns
 dev_counters_read_fndecl_5635_fns dev_counters_read fndecl 3 5635 NULL
 tx_ring_size_altera_tse_private_5654_fns tx_ring_size altera_tse_private 0 5654 NULL
+ucma_query_fndecl_5679_fns ucma_query fndecl 4 5679 NULL
 bio_alloc_mddev_fndecl_5685_fns bio_alloc_mddev fndecl 2 5685 NULL
 batadv_tt_save_orig_buffer_fndecl_5707_fns batadv_tt_save_orig_buffer fndecl 4 5707 NULL
 event_tx_stuck_read_fndecl_5754_fns event_tx_stuck_read fndecl 3 5754 NULL
@@ -399,6 +443,7 @@ hid_hw_raw_request_fndecl_5827_fns hid_hw_raw_request fndecl 0 5827 NULL
 dvbdmx_write_fndecl_5836_fns dvbdmx_write fndecl 3 5836 NULL
 interpret_user_input_fndecl_5842_fns interpret_user_input fndecl 2 5842 NULL
 get_n_events_by_type_fndecl_5850_fns get_n_events_by_type fndecl 0 5850 NULL
+iproc_asiu_setup_fndecl_5902_fns iproc_asiu_setup fndecl 4 5902 NULL
 layout_in_gaps_fndecl_5933_fns layout_in_gaps fndecl 2 5933 NULL nohasharray
 sq_size_i40iw_puda_rsrc_info_5933_fns sq_size i40iw_puda_rsrc_info 0 5933 &layout_in_gaps_fndecl_5933_fns
 write_pmem_fndecl_5936_fns write_pmem fndecl 4 5936 NULL
@@ -426,6 +471,7 @@ brcmf_usb_attach_fndecl_6261_fns brcmf_usb_attach fndecl 2-3 6261 NULL
 sb_nextnum_nilfs_segment_buffer_6275_fns sb_nextnum nilfs_segment_buffer 0 6275 NULL
 command_setsensorfps_fndecl_6277_fns command_setsensorfps fndecl 0 6277 NULL
 nrealwriters_stress_lock_torture_cxt_6279_fns nrealwriters_stress lock_torture_cxt 0 6279 NULL
+count_leafs_fndecl_6305_fns count_leafs fndecl 0 6305 NULL
 sn9c2028_command_fndecl_6307_fns sn9c2028_command fndecl 0 6307 NULL
 shadow_fetch_fndecl_6315_fns shadow_fetch fndecl 3 6315 NULL
 len_ethtool_gstrings_6325_fns len ethtool_gstrings 0 6325 NULL
@@ -435,6 +481,7 @@ i40e_align_l2obj_base_fndecl_6341_fns i40e_align_l2obj_base fndecl 1 6341 NULL
 init_per_cpu_fndecl_6347_fns init_per_cpu fndecl 1 6347 NULL
 dev_pm_opp_get_opp_count_fndecl_6372_fns dev_pm_opp_get_opp_count fndecl 0 6372 NULL
 partition_sched_domains_fndecl_6386_fns partition_sched_domains fndecl 1 6386 NULL
+lpfc_debugfs_dif_err_write_fndecl_6403_fns lpfc_debugfs_dif_err_write fndecl 3 6403 NULL
 x509_note_serial_fndecl_6424_fns x509_note_serial fndecl 5 6424 NULL
 parse_dcb20_entry_fndecl_6440_fns parse_dcb20_entry fndecl 3 6440 NULL
 i40iw_qp_roundup_fndecl_6447_fns i40iw_qp_roundup fndecl 1 6447 NULL
@@ -457,6 +504,7 @@ pccard_store_cis_fndecl_6675_fns pccard_store_cis fndecl 6 6675 NULL
 nroots_rs_control_6706_fns nroots rs_control 0 6706 NULL
 qdisc_class_hash_alloc_fndecl_6725_fns qdisc_class_hash_alloc fndecl 1 6725 NULL
 pagesize_sddr09_card_info_6735_fns pagesize sddr09_card_info 0 6735 NULL
+hostif_mib_set_request_fndecl_6736_fns hostif_mib_set_request fndecl 3 6736 NULL
 gnttab_alloc_grant_references_fndecl_6739_fns gnttab_alloc_grant_references fndecl 1 6739 NULL
 _read_and_match_data_map_fndecl_6747_fns _read_and_match_data_map fndecl 2 6747 NULL
 rfcomm_sock_setsockopt_fndecl_6749_fns rfcomm_sock_setsockopt fndecl 5 6749 NULL
@@ -464,6 +512,7 @@ alloc_ring_fndecl_6773_fns alloc_ring fndecl 2-4 6773 NULL
 max_vals_input_dev_6777_fns max_vals input_dev 0 6777 NULL
 mmc_send_bus_test_fndecl_6782_fns mmc_send_bus_test fndecl 4 6782 NULL
 csio_mem_read_fndecl_6812_fns csio_mem_read fndecl 3 6812 NULL
+debugfs_write_file_bool_fndecl_6814_fns debugfs_write_file_bool fndecl 3 6814 NULL
 pwr_power_save_off_read_fndecl_6816_fns pwr_power_save_off_read fndecl 3 6816 NULL
 minor_miscdevice_6818_fns minor miscdevice 0 6818 NULL
 xlbd_reserve_minors_fndecl_6830_fns xlbd_reserve_minors fndecl 2-1 6830 NULL
@@ -477,6 +526,7 @@ pwr_sleep_time_count_read_fndecl_6914_fns pwr_sleep_time_count_read fndecl 3 691
 multi_src_desc_6933_fns multi src_desc 0 6933 NULL
 nvram_pagesize_tg3_6938_fns nvram_pagesize tg3 0 6938 NULL
 tlv_put_u64_fndecl_6968_fns tlv_put_u64 fndecl 0 6968 NULL
+mwifiex_verext_write_fndecl_6972_fns mwifiex_verext_write fndecl 3 6972 NULL
 pvr2_v4l2_read_fndecl_6981_fns pvr2_v4l2_read fndecl 3 6981 NULL
 bits_from_user_fndecl_6996_fns bits_from_user fndecl 2-3 6996 NULL
 fpregs_get_fndecl_7041_fns fpregs_get fndecl 4 7041 NULL
@@ -499,6 +549,7 @@ mfd_add_devices_fndecl_7183_fns mfd_add_devices fndecl 4 7183 NULL
 remote_addr_ib_atomic_wr_7192_fns remote_addr ib_atomic_wr 0 7192 NULL
 ide_init_port_fndecl_7207_fns ide_init_port fndecl 2 7207 NULL
 max_id_Scsi_Host_7217_fns max_id Scsi_Host 0 7217 NULL
+ll_unstable_stats_seq_write_fndecl_7255_fns ll_unstable_stats_seq_write fndecl 3 7255 NULL
 num_asq_entries_i40e_adminq_info_7278_fns num_asq_entries i40e_adminq_info 0 7278 NULL
 __copy_to_user_swizzled_fndecl_7295_fns __copy_to_user_swizzled fndecl 3-4 7295 NULL
 fdir_filter_count_ixgbe_adapter_7322_fns fdir_filter_count ixgbe_adapter 0 7322 NULL
@@ -512,10 +563,12 @@ block_ack_param_set_host_cmd_ds_11n_addba_req_7415_fns block_ack_param_set host_
 alloc_idx_lebs_fndecl_7419_fns alloc_idx_lebs fndecl 2 7419 NULL
 xfs_file_fsync_fndecl_7433_fns xfs_file_fsync fndecl 2-3 7433 NULL
 iio_device_add_event_fndecl_7439_fns iio_device_add_event fndecl 0 7439 NULL
+stat_st_vardecl_drv_c_7451_fns stat_st vardecl_drv.c 0 7451 NULL
 num_present_cpu_lpfc_sli4_hba_7465_fns num_present_cpu lpfc_sli4_hba 0 7465 NULL nohasharray
 cmdline_store_fndecl_7465_fns cmdline_store fndecl 4 7465 &num_present_cpu_lpfc_sli4_hba_7465_fns
 minors_gigaset_driver_7468_fns minors gigaset_driver 0 7468 NULL
 rxrpc_server_keyring_fndecl_7484_fns rxrpc_server_keyring fndecl 3 7484 NULL
+req_capsule_get_size_fndecl_7488_fns req_capsule_get_size fndecl 0 7488 NULL
 calculate_inocache_hashsize_fndecl_7506_fns calculate_inocache_hashsize fndecl 0-1 7506 NULL
 relay_consume_bytes_fndecl_7510_fns relay_consume_bytes fndecl 2 7510 NULL
 alloc_disk_node_fndecl_7513_fns alloc_disk_node fndecl 1 7513 NULL
@@ -557,10 +610,12 @@ sd_start_fndecl_7964_fns sd_start fndecl 0 7964 NULL
 squashfs_read_table_fndecl_7970_fns squashfs_read_table fndecl 3 7970 NULL
 _sp2d_alloc_fndecl_7971_fns _sp2d_alloc fndecl 3-2 7971 NULL
 acpi_tb_install_and_load_table_fndecl_7976_fns acpi_tb_install_and_load_table fndecl 2 7976 NULL
+svcxdr_dupstr_fndecl_8016_fns svcxdr_dupstr fndecl 3 8016 NULL
 keyctl_instantiate_key_iov_fndecl_8026_fns keyctl_instantiate_key_iov fndecl 3 8026 NULL
 pd_handles_sz_MPT3SAS_ADAPTER_8057_fns pd_handles_sz MPT3SAS_ADAPTER 0 8057 NULL
 ceph_read_dir_fndecl_8062_fns ceph_read_dir fndecl 3 8062 NULL
 copy_counters_to_user_fndecl_8080_fns copy_counters_to_user fndecl 5 8080 NULL
+dvb_dvr_read_fndecl_8098_fns dvb_dvr_read fndecl 3 8098 NULL
 error_num_frame_cts_nul_flid_read_fndecl_8099_fns error_num_frame_cts_nul_flid_read fndecl 3 8099 NULL
 simple_transaction_read_fndecl_8103_fns simple_transaction_read fndecl 3 8103 NULL
 acpi_ut_get_resource_header_length_fndecl_8110_fns acpi_ut_get_resource_header_length fndecl 0 8110 NULL
@@ -599,12 +654,14 @@ copy_from_user_toio_fndecl_8653_fns copy_from_user_toio fndecl 3 8653 NULL
 read_mem_fndecl_8661_fns read_mem fndecl 3 8661 NULL
 SYSC_sethostname_fndecl_8663_fns SYSC_sethostname fndecl 2 8663 NULL
 b_out_mon_reader_bin_8691_fns b_out mon_reader_bin 0 8691 NULL
-blk_mq_update_nr_requests_fndecl_8694_fns blk_mq_update_nr_requests fndecl 2 8694 NULL
+blk_mq_update_nr_requests_fndecl_8694_fns blk_mq_update_nr_requests fndecl 2 8694 NULL nohasharray
+data_width_stedma40_half_channel_info_8694_fns data_width stedma40_half_channel_info 0 8694 &blk_mq_update_nr_requests_fndecl_8694_fns
 ebcnt_vardecl_readtest_c_8699_fns ebcnt vardecl_readtest.c 0 8699 NULL
 iblock_execute_rw_fndecl_8701_fns iblock_execute_rw fndecl 3 8701 NULL
 ilo_read_fndecl_8704_fns ilo_read fndecl 3 8704 NULL
 out_ptr_mdc800_data_8709_fns out_ptr mdc800_data 0 8709 NULL
 key_len_host_if_wep_attr_8712_fns key_len host_if_wep_attr 0 8712 NULL
+rockchip_rk3399_efuse_read_fndecl_8717_fns rockchip_rk3399_efuse_read fndecl 4-2 8717 NULL
 qsfp_read_fndecl_8729_fns qsfp_read fndecl 2-4-0 8729 NULL
 ip_set_elem_len_fndecl_8730_fns ip_set_elem_len fndecl 0 8730 NULL
 alloc_state_change_fndecl_8735_fns alloc_state_change fndecl 1-2 8735 NULL
@@ -641,6 +698,7 @@ learn_buffer_len_vardecl_gracl_learn_c_9167_fns learn_buffer_len vardecl_gracl_l
 hid_input_report_fndecl_9177_fns hid_input_report fndecl 4 9177 NULL
 max_pages_ib_fmr_attr_9206_fns max_pages ib_fmr_attr 0 9206 NULL
 ide_driver_proc_write_fndecl_9214_fns ide_driver_proc_write fndecl 3 9214 NULL
+qcom_rpm_smd_write_fndecl_9229_fns qcom_rpm_smd_write fndecl 6 9229 NULL
 call_netdevice_notifiers_info_fndecl_9239_fns call_netdevice_notifiers_info fndecl 0 9239 NULL
 acpi_ns_build_normalized_path_fndecl_9269_fns acpi_ns_build_normalized_path fndecl 0 9269 NULL
 lbs_failcount_read_fndecl_9284_fns lbs_failcount_read fndecl 3 9284 NULL
@@ -660,10 +718,12 @@ maxdev_vardecl_slcan_c_9507_fns maxdev vardecl_slcan.c 0 9507 NULL
 fillonedir_fndecl_9511_fns fillonedir fndecl 3 9511 NULL
 smk_read_doi_fndecl_9550_fns smk_read_doi fndecl 3 9550 NULL
 __bio_alloc_fndecl_9552_fns __bio_alloc fndecl 3 9552 NULL
-pwr_sleep_time_avg_read_fndecl_9572_fns pwr_sleep_time_avg_read fndecl 3 9572 NULL
+pwr_sleep_time_avg_read_fndecl_9572_fns pwr_sleep_time_avg_read fndecl 3 9572 NULL nohasharray
+mvneta_frag_alloc_fndecl_9572_fns mvneta_frag_alloc fndecl 1 9572 &pwr_sleep_time_avg_read_fndecl_9572_fns
 sctp_setsockopt_auth_chunk_fndecl_9576_fns sctp_setsockopt_auth_chunk fndecl 3 9576 NULL
 of_gpio_named_count_fndecl_9578_fns of_gpio_named_count fndecl 0 9578 NULL
 get_kobj_path_length_fndecl_9596_fns get_kobj_path_length fndecl 0 9596 NULL
+frag_size_mvneta_port_9606_fns frag_size mvneta_port 0 9606 NULL
 skd_max_pass_thru_vardecl_skd_main_c_9608_fns skd_max_pass_thru vardecl_skd_main.c 0 9608 NULL
 acpi_copy_property_array_u16_fndecl_9618_fns acpi_copy_property_array_u16 fndecl 0 9618 NULL
 usnic_debugfs_buildinfo_read_fndecl_9667_fns usnic_debugfs_buildinfo_read fndecl 3 9667 NULL
@@ -673,6 +733,7 @@ tty_insert_flip_string_flags_fndecl_9706_fns tty_insert_flip_string_flags fndecl
 tx_ringsz_alx_priv_9722_fns tx_ringsz alx_priv 0 9722 NULL
 vicam_control_msg_fndecl_9727_fns vicam_control_msg fndecl 0 9727 NULL
 sg_cnt_nvmet_req_9742_fns sg_cnt nvmet_req 0 9742 NULL
+samsung_clk_sleep_init_fndecl_9743_fns samsung_clk_sleep_init fndecl 3 9743 NULL
 qsfp_2_read_fndecl_9744_fns qsfp_2_read fndecl 3 9744 NULL
 blkdev_fsync_fndecl_9745_fns blkdev_fsync fndecl 2-3 9745 NULL
 bnx2x_mcast_handle_current_cmd_fndecl_9747_fns bnx2x_mcast_handle_current_cmd fndecl 0 9747 NULL
@@ -709,13 +770,16 @@ outlen_write_fndecl_10093_fns outlen_write fndecl 3 10093 NULL
 msix_num_bnad_10096_fns msix_num bnad 0 10096 NULL
 em28xx_init_usb_xfer_fndecl_10106_fns em28xx_init_usb_xfer fndecl 4 10106 NULL
 _regmap_raw_multi_reg_write_fndecl_10107_fns _regmap_raw_multi_reg_write fndecl 3 10107 NULL
+trace_parser_get_init_fndecl_10112_fns trace_parser_get_init fndecl 2 10112 NULL
 tfms_count_crypt_config_10114_fns tfms_count crypt_config 0 10114 NULL
 sg_segs_osst_buffer_10144_fns sg_segs osst_buffer 0 10144 NULL
 nvme_rdma_alloc_qe_fndecl_10151_fns nvme_rdma_alloc_qe fndecl 3 10151 NULL
+ldebugfs_fid_space_seq_write_fndecl_10152_fns ldebugfs_fid_space_seq_write fndecl 3 10152 NULL
 udp_tun_rx_dst_fndecl_10154_fns udp_tun_rx_dst fndecl 5 10154 NULL
 _sp2d_max_pg_fndecl_10157_fns _sp2d_max_pg fndecl 0 10157 NULL
 substream_count_snd_rawmidi_str_10174_fns substream_count snd_rawmidi_str 0 10174 NULL
 opera1_xilinx_rw_fndecl_10190_fns opera1_xilinx_rw fndecl 5 10190 NULL
+sa_alloc_fndecl_10205_fns sa_alloc fndecl 5 10205 NULL
 old_log_size_persistent_ram_zone_10215_fns old_log_size persistent_ram_zone 0 10215 NULL
 wil_addba_rx_request_fndecl_10219_fns wil_addba_rx_request fndecl 4 10219 NULL
 rds_message_map_pages_fndecl_10220_fns rds_message_map_pages fndecl 2 10220 NULL
@@ -747,22 +811,28 @@ posix_acl_from_xattr_fndecl_10527_fns posix_acl_from_xattr fndecl 3 10527 &sd_al
 touchscreen_set_params_fndecl_10540_fns touchscreen_set_params fndecl 3 10540 NULL
 nfp_net_netdev_alloc_fndecl_10548_fns nfp_net_netdev_alloc fndecl 3-2 10548 NULL nohasharray
 read_cis_cache_fndecl_10548_fns read_cis_cache fndecl 4 10548 &nfp_net_netdev_alloc_fndecl_10548_fns
+wm_adsp_read_algs_fndecl_10552_fns wm_adsp_read_algs fndecl 4 10552 NULL
 lpfc_present_cpu_vardecl_10567_fns lpfc_present_cpu vardecl 0 10567 NULL
 num_send_contexts_hfi1_devdata_10569_fns num_send_contexts hfi1_devdata 0 10569 NULL
 fuse_fsync_fndecl_10582_fns fuse_fsync fndecl 2-3 10582 NULL nohasharray
 sctp_make_control_fndecl_10582_fns sctp_make_control fndecl 2 10582 &fuse_fsync_fndecl_10582_fns
 static_key_count_fndecl_10584_fns static_key_count fndecl 0 10584 NULL
 num_amd_northbridge_info_10604_fns num amd_northbridge_info 0 10604 NULL
-__probe_kernel_write_fndecl_10625_fns __probe_kernel_write fndecl 3 10625 NULL
+__probe_kernel_write_fndecl_10625_fns __probe_kernel_write fndecl 3 10625 NULL nohasharray
+lch_count_omap_dma_dev_attr_10625_fns lch_count omap_dma_dev_attr 0 10625 &__probe_kernel_write_fndecl_10625_fns
 smk_write_relabel_self_fndecl_10657_fns smk_write_relabel_self fndecl 3 10657 NULL
 tlv_put_fndecl_10659_fns tlv_put fndecl 0 10659 NULL
+ipv6_setsockopt_fndecl_10684_fns ipv6_setsockopt fndecl 5 10684 NULL
 write_file_bool_bmps_fndecl_10685_fns write_file_bool_bmps fndecl 3 10685 NULL
+lov_ost_pool_extend_fndecl_10697_fns lov_ost_pool_extend fndecl 2 10697 NULL
 __btrfs_getxattr_fndecl_10728_fns __btrfs_getxattr fndecl 0 10728 NULL
 ntp_fltr_count_bnxt_10734_fns ntp_fltr_count bnxt 0 10734 NULL
 write_file_queue_fndecl_10737_fns write_file_queue fndecl 3 10737 NULL
 setexposure_fndecl_10781_fns setexposure fndecl 0 10781 NULL
+dwc3_testmode_write_fndecl_10791_fns dwc3_testmode_write fndecl 3 10791 NULL
 rndis_add_response_fndecl_10854_fns rndis_add_response fndecl 2 10854 NULL
 disk_expand_part_tbl_fndecl_10866_fns disk_expand_part_tbl fndecl 2 10866 NULL
+__vmalloc_fndecl_10880_fns __vmalloc fndecl 1 10880 NULL
 sgl_map_user_pages_fndecl_10881_fns sgl_map_user_pages fndecl 2 10881 NULL
 compat_sys_msgsnd_fndecl_10918_fns compat_sys_msgsnd fndecl 3 10918 NULL
 compat_raw_setsockopt_fndecl_10937_fns compat_raw_setsockopt fndecl 5 10937 NULL
@@ -780,11 +850,14 @@ snd_pcm_new_internal_fndecl_11091_fns snd_pcm_new_internal fndecl 4-5 11091 NULL
 mbox_alloc_fndecl_11103_fns mbox_alloc fndecl 2 11103 NULL
 acpi_processor_power_verify_fndecl_11105_fns acpi_processor_power_verify fndecl 0 11105 NULL
 __vmalloc_node_flags_fndecl_11139_fns __vmalloc_node_flags fndecl 1 11139 NULL
+resource_from_user_fndecl_11158_fns resource_from_user fndecl 3 11158 NULL
 nvme_fill_device_id_eui64_fndecl_11160_fns nvme_fill_device_id_eui64 fndecl 4 11160 NULL
 max_supported_extcon_dev_11172_fns max_supported extcon_dev 0 11172 NULL
 c4iw_init_resource_fndecl_11178_fns c4iw_init_resource fndecl 2-3 11178 NULL
 sys_get_mempolicy_fndecl_11192_fns sys_get_mempolicy fndecl 3 11192 NULL
 mangle_sdp_packet_fndecl_11198_fns mangle_sdp_packet fndecl 10 11198 NULL
+submit_create_fndecl_11207_fns submit_create fndecl 3-4 11207 NULL
+lstcon_session_info_fndecl_11210_fns lstcon_session_info fndecl 6 11210 NULL
 tx_tx_template_prepared_read_fndecl_11211_fns tx_tx_template_prepared_read fndecl 3 11211 NULL
 enable_write_fndecl_11243_fns enable_write fndecl 3 11243 NULL
 tx_tx_template_programmed_read_fndecl_11246_fns tx_tx_template_programmed_read fndecl 3 11246 NULL
@@ -794,6 +867,7 @@ buffer_length_usbdevfs_urb_11350_fns buffer_length usbdevfs_urb 0 11350 NULL
 nilfs_cpfile_delete_checkpoints_fndecl_11352_fns nilfs_cpfile_delete_checkpoints fndecl 2-3 11352 NULL nohasharray
 fdb_insert_fndecl_11352_fns fdb_insert fndecl 4 11352 &nilfs_cpfile_delete_checkpoints_fndecl_11352_fns
 fd_execute_rw_fndecl_11359_fns fd_execute_rw fndecl 3 11359 NULL
+arpc_sync_fndecl_11389_fns arpc_sync fndecl 4 11389 NULL
 sctp_getsockopt_assoc_stats_fndecl_11393_fns sctp_getsockopt_assoc_stats fndecl 2 11393 NULL
 msix_setup_entries_fndecl_11398_fns msix_setup_entries fndecl 4-0 11398 NULL nohasharray
 txs_vardecl_ambassador_c_11398_fns txs vardecl_ambassador.c 0 11398 &msix_setup_entries_fndecl_11398_fns
@@ -824,14 +898,19 @@ gart_pin_size_radeon_device_11745_fns gart_pin_size radeon_device 0 11745 NULL
 cifs_linux_ext_proc_write_fndecl_11755_fns cifs_linux_ext_proc_write fndecl 3 11755 NULL
 iscsi_sw_tcp_session_create_fndecl_11792_fns iscsi_sw_tcp_session_create fndecl 3 11792 NULL
 __kmalloc_node_fndecl_11804_fns __kmalloc_node fndecl 1 11804 NULL
+size_mvpp2_tx_queue_11816_fns size mvpp2_tx_queue 0 11816 NULL
 pci_enable_msix_fndecl_11847_fns pci_enable_msix fndecl 3 11847 NULL
 num_crtc_mga_device_11851_fns num_crtc mga_device 0 11851 NULL
+btmrvl_pscmd_write_fndecl_11859_fns btmrvl_pscmd_write fndecl 3 11859 NULL
 frame_rate_sd_11862_fns frame_rate sd 0 11862 NULL
 wr_host_buf_pos_xilly_channel_11866_fns wr_host_buf_pos xilly_channel 0 11866 NULL
 alloc_empty_pages_fndecl_11885_fns alloc_empty_pages fndecl 2 11885 NULL
 snd_device_new_fndecl_11911_fns snd_device_new fndecl 0 11911 NULL
 lbs_lowsnr_read_fndecl_11920_fns lbs_lowsnr_read fndecl 3 11920 NULL
 kvm_read_guest_virt_system_fndecl_11922_fns kvm_read_guest_virt_system fndecl 4-2 11922 NULL
+arm_coherent_iommu_alloc_attrs_fndecl_11939_fns arm_coherent_iommu_alloc_attrs fndecl 2 11939 NULL
+osc_cached_mb_seq_write_fndecl_11961_fns osc_cached_mb_seq_write fndecl 3 11961 NULL
+sa11x0_dma_prep_slave_sg_fndecl_11965_fns sa11x0_dma_prep_slave_sg fndecl 3 11965 NULL
 bsg_major_vardecl_bsg_c_11972_fns bsg_major vardecl_bsg.c 0 11972 NULL
 sctp_make_abort_user_fndecl_11973_fns sctp_make_abort_user fndecl 3 11973 NULL nohasharray
 spmi_controller_alloc_fndecl_11973_fns spmi_controller_alloc fndecl 2 11973 &sctp_make_abort_user_fndecl_11973_fns
@@ -842,6 +921,7 @@ ndevcntrs_hfi1_devdata_11997_fns ndevcntrs hfi1_devdata 0 11997 NULL
 alloc_group_attrs_fndecl_12032_fns alloc_group_attrs fndecl 3 12032 NULL nohasharray
 wusb_prf_256_fndecl_12032_fns wusb_prf_256 fndecl 7 12032 &alloc_group_attrs_fndecl_12032_fns
 drm_property_create_enum_fndecl_12034_fns drm_property_create_enum fndecl 5 12034 NULL
+comedi_alloc_subdevices_fndecl_12036_fns comedi_alloc_subdevices fndecl 2 12036 NULL
 evdev_handle_get_val_fndecl_12073_fns evdev_handle_get_val fndecl 5-6 12073 NULL
 nvme_trans_copy_from_user_fndecl_12088_fns nvme_trans_copy_from_user fndecl 3 12088 NULL
 security_context_to_sid_core_fndecl_12115_fns security_context_to_sid_core fndecl 2 12115 NULL
@@ -851,12 +931,14 @@ max_fingers_silead_ts_data_12170_fns max_fingers silead_ts_data 0 12170 NULL
 of_phandle_iterator_next_fndecl_12171_fns of_phandle_iterator_next fndecl 0 12171 NULL
 __fuse_get_req_fndecl_12176_fns __fuse_get_req fndecl 2 12176 NULL
 bulk_in_size_sur40_state_12178_fns bulk_in_size sur40_state 0 12178 NULL
+lprocfs_write_helper_fndecl_12184_fns lprocfs_write_helper fndecl 2 12184 NULL
 l2cap_sock_setsockopt_old_fndecl_12209_fns l2cap_sock_setsockopt_old fndecl 4 12209 NULL
 unique_len_drm_master_12259_fns unique_len drm_master 0 12259 NULL
 zs_size_classes_vardecl_zsmalloc_c_12260_fns zs_size_classes vardecl_zsmalloc.c 0 12260 NULL
 mempool_create_fndecl_12270_fns mempool_create fndecl 1 12270 NULL
 capacity_sddr09_card_info_12286_fns capacity sddr09_card_info 0 12286 NULL
 nb_blocks_NFTLrecord_12306_fns nb_blocks NFTLrecord 0 12306 NULL
+tracing_clock_write_fndecl_12330_fns tracing_clock_write fndecl 3 12330 NULL
 srpt_alloc_rw_ctxs_fndecl_12333_fns srpt_alloc_rw_ctxs fndecl 3 12333 NULL
 snd_hdac_bus_exec_verb_unlocked_fndecl_12335_fns snd_hdac_bus_exec_verb_unlocked fndecl 0 12335 NULL
 bank_size_stub_chip_12338_fns bank_size stub_chip 0 12338 NULL
@@ -865,6 +947,7 @@ mic_rx_pkts_read_fndecl_12375_fns mic_rx_pkts_read fndecl 3 12375 NULL
 pci_enable_device_flags_fndecl_12378_fns pci_enable_device_flags fndecl 0 12378 NULL
 powercap_register_zone_fndecl_12399_fns powercap_register_zone fndecl 6 12399 NULL
 ieee802154_alloc_hw_fndecl_12400_fns ieee802154_alloc_hw fndecl 1 12400 NULL
+edt_ft5x06_debugfs_raw_data_read_fndecl_12401_fns edt_ft5x06_debugfs_raw_data_read fndecl 3 12401 NULL
 snd_rawmidi_write_fndecl_12411_fns snd_rawmidi_write fndecl 3 12411 NULL
 cx231xx_init_vbi_isoc_fndecl_12422_fns cx231xx_init_vbi_isoc fndecl 3 12422 NULL
 init_rs_non_canonical_fndecl_12424_fns init_rs_non_canonical fndecl 1-5 12424 NULL
@@ -891,15 +974,20 @@ kcalloc_fndecl_12649_fns kcalloc fndecl 1-2 12649 NULL
 fdir_pf_active_filters_i40e_pf_12654_fns fdir_pf_active_filters i40e_pf 0 12654 NULL
 num_aces_cifs_acl_12670_fns num_aces cifs_acl 0 12670 NULL
 t2_num_pages_qed_cxt_mngr_12696_fns t2_num_pages qed_cxt_mngr 0 12696 NULL
+gb_loopback_async_sink_fndecl_12706_fns gb_loopback_async_sink fndecl 2 12706 NULL
+fld_debugfs_hash_seq_write_fndecl_12713_fns fld_debugfs_hash_seq_write fndecl 3 12713 NULL
 sys_listxattr_fndecl_12714_fns sys_listxattr fndecl 3 12714 NULL
 rdma_rw_init_mr_wrs_fndecl_12719_fns rdma_rw_init_mr_wrs fndecl 7-5 12719 NULL
 read_profile_fndecl_12736_fns read_profile fndecl 3 12736 NULL
 num_unit_element_struct_12767_fns num unit_element_struct 0 12767 NULL
 driver_add_groups_fndecl_12778_fns driver_add_groups fndecl 0 12778 NULL
+testmode_write_fndecl_12814_fns testmode_write fndecl 3 12814 NULL
 hint_events_per_packet_input_dev_12818_fns hint_events_per_packet input_dev 0 12818 NULL nohasharray
 subdev_ioctl_fndecl_12818_fns subdev_ioctl fndecl 2 12818 &hint_events_per_packet_input_dev_12818_fns
+ksocknal_alloc_tx_fndecl_12825_fns ksocknal_alloc_tx fndecl 2 12825 NULL
 of_n_addr_cells_fndecl_12852_fns of_n_addr_cells fndecl 0 12852 NULL
 max_ddbs_hw_profile_12873_fns max_ddbs hw_profile 0 12873 NULL
+omap_gem_new_dmabuf_fndecl_12877_fns omap_gem_new_dmabuf fndecl 2 12877 NULL
 nilfs_sufile_delete_segment_usage_block_fndecl_12921_fns nilfs_sufile_delete_segment_usage_block fndecl 2 12921 NULL
 run_delalloc_range_fndecl_12946_fns run_delalloc_range fndecl 3-4 12946 NULL nohasharray
 aio_read_events_fndecl_12946_fns aio_read_events fndecl 3 12946 &run_delalloc_range_fndecl_12946_fns nohasharray
@@ -923,6 +1011,7 @@ line6_alloc_sysex_buffer_fndecl_13138_fns line6_alloc_sysex_buffer fndecl 4 1313
 mousedev_reserve_minor_fndecl_13143_fns mousedev_reserve_minor fndecl 0 13143 NULL
 nr_possible_cpus_uv_hub_info_s_13164_fns nr_possible_cpus uv_hub_info_s 0 13164 NULL
 inline_xattr_size_fndecl_13166_fns inline_xattr_size fndecl 0 13166 NULL
+iproc_pll_clk_setup_fndecl_13179_fns iproc_pll_clk_setup fndecl 6 13179 NULL
 nouveau_compat_ioctl_fndecl_13186_fns nouveau_compat_ioctl fndecl 2 13186 NULL
 blocksize_f2fs_sb_info_13191_fns blocksize f2fs_sb_info 0 13191 NULL
 bsg_setup_queue_fndecl_13194_fns bsg_setup_queue fndecl 5 13194 NULL
@@ -946,11 +1035,13 @@ subdevices_count_snd_rawmidi_info_13408_fns subdevices_count snd_rawmidi_info 0
 nrealreaders_stress_lock_torture_cxt_13422_fns nrealreaders_stress lock_torture_cxt 0 13422 NULL
 tb_path_alloc_fndecl_13427_fns tb_path_alloc fndecl 2 13427 NULL
 kvm_read_guest_phys_system_fndecl_13445_fns kvm_read_guest_phys_system fndecl 2-4 13445 NULL
+mmp_clk_init_fndecl_13447_fns mmp_clk_init fndecl 3 13447 NULL
 fill_read_buf_fndecl_13455_fns fill_read_buf fndecl 2 13455 NULL
 snd_ctl_new_fndecl_13472_fns snd_ctl_new fndecl 2 13472 NULL
 __videobuf_alloc_vb_fndecl_13477_fns __videobuf_alloc_vb fndecl 1 13477 NULL
 devfn_slot_13478_fns devfn slot 0 13478 NULL
 iwl_mvm_notify_rx_queue_fndecl_13499_fns iwl_mvm_notify_rx_queue fndecl 4 13499 NULL
+btmrvl_hscmd_write_fndecl_13506_fns btmrvl_hscmd_write fndecl 3 13506 NULL
 max_out_size_ims_pcu_13527_fns max_out_size ims_pcu 0 13527 NULL
 alloc_fdmem_fndecl_13528_fns alloc_fdmem fndecl 1 13528 NULL
 tool_mw_read_fndecl_13537_fns tool_mw_read fndecl 3 13537 NULL
@@ -968,6 +1059,7 @@ sysfs_add_file_fndecl_13647_fns sysfs_add_file fndecl 0 13647 NULL
 __fwnode_property_read_string_array_fndecl_13689_fns __fwnode_property_read_string_array fndecl 0 13689 NULL
 resize_platform_label_table_fndecl_13711_fns resize_platform_label_table fndecl 2 13711 NULL
 wsm_buf_reserve_fndecl_13730_fns wsm_buf_reserve fndecl 2 13730 NULL
+shdma_prep_dma_cyclic_fndecl_13739_fns shdma_prep_dma_cyclic fndecl 4-3 13739 NULL
 pof_write_buffer_fndecl_13741_fns pof_write_buffer fndecl 2-0 13741 NULL
 regmap_ibt_write_fndecl_13743_fns regmap_ibt_write fndecl 3 13743 NULL
 qlcnic_alloc_sds_rings_fndecl_13752_fns qlcnic_alloc_sds_rings fndecl 2 13752 NULL
@@ -982,21 +1074,26 @@ seq_read_fndecl_13824_fns seq_read fndecl 3 13824 NULL
 ib_dma_map_sg_fndecl_13830_fns ib_dma_map_sg fndecl 0 13830 NULL
 init_memory_mapping_fndecl_13840_fns init_memory_mapping fndecl 1-2 13840 NULL
 rlen_cm4000_dev_13899_fns rlen cm4000_dev 0 13899 NULL
-num_vfs_adapter_13918_fns num_vfs adapter 0 13918 NULL
+num_vfs_adapter_13918_fns num_vfs adapter 0 13918 NULL nohasharray
+wm_coeff_parse_int_fndecl_13918_fns wm_coeff_parse_int fndecl 0 13918 &num_vfs_adapter_13918_fns
 trips_thermal_zone_device_13921_fns trips thermal_zone_device 0 13921 NULL
 garmin_read_process_fndecl_13926_fns garmin_read_process fndecl 3 13926 NULL
 hcd_buffer_alloc_fndecl_13940_fns hcd_buffer_alloc fndecl 2 13940 NULL
+img_IMEM_size_fw_hdr_13961_fns img_IMEM_size fw_hdr 0 13961 NULL
 ib_copy_to_udata_fndecl_13974_fns ib_copy_to_udata fndecl 3 13974 NULL
 e_phnum_elf32_hdr_13980_fns e_phnum elf32_hdr 0 13980 NULL
 syslog_partial_vardecl_printk_c_13985_fns syslog_partial vardecl_printk.c 0 13985 NULL
 rd_size_uhid_device_13986_fns rd_size uhid_device 0 13986 NULL
 libipw_alloc_txb_fndecl_13992_fns libipw_alloc_txb fndecl 1 13992 NULL
+batadv_socket_add_packet_fndecl_14011_fns batadv_socket_add_packet fndecl 3 14011 NULL
 sensor_framerate_go7007_14025_fns sensor_framerate go7007 0 14025 NULL
 descriptors_per_page__drm_via_sg_info_14046_fns descriptors_per_page _drm_via_sg_info 0 14046 NULL
 C_SYSC_mbind_fndecl_14055_fns C_SYSC_mbind fndecl 5 14055 NULL
+read_flush_procfs_fndecl_14057_fns read_flush_procfs fndecl 3 14057 NULL
 regmap_ibt_gather_write_fndecl_14087_fns regmap_ibt_gather_write fndecl 5 14087 NULL
 _mv88e6xxx_port_vlan_add_fndecl_14091_fns _mv88e6xxx_port_vlan_add fndecl 3 14091 NULL
 snd_compr_calc_avail_fndecl_14094_fns snd_compr_calc_avail fndecl 0 14094 NULL
+btmrvl_hscfgcmd_write_fndecl_14100_fns btmrvl_hscfgcmd_write fndecl 3 14100 NULL
 wil_write_file_wmi_fndecl_14109_fns wil_write_file_wmi fndecl 3 14109 NULL
 dqi_entry_size_qtree_mem_dqinfo_14150_fns dqi_entry_size qtree_mem_dqinfo 0 14150 NULL
 write_kmem_fndecl_14154_fns write_kmem fndecl 3 14154 NULL nohasharray
@@ -1004,20 +1101,27 @@ svcxdr_tmpalloc_fndecl_14154_fns svcxdr_tmpalloc fndecl 2 14154 &write_kmem_fnde
 vfs_writev_fndecl_14168_fns vfs_writev fndecl 3 14168 NULL
 rxrpc_request_key_fndecl_14192_fns rxrpc_request_key fndecl 3 14192 NULL
 uvc_fraction_to_interval_fndecl_14194_fns uvc_fraction_to_interval fndecl 0-2-1 14194 NULL
+comedi_alloc_devpriv_fndecl_14235_fns comedi_alloc_devpriv fndecl 2 14235 NULL
 write_buf_fndecl_14247_fns write_buf fndecl 0 14247 NULL
 copy_from_buf_fndecl_14271_fns copy_from_buf fndecl 4-2 14271 NULL
 afs_cell_create_fndecl_14273_fns afs_cell_create fndecl 2 14273 NULL
 snd_pcm_oss_write2_fndecl_14295_fns snd_pcm_oss_write2 fndecl 3 14295 NULL
 scif_p2p_setsg_fndecl_14314_fns scif_p2p_setsg fndecl 3 14314 NULL
+size_wpa_suite_t_14321_fns size wpa_suite_t 0 14321 NULL
+pcbit_stat_fndecl_14327_fns pcbit_stat fndecl 2 14327 NULL
+pxad_alloc_desc_fndecl_14330_fns pxad_alloc_desc fndecl 2 14330 NULL
 ath6kl_regread_read_fndecl_14351_fns ath6kl_regread_read fndecl 3 14351 NULL
 nvme_trans_mode_page_create_fndecl_14375_fns nvme_trans_mode_page_create fndecl 7-4 14375 NULL
+lirc_rx51_write_fndecl_14379_fns lirc_rx51_write fndecl 3 14379 NULL
 num_phys__sas_node_14384_fns num_phys _sas_node 0 14384 NULL
 fdb_create_fndecl_14403_fns fdb_create fndecl 4 14403 NULL
 vmcb_iopm_nested_state_14411_fns vmcb_iopm nested_state 0 14411 NULL
+max_ep_fsl_udc_14417_fns max_ep fsl_udc 0 14417 NULL
 snd_es1938_capture_copy_fndecl_14425_fns snd_es1938_capture_copy fndecl 5 14425 NULL
 wrt_pass_cntr_osst_tape_14444_fns wrt_pass_cntr osst_tape 0 14444 NULL
 flush_fndecl_14454_fns flush fndecl 2 14454 NULL
 _regmap_multi_reg_write_fndecl_14460_fns _regmap_multi_reg_write fndecl 3 14460 NULL
+cfs_hash_create_fndecl_14468_fns cfs_hash_create fndecl 4-2 14468 NULL
 user_ucs2_strsize_fndecl_14469_fns user_ucs2_strsize fndecl 0 14469 NULL
 rdmarc_entry_sz_mlx4_dev_cap_14475_fns rdmarc_entry_sz mlx4_dev_cap 0 14475 NULL
 selinux_inode_post_setxattr_fndecl_14502_fns selinux_inode_post_setxattr fndecl 4 14502 NULL
@@ -1031,6 +1135,7 @@ befs_utf2nls_fndecl_14607_fns befs_utf2nls fndecl 3 14607 NULL
 interval_solo_enc_dev_14661_fns interval solo_enc_dev 0 14661 NULL
 tty_copy_to_user_fndecl_14668_fns tty_copy_to_user fndecl 3-4 14668 NULL
 image_size_ls_ucode_img_desc_14672_fns image_size ls_ucode_img_desc 0 14672 NULL
+lpfc_idiag_cmd_get_fndecl_14683_fns lpfc_idiag_cmd_get fndecl 2 14683 NULL
 rx_filter_mc_filter_read_fndecl_14691_fns rx_filter_mc_filter_read fndecl 3 14691 NULL
 smt_fill_path_fndecl_14692_fns smt_fill_path fndecl 0 14692 NULL
 num_sizes_vmw_surface_14695_fns num_sizes vmw_surface 0 14695 NULL
@@ -1069,6 +1174,7 @@ copy_oldmem_page_fndecl_15143_fns copy_oldmem_page fndecl 3 15143 NULL
 elem_size_snd_array_15155_fns elem_size snd_array 0 15155 NULL nohasharray
 chaoskey_read_fndecl_15155_fns chaoskey_read fndecl 3 15155 &elem_size_snd_array_15155_fns
 walk_hugetlb_range_fndecl_15190_fns walk_hugetlb_range fndecl 0 15190 NULL
+get_registers_fndecl_15192_fns get_registers fndecl 3 15192 NULL
 max_clk_sdhci_host_15206_fns max_clk sdhci_host 0 15206 NULL
 nlm_end_grace_read_fndecl_15209_fns nlm_end_grace_read fndecl 3 15209 NULL
 genwqe_ffdc_buff_size_fndecl_15236_fns genwqe_ffdc_buff_size fndecl 0 15236 NULL
@@ -1123,10 +1229,12 @@ rstatus_usblp_15945_fns rstatus usblp 0 15945 NULL
 hw_scan_ies_bufsize_ieee80211_local_15949_fns hw_scan_ies_bufsize ieee80211_local 0 15949 NULL
 mlxsw_sp_port_ets_set_fndecl_15981_fns mlxsw_sp_port_ets_set fndecl 0 15981 NULL
 nilfs_cpfile_get_blkoff_fndecl_15997_fns nilfs_cpfile_get_blkoff fndecl 2-0 15997 NULL
+gb_operation_create_incoming_fndecl_15999_fns gb_operation_create_incoming fndecl 5 15999 NULL
 gk20a_instobj_new_fndecl_16015_fns gk20a_instobj_new fndecl 2 16015 NULL
 num_stripes_map_lookup_16016_fns num_stripes map_lookup 0 16016 NULL
 snd_pcm_plugin_build_fndecl_16050_fns snd_pcm_plugin_build fndecl 5 16050 NULL
 pgsize_vardecl_pagetest_c_16065_fns pgsize vardecl_pagetest.c 0 16065 NULL
+sa_statahead_fndecl_16102_fns sa_statahead fndecl 3 16102 NULL
 snd_rawmidi_kernel_write_fndecl_16129_fns snd_rawmidi_kernel_write fndecl 3 16129 NULL
 fanout_set_data_ebpf_fndecl_16141_fns fanout_set_data_ebpf fndecl 3 16141 NULL
 ib_uverbs_alloc_pd_fndecl_16189_fns ib_uverbs_alloc_pd fndecl 4-5 16189 NULL
@@ -1140,24 +1248,31 @@ f_max_mmc_host_16291_fns f_max mmc_host 0 16291 NULL
 dvbdev_get_free_adapter_num_fndecl_16292_fns dvbdev_get_free_adapter_num fndecl 0 16292 NULL
 crypto_alloc_instance2_fndecl_16302_fns crypto_alloc_instance2 fndecl 3 16302 NULL
 jent_zalloc_fndecl_16331_fns jent_zalloc fndecl 1 16331 NULL
+spi_sync_transfer_fndecl_16337_fns spi_sync_transfer fndecl 0 16337 NULL
 l2tp_session_create_fndecl_16341_fns l2tp_session_create fndecl 1 16341 NULL
 help_fndecl_16375_fns help fndecl 5 16375 NULL
+samsung_clk_init_fndecl_16382_fns samsung_clk_init fndecl 3 16382 NULL
 zd_mac_preinit_hw_fndecl_16386_fns zd_mac_preinit_hw fndecl 0 16386 NULL
 dsize_ip_set_16391_fns dsize ip_set 0 16391 NULL
 ip_options_get_alloc_fndecl_16395_fns ip_options_get_alloc fndecl 1 16395 NULL
 SYSC_setgroups_fndecl_16397_fns SYSC_setgroups fndecl 1 16397 NULL
 sdhci_alloc_host_fndecl_16454_fns sdhci_alloc_host fndecl 2 16454 NULL
+mtk_alloc_clk_data_fndecl_16481_fns mtk_alloc_clk_data fndecl 1 16481 NULL
 ptrace_access_vm_fndecl_16494_fns ptrace_access_vm fndecl 0 16494 NULL
 ttm_page_alloc_init_fndecl_16498_fns ttm_page_alloc_init fndecl 2 16498 NULL
+cfs_cpt_num_estimate_fndecl_16512_fns cfs_cpt_num_estimate fndecl 0 16512 NULL
 smk_read_mapped_fndecl_16537_fns smk_read_mapped fndecl 3 16537 NULL
 groups_alloc_fndecl_16557_fns groups_alloc fndecl 1 16557 NULL nohasharray
 create_dir_fndecl_16557_fns create_dir fndecl 0 16557 &groups_alloc_fndecl_16557_fns
 ceph_fsync_fndecl_16625_fns ceph_fsync fndecl 2-3 16625 NULL
 of_dma_match_channel_fndecl_16675_fns of_dma_match_channel fndecl 3 16675 NULL
 cons_read_buffer_16688_fns cons read_buffer 0 16688 NULL
+i2c1_debugfs_read_fndecl_16712_fns i2c1_debugfs_read fndecl 3 16712 NULL
 rx_rate_rx_frames_per_rates_read_fndecl_16737_fns rx_rate_rx_frames_per_rates_read fndecl 3 16737 NULL
-devlink_alloc_fndecl_16742_fns devlink_alloc fndecl 2 16742 NULL
+devlink_alloc_fndecl_16742_fns devlink_alloc fndecl 2 16742 NULL nohasharray
+fault_disconnect_write_fndecl_16742_fns fault_disconnect_write fndecl 3 16742 &devlink_alloc_fndecl_16742_fns
 num_q_csio_wrm_16770_fns num_q csio_wrm 0 16770 NULL
+max_iu_len_srp_target_port_16784_fns max_iu_len srp_target_port 0 16784 NULL
 ishtp_host_dma_tx_buf_size_ishtp_device_16798_fns ishtp_host_dma_tx_buf_size ishtp_device 0 16798 NULL
 diva_xdi_read_fndecl_16814_fns diva_xdi_read fndecl 0 16814 NULL
 drm_property_create_blob_fndecl_16869_fns drm_property_create_blob fndecl 2 16869 NULL
@@ -1165,6 +1280,7 @@ len_snd_fw_async_midi_port_16875_fns len snd_fw_async_midi_port 0 16875 NULL
 _ore_add_stripe_unit_fndecl_16884_fns _ore_add_stripe_unit fndecl 3-6 16884 NULL
 ncbflooders_vardecl_rcutorture_c_16899_fns ncbflooders vardecl_rcutorture.c 0 16899 NULL
 clk_set_rate_fndecl_16902_fns clk_set_rate fndecl 2 16902 NULL
+n_ai_urbs_usbduxsigma_private_16912_fns n_ai_urbs usbduxsigma_private 0 16912 NULL
 idx_mxser_board_16916_fns idx mxser_board 0 16916 NULL
 sys_mbind_fndecl_16933_fns sys_mbind fndecl 5 16933 NULL
 vidioc_dqbuf_fndecl_16948_fns vidioc_dqbuf fndecl 0 16948 NULL
@@ -1174,6 +1290,7 @@ tt3650_ci_msg_locked_fndecl_16990_fns tt3650_ci_msg_locked fndecl 4 16990 NULL
 cifs_min_rcv_vardecl_17001_fns cifs_min_rcv vardecl 0 17001 NULL
 id_rtc_device_17005_fns id rtc_device 0 17005 NULL
 snd_hdac_bus_exec_verb_fndecl_17009_fns snd_hdac_bus_exec_verb fndecl 0 17009 NULL
+__iommu_dma_alloc_pages_fndecl_17015_fns __iommu_dma_alloc_pages fndecl 1 17015 NULL
 reiserfs_sync_file_fndecl_17045_fns reiserfs_sync_file fndecl 2-3 17045 NULL
 qla4xxx_post_ping_evt_work_fndecl_17049_fns qla4xxx_post_ping_evt_work fndecl 4 17049 NULL
 command_setcompressiontarget_fndecl_17055_fns command_setcompressiontarget fndecl 0 17055 NULL
@@ -1187,8 +1304,10 @@ cx18_queue_get_mdl_fndecl_17103_fns cx18_queue_get_mdl fndecl 3 17103 NULL
 dlm_user_request_fndecl_17104_fns dlm_user_request fndecl 6 17104 NULL
 minors_gendisk_17113_fns minors gendisk 0 17113 NULL
 in___kfifo_17131_fns in __kfifo 0 17131 NULL
+lnet_ipif_enumerate_fndecl_17135_fns lnet_ipif_enumerate fndecl 0 17135 NULL
 acpi_hw_validate_register_fndecl_17141_fns acpi_hw_validate_register fndecl 2 17141 NULL
 blockSize_ms_lib_ctrl_17144_fns blockSize ms_lib_ctrl 0 17144 NULL
+size_buf_image_desc_17151_fns size_buf image_desc 0 17151 NULL
 len_read_buffer_17166_fns len read_buffer 0 17166 NULL
 acpi_ex_allocate_name_string_fndecl_17174_fns acpi_ex_allocate_name_string fndecl 1-2 17174 NULL
 pci_raw_set_power_state_fndecl_17186_fns pci_raw_set_power_state fndecl 0 17186 NULL
@@ -1199,6 +1318,7 @@ dfs_global_file_read_fndecl_17272_fns dfs_global_file_read fndecl 3 17272 NULL n
 offs_nand_bbt_descr_17272_fns offs nand_bbt_descr 0 17272 &dfs_global_file_read_fndecl_17272_fns
 bnx2_nvram_write_fndecl_17277_fns bnx2_nvram_write fndecl 2-4 17277 NULL
 seq_buf_alloc_fndecl_17287_fns seq_buf_alloc fndecl 1 17287 NULL
+cfs_trace_dump_debug_buffer_usrstr_fndecl_17318_fns cfs_trace_dump_debug_buffer_usrstr fndecl 2 17318 NULL
 MaxBuses__MSG_IOC_FACTS_REPLY_17350_fns MaxBuses _MSG_IOC_FACTS_REPLY 0 17350 NULL
 dvb_dmxdev_read_sec_fndecl_17351_fns dvb_dmxdev_read_sec fndecl 4 17351 NULL
 audio_buf_size_f_uac1_opts_17353_fns audio_buf_size f_uac1_opts 0 17353 NULL
@@ -1217,6 +1337,7 @@ offset_icmp_bxm_17531_fns offset icmp_bxm 0 17531 NULL
 rndis_set_oid_fndecl_17536_fns rndis_set_oid fndecl 4 17536 NULL
 fb_alloc_cmap_fndecl_17545_fns fb_alloc_cmap fndecl 2 17545 NULL
 stack_size_ahd_softc_17574_fns stack_size ahd_softc 0 17574 NULL
+sita_init_fndecl_17588_fns sita_init fndecl 2-1 17588 NULL
 skb_array_init_fndecl_17590_fns skb_array_init fndecl 2 17590 NULL
 drbg_init_hash_kernel_fndecl_17617_fns drbg_init_hash_kernel fndecl 0 17617 NULL
 dvb_dmx_init_fndecl_17652_fns dvb_dmx_init fndecl 0 17652 NULL
@@ -1235,6 +1356,7 @@ snd_hda_override_conn_list_fndecl_17817_fns snd_hda_override_conn_list fndecl 3
 xenbus_file_write_fndecl_17817_fns xenbus_file_write fndecl 3 17817 &snd_hda_override_conn_list_fndecl_17817_fns
 tx_tx_start_null_frame_read_fndecl_17818_fns tx_tx_start_null_frame_read fndecl 3 17818 NULL
 qlcnic_sriov_alloc_bc_msg_fndecl_17846_fns qlcnic_sriov_alloc_bc_msg fndecl 2 17846 NULL
+jz4740_dma_prep_dma_cyclic_fndecl_17849_fns jz4740_dma_prep_dma_cyclic fndecl 4-3 17849 NULL
 preferred_minor_md_rdev_17857_fns preferred_minor md_rdev 0 17857 NULL
 host_int_get_assoc_res_info_fndecl_17869_fns host_int_get_assoc_res_info fndecl 3 17869 NULL
 fuse_get_req_for_background_fndecl_17874_fns fuse_get_req_for_background fndecl 2 17874 NULL
@@ -1250,6 +1372,7 @@ nilfs_set_last_segment_fndecl_17983_fns nilfs_set_last_segment fndecl 4 17983 NU
 count_mlxsw_pci_queue_17987_fns count mlxsw_pci_queue 0 17987 NULL
 size_firmware_buf_18003_fns size firmware_buf 0 18003 NULL
 request_key_async_fndecl_18013_fns request_key_async fndecl 4 18013 NULL
+raid56_parity_recover_fndecl_18019_fns raid56_parity_recover fndecl 4 18019 NULL
 condc_tomoyo_condition_18025_fns condc tomoyo_condition 0 18025 NULL
 fip_dl_len_fip_header_18032_fns fip_dl_len fip_header 0 18032 NULL
 copy_items_fndecl_18039_fns copy_items fndecl 7 18039 NULL
@@ -1272,10 +1395,12 @@ posix_acl_xattr_count_fndecl_18262_fns posix_acl_xattr_count fndecl 1-0 18262 NU
 video_proc_write_fndecl_18263_fns video_proc_write fndecl 3 18263 NULL
 rds_rdma_pages_fndecl_18268_fns rds_rdma_pages fndecl 0 18268 NULL
 add_pfn_range_mapped_fndecl_18307_fns add_pfn_range_mapped fndecl 1 18307 NULL
+i2c_read_fndecl_18308_fns i2c_read fndecl 0 18308 NULL
 rpipes_wahc_18323_fns rpipes wahc 0 18323 NULL
 tx_tx_done_data_read_fndecl_18332_fns tx_tx_done_data_read fndecl 3 18332 NULL
 blk_alloc_flush_queue_fndecl_18340_fns blk_alloc_flush_queue fndecl 3 18340 NULL
 calc_pages_for_fndecl_18341_fns calc_pages_for fndecl 0-2-1 18341 NULL
+sg_split_fndecl_18342_fns sg_split fndecl 4 18342 NULL
 mon_bin_read_fndecl_18346_fns mon_bin_read fndecl 3 18346 NULL
 nsm_get_handle_fndecl_18347_fns nsm_get_handle fndecl 5 18347 NULL
 snd_cs4281_BA0_read_fndecl_18348_fns snd_cs4281_BA0_read fndecl 5 18348 NULL
@@ -1286,6 +1411,7 @@ acm_alloc_minor_fndecl_18412_fns acm_alloc_minor fndecl 0 18412 &proc_sessionid_
 raw_seticmpfilter_fndecl_18427_fns raw_seticmpfilter fndecl 3 18427 NULL
 dlmfs_file_write_fndecl_18431_fns dlmfs_file_write fndecl 3 18431 NULL
 error_bar_retry_read_fndecl_18460_fns error_bar_retry_read fndecl 3 18460 NULL
+cpg_div6_register_fndecl_18462_fns cpg_div6_register fndecl 2 18462 NULL
 mddev_find_fndecl_18492_fns mddev_find fndecl 1 18492 NULL
 xfs_efd_init_fndecl_18500_fns xfs_efd_init fndecl 3 18500 NULL
 wil_pmc_read_fndecl_18503_fns wil_pmc_read fndecl 3 18503 NULL
@@ -1312,9 +1438,11 @@ dwc2_hcd_urb_alloc_fndecl_18802_fns dwc2_hcd_urb_alloc fndecl 2 18802 NULL
 ath6kl_debug_roam_tbl_event_fndecl_18811_fns ath6kl_debug_roam_tbl_event fndecl 3 18811 NULL
 gfn_to_hva_memslot_fndecl_18818_fns gfn_to_hva_memslot fndecl 2 18818 NULL
 dvb_ringbuffer_write_user_fndecl_18821_fns dvb_ringbuffer_write_user fndecl 3 18821 NULL
+clk_num_clk_onecell_data_18830_fns clk_num clk_onecell_data 0 18830 NULL
 DriverQueueDepth_DAC960_Controller_18839_fns DriverQueueDepth DAC960_Controller 0 18839 NULL
 private_data_len_ib_cm_req_param_18848_fns private_data_len ib_cm_req_param 0 18848 NULL
 length_acpi_resource_18863_fns length acpi_resource 0 18863 NULL
+uinput_ioctl_fndecl_18893_fns uinput_ioctl fndecl 2 18893 NULL
 pwr_elp_enter_read_fndecl_18911_fns pwr_elp_enter_read fndecl 3 18911 NULL
 ps_pspoll_utilization_read_fndecl_18914_fns ps_pspoll_utilization_read fndecl 3 18914 NULL
 kvm_pin_pages_fndecl_18922_fns kvm_pin_pages fndecl 2 18922 NULL
@@ -1331,12 +1459,14 @@ mei_cl_read_start_fndecl_19077_fns mei_cl_read_start fndecl 2 19077 NULL
 btrfs_qgroup_inherit_fndecl_19103_fns btrfs_qgroup_inherit fndecl 4 19103 NULL
 sctp_setsockopt_connectx_fndecl_19114_fns sctp_setsockopt_connectx fndecl 3 19114 NULL
 alloc_msg_fndecl_19115_fns alloc_msg fndecl 1 19115 NULL
+gb_module_create_fndecl_19119_fns gb_module_create fndecl 3 19119 NULL
 rx_keycache_size_p54_common_19128_fns rx_keycache_size p54_common 0 19128 NULL
 start_vivitar_cam_fndecl_19144_fns start_vivitar_cam fndecl 0 19144 NULL
 ipmi_addr_length_fndecl_19149_fns ipmi_addr_length fndecl 0 19149 NULL
 inftl_write_oob_fndecl_19154_fns inftl_write_oob fndecl 3 19154 NULL
 alloc_indirect_fndecl_19156_fns alloc_indirect fndecl 2 19156 NULL
 len_ntb_queue_entry_19166_fns len ntb_queue_entry 0 19166 NULL
+lprocfs_alloc_stats_fndecl_19181_fns lprocfs_alloc_stats fndecl 1 19181 NULL
 read_packet_fndecl_19183_fns read_packet fndecl 5 19183 NULL
 dfs_global_file_write_fndecl_19187_fns dfs_global_file_write fndecl 3 19187 NULL
 ext4_xattr_get_fndecl_19214_fns ext4_xattr_get fndecl 0 19214 NULL
@@ -1364,9 +1494,12 @@ libfc_vport_create_fndecl_19500_fns libfc_vport_create fndecl 2 19500 NULL
 cxacru_cm_get_array_fndecl_19503_fns cxacru_cm_get_array fndecl 4 19503 NULL
 ecryptfs_write_tag_70_packet_fndecl_19510_fns ecryptfs_write_tag_70_packet fndecl 6 19510 NULL
 do_pages_stat_fndecl_19526_fns do_pages_stat fndecl 2 19526 NULL
-netdev_register_kobject_fndecl_19535_fns netdev_register_kobject fndecl 0 19535 NULL
+netdev_register_kobject_fndecl_19535_fns netdev_register_kobject fndecl 0 19535 NULL nohasharray
+d40_sg_2_dmalen_fndecl_19535_fns d40_sg_2_dmalen fndecl 3-4-0 19535 &netdev_register_kobject_fndecl_19535_fns
+rtw_android_get_rssi_fndecl_19542_fns rtw_android_get_rssi fndecl 0 19542 NULL
 response_length_mlx5_ib_query_device_resp_19546_fns response_length mlx5_ib_query_device_resp 0 19546 NULL
 cmpt_entry_sz_mlx4_dev_cap_19564_fns cmpt_entry_sz mlx4_dev_cap 0 19564 NULL
+buf_size_pxa3xx_nand_info_19573_fns buf_size pxa3xx_nand_info 0 19573 NULL
 snd_seq_expand_var_event_fndecl_19602_fns snd_seq_expand_var_event fndecl 0 19602 NULL
 vmbus_establish_gpadl_fndecl_19612_fns vmbus_establish_gpadl fndecl 3 19612 NULL
 __gfn_to_pfn_memslot_fndecl_19617_fns __gfn_to_pfn_memslot fndecl 2 19617 NULL
@@ -1379,6 +1512,7 @@ bch_alloc_fndecl_19682_fns bch_alloc fndecl 1 19682 NULL
 xfs_buf_get_maps_fndecl_19702_fns xfs_buf_get_maps fndecl 2 19702 NULL
 acpi_read_fast_fndecl_19709_fns acpi_read_fast fndecl 3-2 19709 NULL
 msc_win_to_user_fndecl_19728_fns msc_win_to_user fndecl 3 19728 NULL
+mps_trc_write_fndecl_19736_fns mps_trc_write fndecl 3 19736 NULL
 max_active_conns_bnx2i_hba_19740_fns max_active_conns bnx2i_hba 0 19740 NULL
 nftl_write_oob_fndecl_19745_fns nftl_write_oob fndecl 3 19745 NULL
 mpt_raid_phys_disk_get_num_paths_fndecl_19752_fns mpt_raid_phys_disk_get_num_paths fndecl 0 19752 NULL
@@ -1388,6 +1522,7 @@ ip_send_unicast_reply_fndecl_19820_fns ip_send_unicast_reply fndecl 7 19820 NULL
 _osd_req_list_objects_fndecl_19839_fns _osd_req_list_objects fndecl 6 19839 NULL
 rpos_cm4000_dev_19844_fns rpos cm4000_dev 0 19844 NULL
 ath6kl_force_roam_write_fndecl_19881_fns ath6kl_force_roam_write fndecl 3 19881 NULL
+goldfish_audio_write_fndecl_19887_fns goldfish_audio_write fndecl 3 19887 NULL
 count_strings_fndecl_19912_fns count_strings fndecl 0 19912 NULL
 get_connectors_for_crtc_fndecl_19920_fns get_connectors_for_crtc fndecl 0 19920 NULL
 do_readv_fndecl_19922_fns do_readv fndecl 3 19922 NULL
@@ -1395,6 +1530,7 @@ __usbnet_read_cmd_fndecl_19928_fns __usbnet_read_cmd fndecl 7 19928 NULL
 dvb_ringbuffer_pkt_read_user_fndecl_19932_fns dvb_ringbuffer_pkt_read_user fndecl 2-3-5 19932 NULL
 ima_eventdigest_init_common_fndecl_19937_fns ima_eventdigest_init_common fndecl 2 19937 NULL
 max_buckets_crush_map_19942_fns max_buckets crush_map 0 19942 NULL
+snd_rawmidi_kernel_read_fndecl_19963_fns snd_rawmidi_kernel_read fndecl 3 19963 NULL
 vga_arb_read_fndecl_19973_fns vga_arb_read fndecl 3 19973 NULL
 paravirt_read_msr_fndecl_19974_fns paravirt_read_msr fndecl 0 19974 NULL
 le_max_key_size_read_fndecl_19975_fns le_max_key_size_read fndecl 3 19975 NULL
@@ -1408,21 +1544,27 @@ submit_rtpg_fndecl_20091_fns submit_rtpg fndecl 3 20091 NULL
 do_mincore_fndecl_20105_fns do_mincore fndecl 0-1-2 20105 NULL
 snd_mixart_BA1_read_fndecl_20169_fns snd_mixart_BA1_read fndecl 5 20169 NULL
 __kmalloc_track_caller_fndecl_20188_fns __kmalloc_track_caller fndecl 1 20188 NULL
+num_counters_vardecl_oprofile_perf_c_20189_fns num_counters vardecl_oprofile_perf.c 0 20189 NULL
 qp_attach_mbox_size_fndecl_20191_fns qp_attach_mbox_size fndecl 0 20191 NULL
 max_frame_size__mgslpc_info_20204_fns max_frame_size _mgslpc_info 0 20204 NULL
 sbq_len_rx_ring_20205_fns sbq_len rx_ring 0 20205 NULL
+i40e_dbg_netdev_ops_write_fndecl_20206_fns i40e_dbg_netdev_ops_write fndecl 3 20206 NULL
 kfifo_copy_from_user_fndecl_20208_fns kfifo_copy_from_user fndecl 0-4-3 20208 NULL
 sound_write_fndecl_20221_fns sound_write fndecl 3 20221 NULL
 use_sg_osst_buffer_20225_fns use_sg osst_buffer 0 20225 NULL
+ll_rw_extents_stats_seq_write_fndecl_20234_fns ll_rw_extents_stats_seq_write fndecl 3 20234 NULL
 rx_agg_bmap_size_bnxt_rx_ring_info_20244_fns rx_agg_bmap_size bnxt_rx_ring_info 0 20244 NULL
+arm_setup_iommu_dma_ops_fndecl_20272_fns arm_setup_iommu_dma_ops fndecl 3 20272 NULL
 kone_receive_fndecl_20289_fns kone_receive fndecl 4 20289 NULL
 register_queue_kobjects_fndecl_20291_fns register_queue_kobjects fndecl 0 20291 NULL
 round_pipe_size_fndecl_20302_fns round_pipe_size fndecl 0 20302 NULL
 cx18_read_pos_fndecl_20312_fns cx18_read_pos fndecl 3 20312 NULL
+wilc_spi_rx_fndecl_20314_fns wilc_spi_rx fndecl 3 20314 NULL
 ati_create_gatt_pages_fndecl_20321_fns ati_create_gatt_pages fndecl 1 20321 NULL
 num_cvts_hdmi_spec_20322_fns num_cvts hdmi_spec 0 20322 NULL
 i_ecryptfs_parse_tag_70_packet_silly_stack_20325_fns i ecryptfs_parse_tag_70_packet_silly_stack 0 20325 NULL
 cxgbi_alloc_big_mem_fndecl_20336_fns cxgbi_alloc_big_mem fndecl 1 20336 NULL
+ll_rw_offset_stats_seq_write_fndecl_20371_fns ll_rw_offset_stats_seq_write fndecl 3 20371 NULL
 drm_fb_helper_sys_read_fndecl_20376_fns drm_fb_helper_sys_read fndecl 3 20376 NULL
 sys_pwritev2_fndecl_20390_fns sys_pwritev2 fndecl 3 20390 NULL
 periodic_size_fotg210_hcd_20395_fns periodic_size fotg210_hcd 0 20395 NULL
@@ -1446,7 +1588,8 @@ pci_add_cap_save_buffer_fndecl_20593_fns pci_add_cap_save_buffer fndecl 3 20593
 nilfs_cpfile_set_snapshot_fndecl_20616_fns nilfs_cpfile_set_snapshot fndecl 2 20616 NULL
 snd_pcm_lib_readv_transfer_fndecl_20635_fns snd_pcm_lib_readv_transfer fndecl 5 20635 NULL
 cursor_size_fbcon_ops_20640_fns cursor_size fbcon_ops 0 20640 NULL
-nr_pages_ore_io_state_20648_fns nr_pages ore_io_state 0 20648 NULL
+nr_pages_ore_io_state_20648_fns nr_pages ore_io_state 0 20648 NULL nohasharray
+bcm2835_dma_create_cb_chain_fndecl_20648_fns bcm2835_dma_create_cb_chain fndecl 6 20648 &nr_pages_ore_io_state_20648_fns
 security_context_to_sid_default_fndecl_20663_fns security_context_to_sid_default fndecl 2 20663 NULL
 kvm_handle_bad_page_fndecl_20668_fns kvm_handle_bad_page fndecl 2 20668 NULL
 btrfs_dir_name_len_fndecl_20686_fns btrfs_dir_name_len fndecl 0 20686 NULL
@@ -1471,6 +1614,7 @@ shmem_pread_slow_fndecl_20845_fns shmem_pread_slow fndecl 2-3 20845 NULL nohasha
 udp_sendpage_fndecl_20845_fns udp_sendpage fndecl 3 20845 &shmem_pread_slow_fndecl_20845_fns
 acpi_copy_property_array_u64_fndecl_20846_fns acpi_copy_property_array_u64 fndecl 0 20846 NULL
 uinput_ioctl_handler_fndecl_20862_fns uinput_ioctl_handler fndecl 2 20862 NULL
+codec_reg_write_file_fndecl_20887_fns codec_reg_write_file fndecl 3 20887 NULL
 aggr_size_tx_agg_len_read_fndecl_20910_fns aggr_size_tx_agg_len_read fndecl 3 20910 NULL
 btrfs_next_leaf_fndecl_20915_fns btrfs_next_leaf fndecl 0 20915 NULL
 dbDiscardAG_fndecl_20969_fns dbDiscardAG fndecl 3 20969 NULL
@@ -1478,10 +1622,12 @@ count_cma_20973_fns count cma 0 20973 NULL nohasharray
 compat_sys_setsockopt_fndecl_20973_fns compat_sys_setsockopt fndecl 5 20973 &count_cma_20973_fns
 spidev_compat_ioc_message_fndecl_20986_fns spidev_compat_ioc_message fndecl 2 20986 NULL
 get_fd_set_fndecl_21001_fns get_fd_set fndecl 1 21001 NULL
+nouveau_debugfs_pstate_set_fndecl_21004_fns nouveau_debugfs_pstate_set fndecl 3 21004 NULL
 br_fdb_insert_fndecl_21006_fns br_fdb_insert fndecl 4 21006 NULL
 sst_hsw_module_set_param_fndecl_21007_fns sst_hsw_module_set_param fndecl 5 21007 NULL
 nvram_write_fndecl_21029_fns nvram_write fndecl 3 21029 NULL
 efivarfs_file_read_fndecl_21030_fns efivarfs_file_read fndecl 3 21030 NULL
+comedi_buf_read_n_available_fndecl_21032_fns comedi_buf_read_n_available fndecl 0 21032 NULL
 pipeline_pre_proc_swi_read_fndecl_21033_fns pipeline_pre_proc_swi_read fndecl 3 21033 NULL
 chaoskey_rng_read_fndecl_21064_fns chaoskey_rng_read fndecl 3 21064 NULL
 vcs_write_fndecl_21077_fns vcs_write fndecl 3 21077 NULL
@@ -1505,6 +1651,7 @@ fm10k_alloc_q_vector_fndecl_21285_fns fm10k_alloc_q_vector fndecl 6-4 21285 NULL
 tx_tx_starts_read_fndecl_21298_fns tx_tx_starts_read fndecl 3 21298 NULL
 nvdimm_major_vardecl_21302_fns nvdimm_major vardecl 0 21302 NULL
 aligned_kmalloc_fndecl_21311_fns aligned_kmalloc fndecl 1 21311 NULL
+apb_log_read_fndecl_21318_fns apb_log_read fndecl 3 21318 NULL
 i915_compat_ioctl_fndecl_21339_fns i915_compat_ioctl fndecl 2 21339 NULL
 temp_count_applesmc_registers_21387_fns temp_count applesmc_registers 0 21387 NULL
 ci_ll_write_fndecl_21391_fns ci_ll_write fndecl 4 21391 NULL
@@ -1513,6 +1660,7 @@ v4l2_fh_open_fndecl_21406_fns v4l2_fh_open fndecl 0 21406 NULL
 length_r3964_block_header_21407_fns length r3964_block_header 0 21407 NULL
 sctp_setsockopt_auth_key_fndecl_21442_fns sctp_setsockopt_auth_key fndecl 3 21442 NULL
 fwnode_property_read_u32_array_fndecl_21467_fns fwnode_property_read_u32_array fndecl 0 21467 NULL
+msm_otg_mode_write_fndecl_21471_fns msm_otg_mode_write fndecl 3 21471 NULL
 intel_sdvo_set_value_fndecl_21524_fns intel_sdvo_set_value fndecl 4 21524 NULL
 kvm_clear_guest_page_fndecl_21527_fns kvm_clear_guest_page fndecl 4-2 21527 NULL
 ooblen_mtd_oob_ops_21531_fns ooblen mtd_oob_ops 0 21531 NULL
@@ -1538,6 +1686,7 @@ smk_write_syslog_fndecl_21746_fns smk_write_syslog fndecl 3 21746 NULL
 id_gpio_device_21753_fns id gpio_device 0 21753 NULL
 regmap_get_val_bytes_fndecl_21774_fns regmap_get_val_bytes fndecl 0 21774 NULL
 ath6kl_fwlog_mask_read_fndecl_21777_fns ath6kl_fwlog_mask_read fndecl 3 21777 NULL
+__set_print_fmt_fndecl_21801_fns __set_print_fmt fndecl 0 21801 NULL
 __svc_create_fndecl_21804_fns __svc_create fndecl 3 21804 NULL
 nfs4_copy_file_range_fndecl_21835_fns nfs4_copy_file_range fndecl 2-5 21835 NULL
 check_load_and_stores_fndecl_21836_fns check_load_and_stores fndecl 2 21836 NULL
@@ -1546,10 +1695,12 @@ enable_read_fndecl_21846_fns enable_read fndecl 3 21846 NULL
 btrfs_file_extent_inline_len_fndecl_21847_fns btrfs_file_extent_inline_len fndecl 0 21847 NULL
 _ore_get_io_state_fndecl_21861_fns _ore_get_io_state fndecl 5-4-3 21861 NULL
 mlx4_init_icm_table_fndecl_21876_fns mlx4_init_icm_table fndecl 4-5 21876 NULL
+picolcd_debug_reset_write_fndecl_21888_fns picolcd_debug_reset_write fndecl 3 21888 NULL
 bio_integrity_alloc_fndecl_21889_fns bio_integrity_alloc fndecl 3 21889 NULL
 wilc_network_info_received_fndecl_21936_fns wilc_network_info_received fndecl 3 21936 NULL
 sel_write_avc_cache_threshold_fndecl_21955_fns sel_write_avc_cache_threshold fndecl 3 21955 NULL
 sr_read_cmd_fndecl_21992_fns sr_read_cmd fndecl 5 21992 NULL
+vpdma_alloc_desc_buf_fndecl_22005_fns vpdma_alloc_desc_buf fndecl 2 22005 NULL
 nv50_dmac_create_fndecl_22035_fns nv50_dmac_create fndecl 6 22035 NULL
 roccat_connect_fndecl_22044_fns roccat_connect fndecl 3 22044 NULL
 sel_read_enforce_fndecl_22047_fns sel_read_enforce fndecl 3 22047 NULL
@@ -1569,6 +1720,7 @@ acpi_aml_read_fndecl_22207_fns acpi_aml_read fndecl 3 22207 NULL
 xfrm_dst_alloc_copy_fndecl_22217_fns xfrm_dst_alloc_copy fndecl 3 22217 NULL nohasharray
 s_len_rvt_qp_22217_fns s_len rvt_qp 0 22217 &xfrm_dst_alloc_copy_fndecl_22217_fns
 get_max_acpi_id_fndecl_22220_fns get_max_acpi_id fndecl 0 22220 NULL
+lpfc_idiag_mbxacc_write_fndecl_22221_fns lpfc_idiag_mbxacc_write fndecl 3 22221 NULL
 thermal_adc_source_unexpected_read_fndecl_22235_fns thermal_adc_source_unexpected_read fndecl 3 22235 NULL
 depth_write_fndecl_22238_fns depth_write fndecl 3 22238 NULL
 dac960_user_command_proc_write_fndecl_22252_fns dac960_user_command_proc_write fndecl 3 22252 NULL
@@ -1604,10 +1756,12 @@ rdma_alloc_hw_stats_struct_fndecl_22643_fns rdma_alloc_hw_stats_struct fndecl 2
 sctp_setsockopt_initmsg_fndecl_22644_fns sctp_setsockopt_initmsg fndecl 3 22644 NULL
 md_probe_fndecl_22668_fns md_probe fndecl 1 22668 NULL
 init_rs_internal_fndecl_22671_fns init_rs_internal fndecl 6-1 22671 NULL
+cfs_trace_copyout_string_fndecl_22683_fns cfs_trace_copyout_string fndecl 2 22683 NULL
 tx_queue_len_read_fndecl_22692_fns tx_queue_len_read fndecl 3 22692 NULL
 fpregs_set_fndecl_22730_fns fpregs_set fndecl 4 22730 NULL
 xprt_alloc_fndecl_22736_fns xprt_alloc fndecl 2 22736 NULL
 SYSC_syslog_fndecl_22742_fns SYSC_syslog fndecl 3 22742 NULL
+slave_num_ad7280_state_22755_fns slave_num ad7280_state 0 22755 NULL
 alloc_perm_bits_fndecl_22767_fns alloc_perm_bits fndecl 2 22767 NULL
 tomoyo_round2_fndecl_22781_fns tomoyo_round2 fndecl 0 22781 NULL
 agp_create_memory_fndecl_22816_fns agp_create_memory fndecl 1 22816 NULL
@@ -1615,11 +1769,14 @@ pwr_sleep_cycle_avg_read_fndecl_22826_fns pwr_sleep_cycle_avg_read fndecl 3 2282
 nfs_pgarray_set_fndecl_22830_fns nfs_pgarray_set fndecl 2 22830 NULL
 gigaset_initdriver_fndecl_22839_fns gigaset_initdriver fndecl 2 22839 NULL
 xs_sendpages_fndecl_22864_fns xs_sendpages fndecl 3 22864 NULL
+stm32_dma_alloc_desc_fndecl_22870_fns stm32_dma_alloc_desc fndecl 1 22870 NULL
 max_part_vardecl_brd_c_22873_fns max_part vardecl_brd.c 0 22873 NULL
 __btrfs_cow_block_fndecl_22902_fns __btrfs_cow_block fndecl 0 22902 NULL
+lmd_exclude_count_lustre_mount_data_22915_fns lmd_exclude_count lustre_mount_data 0 22915 NULL
 cifs_xattr_set_fndecl_22930_fns cifs_xattr_set fndecl 6 22930 NULL
 cp210x_read_reg_block_fndecl_22947_fns cp210x_read_reg_block fndecl 4 22947 NULL
 i2cdev_read_fndecl_22949_fns i2cdev_read fndecl 3 22949 NULL
+lov_ost_pool_init_fndecl_22956_fns lov_ost_pool_init fndecl 2 22956 NULL
 ipc_alloc_fndecl_22971_fns ipc_alloc fndecl 1 22971 NULL
 kernfs_file_direct_read_fndecl_22981_fns kernfs_file_direct_read fndecl 3 22981 NULL
 acpi_battery_write_alarm_fndecl_22987_fns acpi_battery_write_alarm fndecl 3 22987 NULL
@@ -1629,6 +1786,7 @@ ioctl_private_iw_point_fndecl_23018_fns ioctl_private_iw_point fndecl 7 23018 NU
 nested_get_page_fndecl_23031_fns nested_get_page fndecl 2 23031 NULL
 gnttab_free_count_vardecl_grant_table_c_23049_fns gnttab_free_count vardecl_grant-table.c 0 23049 NULL
 fcoe_ctlr_device_add_fndecl_23058_fns fcoe_ctlr_device_add fndecl 3 23058 NULL
+usb_dmac_desc_alloc_fndecl_23059_fns usb_dmac_desc_alloc fndecl 2 23059 NULL
 to_clkrc_fndecl_23074_fns to_clkrc fndecl 0-2-3 23074 NULL
 vicam_set_camera_power_fndecl_23091_fns vicam_set_camera_power fndecl 0 23091 NULL
 rproc_state_write_fndecl_23143_fns rproc_state_write fndecl 3 23143 NULL
@@ -1642,6 +1800,7 @@ devm_create_dax_dev_fndecl_23226_fns devm_create_dax_dev fndecl 3 23226 NULL
 ivtv_v4l2_read_fndecl_23231_fns ivtv_v4l2_read fndecl 3 23231 NULL
 rx_rx_defrag_read_fndecl_23241_fns rx_rx_defrag_read fndecl 3 23241 NULL
 __alloc_bootmem_node_fndecl_23259_fns __alloc_bootmem_node fndecl 2 23259 NULL
+write_flush_pipefs_fndecl_23286_fns write_flush_pipefs fndecl 3 23286 NULL
 tail_userio_device_23332_fns tail userio_device 0 23332 NULL
 compat_sys_vmsplice_fndecl_23344_fns compat_sys_vmsplice fndecl 3 23344 NULL
 v9fs_fid_xattr_get_fndecl_23361_fns v9fs_fid_xattr_get fndecl 0 23361 NULL
@@ -1668,6 +1827,7 @@ cosa_write_fndecl_23549_fns cosa_write fndecl 3 23549 NULL
 syslog_print_fndecl_23584_fns syslog_print fndecl 2 23584 NULL
 tail_len_beacon_attr_23587_fns tail_len beacon_attr 0 23587 NULL
 max_cmd_size_ath6kl_bmi_23591_fns max_cmd_size ath6kl_bmi 0 23591 NULL
+dn_setsockopt_fndecl_23593_fns dn_setsockopt fndecl 5 23593 NULL
 read_file_war_stats_fndecl_23607_fns read_file_war_stats fndecl 3 23607 NULL
 nr_grant_frames_vardecl_grant_table_c_23609_fns nr_grant_frames vardecl_grant-table.c 0 23609 NULL
 nr_tags_blk_mq_tags_23638_fns nr_tags blk_mq_tags 0 23638 NULL
@@ -1676,7 +1836,8 @@ lbs_rdmac_read_fndecl_23729_fns lbs_rdmac_read fndecl 3 23729 NULL
 rx_rx_defrag_end_read_fndecl_23786_fns rx_rx_defrag_end_read fndecl 3 23786 NULL
 read_buffer_length_lego_usb_tower_23787_fns read_buffer_length lego_usb_tower 0 23787 NULL
 nvme_trans_modesel_data_fndecl_23803_fns nvme_trans_modesel_data fndecl 4 23803 NULL
-desc_list_len_timb_dma_desc_23804_fns desc_list_len timb_dma_desc 0 23804 NULL
+desc_list_len_timb_dma_desc_23804_fns desc_list_len timb_dma_desc 0 23804 NULL nohasharray
+_find_next_bit_be_fndecl_23804_fns _find_next_bit_be fndecl 0 23804 &desc_list_len_timb_dma_desc_23804_fns
 compat_sock_setsockopt_fndecl_23812_fns compat_sock_setsockopt fndecl 5 23812 NULL
 sctp_init_cause_fndecl_23813_fns sctp_init_cause fndecl 3 23813 NULL
 carl9170_alloc_fndecl_23816_fns carl9170_alloc fndecl 1 23816 NULL
@@ -1686,22 +1847,28 @@ sel_read_policyvers_fndecl_23844_fns sel_read_policyvers fndecl 3 23844 &padzero
 subbufs_consumed_rchan_buf_23869_fns subbufs_consumed rchan_buf 0 23869 NULL
 load_msg_fndecl_23884_fns load_msg fndecl 2 23884 NULL
 snd_korg1212_copy_to_fndecl_23887_fns snd_korg1212_copy_to fndecl 6 23887 NULL
+tracing_trace_options_write_fndecl_23946_fns tracing_trace_options_write fndecl 3 23946 NULL
 init_q_fndecl_23959_fns init_q fndecl 4 23959 NULL
 memstick_alloc_host_fndecl_23965_fns memstick_alloc_host fndecl 1 23965 NULL
 xfs_buf_item_get_format_fndecl_23982_fns xfs_buf_item_get_format fndecl 2 23982 NULL
 pci_request_selected_regions_fndecl_23994_fns pci_request_selected_regions fndecl 0 23994 NULL
 extract_crng_user_fndecl_23995_fns extract_crng_user fndecl 2 23995 NULL
 iscsi_session_setup_fndecl_24023_fns iscsi_session_setup fndecl 4-5-3 24023 NULL
+vpdma_create_desc_list_fndecl_24044_fns vpdma_create_desc_list fndecl 2 24044 NULL
 buf_size_conf_writedata_24046_fns buf_size conf_writedata 0 24046 NULL
 bNumEndpoints_usb_interface_descriptor_24052_fns bNumEndpoints usb_interface_descriptor 0 24052 NULL
+shdma_init_fndecl_24059_fns shdma_init fndecl 3 24059 NULL
 ws_row_winsize_24064_fns ws_row winsize 0 24064 NULL
 ebx_v86_regs_24072_fns ebx v86_regs 0 24072 NULL
 raydium_i2c_send_fndecl_24090_fns raydium_i2c_send fndecl 4 24090 NULL
+cfs_trace_allocate_string_buffer_fndecl_24094_fns cfs_trace_allocate_string_buffer fndecl 2 24094 NULL
 cnt_nfp_net_rx_ring_24099_fns cnt nfp_net_rx_ring 0 24099 NULL
 size_sge_rspq_24120_fns size sge_rspq 0 24120 NULL
 error_state_read_fndecl_24136_fns error_state_read fndecl 6 24136 NULL
+tegra_clk_init_fndecl_24143_fns tegra_clk_init fndecl 3-2 24143 NULL
 o2net_send_message_vec_fndecl_24188_fns o2net_send_message_vec fndecl 4 24188 NULL
 modules_num_mcp_trace_meta_24193_fns modules_num mcp_trace_meta 0 24193 NULL
+raw_write_fndecl_24208_fns raw_write fndecl 3 24208 NULL
 carl9170_cmd_buf_fndecl_24229_fns carl9170_cmd_buf fndecl 3 24229 NULL
 __nodes_weight_fndecl_24239_fns __nodes_weight fndecl 0 24239 NULL
 iio_storage_bytes_for_timestamp_fndecl_24260_fns iio_storage_bytes_for_timestamp fndecl 0 24260 NULL
@@ -1716,8 +1883,10 @@ compat_sys_preadv_fndecl_24404_fns compat_sys_preadv fndecl 3 24404 NULL
 completed_vringh_24407_fns completed vringh 0 24407 NULL
 max_scbs_hw_profile_24409_fns max_scbs hw_profile 0 24409 NULL
 srpt_cm_rej_recv_fndecl_24427_fns srpt_cm_rej_recv fndecl 4 24427 NULL
+ni_gpct_device_construct_fndecl_24433_fns ni_gpct_device_construct fndecl 5 24433 NULL
 size_tty_buffer_24438_fns size tty_buffer 0 24438 NULL
 fuse_request_alloc_nofs_fndecl_24442_fns fuse_request_alloc_nofs fndecl 1 24442 NULL
+ptlrpc_lprocfs_nrs_seq_write_fndecl_24446_fns ptlrpc_lprocfs_nrs_seq_write fndecl 3 24446 NULL
 unlink_queued_fndecl_24470_fns unlink_queued fndecl 3 24470 NULL
 dtim_interval_read_fndecl_24477_fns dtim_interval_read fndecl 3 24477 NULL
 dvb_video_write_fndecl_24545_fns dvb_video_write fndecl 3 24545 NULL
@@ -1741,6 +1910,7 @@ wilc_set_join_req_fndecl_24725_fns wilc_set_join_req fndecl 4-6 24725 NULL
 outlen_ib_udata_24729_fns outlen ib_udata 0 24729 NULL
 HiSax_readstatus_fndecl_24731_fns HiSax_readstatus fndecl 2 24731 NULL
 smk_read_direct_fndecl_24744_fns smk_read_direct fndecl 3 24744 NULL
+n_ao_urbs_usbduxsigma_private_24760_fns n_ao_urbs usbduxsigma_private 0 24760 NULL
 inftl_read_oob_fndecl_24761_fns inftl_read_oob fndecl 3 24761 NULL
 _sdma_txadd_daddr_fndecl_24789_fns _sdma_txadd_daddr fndecl 5 24789 NULL
 gnttab_expand_fndecl_24794_fns gnttab_expand fndecl 1 24794 NULL
@@ -1757,13 +1927,16 @@ zero_the_pointer_fndecl_25003_fns zero_the_pointer fndecl 0 25003 NULL
 default_density_st_modedef_25006_fns default_density st_modedef 0 25006 NULL
 sdp0length__SpiCfgData_25007_fns sdp0length _SpiCfgData 0 25007 NULL
 acpi_gpio_count_fndecl_25052_fns acpi_gpio_count fndecl 0 25052 NULL
-buffer_size_snd_compr_runtime_25072_fns buffer_size snd_compr_runtime 0 25072 NULL
+buffer_size_snd_compr_runtime_25072_fns buffer_size snd_compr_runtime 0 25072 NULL nohasharray
+vme_user_write_fndecl_25072_fns vme_user_write fndecl 3 25072 &buffer_size_snd_compr_runtime_25072_fns
 mlxsw_reg_trans_wait_fndecl_25101_fns mlxsw_reg_trans_wait fndecl 0 25101 NULL
 num_pbls_ocrdma_hw_mr_25102_fns num_pbls ocrdma_hw_mr 0 25102 NULL
 compat_sys_select_fndecl_25104_fns compat_sys_select fndecl 1 25104 NULL
-fsm_init_fndecl_25109_fns fsm_init fndecl 2 25109 NULL
+fsm_init_fndecl_25109_fns fsm_init fndecl 2 25109 NULL nohasharray
+output_fndecl_25109_fns output fndecl 3 25109 &fsm_init_fndecl_25109_fns
 i40e_allocate_virt_mem_d_fndecl_25132_fns i40e_allocate_virt_mem_d fndecl 3 25132 NULL
 create_table_fndecl_25158_fns create_table fndecl 2 25158 NULL
+ux500_regulator_debug_init_fndecl_25207_fns ux500_regulator_debug_init fndecl 3 25207 NULL
 npeers_cm_dev_25216_fns npeers cm_dev 0 25216 NULL
 of_property_read_string_helper_fndecl_25257_fns of_property_read_string_helper fndecl 0-5 25257 NULL
 stk_allocate_buffers_fndecl_25264_fns stk_allocate_buffers fndecl 2 25264 NULL
@@ -1779,6 +1952,7 @@ native_read_msr_fndecl_25394_fns native_read_msr fndecl 0 25394 NULL
 memblock_virt_alloc_try_nid_fndecl_25409_fns memblock_virt_alloc_try_nid fndecl 1 25409 NULL nohasharray
 memsize_t4_cq_25409_fns memsize t4_cq 0 25409 &memblock_virt_alloc_try_nid_fndecl_25409_fns
 snd_pcm_lib_read_transfer_fndecl_25411_fns snd_pcm_lib_read_transfer fndecl 5 25411 NULL
+ptlrpcd_per_cpt_max_vardecl_ptlrpcd_c_25416_fns ptlrpcd_per_cpt_max vardecl_ptlrpcd.c 0 25416 NULL
 smk_read_ptrace_fndecl_25461_fns smk_read_ptrace fndecl 3 25461 NULL
 viafb_vt1636_proc_write_fndecl_25473_fns viafb_vt1636_proc_write fndecl 3 25473 NULL
 max_buckets_out_mpt_lan_priv_25498_fns max_buckets_out mpt_lan_priv 0 25498 NULL
@@ -1790,6 +1964,7 @@ smk_write_unconfined_fndecl_25530_fns smk_write_unconfined fndecl 3 25530 NULL
 wsm_write_mib_fndecl_25575_fns wsm_write_mib fndecl 4 25575 NULL
 cifs_mapchar_fndecl_25586_fns cifs_mapchar fndecl 0 25586 NULL
 isr_tx_exch_complete_read_fndecl_25588_fns isr_tx_exch_complete_read fndecl 3 25588 NULL
+udelay_test_write_fndecl_25596_fns udelay_test_write fndecl 3 25596 NULL
 isr_hw_pm_mode_changes_read_fndecl_25597_fns isr_hw_pm_mode_changes_read fndecl 3 25597 NULL nohasharray
 dma_tx_requested_read_fndecl_25597_fns dma_tx_requested_read fndecl 3 25597 &isr_hw_pm_mode_changes_read_fndecl_25597_fns
 max_cmd_sg_entries_ctlr_info_25601_fns max_cmd_sg_entries ctlr_info 0 25601 NULL
@@ -1815,16 +1990,19 @@ ext4_kvmalloc_fndecl_25823_fns ext4_kvmalloc fndecl 1 25823 NULL
 pages_per_rd_bio_scrub_ctx_25831_fns pages_per_rd_bio scrub_ctx 0 25831 NULL
 rvt_reg_user_mr_fndecl_25852_fns rvt_reg_user_mr fndecl 4 25852 NULL
 ishtp_dma_num_slots_ishtp_device_25858_fns ishtp_dma_num_slots ishtp_device 0 25858 NULL
+alloc_tx_struct_fndecl_25886_fns alloc_tx_struct fndecl 1 25886 NULL
 walk_page_range_fndecl_25894_fns walk_page_range fndecl 0 25894 NULL
 ath6kl_regdump_read_fndecl_25898_fns ath6kl_regdump_read fndecl 3 25898 NULL
 nfp_net_tx_ring_alloc_fndecl_25907_fns nfp_net_tx_ring_alloc fndecl 2 25907 NULL
 kvm_vcpu_gfn_to_hva_prot_fndecl_25911_fns kvm_vcpu_gfn_to_hva_prot fndecl 2 25911 NULL
-mtd_concat_create_fndecl_25923_fns mtd_concat_create fndecl 2 25923 NULL
+mtd_concat_create_fndecl_25923_fns mtd_concat_create fndecl 2 25923 NULL nohasharray
+d40_pool_lli_alloc_fndecl_25923_fns d40_pool_lli_alloc fndecl 3 25923 &mtd_concat_create_fndecl_25923_fns
 get_kcore_size_fndecl_25930_fns get_kcore_size fndecl 0 25930 NULL
 smk_write_onlycap_fndecl_25939_fns smk_write_onlycap fndecl 3 25939 NULL
 kvm_hv_set_msr_common_fndecl_25940_fns kvm_hv_set_msr_common fndecl 3 25940 NULL
 __media_entity_enum_init_fndecl_25953_fns __media_entity_enum_init fndecl 2 25953 NULL
 tx_max_out_mpt_lan_priv_25974_fns tx_max_out mpt_lan_priv 0 25974 NULL
+picolcd_debug_eeprom_read_fndecl_26054_fns picolcd_debug_eeprom_read fndecl 3 26054 NULL
 _pcol_init_fndecl_26056_fns _pcol_init fndecl 2 26056 NULL
 ep0_write_fndecl_26075_fns ep0_write fndecl 3 26075 NULL
 alloc_bitmap_fndecl_26079_fns alloc_bitmap fndecl 1 26079 NULL
@@ -1851,11 +2029,13 @@ ept_prefetch_gpte_fndecl_26343_fns ept_prefetch_gpte fndecl 4 26343 NULL
 kovaplus_sysfs_read_fndecl_26362_fns kovaplus_sysfs_read fndecl 6 26362 NULL
 __krealloc_fndecl_26394_fns __krealloc fndecl 2 26394 NULL
 get_user_cpu_mask_fndecl_26398_fns get_user_cpu_mask fndecl 2 26398 NULL
+omap_hwmod_count_resources_fndecl_26400_fns omap_hwmod_count_resources fndecl 0 26400 NULL
 krealloc_fndecl_26415_fns krealloc fndecl 2 26415 NULL
 acpi_os_allocate_fndecl_26431_fns acpi_os_allocate fndecl 1 26431 NULL
 start_cif_cam_fndecl_26442_fns start_cif_cam fndecl 0 26442 NULL
 usbat_bulk_read_fndecl_26469_fns usbat_bulk_read fndecl 4 26469 NULL
 queue_cnt_fndecl_26484_fns queue_cnt fndecl 0 26484 NULL
+videobuf_read_stream_fndecl_26495_fns videobuf_read_stream fndecl 3 26495 NULL
 setkey_fndecl_26520_fns setkey fndecl 3 26520 NULL nohasharray
 num_tc_mlx5e_params_26520_fns num_tc mlx5e_params 0 26520 &setkey_fndecl_26520_fns
 npages_kvm_memory_slot_26541_fns npages kvm_memory_slot 0 26541 NULL
@@ -1868,6 +2048,7 @@ hdac_hdmi_fill_widget_info_fndecl_26629_fns hdac_hdmi_fill_widget_info fndecl 8
 cache_write_fndecl_26630_fns cache_write fndecl 3 26630 NULL
 read_file_antenna_fndecl_26645_fns read_file_antenna fndecl 3 26645 NULL
 iio_device_add_event_sysfs_fndecl_26664_fns iio_device_add_event_sysfs fndecl 0 26664 NULL
+gb_operation_unidirectional_timeout_fndecl_26694_fns gb_operation_unidirectional_timeout fndecl 4 26694 NULL
 len_tipc_mon_domain_26711_fns len tipc_mon_domain 0 26711 NULL
 wil_read_back_fndecl_26724_fns wil_read_back fndecl 3 26724 NULL
 cache_downcall_fndecl_26737_fns cache_downcall fndecl 3 26737 NULL
@@ -1885,8 +2066,10 @@ hsi_register_board_info_fndecl_26863_fns hsi_register_board_info fndecl 2 26863
 kvm_read_nested_guest_page_fndecl_26890_fns kvm_read_nested_guest_page fndecl 5 26890 NULL
 read_file_phy_err_fndecl_26901_fns read_file_phy_err fndecl 3 26901 NULL
 reexecute_instruction_fndecl_26906_fns reexecute_instruction fndecl 2 26906 NULL
+edma_prep_slave_sg_fndecl_26917_fns edma_prep_slave_sg fndecl 3 26917 NULL
 cache_ctr_fndecl_26919_fns cache_ctr fndecl 2 26919 NULL
 round_event_name_len_fndecl_26935_fns round_event_name_len fndecl 0 26935 NULL
+axi_dmac_prep_dma_cyclic_fndecl_26953_fns axi_dmac_prep_dma_cyclic fndecl 3-4 26953 NULL
 kvm_vcpu_gfn_to_hva_fndecl_26957_fns kvm_vcpu_gfn_to_hva fndecl 2 26957 NULL
 iso_sched_alloc_fndecl_26962_fns iso_sched_alloc fndecl 1 26962 NULL nohasharray
 wep_key_not_found_read_fndecl_26962_fns wep_key_not_found_read fndecl 3 26962 &iso_sched_alloc_fndecl_26962_fns
@@ -1904,6 +2087,7 @@ sys32_fadvise64_fndecl_27136_fns sys32_fadvise64 fndecl 4 27136 NULL
 do_proc_readlink_fndecl_27139_fns do_proc_readlink fndecl 3 27139 NULL
 compat_sys_pselect6_fndecl_27146_fns compat_sys_pselect6 fndecl 1 27146 NULL
 nilfs_attach_checkpoint_fndecl_27152_fns nilfs_attach_checkpoint fndecl 2 27152 NULL
+cfs_hash_rehash_bits_fndecl_27208_fns cfs_hash_rehash_bits fndecl 0 27208 NULL
 mx_sb_len_sg_io_hdr_27261_fns mx_sb_len sg_io_hdr 0 27261 NULL
 alloc_async_fndecl_27283_fns alloc_async fndecl 1 27283 NULL
 ath6kl_connect_event_fndecl_27304_fns ath6kl_connect_event fndecl 8-9 27304 NULL
@@ -1922,12 +2106,15 @@ evdev_ioctl_compat_fndecl_27400_fns evdev_ioctl_compat fndecl 2 27400 NULL
 max_packages_vardecl_uncore_c_27449_fns max_packages vardecl_uncore.c 0 27449 NULL
 tool_peer_mw_read_fndecl_27484_fns tool_peer_mw_read fndecl 3 27484 NULL
 local_nentries_xpc_channel_27489_fns local_nentries xpc_channel 0 27489 NULL
+dvb_demux_read_fndecl_27534_fns dvb_demux_read fndecl 3 27534 NULL
+lov_obd_packmd_fndecl_27573_fns lov_obd_packmd fndecl 0 27573 NULL
 pci_add_ext_cap_save_buffer_fndecl_27587_fns pci_add_ext_cap_save_buffer fndecl 3 27587 NULL
 dvb_usercopy_fndecl_27591_fns dvb_usercopy fndecl 2 27591 NULL
 md_alloc_fndecl_27600_fns md_alloc fndecl 1 27600 NULL
 iscsi_create_flashnode_conn_fndecl_27605_fns iscsi_create_flashnode_conn fndecl 4 27605 NULL
 error_res_proc_context_27648_fns error res_proc_context 0 27648 NULL
 nvkm_event_init_fndecl_27654_fns nvkm_event_init fndecl 2-3 27654 NULL
+gb_operation_create_common_fndecl_27662_fns gb_operation_create_common fndecl 3 27662 NULL
 masq_device_event_fndecl_27665_fns masq_device_event fndecl 0 27665 NULL
 mr_write_fndecl_27670_fns mr_write fndecl 0 27670 NULL
 tlbflush_write_file_fndecl_27685_fns tlbflush_write_file fndecl 3 27685 NULL
@@ -1942,6 +2129,8 @@ ioat_dca_count_dca_slots_fndecl_27732_fns ioat_dca_count_dca_slots fndecl 0 2773
 word_size_e1000_eeprom_info_27741_fns word_size e1000_eeprom_info 0 27741 NULL
 si_blocks_ocfs2_slot_info_27753_fns si_blocks ocfs2_slot_info 0 27753 NULL
 sel_read_class_fndecl_27758_fns sel_read_class fndecl 3 27758 NULL
+dwc3_link_state_write_fndecl_27762_fns dwc3_link_state_write fndecl 3 27762 NULL
+rtw_android_get_link_speed_fndecl_27772_fns rtw_android_get_link_speed fndecl 0 27772 NULL
 nr_ports_solos_card_27804_fns nr_ports solos_card 0 27804 NULL
 roundup_brcmf_sdio_27833_fns roundup brcmf_sdio 0 27833 NULL nohasharray
 type_kqid_27833_fns type kqid 0 27833 &roundup_brcmf_sdio_27833_fns
@@ -1951,10 +2140,14 @@ listxattr_fndecl_27890_fns listxattr fndecl 3 27890 NULL
 lbq_len_rx_ring_27913_fns lbq_len rx_ring 0 27913 NULL
 numchips_lpddr_private_27938_fns numchips lpddr_private 0 27938 NULL
 usbat_hp8200e_rw_block_test_fndecl_27957_fns usbat_hp8200e_rw_block_test fndecl 5-13 27957 NULL
+pcbit_writecmd_fndecl_27967_fns pcbit_writecmd fndecl 2 27967 NULL
+parser_init_byte_stream_fndecl_27973_fns parser_init_byte_stream fndecl 2 27973 NULL
+mptctl_ioctl_fndecl_27984_fns mptctl_ioctl fndecl 2 27984 NULL
 __nf_ct_ext_add_length_fndecl_27999_fns __nf_ct_ext_add_length fndecl 3 27999 NULL
 xfs_iext_inline_to_direct_fndecl_28019_fns xfs_iext_inline_to_direct fndecl 2 28019 NULL
 populate_dir_fndecl_28020_fns populate_dir fndecl 0 28020 NULL nohasharray
 write_file_dump_fndecl_28020_fns write_file_dump fndecl 3 28020 &populate_dir_fndecl_28020_fns
+cfs_array_alloc_fndecl_28042_fns cfs_array_alloc fndecl 2 28042 NULL
 num_intr_mic_intr_info_28048_fns num_intr mic_intr_info 0 28048 NULL
 bio_slab_max_vardecl_bio_c_28087_fns bio_slab_max vardecl_bio.c 0 28087 NULL
 fnic_trace_ctrl_read_fndecl_28098_fns fnic_trace_ctrl_read fndecl 3 28098 NULL
@@ -1969,9 +2162,11 @@ relay_file_read_fndecl_28240_fns relay_file_read fndecl 3 28240 NULL
 pwr_disable_ps_read_fndecl_28267_fns pwr_disable_ps_read fndecl 3 28267 NULL
 pbdma_nr_gk104_fifo_28278_fns pbdma_nr gk104_fifo 0 28278 NULL
 xhci_segment_alloc_fndecl_28310_fns xhci_segment_alloc fndecl 3 28310 NULL
+comedi_read_fndecl_28316_fns comedi_read fndecl 3 28316 NULL
 npages_mlx4_buf_28321_fns npages mlx4_buf 0 28321 NULL
 set_video_mode_Kiara_fndecl_28325_fns set_video_mode_Kiara fndecl 4 28325 NULL
 fnic_trace_ctrl_write_fndecl_28350_fns fnic_trace_ctrl_write fndecl 3 28350 NULL
+dma_lch_count_vardecl_dma_c_28369_fns dma_lch_count vardecl_dma.c 0 28369 NULL
 usbat_multiple_write_fndecl_28375_fns usbat_multiple_write fndecl 4 28375 NULL
 bio_integrity_trim_fndecl_28376_fns bio_integrity_trim fndecl 2-3 28376 NULL
 simple_attr_write_fndecl_28383_fns simple_attr_write fndecl 3 28383 NULL
@@ -1997,15 +2192,19 @@ wil_write_back_fndecl_28568_fns wil_write_back fndecl 3 28568 NULL
 ufx_i2c_wait_busy_fndecl_28574_fns ufx_i2c_wait_busy fndecl 0 28574 NULL
 charcount_console_font_op_28585_fns charcount console_font_op 0 28585 NULL
 i915_gem_gtt_pread_fndecl_28595_fns i915_gem_gtt_pread fndecl 3-4 28595 NULL
+tmc_read_fndecl_28597_fns tmc_read fndecl 3 28597 NULL
 menu_count_uvc_xu_control_mapping_28599_fns menu_count uvc_xu_control_mapping 0 28599 NULL nohasharray
 bm_status_write_fndecl_28599_fns bm_status_write fndecl 3 28599 &menu_count_uvc_xu_control_mapping_28599_fns
+output_async_fndecl_28621_fns output_async fndecl 3 28621 NULL
 hfi1_rcvarr_split_vardecl_init_c_28624_fns hfi1_rcvarr_split vardecl_init.c 0 28624 NULL
 rvt_rkey_ok_fndecl_28649_fns rvt_rkey_ok fndecl 3-4 28649 NULL
 alloc_size_chunk_28657_fns alloc_size chunk 0 28657 NULL
 offset_cache_reader_28697_fns offset cache_reader 0 28697 NULL
 mlx4_init_cmpt_table_fndecl_28706_fns mlx4_init_cmpt_table fndecl 3 28706 NULL
+lpfc_idiag_ctlacc_write_fndecl_28715_fns lpfc_idiag_ctlacc_write fndecl 3 28715 NULL
 oprofilefs_ulong_to_user_fndecl_28717_fns oprofilefs_ulong_to_user fndecl 3 28717 NULL
-note_last_dentry_fndecl_28724_fns note_last_dentry fndecl 3 28724 NULL
+note_last_dentry_fndecl_28724_fns note_last_dentry fndecl 3 28724 NULL nohasharray
+d40_prep_memcpy_fndecl_28724_fns d40_prep_memcpy fndecl 4 28724 &note_last_dentry_fndecl_28724_fns
 skb_cow_data_fndecl_28734_fns skb_cow_data fndecl 0 28734 NULL
 batadv_iv_ogm_orig_del_if_fndecl_28743_fns batadv_iv_ogm_orig_del_if fndecl 2 28743 NULL
 batadv_iv_ogm_orig_add_if_fndecl_28753_fns batadv_iv_ogm_orig_add_if fndecl 2 28753 NULL
@@ -2033,8 +2232,11 @@ devm_mfd_add_devices_fndecl_29043_fns devm_mfd_add_devices fndecl 4 29043 NULL
 qib_get_base_info_fndecl_29050_fns qib_get_base_info fndecl 3 29050 NULL
 str_to_user_fndecl_29056_fns str_to_user fndecl 2 29056 NULL
 ___alloc_bootmem_fndecl_29057_fns ___alloc_bootmem fndecl 1 29057 NULL
+i40e_dbg_command_write_fndecl_29070_fns i40e_dbg_command_write fndecl 3 29070 NULL
 dev_irnet_write_fndecl_29077_fns dev_irnet_write fndecl 3 29077 NULL
-pci_set_power_state_fndecl_29124_fns pci_set_power_state fndecl 0 29124 NULL
+ablkcipher_edesc_alloc_fndecl_29119_fns ablkcipher_edesc_alloc fndecl 2 29119 NULL
+pci_set_power_state_fndecl_29124_fns pci_set_power_state fndecl 0 29124 NULL nohasharray
+sca3000_read_first_n_hw_rb_fndecl_29124_fns sca3000_read_first_n_hw_rb fndecl 2 29124 &pci_set_power_state_fndecl_29124_fns
 tool_peer_mw_write_fndecl_29137_fns tool_peer_mw_write fndecl 3 29137 NULL
 max_dump_cnt_ramoops_context_29141_fns max_dump_cnt ramoops_context 0 29141 NULL
 kmem_zalloc_fndecl_29157_fns kmem_zalloc fndecl 1 29157 NULL
@@ -2045,6 +2247,7 @@ dvb_dmxdev_buffer_write_fndecl_29234_fns dvb_dmxdev_buffer_write fndecl 0 29234
 count_qed_tid_seg_29243_fns count qed_tid_seg 0 29243 NULL
 ptc_proc_write_fndecl_29247_fns ptc_proc_write fndecl 3 29247 NULL
 hfi1_copy_sge_fndecl_29257_fns hfi1_copy_sge fndecl 3 29257 NULL
+rtw_malloc2d_fndecl_29269_fns rtw_malloc2d fndecl 3-2-1 29269 NULL
 ib_uverbs_open_xrcd_fndecl_29276_fns ib_uverbs_open_xrcd fndecl 4-5 29276 NULL
 xfs_handle_to_dentry_fndecl_29300_fns xfs_handle_to_dentry fndecl 3 29300 NULL
 rawv6_seticmpfilter_fndecl_29306_fns rawv6_seticmpfilter fndecl 5 29306 NULL
@@ -2052,6 +2255,7 @@ fnic_reset_stats_write_fndecl_29314_fns fnic_reset_stats_write fndecl 3 29314 NU
 total_size_orangefs_bufmap_29333_fns total_size orangefs_bufmap 0 29333 NULL
 alloced_snd_array_29353_fns alloced snd_array 0 29353 NULL
 fuse_get_req_fndecl_29358_fns fuse_get_req fndecl 2 29358 NULL
+tx_ring_size_pxa168_eth_private_29372_fns tx_ring_size pxa168_eth_private 0 29372 NULL
 ib_uverbs_unmarshall_recv_fndecl_29384_fns ib_uverbs_unmarshall_recv fndecl 5 29384 NULL
 __alloc_bootmem_low_nopanic_fndecl_29400_fns __alloc_bootmem_low_nopanic fndecl 1 29400 NULL nohasharray
 octeon_alloc_recv_info_fndecl_29400_fns octeon_alloc_recv_info fndecl 1 29400 &__alloc_bootmem_low_nopanic_fndecl_29400_fns
@@ -2069,7 +2273,8 @@ acpi_rs_set_resource_header_fndecl_29642_fns acpi_rs_set_resource_header fndecl
 er_extcount_xfs_ext_irec_29646_fns er_extcount xfs_ext_irec 0 29646 NULL
 control_read_fndecl_29649_fns control_read fndecl 6 29649 NULL
 count_vfio_pci_hot_reset_info_29655_fns count vfio_pci_hot_reset_info 0 29655 NULL
-split_node_fndecl_29659_fns split_node fndecl 0 29659 NULL
+split_node_fndecl_29659_fns split_node fndecl 0 29659 NULL nohasharray
+ls_num_lprocfs_stats_29659_fns ls_num lprocfs_stats 0 29659 &split_node_fndecl_29659_fns
 rds_message_alloc_fndecl_29702_fns rds_message_alloc fndecl 1 29702 NULL
 maxframe_vardecl_n_hdlc_c_29719_fns maxframe vardecl_n_hdlc.c 0 29719 NULL
 sel_write_disable_fndecl_29724_fns sel_write_disable fndecl 3 29724 NULL
@@ -2086,6 +2291,7 @@ error_error_frame_ctrl_read_fndecl_29919_fns error_error_frame_ctrl_read fndecl
 sctp_getsockopt_maxseg_fndecl_29922_fns sctp_getsockopt_maxseg fndecl 2 29922 NULL
 sys_syslog_fndecl_29929_fns sys_syslog fndecl 3 29929 NULL
 cciss_proc_write_fndecl_29952_fns cciss_proc_write fndecl 3 29952 NULL
+msc_nfinalizers_lnet_msg_container_30006_fns msc_nfinalizers lnet_msg_container 0 30006 NULL
 __qlcnic_pci_sriov_enable_fndecl_30010_fns __qlcnic_pci_sriov_enable fndecl 2 30010 NULL
 snd_rme9652_capture_copy_fndecl_30012_fns snd_rme9652_capture_copy fndecl 5 30012 NULL
 read_file_spectral_count_fndecl_30019_fns read_file_spectral_count fndecl 3 30019 NULL
@@ -2096,12 +2302,15 @@ do_compat_pselect_fndecl_30093_fns do_compat_pselect fndecl 1 30093 NULL
 ecryptfs_decode_and_decrypt_filename_fndecl_30104_fns ecryptfs_decode_and_decrypt_filename fndecl 5 30104 NULL
 if_real_bytes_xfs_ifork_30126_fns if_real_bytes xfs_ifork 0 30126 NULL
 send_section_size_netvsc_device_30166_fns send_section_size netvsc_device 0 30166 NULL
+rx_ring_size_pxa168_eth_private_30172_fns rx_ring_size pxa168_eth_private 0 30172 NULL
 event_phy_transmit_error_read_fndecl_30196_fns event_phy_transmit_error_read fndecl 3 30196 NULL
+hrp_nthrs_ptlrpc_hr_partition_30214_fns hrp_nthrs ptlrpc_hr_partition 0 30214 NULL
 minor_rbd_device_30216_fns minor rbd_device 0 30216 NULL
 SetLineNumber_fndecl_30236_fns SetLineNumber fndecl 0 30236 NULL
 minor_count_vardecl_30272_fns minor_count vardecl 0 30272 NULL
 count_argc_fndecl_30296_fns count_argc fndecl 0 30296 NULL
 alloc_alien_cache_fndecl_30308_fns alloc_alien_cache fndecl 2 30308 NULL
+tracing_buffers_read_fndecl_30311_fns tracing_buffers_read fndecl 3 30311 NULL
 kvm_write_guest_cached_fndecl_30321_fns kvm_write_guest_cached fndecl 4 30321 NULL
 avc_stream_set_format_fndecl_30322_fns avc_stream_set_format fndecl 5 30322 NULL
 init_mr_info_fndecl_30331_fns init_mr_info fndecl 3 30331 NULL
@@ -2110,9 +2319,11 @@ nr_ops_rdma_rw_ctx_30338_fns nr_ops rdma_rw_ctx 0 30338 NULL
 len_snd_seq_ev_ext_30374_fns len snd_seq_ev_ext 0 30374 NULL
 max_span_mlxsw_resources_30386_fns max_span mlxsw_resources 0 30386 NULL
 hwm_tx_init_fndecl_30411_fns hwm_tx_init fndecl 4 30411 NULL
+get_pages_vram_fndecl_30416_fns get_pages_vram fndecl 2 30416 NULL
 decode_opaque_fixed_fndecl_30421_fns decode_opaque_fixed fndecl 3 30421 NULL
 flat_state_cnt_vardecl_processor_idle_c_30427_fns flat_state_cnt vardecl_processor_idle.c 0 30427 NULL
 of_irq_count_fndecl_30438_fns of_irq_count fndecl 0 30438 NULL
+comedi_alloc_spriv_fndecl_30449_fns comedi_alloc_spriv fndecl 2 30449 NULL
 btrfs_sync_file_fndecl_30480_fns btrfs_sync_file fndecl 3 30480 NULL
 rd_build_prot_space_fndecl_30490_fns rd_build_prot_space fndecl 3-2 30490 NULL
 vhost_add_used_n_fndecl_30491_fns vhost_add_used_n fndecl 3 30491 NULL
@@ -2122,6 +2333,7 @@ nvme_submit_sync_cmd_fndecl_30530_fns nvme_submit_sync_cmd fndecl 4 30530 NULL
 wMaxCommand_wdm_device_30565_fns wMaxCommand wdm_device 0 30565 NULL
 wil_read_led_blink_time_fndecl_30567_fns wil_read_led_blink_time fndecl 3 30567 NULL
 snd_pcm_oss_write1_fndecl_30571_fns snd_pcm_oss_write1 fndecl 3 30571 NULL
+wiidebug_drm_write_fndecl_30572_fns wiidebug_drm_write fndecl 3 30572 NULL
 mbox_test_message_read_fndecl_30588_fns mbox_test_message_read fndecl 3 30588 NULL
 get_scq_fndecl_30594_fns get_scq fndecl 2 30594 NULL
 tifm_alloc_adapter_fndecl_30596_fns tifm_alloc_adapter fndecl 1 30596 NULL
@@ -2132,6 +2344,7 @@ xfrm_hash_alloc_fndecl_30694_fns xfrm_hash_alloc fndecl 1 30694 NULL
 rx_filter_accum_arp_pend_requests_read_fndecl_30696_fns rx_filter_accum_arp_pend_requests_read fndecl 3 30696 NULL
 bm_entry_read_fndecl_30707_fns bm_entry_read fndecl 3 30707 NULL
 sched_autogroup_write_fndecl_30715_fns sched_autogroup_write fndecl 3 30715 NULL
+__alloc_preds_fndecl_30727_fns __alloc_preds fndecl 2 30727 NULL
 lbs_threshold_write_fndecl_30733_fns lbs_threshold_write fndecl 5 30733 NULL
 mlx5_wq_cyc_get_size_fndecl_30741_fns mlx5_wq_cyc_get_size fndecl 0 30741 NULL
 copy_ucs2_to_user_len_fndecl_30743_fns copy_ucs2_to_user_len fndecl 3 30743 NULL
@@ -2144,6 +2357,7 @@ kobj_map_fndecl_30797_fns kobj_map fndecl 3-2 30797 NULL nohasharray
 ogm_buff_len_batadv_priv_bat_v_30797_fns ogm_buff_len batadv_priv_bat_v 0 30797 &kobj_map_fndecl_30797_fns
 shadow_root_level_kvm_mmu_30842_fns shadow_root_level kvm_mmu 0 30842 NULL
 saa7164_buffer_alloc_user_fndecl_30856_fns saa7164_buffer_alloc_user fndecl 2 30856 NULL
+lov_ost_pool_add_fndecl_30857_fns lov_ost_pool_add fndecl 3 30857 NULL
 snd_emu10k1_fx8010_read_fndecl_30870_fns snd_emu10k1_fx8010_read fndecl 5 30870 NULL
 do_sync_fndecl_30871_fns do_sync fndecl 1 30871 NULL
 num_vec_nicpf_30886_fns num_vec nicpf 0 30886 NULL
@@ -2158,7 +2372,9 @@ __list_lru_count_one_fndecl_30962_fns __list_lru_count_one fndecl 0 30962 NULL
 tx_tx_prepared_descs_read_fndecl_30998_fns tx_tx_prepared_descs_read fndecl 3 30998 NULL
 btrfs_search_slot_fndecl_31011_fns btrfs_search_slot fndecl 0 31011 NULL
 max_order_mthca_buddy_31017_fns max_order mthca_buddy 0 31017 NULL
+hisi_clk_init_fndecl_31037_fns hisi_clk_init fndecl 2 31037 NULL
 krb5_nfold_fndecl_31038_fns krb5_nfold fndecl 1-3 31038 NULL
+samsung_clk_alloc_reg_dump_fndecl_31054_fns samsung_clk_alloc_reg_dump fndecl 2 31054 NULL
 le_max_key_size_write_fndecl_31068_fns le_max_key_size_write fndecl 3 31068 NULL
 get_pipes_num_fndecl_31084_fns get_pipes_num fndecl 0 31084 NULL
 nvme_trans_fmt_get_parm_header_fndecl_31087_fns nvme_trans_fmt_get_parm_header fndecl 2 31087 NULL
@@ -2169,6 +2385,7 @@ read_fndecl_31142_fns read fndecl 3 31142 NULL
 size_stp_policy_id_31167_fns size stp_policy_id 0 31167 NULL
 bm_realloc_pages_fndecl_31172_fns bm_realloc_pages fndecl 2 31172 NULL
 ffs_ep0_write_fndecl_31181_fns ffs_ep0_write fndecl 3 31181 NULL
+op_size_ost_pool_31182_fns op_size ost_pool 0 31182 NULL
 nf_nat_sip_expect_fndecl_31193_fns nf_nat_sip_expect fndecl 8 31193 NULL
 max_packet_size_in_snd_line6_pcm_31207_fns max_packet_size_in snd_line6_pcm 0 31207 NULL
 agp_generic_alloc_user_fndecl_31213_fns agp_generic_alloc_user fndecl 1 31213 NULL nohasharray
@@ -2208,6 +2425,7 @@ compat_import_iovec_fndecl_31721_fns compat_import_iovec fndecl 3 31721 NULL
 transport_len_sockaddr_rxrpc_31772_fns transport_len sockaddr_rxrpc 0 31772 NULL
 i40e_init_msix_fndecl_31776_fns i40e_init_msix fndecl 0 31776 NULL
 fore200e_chunk_alloc_fndecl_31782_fns fore200e_chunk_alloc fndecl 4-3 31782 NULL
+dev_config_fndecl_31785_fns dev_config fndecl 3 31785 NULL
 afs_cell_lookup_fndecl_31793_fns afs_cell_lookup fndecl 2 31793 NULL
 target_submit_cmd_map_sgls_fndecl_31806_fns target_submit_cmd_map_sgls fndecl 11 31806 NULL
 snd_malloc_sgbuf_pages_fndecl_31815_fns snd_malloc_sgbuf_pages fndecl 2 31815 NULL
@@ -2220,6 +2438,7 @@ tty_get_baud_rate_fndecl_31871_fns tty_get_baud_rate fndecl 0 31871 &profile_rem
 s_hdrwords_rvt_qp_31882_fns s_hdrwords rvt_qp 0 31882 NULL
 max_tasks_bnx2fc_hba_31893_fns max_tasks bnx2fc_hba 0 31893 NULL
 it821x_firmware_command_fndecl_31911_fns it821x_firmware_command fndecl 3 31911 NULL
+cfs_cpt_number_fndecl_31929_fns cfs_cpt_number fndecl 0 31929 NULL
 mlx5_vzalloc_fndecl_31940_fns mlx5_vzalloc fndecl 1 31940 NULL
 arcfb_write_fndecl_31981_fns arcfb_write fndecl 3 31981 NULL
 record_size_ramoops_context_31989_fns record_size ramoops_context 0 31989 NULL nohasharray
@@ -2233,8 +2452,12 @@ kvm_mmu_page_set_gfn_fndecl_32050_fns kvm_mmu_page_set_gfn fndecl 2 32050 NULL
 g_num_of_iommus_vardecl_intel_iommu_c_32059_fns g_num_of_iommus vardecl_intel-iommu.c 0 32059 NULL
 assoc_sta_del_all_sta_32069_fns assoc_sta del_all_sta 0 32069 NULL
 rproc_recovery_write_fndecl_32074_fns rproc_recovery_write fndecl 3 32074 NULL
+ahash_edesc_alloc_fndecl_32097_fns ahash_edesc_alloc fndecl 2 32097 NULL
 pci_scan_slot_fndecl_32102_fns pci_scan_slot fndecl 2 32102 NULL
+lpfc_debugfs_max_slow_ring_trc_vardecl_lpfc_debugfs_c_32130_fns lpfc_debugfs_max_slow_ring_trc vardecl_lpfc_debugfs.c 0 32130 NULL
+pwm_buf_sz_usbduxsigma_private_32156_fns pwm_buf_sz usbduxsigma_private 0 32156 NULL
 ioat_alloc_ring_fndecl_32201_fns ioat_alloc_ring fndecl 2 32201 NULL
+nr_spis_v2m_data_32203_fns nr_spis v2m_data 0 32203 NULL
 xdi_copy_from_user_fndecl_32216_fns xdi_copy_from_user fndecl 4 32216 NULL
 generic_bin_search_fndecl_32235_fns generic_bin_search fndecl 0 32235 NULL
 roccat_common2_sysfs_read_fndecl_32252_fns roccat_common2_sysfs_read fndecl 6 32252 NULL
@@ -2270,6 +2493,7 @@ ev_next_dev_data_32542_fns ev_next dev_data 0 32542 NULL
 yurex_write_fndecl_32554_fns yurex_write fndecl 3 32554 NULL
 sys_prctl_fndecl_32557_fns sys_prctl fndecl 4 32557 NULL
 joydev_compat_ioctl_fndecl_32558_fns joydev_compat_ioctl fndecl 2 32558 NULL
+gb_loopback_sync_transfer_fndecl_32561_fns gb_loopback_sync_transfer fndecl 2 32561 NULL
 tx_tx_exch_expiry_read_fndecl_32574_fns tx_tx_exch_expiry_read fndecl 3 32574 NULL
 msg_print_ext_header_fndecl_32580_fns msg_print_ext_header fndecl 0 32580 NULL
 mlx5_modify_nic_vport_vlans_fndecl_32595_fns mlx5_modify_nic_vport_vlans fndecl 3 32595 NULL
@@ -2279,6 +2503,7 @@ wa_nep_queue_fndecl_32649_fns wa_nep_queue fndecl 2 32649 NULL
 dvb_ringbuffer_pkt_next_fndecl_32657_fns dvb_ringbuffer_pkt_next fndecl 0-2 32657 NULL
 nrof_flowrings_brcmf_msgbuf_32666_fns nrof_flowrings brcmf_msgbuf 0 32666 NULL
 compressed_bio_size_fndecl_32676_fns compressed_bio_size fndecl 0-2 32676 NULL
+ab3100_get_set_reg_fndecl_32681_fns ab3100_get_set_reg fndecl 3 32681 NULL
 radeon_drm_ioctl_fndecl_32696_fns radeon_drm_ioctl fndecl 2 32696 NULL
 write_file_ani_fndecl_32709_fns write_file_ani fndecl 3 32709 NULL
 sysfs_merge_group_fndecl_32710_fns sysfs_merge_group fndecl 0 32710 NULL
@@ -2297,14 +2522,17 @@ size_mem_cgroup_threshold_ary_32855_fns size mem_cgroup_threshold_ary 0 32855 NU
 uvc_debugfs_stats_read_fndecl_32856_fns uvc_debugfs_stats_read fndecl 3 32856 NULL
 dvb_ringbuffer_read_user_fndecl_32877_fns dvb_ringbuffer_read_user fndecl 3-0 32877 NULL nohasharray
 dz_divisor_dn_zone_32877_fns dz_divisor dn_zone 0 32877 &dvb_ringbuffer_read_user_fndecl_32877_fns
-btrfs_cow_block_fndecl_32885_fns btrfs_cow_block fndecl 0 32885 NULL
+btrfs_cow_block_fndecl_32885_fns btrfs_cow_block fndecl 0 32885 NULL nohasharray
+wilc_spi_write_fndecl_32885_fns wilc_spi_write fndecl 4 32885 &btrfs_cow_block_fndecl_32885_fns
 snoop_table_size_ib_mad_qp_info_32891_fns snoop_table_size ib_mad_qp_info 0 32891 NULL
 snd_gus_dram_read_fndecl_32893_fns snd_gus_dram_read fndecl 4 32893 NULL
 num_vfs_qlcnic_sriov_32913_fns num_vfs qlcnic_sriov 0 32913 NULL
 ipv6_getsockopt_sticky_fndecl_32916_fns ipv6_getsockopt_sticky fndecl 5 32916 NULL
 ttm_alloc_new_pages_fndecl_32971_fns ttm_alloc_new_pages fndecl 5 32971 NULL
 mtdchar_write_fndecl_33004_fns mtdchar_write fndecl 3 33004 NULL
+ion_ioctl_fndecl_33013_fns ion_ioctl fndecl 2 33013 NULL
 mlxsw_sp_port_ets_maxrate_set_fndecl_33018_fns mlxsw_sp_port_ets_maxrate_set fndecl 0 33018 NULL
+snd_rawmidi_read_fndecl_33026_fns snd_rawmidi_read fndecl 3 33026 NULL
 pipeline_pre_to_defrag_swi_read_fndecl_33042_fns pipeline_pre_to_defrag_swi_read fndecl 3 33042 NULL
 dev_read_fndecl_33058_fns dev_read fndecl 3 33058 NULL
 iov_iter_copy_from_user_atomic_fndecl_33059_fns iov_iter_copy_from_user_atomic fndecl 4 33059 NULL
@@ -2314,6 +2542,7 @@ ocfs2_control_read_fndecl_33094_fns ocfs2_control_read fndecl 3 33094 NULL
 write_gssp_fndecl_33095_fns write_gssp fndecl 3 33095 NULL
 length_rvt_sge_33107_fns length rvt_sge 0 33107 NULL
 fl_create_fndecl_33120_fns fl_create fndecl 5 33120 NULL
+__iommu_alloc_buffer_fndecl_33122_fns __iommu_alloc_buffer fndecl 2 33122 NULL
 drm_atomic_helper_legacy_gamma_set_fndecl_33124_fns drm_atomic_helper_legacy_gamma_set fndecl 5 33124 NULL nohasharray
 gnttab_map_fndecl_33124_fns gnttab_map fndecl 2 33124 &drm_atomic_helper_legacy_gamma_set_fndecl_33124_fns
 ib_uverbs_alloc_mw_fndecl_33131_fns ib_uverbs_alloc_mw fndecl 4-5 33131 NULL
@@ -2331,6 +2560,7 @@ alloc_apertures_fndecl_33250_fns alloc_apertures fndecl 1 33250 NULL
 mem_size_ramoops_platform_data_33263_fns mem_size ramoops_platform_data 0 33263 NULL
 drv_file_st_partstat_33277_fns drv_file st_partstat 0 33277 NULL
 ecryptfs_encrypt_and_encode_filename_fndecl_33297_fns ecryptfs_encrypt_and_encode_filename fndecl 5 33297 NULL
+tracing_set_trace_write_fndecl_33307_fns tracing_set_trace_write fndecl 3 33307 NULL
 ima_show_htable_value_fndecl_33315_fns ima_show_htable_value fndecl 2 33315 NULL
 acpi_gsb_i2c_read_bytes_fndecl_33322_fns acpi_gsb_i2c_read_bytes fndecl 4 33322 NULL
 stk_prepare_sio_buffers_fndecl_33347_fns stk_prepare_sio_buffers fndecl 2 33347 NULL
@@ -2360,6 +2590,7 @@ __kfifo_out_fndecl_33612_fns __kfifo_out fndecl 3-0 33612 NULL
 nf_getsockopt_fndecl_33630_fns nf_getsockopt fndecl 0 33630 NULL nohasharray
 scif_setup_qp_accept_fndecl_33630_fns scif_setup_qp_accept fndecl 4 33630 &nf_getsockopt_fndecl_33630_fns
 memblock_size_vxge_hw_mempool_33647_fns memblock_size vxge_hw_mempool 0 33647 NULL
+rxe_mem_init_fast_fndecl_33682_fns rxe_mem_init_fast fndecl 3 33682 NULL
 diva_get_driver_info_fndecl_33684_fns diva_get_driver_info fndecl 0 33684 NULL
 vlsi_alloc_ring_fndecl_33720_fns vlsi_alloc_ring fndecl 3-4 33720 NULL
 stub_chips_nr_vardecl_i2c_stub_c_33739_fns stub_chips_nr vardecl_i2c-stub.c 0 33739 NULL
@@ -2367,6 +2598,8 @@ xfs_buf_read_map_fndecl_33742_fns xfs_buf_read_map fndecl 3 33742 NULL nohasharr
 do_pwritev_fndecl_33742_fns do_pwritev fndecl 3 33742 &xfs_buf_read_map_fndecl_33742_fns
 cx2341x_ctrl_new_std_fndecl_33782_fns cx2341x_ctrl_new_std fndecl 4 33782 NULL
 pcmcia_replace_cis_fndecl_33785_fns pcmcia_replace_cis fndecl 3 33785 NULL
+sca3000_read_data_fndecl_33787_fns sca3000_read_data fndecl 4 33787 NULL
+gicv2m_init_one_fndecl_33791_fns gicv2m_init_one fndecl 3 33791 NULL
 snd_find_free_minor_fndecl_33820_fns snd_find_free_minor fndecl 0 33820 NULL
 dn_ide_drive_s_33823_fns dn ide_drive_s 0 33823 NULL
 add_partition_fndecl_33847_fns add_partition fndecl 2 33847 NULL
@@ -2383,6 +2616,7 @@ pm8001_store_update_fw_fndecl_33975_fns pm8001_store_update_fw fndecl 4 33975 NU
 mwifiex_create_custom_regdomain_fndecl_33978_fns mwifiex_create_custom_regdomain fndecl 3 33978 NULL nohasharray
 cwarn_cm4000_dev_33978_fns cwarn cm4000_dev 0 33978 &mwifiex_create_custom_regdomain_fndecl_33978_fns
 usbat_bulk_write_fndecl_33983_fns usbat_bulk_write fndecl 4 33983 NULL
+spi_data_write_fndecl_33987_fns spi_data_write fndecl 3 33987 NULL
 ethtool_copy_validate_indir_fndecl_33994_fns ethtool_copy_validate_indir fndecl 4 33994 NULL
 count_xfs_attr_sf_hdr_33996_fns count xfs_attr_sf_hdr 0 33996 NULL
 of_n_size_cells_fndecl_34009_fns of_n_size_cells fndecl 0 34009 NULL
@@ -2393,9 +2627,12 @@ __kvm_write_guest_page_fndecl_34021_fns __kvm_write_guest_page fndecl 5-2 34021
 wil_addba_tx_request_fndecl_34039_fns wil_addba_tx_request fndecl 3 34039 NULL
 conf_read_fndecl_34041_fns conf_read fndecl 3 34041 NULL
 ide_do_setfeature_fndecl_34050_fns ide_do_setfeature fndecl 3 34050 NULL
+lov_get_stripecnt_fndecl_34066_fns lov_get_stripecnt fndecl 3 34066 NULL
+vme_user_read_fndecl_34105_fns vme_user_read fndecl 3 34105 NULL
 vb2_dvb_register_adapter_fndecl_34122_fns vb2_dvb_register_adapter fndecl 0 34122 NULL
 do_command_fndecl_34128_fns do_command fndecl 0 34128 NULL
 switchdev_port_fdb_add_fndecl_34145_fns switchdev_port_fdb_add fndecl 5 34145 NULL
+arm_iommu_alloc_attrs_fndecl_34147_fns arm_iommu_alloc_attrs fndecl 2 34147 NULL
 substream_count_snd_pcm_str_34149_fns substream_count snd_pcm_str 0 34149 NULL
 si476x_radio_read_rds_blckcnt_blob_fndecl_34192_fns si476x_radio_read_rds_blckcnt_blob fndecl 3 34192 NULL
 xen_evtchn_max_channels_fndecl_34213_fns xen_evtchn_max_channels fndecl 0 34213 NULL
@@ -2408,6 +2645,7 @@ tty_port_register_device_fndecl_34276_fns tty_port_register_device fndecl 3 3427
 vb2_core_queue_init_fndecl_34278_fns vb2_core_queue_init fndecl 0 34278 NULL
 write_file_frameerrors_fndecl_34370_fns write_file_frameerrors fndecl 3 34370 NULL
 sel_read_handle_status_fndecl_34392_fns sel_read_handle_status fndecl 3 34392 NULL
+rawv6_setsockopt_fndecl_34422_fns rawv6_setsockopt fndecl 5 34422 NULL
 offsets_size_binder_transaction_data_34461_fns offsets_size binder_transaction_data 0 34461 NULL
 fd_copyin_fndecl_34468_fns fd_copyin fndecl 3 34468 NULL
 num_rx_queues_net_device_34480_fns num_rx_queues net_device 0 34480 NULL
@@ -2416,6 +2654,7 @@ acpi_ex_get_serial_access_length_fndecl_34496_fns acpi_ex_get_serial_access_leng
 count_res_proc_context_34514_fns count res_proc_context 0 34514 NULL
 __add_keyed_refs_fndecl_34517_fns __add_keyed_refs fndecl 3 34517 NULL
 ogm_buff_len_batadv_hard_iface_bat_iv_34532_fns ogm_buff_len batadv_hard_iface_bat_iv 0 34532 NULL
+speakup_file_write_fndecl_34533_fns speakup_file_write fndecl 3 34533 NULL
 dvb_aplay_fndecl_34555_fns dvb_aplay fndecl 3 34555 NULL
 rx_ring_num_config_param_34571_fns rx_ring_num config_param 0 34571 NULL
 sb16_copy_from_user_fndecl_34575_fns sb16_copy_from_user fndecl 10-7-6 34575 NULL
@@ -2456,8 +2695,10 @@ bus_add_device_fndecl_34970_fns bus_add_device fndecl 0 34970 NULL
 rfkill_fop_read_fndecl_34980_fns rfkill_fop_read fndecl 3 34980 NULL
 kfd_gtt_sa_init_fndecl_34996_fns kfd_gtt_sa_init fndecl 3-2 34996 NULL
 error_elp_while_tx_read_fndecl_35002_fns error_elp_while_tx_read fndecl 3 35002 NULL
+arpc_alloc_fndecl_35008_fns arpc_alloc fndecl 2 35008 NULL
 ocfs2_control_write_fndecl_35010_fns ocfs2_control_write fndecl 3 35010 NULL
 kzalloc_fndecl_35015_fns kzalloc fndecl 1 35015 NULL
+lpfc_idiag_pcicfg_write_fndecl_35022_fns lpfc_idiag_pcicfg_write fndecl 3 35022 NULL
 set_video_mode_Timon_fndecl_35074_fns set_video_mode_Timon fndecl 4 35074 NULL
 number_scales_vardecl_powernow_k7_c_35080_fns number_scales vardecl_powernow-k7.c 0 35080 NULL
 sys_kexec_file_load_fndecl_35083_fns sys_kexec_file_load fndecl 3 35083 NULL nohasharray
@@ -2496,7 +2737,8 @@ btrfs_fdatawrite_range_fndecl_35427_fns btrfs_fdatawrite_range fndecl 3 35427 NU
 major_gendisk_35443_fns major gendisk 0 35443 NULL
 sel_write_relabel_fndecl_35464_fns sel_write_relabel fndecl 3 35464 NULL
 kmem_realloc_fndecl_35475_fns kmem_realloc fndecl 2 35475 NULL
-qxl_alloc_client_monitors_config_fndecl_35491_fns qxl_alloc_client_monitors_config fndecl 2 35491 NULL
+qxl_alloc_client_monitors_config_fndecl_35491_fns qxl_alloc_client_monitors_config fndecl 2 35491 NULL nohasharray
+ptlrpcd_partner_group_size_vardecl_ptlrpcd_c_35491_fns ptlrpcd_partner_group_size vardecl_ptlrpcd.c 0 35491 &qxl_alloc_client_monitors_config_fndecl_35491_fns
 sched_feat_write_fndecl_35505_fns sched_feat_write fndecl 3 35505 NULL
 spi_res_alloc_fndecl_35507_fns spi_res_alloc fndecl 3 35507 NULL
 dlci_change_mtu_fndecl_35513_fns dlci_change_mtu fndecl 2 35513 NULL
@@ -2525,6 +2767,7 @@ iscsi_pool_init_fndecl_35730_fns iscsi_pool_init fndecl 2-4 35730 &kobject_set_n
 c4_add_card_fndecl_35755_fns c4_add_card fndecl 3 35755 NULL
 used_tty_buffer_35815_fns used tty_buffer 0 35815 NULL
 paging32_get_level1_sp_gpa_fndecl_35837_fns paging32_get_level1_sp_gpa fndecl 0 35837 NULL
+size_mvneta_tx_queue_35842_fns size mvneta_tx_queue 0 35842 NULL
 start_vga_cam_fndecl_35860_fns start_vga_cam fndecl 0 35860 NULL
 cifs_utf16_bytes_fndecl_35914_fns cifs_utf16_bytes fndecl 0 35914 NULL
 max_packet_size_out_snd_line6_pcm_35915_fns max_packet_size_out snd_line6_pcm 0 35915 NULL
@@ -2539,11 +2782,13 @@ ccid_getsockopt_builtin_ccids_fndecl_35985_fns ccid_getsockopt_builtin_ccids fnd
 v4l2_event_subscribe_fndecl_36004_fns v4l2_event_subscribe fndecl 3 36004 NULL
 igb_alloc_q_vector_fndecl_36009_fns igb_alloc_q_vector fndecl 6-4 36009 NULL nohasharray
 bdev_logical_block_size_fndecl_36009_fns bdev_logical_block_size fndecl 0 36009 &igb_alloc_q_vector_fndecl_36009_fns
+num_of_memcpy_chans_stedma40_platform_data_36011_fns num_of_memcpy_chans stedma40_platform_data 0 36011 NULL
 n_sg_vscsibk_pend_36028_fns n_sg vscsibk_pend 0 36028 NULL
 count_sgentry64_36033_fns count sgentry64 0 36033 NULL
 wdm_write_fndecl_36084_fns wdm_write fndecl 3 36084 NULL
 xfs_trans_read_buf_map_fndecl_36121_fns xfs_trans_read_buf_map fndecl 5 36121 NULL
 sock_setbindtodevice_fndecl_36202_fns sock_setbindtodevice fndecl 3 36202 NULL
+qsfp1_debugfs_write_fndecl_36216_fns qsfp1_debugfs_write fndecl 3 36216 NULL
 MaxDevHandle_mpt3sas_facts_36227_fns MaxDevHandle mpt3sas_facts 0 36227 NULL
 data_queues_rt2x00_dev_36241_fns data_queues rt2x00_dev 0 36241 NULL
 vhost_kvzalloc_fndecl_36242_fns vhost_kvzalloc fndecl 1 36242 NULL
@@ -2554,9 +2799,11 @@ iwl_pcie_txq_alloc_fndecl_36278_fns iwl_pcie_txq_alloc fndecl 3 36278 NULL
 collection_size_hid_device_36289_fns collection_size hid_device 0 36289 NULL
 ssl_next_nilfs_snapshot_list_36302_fns ssl_next nilfs_snapshot_list 0 36302 NULL
 paging64_prefetch_gpte_fndecl_36303_fns paging64_prefetch_gpte fndecl 4 36303 NULL
+tegra_fb_alloc_fndecl_36306_fns tegra_fb_alloc fndecl 4 36306 NULL
 move_buffer_data_fndecl_36318_fns move_buffer_data fndecl 2 36318 NULL
 apei_exec_run_optional_fndecl_36319_fns apei_exec_run_optional fndecl 0 36319 NULL
-ima_write_template_field_data_fndecl_36336_fns ima_write_template_field_data fndecl 2 36336 NULL
+ima_write_template_field_data_fndecl_36336_fns ima_write_template_field_data fndecl 2 36336 NULL nohasharray
+create_trace_kprobe_fndecl_36336_fns create_trace_kprobe fndecl 1 36336 &ima_write_template_field_data_fndecl_36336_fns
 pset_prop_read_u32_array_fndecl_36338_fns pset_prop_read_u32_array fndecl 0 36338 NULL
 iowarrior_read_fndecl_36344_fns iowarrior_read fndecl 3 36344 NULL
 osd_req_write_kern_fndecl_36349_fns osd_req_write_kern fndecl 5 36349 NULL
@@ -2578,6 +2825,7 @@ capture_chips_pcxhr_mgr_36555_fns capture_chips pcxhr_mgr 0 36555 NULL
 __register_chrdev_fndecl_36572_fns __register_chrdev fndecl 2-3 36572 NULL
 do_sys_poll_fndecl_36574_fns do_sys_poll fndecl 2 36574 NULL
 audio_write_fndecl_36582_fns audio_write fndecl 4 36582 NULL
+scan_cnt_ad7280_state_36592_fns scan_cnt ad7280_state 0 36592 NULL
 alloc_fw_event_work_fndecl_36593_fns alloc_fw_event_work fndecl 1 36593 NULL
 __br_fdb_add_fndecl_36596_fns __br_fdb_add fndecl 6 36596 NULL
 write_file_spec_scan_ctl_fndecl_36603_fns write_file_spec_scan_ctl fndecl 3 36603 NULL
@@ -2612,7 +2860,9 @@ gpe_count_acpi_gpe_block_info_37173_fns gpe_count acpi_gpe_block_info 0 37173 NU
 fdb_add_entry_fndecl_37182_fns fdb_add_entry fndecl 6 37182 NULL
 of_address_to_resource_fndecl_37191_fns of_address_to_resource fndecl 2 37191 NULL
 ssd1307fb_write_fndecl_37192_fns ssd1307fb_write fndecl 3 37192 NULL
+hur_len_fndecl_37216_fns hur_len fndecl 0 37216 NULL
 tw686x_real_fps_fndecl_37230_fns tw686x_real_fps fndecl 0-2 37230 NULL
+bt_bmc_read_fndecl_37232_fns bt_bmc_read fndecl 3 37232 NULL
 copy_entries_to_user_fndecl_37276_fns copy_entries_to_user fndecl 1 37276 NULL
 cyz_load_fw_fndecl_37290_fns cyz_load_fw fndecl 0 37290 NULL
 num_bna_mem_info_37294_fns num bna_mem_info 0 37294 NULL
@@ -2622,6 +2872,7 @@ kstrtobool_from_user_fndecl_37318_fns kstrtobool_from_user fndecl 2 37318 NULL
 line6_midibuf_init_fndecl_37338_fns line6_midibuf_init fndecl 2 37338 NULL
 mdio_mii_ioctl_fndecl_37342_fns mdio_mii_ioctl fndecl 0 37342 NULL
 dlen_pg_read_hdr_37352_fns dlen pg_read_hdr 0 37352 NULL
+ieee80211_alloc_txb_fndecl_37358_fns ieee80211_alloc_txb fndecl 1 37358 NULL
 orig_bi_size_usb_idmouse_37372_fns orig_bi_size usb_idmouse 0 37372 NULL
 tx_tx_exch_pending_read_fndecl_37385_fns tx_tx_exch_pending_read fndecl 3 37385 NULL
 hsc_msg_len_set_fndecl_37398_fns hsc_msg_len_set fndecl 2 37398 NULL
@@ -2629,6 +2880,7 @@ ath6kl_wmi_implicit_create_pstream_fndecl_37407_fns ath6kl_wmi_implicit_create_p
 nice_workqueue_attrs_37437_fns nice workqueue_attrs 0 37437 NULL
 devnum_mtd_blktrans_dev_37465_fns devnum mtd_blktrans_dev 0 37465 NULL nohasharray
 cfi_read_query_fndecl_37465_fns cfi_read_query fndecl 0 37465 &devnum_mtd_blktrans_dev_37465_fns
+omap_dma_reserve_channels_vardecl_dma_c_37479_fns omap_dma_reserve_channels vardecl_dma.c 0 37479 NULL
 do_compat_preadv64_fndecl_37482_fns do_compat_preadv64 fndecl 3 37482 NULL
 ath10k_mac_create_fndecl_37485_fns ath10k_mac_create fndecl 1 37485 NULL
 max_virtual_routers_mlxsw_resources_37525_fns max_virtual_routers mlxsw_resources 0 37525 NULL
@@ -2636,6 +2888,7 @@ dwords_qib_verbs_txreq_37537_fns dwords qib_verbs_txreq 0 37537 NULL
 fuse_fsync_common_fndecl_37543_fns fuse_fsync_common fndecl 2-3 37543 NULL
 btrfs_io_bio_alloc_fndecl_37544_fns btrfs_io_bio_alloc fndecl 2 37544 NULL
 num_rand_bytes_ecryptfs_write_tag_70_packet_silly_stack_37548_fns num_rand_bytes ecryptfs_write_tag_70_packet_silly_stack 0 37548 NULL
+n_ai_urbs_usbdux_private_37595_fns n_ai_urbs usbdux_private 0 37595 NULL
 tx_tx_start_data_read_fndecl_37616_fns tx_tx_start_data_read fndecl 3 37616 NULL
 usb_stor_bulk_srb_fndecl_37641_fns usb_stor_bulk_srb fndecl 2 37641 NULL
 copy_ctr_args_fndecl_37642_fns copy_ctr_args fndecl 2 37642 NULL
@@ -2644,7 +2897,10 @@ nvme_trans_ext_inq_page_fndecl_37691_fns nvme_trans_ext_inq_page fndecl 3 37691
 run_start_commands_fndecl_37723_fns run_start_commands fndecl 0 37723 NULL
 mon_bin_get_event_fndecl_37740_fns mon_bin_get_event fndecl 4-6 37740 NULL
 pwr_rcvd_beacons_read_fndecl_37751_fns pwr_rcvd_beacons_read fndecl 3 37751 NULL
+cache_read_procfs_fndecl_37761_fns cache_read_procfs fndecl 3 37761 NULL
 kvm_kvzalloc_fndecl_37773_fns kvm_kvzalloc fndecl 1 37773 NULL
+ds9490r_read_block_fndecl_37799_fns ds9490r_read_block fndecl 3 37799 NULL
+ifc_len_ifconf_37839_fns ifc_len ifconf 0 37839 NULL
 __kfifo_skip_r_fndecl_37849_fns __kfifo_skip_r fndecl 2 37849 NULL
 sctp_init_cause_fixed_fndecl_37853_fns sctp_init_cause_fixed fndecl 3 37853 NULL
 ioread16be_fndecl_37854_fns ioread16be fndecl 0 37854 NULL
@@ -2654,9 +2910,11 @@ num_node_state_fndecl_37870_fns num_node_state fndecl 0 37870 NULL
 dm_bufio_client_create_fndecl_37889_fns dm_bufio_client_create fndecl 4 37889 NULL
 logi_dj_hidpp_event_fndecl_37899_fns logi_dj_hidpp_event fndecl 4 37899 NULL
 pvr2_i2c_basic_op_fndecl_37917_fns pvr2_i2c_basic_op fndecl 4-6 37917 NULL
+spk_ye_vardecl_37920_fns spk_ye vardecl 0 37920 NULL
 num_escbs_asd_seq_data_37938_fns num_escbs asd_seq_data 0 37938 NULL
 kvm_fetch_guest_virt_fndecl_37942_fns kvm_fetch_guest_virt fndecl 2-4 37942 NULL
 seq_write_fndecl_37946_fns seq_write fndecl 3 37946 NULL
+mbox_write_fndecl_37967_fns mbox_write fndecl 3 37967 NULL
 vortex_core_init_fndecl_37980_fns vortex_core_init fndecl 0 37980 NULL
 key_search_fndecl_37982_fns key_search fndecl 0 37982 NULL
 nlmsvc_lookup_host_fndecl_37992_fns nlmsvc_lookup_host fndecl 3 37992 NULL
@@ -2673,8 +2931,10 @@ nf_ct_ext_create_fndecl_38195_fns nf_ct_ext_create fndecl 3 38195 NULL
 drm_property_create_fndecl_38196_fns drm_property_create fndecl 4 38196 NULL
 nilfs_cpfile_checkpoints_in_block_fndecl_38197_fns nilfs_cpfile_checkpoints_in_block fndecl 0-2-3 38197 NULL
 goto_high_power_fndecl_38198_fns goto_high_power fndecl 0 38198 NULL
+rx_offset_tg3_38201_fns rx_offset tg3 0 38201 NULL
 dvb_audio_write_fndecl_38232_fns dvb_audio_write fndecl 3 38232 NULL
 mwifiex_11n_delba_fndecl_38254_fns mwifiex_11n_delba fndecl 2 38254 NULL
+i2c2_debugfs_read_fndecl_38270_fns i2c2_debugfs_read fndecl 3 38270 NULL
 max_read_sge_ib_qp_38275_fns max_read_sge ib_qp 0 38275 NULL
 header_length_fw_iso_packet_38284_fns header_length fw_iso_packet 0 38284 NULL
 cacheless_memcpy_fndecl_38293_fns cacheless_memcpy fndecl 3 38293 NULL
@@ -2693,15 +2953,19 @@ chrdev_setup_rx_fndecl_38384_fns chrdev_setup_rx fndecl 2 38384 NULL
 blk_register_region_fndecl_38387_fns blk_register_region fndecl 1-2 38387 NULL
 size_vfio_info_cap_38398_fns size vfio_info_cap 0 38398 NULL
 ath6kl_sdio_alloc_prep_scat_req_fndecl_38401_fns ath6kl_sdio_alloc_prep_scat_req fndecl 2 38401 NULL
+dwc3_mode_write_fndecl_38414_fns dwc3_mode_write fndecl 3 38414 NULL
 read_page_fndecl_38423_fns read_page fndecl 2 38423 NULL
 dvb_ringbuffer_avail_fndecl_38474_fns dvb_ringbuffer_avail fndecl 0 38474 NULL
 __fuse_request_alloc_fndecl_38479_fns __fuse_request_alloc fndecl 1 38479 NULL
 dma_rx_errors_read_fndecl_38494_fns dma_rx_errors_read fndecl 3 38494 NULL
+bt_bmc_write_fndecl_38538_fns bt_bmc_write fndecl 3 38538 NULL
 tx_win_size_mwifiex_add_ba_param_38553_fns tx_win_size mwifiex_add_ba_param 0 38553 NULL
 hysdn_conf_write_fndecl_38562_fns hysdn_conf_write fndecl 3 38562 NULL
 retry_count_read_fndecl_38578_fns retry_count_read fndecl 3 38578 NULL
+gdm_usb_hci_send_fndecl_38585_fns gdm_usb_hci_send fndecl 3 38585 NULL
 print_prefix_fndecl_38595_fns print_prefix fndecl 0 38595 NULL
 proc_pid_readlink_fndecl_38601_fns proc_pid_readlink fndecl 3 38601 NULL
+perf_num_counters_fndecl_38605_fns perf_num_counters fndecl 0 38605 NULL
 mga_compat_ioctl_fndecl_38617_fns mga_compat_ioctl fndecl 2 38617 NULL
 vmci_qp_broker_alloc_fndecl_38635_fns vmci_qp_broker_alloc fndecl 6-5 38635 NULL
 str_read_fndecl_38656_fns str_read fndecl 4 38656 NULL
@@ -2718,6 +2982,7 @@ get_user_pages_fast_fndecl_38708_fns get_user_pages_fast fndecl 0 38708 NULL
 acpi_table_parse_entries_fndecl_38730_fns acpi_table_parse_entries fndecl 0 38730 NULL
 last_error_boot_data_38741_fns last_error boot_data 0 38741 NULL
 ssd1307fb_alloc_array_fndecl_38751_fns ssd1307fb_alloc_array fndecl 1 38751 NULL
+buffer_from_user_fndecl_38753_fns buffer_from_user fndecl 3 38753 NULL
 t4_max_iq_size_c4iw_hw_queue_38756_fns t4_max_iq_size c4iw_hw_queue 0 38756 NULL
 egr_start_sge_38761_fns egr_start sge 0 38761 NULL
 write_packet_fndecl_38765_fns write_packet fndecl 5 38765 NULL
@@ -2741,6 +3006,7 @@ xillybus_write_fndecl_39102_fns xillybus_write fndecl 3 39102 NULL
 audio_ins_vx_core_39112_fns audio_ins vx_core 0 39112 NULL
 acpi_data_get_property_array_fndecl_39128_fns acpi_data_get_property_array fndecl 0 39128 NULL
 simple_transaction_get_fndecl_39130_fns simple_transaction_get fndecl 3 39130 NULL
+raid56_parity_alloc_scrub_rbio_fndecl_39153_fns raid56_parity_alloc_scrub_rbio fndecl 4 39153 NULL
 sys_readv_fndecl_39163_fns sys_readv fndecl 3 39163 NULL
 cfg80211_roamed_bss_fndecl_39173_fns cfg80211_roamed_bss fndecl 6-4 39173 NULL
 cyttsp4_probe_fndecl_39178_fns cyttsp4_probe fndecl 4 39178 NULL
@@ -2748,12 +3014,14 @@ l2cap_sock_setsockopt_fndecl_39180_fns l2cap_sock_setsockopt fndecl 5 39180 NULL
 mthca_buddy_init_fndecl_39181_fns mthca_buddy_init fndecl 2 39181 NULL
 rvt_map_phys_fmr_fndecl_39197_fns rvt_map_phys_fmr fndecl 4 39197 NULL
 sg_kmalloc_fndecl_39251_fns sg_kmalloc fndecl 1 39251 NULL
+soc_codec_reg_show_fndecl_39277_fns soc_codec_reg_show fndecl 3-0 39277 NULL
 size_tomoyo_condition_39281_fns size tomoyo_condition 0 39281 NULL
 rxrpc_setsockopt_fndecl_39293_fns rxrpc_setsockopt fndecl 5 39293 NULL
 SYSC_flistxattr_fndecl_39312_fns SYSC_flistxattr fndecl 3 39312 NULL
 SYSC_sched_setaffinity_fndecl_39317_fns SYSC_sched_setaffinity fndecl 2 39317 NULL
 isdn_ppp_read_fndecl_39335_fns isdn_ppp_read fndecl 4 39335 NULL
-fscrypt_fname_alloc_buffer_fndecl_39339_fns fscrypt_fname_alloc_buffer fndecl 2 39339 NULL
+fscrypt_fname_alloc_buffer_fndecl_39339_fns fscrypt_fname_alloc_buffer fndecl 2 39339 NULL nohasharray
+musb_softconnect_write_fndecl_39339_fns musb_softconnect_write fndecl 3 39339 &fscrypt_fname_alloc_buffer_fndecl_39339_fns
 setbrightness_fndecl_39342_fns setbrightness fndecl 0 39342 NULL
 tpm_read_fndecl_39355_fns tpm_read fndecl 3 39355 NULL
 max_skl_algo_data_39368_fns max skl_algo_data 0 39368 NULL
@@ -2763,9 +3031,11 @@ sl_alloc_bufs_fndecl_39391_fns sl_alloc_bufs fndecl 2 39391 NULL
 iscsi_create_conn_fndecl_39402_fns iscsi_create_conn fndecl 2 39402 NULL
 show_device_status_fndecl_39440_fns show_device_status fndecl 0 39440 NULL
 virtio_cread16_fndecl_39444_fns virtio_cread16 fndecl 0 39444 NULL
+tp_la_write_fndecl_39445_fns tp_la_write fndecl 3 39445 NULL
 proc_write_fndecl_39464_fns proc_write fndecl 3 39464 NULL
 qib_verbs_send_pio_fndecl_39482_fns qib_verbs_send_pio fndecl 5 39482 NULL
-lbs_dev_info_fndecl_39516_fns lbs_dev_info fndecl 3 39516 NULL
+lbs_dev_info_fndecl_39516_fns lbs_dev_info fndecl 3 39516 NULL nohasharray
+mwifiex_timeshare_coex_write_fndecl_39516_fns mwifiex_timeshare_coex_write fndecl 3 39516 &lbs_dev_info_fndecl_39516_fns
 error_tx_resume_failure_read_fndecl_39521_fns error_tx_resume_failure_read fndecl 3 39521 NULL
 rsc_mgr_init_fndecl_39528_fns rsc_mgr_init fndecl 3 39528 NULL
 wusb_prf_64_fndecl_39530_fns wusb_prf_64 fndecl 7 39530 NULL
@@ -2803,6 +3073,7 @@ compat_do_msg_fill_fndecl_39987_fns compat_do_msg_fill fndecl 3 39987 NULL
 start_sram_reserve_39999_fns start sram_reserve 0 39999 NULL
 isr_decrypt_done_read_fndecl_40001_fns isr_decrypt_done_read fndecl 3 40001 NULL
 emulator_write_phys_fndecl_40035_fns emulator_write_phys fndecl 2-4 40035 NULL
+stm32_dma_prep_dma_memcpy_fndecl_40057_fns stm32_dma_prep_dma_memcpy fndecl 4 40057 NULL
 rx_queue_add_kobject_fndecl_40068_fns rx_queue_add_kobject fndecl 0 40068 NULL
 x25_asy_maxdev_vardecl_x25_asy_c_40074_fns x25_asy_maxdev vardecl_x25_asy.c 0 40074 NULL
 num_parents_clk_core_40091_fns num_parents clk_core 0 40091 NULL
@@ -2819,17 +3090,21 @@ ipw_queue_tx_init_fndecl_40218_fns ipw_queue_tx_init fndecl 3 40218 NULL
 skl_get_module_params_fndecl_40234_fns skl_get_module_params fndecl 3 40234 NULL
 digest_size_public_key_signature_40282_fns digest_size public_key_signature 0 40282 NULL
 rx_filter_beacon_filter_read_fndecl_40300_fns rx_filter_beacon_filter_read fndecl 3 40300 NULL
+num_engines_dmm_40301_fns num_engines dmm 0 40301 NULL
 uio_read_fndecl_40327_fns uio_read fndecl 3 40327 NULL
 nvif_notify_init_fndecl_40342_fns nvif_notify_init fndecl 7-6 40342 NULL
-srpt_alloc_ioctx_ring_fndecl_40353_fns srpt_alloc_ioctx_ring fndecl 2 40353 NULL
+srpt_alloc_ioctx_ring_fndecl_40353_fns srpt_alloc_ioctx_ring fndecl 2-3-4 40353 NULL
 tool_link_event_write_fndecl_40366_fns tool_link_event_write fndecl 3 40366 NULL
 SYSC_mincore_fndecl_40372_fns SYSC_mincore fndecl 2-1 40372 NULL
 pages_per_wr_bio_scrub_wr_ctx_40374_fns pages_per_wr_bio scrub_wr_ctx 0 40374 NULL
+__vmalloc_node_fndecl_40382_fns __vmalloc_node fndecl 1 40382 NULL
+qsfp_read_fndecl_40391_fns qsfp_read fndecl 0 40391 NULL
 px_raw_event_fndecl_40392_fns px_raw_event fndecl 4 40392 NULL
 joydev_ioctl_common_fndecl_40412_fns joydev_ioctl_common fndecl 2 40412 NULL
 applesmc_create_nodes_fndecl_40419_fns applesmc_create_nodes fndecl 2 40419 NULL
 rx_streaming_always_read_fndecl_40426_fns rx_streaming_always_read fndecl 3 40426 NULL
 iscsi_alloc_session_fndecl_40445_fns iscsi_alloc_session fndecl 3 40445 NULL
+submit_create_fndecl_40462_fns submit_create fndecl 3 40462 NULL
 __copy_from_user_inatomic_nocache_fndecl_40466_fns __copy_from_user_inatomic_nocache fndecl 3 40466 NULL
 xfs_rmap_update_create_intent_fndecl_40493_fns xfs_rmap_update_create_intent fndecl 2 40493 NULL
 num_substreams_snd_m3_40528_fns num_substreams snd_m3 0 40528 NULL
@@ -2837,6 +3112,7 @@ nf_sockopt_fndecl_40555_fns nf_sockopt fndecl 0 40555 NULL
 alloc_ebda_hpc_fndecl_40557_fns alloc_ebda_hpc fndecl 1-2 40557 NULL
 security_context_to_sid_fndecl_40560_fns security_context_to_sid fndecl 2 40560 NULL
 compat_sys_preadv2_fndecl_40579_fns compat_sys_preadv2 fndecl 3 40579 NULL
+android_set_cntry_fndecl_40615_fns android_set_cntry fndecl 0 40615 NULL
 __kfifo_dma_in_prepare_fndecl_40626_fns __kfifo_dma_in_prepare fndecl 4 40626 NULL
 pcpu_get_vm_areas_fndecl_40630_fns pcpu_get_vm_areas fndecl 3 40630 NULL
 dev_set_alias_fndecl_40631_fns dev_set_alias fndecl 3 40631 NULL
@@ -2868,6 +3144,7 @@ pci_add_dynid_fndecl_40893_fns pci_add_dynid fndecl 8 40893 NULL
 build_verbs_tx_desc_fndecl_40917_fns build_verbs_tx_desc fndecl 3 40917 NULL
 sctp_setsockopt_bindx_fndecl_40925_fns sctp_setsockopt_bindx fndecl 3 40925 NULL
 ecryptfs_filldir_fndecl_40939_fns ecryptfs_filldir fndecl 3 40939 NULL
+sg_nents_for_len_fndecl_40942_fns sg_nents_for_len fndecl 0 40942 NULL
 size_v4l2_ext_control_40952_fns size v4l2_ext_control 0 40952 NULL
 ns_segnum_the_nilfs_40959_fns ns_segnum the_nilfs 0 40959 NULL
 isr_low_rssi_read_fndecl_40966_fns isr_low_rssi_read fndecl 3 40966 NULL
@@ -2880,6 +3157,7 @@ nfsctl_transaction_write_fndecl_41011_fns nfsctl_transaction_write fndecl 3 4101
 proc_projid_map_write_fndecl_41017_fns proc_projid_map_write fndecl 3 41017 NULL
 rfkill_fop_write_fndecl_41019_fns rfkill_fop_write fndecl 3 41019 NULL
 num_qps_qed_rdma_info_41030_fns num_qps qed_rdma_info 0 41030 NULL
+lprocfs_write_u64_helper_fndecl_41059_fns lprocfs_write_u64_helper fndecl 2 41059 NULL
 userio_char_read_fndecl_41065_fns userio_char_read fndecl 3 41065 NULL
 qp_table_size_rvt_qp_ibdev_41075_fns qp_table_size rvt_qp_ibdev 0 41075 NULL
 gfn_to_pfn_fndecl_41077_fns gfn_to_pfn fndecl 2 41077 NULL
@@ -2895,6 +3173,7 @@ hidp_process_report_fndecl_41140_fns hidp_process_report fndecl 4 41140 NULL
 usb_reset_and_verify_device_fndecl_41142_fns usb_reset_and_verify_device fndecl 0 41142 NULL
 calib_fail_count_read_fndecl_41171_fns calib_fail_count_read fndecl 3 41171 NULL
 suspend_dtim_interval_read_fndecl_41176_fns suspend_dtim_interval_read fndecl 3 41176 NULL
+traceprobe_probes_write_fndecl_41178_fns traceprobe_probes_write fndecl 3 41178 NULL
 nr_pages_page_collect_41197_fns nr_pages page_collect 0 41197 NULL
 sq905_command_fndecl_41201_fns sq905_command fndecl 0 41201 NULL
 nr_acpi_bits_vardecl_xen_acpi_processor_c_41210_fns nr_acpi_bits vardecl_xen-acpi-processor.c 0 41210 NULL
@@ -2910,13 +3189,17 @@ num_threads_acpi_db_method_info_41261_fns num_threads acpi_db_method_info 0 4126
 frame_interval_tw5864_input_41274_fns frame_interval tw5864_input 0 41274 NULL
 vb2_queue_init_fndecl_41292_fns vb2_queue_init fndecl 0 41292 NULL
 kfd_set_pasid_limit_fndecl_41300_fns kfd_set_pasid_limit fndecl 1 41300 NULL
+img_SRAM_size_fw_hdr_41311_fns img_SRAM_size fw_hdr 0 41311 NULL nohasharray
+d40_size_2_dmalen_fndecl_41311_fns d40_size_2_dmalen fndecl 0-3-2-1 41311 &img_SRAM_size_fw_hdr_41311_fns
 cma_declare_contiguous_fndecl_41316_fns cma_declare_contiguous fndecl 5 41316 NULL
+gb_loopback_sync_sink_fndecl_41337_fns gb_loopback_sync_sink fndecl 2 41337 NULL
 fanotify_write_fndecl_41340_fns fanotify_write fndecl 3 41340 NULL
 regmap_read_debugfs_fndecl_41345_fns regmap_read_debugfs fndecl 5 41345 NULL
 tlbflush_read_file_fndecl_41350_fns tlbflush_read_file fndecl 3 41350 NULL
 efx_tsoh_get_buffer_fndecl_41355_fns efx_tsoh_get_buffer fndecl 3 41355 NULL
 usb_stor_probe1_fndecl_41357_fns usb_stor_probe1 fndecl 0 41357 NULL
 rx_rx_out_of_mpdu_nodes_read_fndecl_41359_fns rx_rx_out_of_mpdu_nodes_read fndecl 3 41359 NULL
+gb_loopback_async_transfer_fndecl_41372_fns gb_loopback_async_transfer fndecl 2 41372 NULL
 max_frame_size_mgsl_struct_41374_fns max_frame_size mgsl_struct 0 41374 NULL
 TupleDataMax_tuple_t_41376_fns TupleDataMax tuple_t 0 41376 NULL
 l_tree_depth_ocfs2_extent_list_41398_fns l_tree_depth ocfs2_extent_list 0 41398 NULL
@@ -2933,6 +3216,7 @@ unpack_array_fndecl_41525_fns unpack_array fndecl 0 41525 NULL
 pci_vpd_find_tag_fndecl_41534_fns pci_vpd_find_tag fndecl 0-2 41534 NULL
 alloc_cpu_rmap_fndecl_41536_fns alloc_cpu_rmap fndecl 1 41536 NULL
 max_nr_ports_virtio_console_config_41559_fns max_nr_ports virtio_console_config 0 41559 NULL
+fpa_set_fndecl_41560_fns fpa_set fndecl 3-4 41560 NULL
 dma_rx_requested_read_fndecl_41561_fns dma_rx_requested_read fndecl 3 41561 NULL
 stv0680_handle_error_fndecl_41563_fns stv0680_handle_error fndecl 0-2 41563 NULL
 __alloc_bootmem_nopanic_fndecl_41574_fns __alloc_bootmem_nopanic fndecl 1 41574 NULL
@@ -2954,6 +3238,7 @@ v4l2_ctrl_handler_init_class_fndecl_41742_fns v4l2_ctrl_handler_init_class fndec
 insert_dent_fndecl_41753_fns insert_dent fndecl 7 41753 NULL
 vop_virtio_copy_to_user_fndecl_41756_fns vop_virtio_copy_to_user fndecl 4-3 41756 NULL
 __alloc_bootmem_node_high_fndecl_41767_fns __alloc_bootmem_node_high fndecl 2 41767 NULL
+batadv_socket_write_fndecl_41768_fns batadv_socket_write fndecl 3 41768 NULL
 tc_action_net_init_fndecl_41775_fns tc_action_net_init fndecl 3 41775 NULL
 pcibios_enable_device_fndecl_41776_fns pcibios_enable_device fndecl 0 41776 NULL
 outlen_mlx5_cmd_debug_41806_fns outlen mlx5_cmd_debug 0 41806 NULL
@@ -2993,6 +3278,8 @@ snd_compr_write_fndecl_42144_fns snd_compr_write fndecl 3 42144 NULL
 __team_options_register_fndecl_42198_fns __team_options_register fndecl 3 42198 NULL
 reg_count_cpia2_command_42201_fns reg_count cpia2_command 0 42201 NULL
 construct_key_and_link_fndecl_42210_fns construct_key_and_link fndecl 3 42210 NULL
+num_q_vectors_igb_adapter_42232_fns num_q_vectors igb_adapter 0 42232 NULL
+cur_count_of_phandle_iterator_42243_fns cur_count of_phandle_iterator 0 42243 NULL
 len_wmi_tlv_42244_fns len wmi_tlv 0 42244 NULL
 nchunks_radeon_cs_parser_42251_fns nchunks radeon_cs_parser 0 42251 NULL
 read_kcore_fndecl_42259_fns read_kcore fndecl 3 42259 NULL
@@ -3016,6 +3303,7 @@ max_allowed_qxl_monitors_config_42481_fns max_allowed qxl_monitors_config 0 4248
 hid_sensor_client_cnt_sensor_hub_data_42488_fns hid_sensor_client_cnt sensor_hub_data 0 42488 NULL
 bpf_check_classic_fndecl_42501_fns bpf_check_classic fndecl 2 42501 NULL
 __mic_dma_alloc_fndecl_42540_fns __mic_dma_alloc fndecl 2 42540 NULL
+info_debugfs_read_fndecl_42544_fns info_debugfs_read fndecl 3 42544 NULL
 qla8044_write_optrom_data_fndecl_42561_fns qla8044_write_optrom_data fndecl 4 42561 NULL
 ts_write_fndecl_42563_fns ts_write fndecl 3 42563 NULL
 usbtmc_write_fndecl_42567_fns usbtmc_write fndecl 3 42567 NULL
@@ -3041,6 +3329,7 @@ oom_adj_write_fndecl_42687_fns oom_adj_write fndecl 3 42687 NULL
 ccp_update_sg_workarea_fndecl_42688_fns ccp_update_sg_workarea fndecl 2 42688 NULL
 data_size_dm_ioctl_42701_fns data_size dm_ioctl 0 42701 NULL
 handle_abnormal_pfn_fndecl_42730_fns handle_abnormal_pfn fndecl 3 42730 NULL
+gb_control_get_manifest_size_operation_fndecl_42744_fns gb_control_get_manifest_size_operation fndecl 0 42744 NULL
 mlx5_fc_stats_query_fndecl_42750_fns mlx5_fc_stats_query fndecl 3 42750 NULL
 read_file_frameerrors_fndecl_42770_fns read_file_frameerrors fndecl 3 42770 NULL
 ssid_len_ath6kl_vif_42784_fns ssid_len ath6kl_vif 0 42784 NULL
@@ -3052,8 +3341,11 @@ init_bch_fndecl_42897_fns init_bch fndecl 1-2 42897 NULL
 length_drm_property_blob_42912_fns length drm_property_blob 0 42912 NULL
 do_command_extended_fndecl_42913_fns do_command_extended fndecl 0 42913 NULL
 bnx2x_vf_mcast_fndecl_42933_fns bnx2x_vf_mcast fndecl 4 42933 NULL
+wm_coeff_tlv_get_fndecl_42961_fns wm_coeff_tlv_get fndecl 3 42961 NULL
 pof_reclen_boot_data_42966_fns pof_reclen boot_data 0 42966 NULL
 ea_len_fndecl_42998_fns ea_len fndecl 0 42998 NULL
+obd_ioctl_popdata_fndecl_43014_fns obd_ioctl_popdata fndecl 3 43014 NULL
+quirk_simultaneous_discovery_write_fndecl_43076_fns quirk_simultaneous_discovery_write fndecl 3 43076 NULL
 rx_fcs_err_read_fndecl_43119_fns rx_fcs_err_read fndecl 3 43119 NULL
 ndev_init_isr_fndecl_43138_fns ndev_init_isr fndecl 3 43138 NULL
 kvm_vcpu_gfn_to_pfn_fndecl_43158_fns kvm_vcpu_gfn_to_pfn fndecl 2 43158 NULL
@@ -3068,6 +3360,7 @@ send_write_fndecl_43242_fns send_write fndecl 2-0 43242 NULL
 agp_create_user_memory_fndecl_43256_fns agp_create_user_memory fndecl 1 43256 NULL
 persistent_ram_new_fndecl_43278_fns persistent_ram_new fndecl 1-2 43278 NULL
 of_property_read_string_array_fndecl_43294_fns of_property_read_string_array fndecl 0 43294 NULL
+__netdev_adjacent_dev_insert_fndecl_43317_fns __netdev_adjacent_dev_insert fndecl 0 43317 NULL
 qib_refresh_qsfp_cache_fndecl_43328_fns qib_refresh_qsfp_cache fndecl 0 43328 NULL
 debugfs_read_fndecl_43348_fns debugfs_read fndecl 3 43348 NULL
 __kmalloc_node_track_caller_fndecl_43349_fns __kmalloc_node_track_caller fndecl 1 43349 NULL
@@ -3097,16 +3390,19 @@ rxpipe_missed_beacon_host_int_trig_rx_data_read_fndecl_43710_fns rxpipe_missed_b
 in_size_xz_buf_43724_fns in_size xz_buf 0 43724 NULL
 gfn_to_hva_many_fndecl_43742_fns gfn_to_hva_many fndecl 2 43742 NULL
 acpi_rs_strcpy_fndecl_43746_fns acpi_rs_strcpy fndecl 0 43746 NULL
+stat_end_vardecl_drv_c_43748_fns stat_end vardecl_drv.c 0 43748 NULL
 tipc_connect_fndecl_43766_fns tipc_connect fndecl 3 43766 NULL
 hwdep_read_fndecl_43779_fns hwdep_read fndecl 3 43779 NULL
 generic_file_fsync_fndecl_43780_fns generic_file_fsync fndecl 2-3 43780 NULL
 len_nft_set_ext_tmpl_43815_fns len nft_set_ext_tmpl 0 43815 NULL
+omap_dma_prep_slave_sg_fndecl_43825_fns omap_dma_prep_slave_sg fndecl 3 43825 NULL
 br_fdb_external_learn_add_fndecl_43850_fns br_fdb_external_learn_add fndecl 4 43850 NULL
 scsi_host_alloc_fndecl_43858_fns scsi_host_alloc fndecl 2 43858 NULL
 Xdsdt_acpi_table_fadt_43871_fns Xdsdt acpi_table_fadt 0 43871 NULL
 sddr09_readX_fndecl_43951_fns sddr09_readX fndecl 7 43951 NULL
 hfsplus_file_fsync_fndecl_43969_fns hfsplus_file_fsync fndecl 2-3 43969 NULL
 smk_write_revoke_subj_fndecl_43990_fns smk_write_revoke_subj fndecl 3 43990 NULL
+vme_master_read_fndecl_44006_fns vme_master_read fndecl 0 44006 NULL
 nr_chnls_nvm_dev_44026_fns nr_chnls nvm_dev 0 44026 NULL
 response_length_ib_uverbs_ex_create_qp_resp_44030_fns response_length ib_uverbs_ex_create_qp_resp 0 44030 NULL
 wilc_gnrl_async_info_received_fndecl_44034_fns wilc_gnrl_async_info_received fndecl 3 44034 NULL
@@ -3117,6 +3413,7 @@ prog_page_fndecl_44060_fns prog_page fndecl 2 44060 NULL
 mb_cache_create_fndecl_44082_fns mb_cache_create fndecl 1 44082 NULL
 udp_sendmsg_fndecl_44135_fns udp_sendmsg fndecl 3 44135 NULL nohasharray
 mls_compute_context_len_fndecl_44135_fns mls_compute_context_len fndecl 0 44135 &udp_sendmsg_fndecl_44135_fns
+gb_operation_sync_timeout_fndecl_44156_fns gb_operation_sync_timeout fndecl 4 44156 NULL
 bfad_debugfs_write_regwr_fndecl_44162_fns bfad_debugfs_write_regwr fndecl 3 44162 NULL
 error_tx_abort_failure_read_fndecl_44184_fns error_tx_abort_failure_read fndecl 3 44184 NULL
 evdev_compute_buffer_size_fndecl_44212_fns evdev_compute_buffer_size fndecl 0 44212 NULL
@@ -3125,6 +3422,8 @@ it_context_support_fw_ohci_44232_fns it_context_support fw_ohci 0 44232 NULL
 rx_filter_arp_filter_read_fndecl_44233_fns rx_filter_arp_filter_read fndecl 3 44233 NULL nohasharray
 ima_store_measurement_fndecl_44233_fns ima_store_measurement fndecl 5 44233 &rx_filter_arp_filter_read_fndecl_44233_fns
 au0828_init_isoc_fndecl_44238_fns au0828_init_isoc fndecl 3 44238 NULL
+spk_xs_vardecl_44242_fns spk_xs vardecl 0 44242 NULL
+lprocfs_write_frac_u64_helper_fndecl_44250_fns lprocfs_write_frac_u64_helper fndecl 2 44250 NULL
 roundup_ring_size_fndecl_44254_fns roundup_ring_size fndecl 0 44254 NULL
 gfn_to_pfn_memslot_atomic_fndecl_44264_fns gfn_to_pfn_memslot_atomic fndecl 2 44264 NULL
 NumberOfPorts_mpt3sas_facts_44306_fns NumberOfPorts mpt3sas_facts 0 44306 NULL nohasharray
@@ -3132,6 +3431,7 @@ mlxsw_core_reg_access_fndecl_44306_fns mlxsw_core_reg_access fndecl 0 44306 &Num
 bytesused_cx18_buffer_44339_fns bytesused cx18_buffer 0 44339 NULL
 snd_pcm_lib_writev_transfer_fndecl_44344_fns snd_pcm_lib_writev_transfer fndecl 5 44344 NULL
 btrfs_item_size_fndecl_44350_fns btrfs_item_size fndecl 0 44350 NULL
+pwm_buf_sz_usbdux_private_44375_fns pwm_buf_sz usbdux_private 0 44375 NULL
 dvb_net_ioctl_fndecl_44388_fns dvb_net_ioctl fndecl 2 44388 NULL
 hidpp_prefix_name_fndecl_44393_fns hidpp_prefix_name fndecl 2 44393 NULL
 num_rx_rings_nfp_net_44395_fns num_rx_rings nfp_net 0 44395 NULL
@@ -3154,6 +3454,7 @@ filter_read_fndecl_44527_fns filter_read fndecl 3 44527 NULL
 smk_read_syslog_fndecl_44544_fns smk_read_syslog fndecl 3 44544 NULL
 numps_powernow_k8_data_44546_fns numps powernow_k8_data 0 44546 NULL
 hv_tsc_page_kvm_hv_44561_fns hv_tsc_page kvm_hv 0 44561 NULL
+ion_handle_test_dma_fndecl_44581_fns ion_handle_test_dma fndecl 4-5 44581 NULL
 maxcontacts_pm_44593_fns maxcontacts pm 0 44593 NULL
 len_poll_list_44603_fns len poll_list 0 44603 NULL
 of_io_request_and_map_fndecl_44605_fns of_io_request_and_map fndecl 2 44605 NULL
@@ -3164,6 +3465,7 @@ num_desc_pages__drm_via_sg_info_44666_fns num_desc_pages _drm_via_sg_info 0 4466
 flash_write_fndecl_44673_fns flash_write fndecl 3 44673 NULL
 xfpregs_set_fndecl_44680_fns xfpregs_set fndecl 4 44680 NULL
 length_ore_striping_info_44681_fns length ore_striping_info 0 44681 NULL
+asic_flags_write_fndecl_44717_fns asic_flags_write fndecl 3 44717 NULL
 altera_irscan_fndecl_44719_fns altera_irscan fndecl 2 44719 NULL
 register_netdevice_fndecl_44725_fns register_netdevice fndecl 0 44725 NULL
 kmalloc_order_fndecl_44727_fns kmalloc_order fndecl 1 44727 NULL
@@ -3198,7 +3500,8 @@ head_timestamp_event_queue_45105_fns head timestamp_event_queue 0 45105 &pitch_t
 dma_map_mr_pas_fndecl_45126_fns dma_map_mr_pas fndecl 3 45126 NULL
 copyout_from_xsaves_fndecl_45153_fns copyout_from_xsaves fndecl 2 45153 NULL
 pwc_get_fps_Nala_fndecl_45162_fns pwc_get_fps_Nala fndecl 0 45162 NULL
-num_mrs_qed_rdma_info_45171_fns num_mrs qed_rdma_info 0 45171 NULL
+num_mrs_qed_rdma_info_45171_fns num_mrs qed_rdma_info 0 45171 NULL nohasharray
+n_ao_urbs_usbdux_private_45171_fns n_ao_urbs usbdux_private 0 45171 &num_mrs_qed_rdma_info_45171_fns
 sel_write_checkreqprot_fndecl_45173_fns sel_write_checkreqprot fndecl 3 45173 NULL
 acl_alloc_num_fndecl_45177_fns acl_alloc_num fndecl 2-1 45177 NULL
 pwr_tx_with_ps_read_fndecl_45216_fns pwr_tx_with_ps_read fndecl 3 45216 NULL
@@ -3210,6 +3513,7 @@ mgt_set_varlen_fndecl_45287_fns mgt_set_varlen fndecl 4 45287 NULL
 tstats_write_fndecl_45315_fns tstats_write fndecl 3 45315 NULL
 of_property_count_elems_of_size_fndecl_45337_fns of_property_count_elems_of_size fndecl 0-3 45337 NULL
 excessive_retries_read_fndecl_45338_fns excessive_retries_read fndecl 3 45338 NULL
+ablkcipher_giv_edesc_alloc_fndecl_45340_fns ablkcipher_giv_edesc_alloc fndecl 2 45340 NULL
 ebcnt_vardecl_speedtest_c_45398_fns ebcnt vardecl_speedtest.c 0 45398 NULL
 brcmf_init_nvram_parser_fndecl_45415_fns brcmf_init_nvram_parser fndecl 3 45415 NULL
 pos_c4iw_debugfs_data_45424_fns pos c4iw_debugfs_data 0 45424 NULL
@@ -3224,6 +3528,7 @@ acl_alloc_stack_init_fndecl_45509_fns acl_alloc_stack_init fndecl 1 45509 NULL
 ptr_ring_init_fndecl_45512_fns ptr_ring_init fndecl 2 45512 NULL
 count_scpi_dvfs_info_45519_fns count scpi_dvfs_info 0 45519 NULL
 wl1273_fm_fops_write_fndecl_45534_fns wl1273_fm_fops_write fndecl 3 45534 NULL
+arch_setup_dma_ops_fndecl_45543_fns arch_setup_dma_ops fndecl 3 45543 NULL
 srp_create_fr_pool_fndecl_45572_fns srp_create_fr_pool fndecl 3 45572 NULL
 f2fs_sync_file_fndecl_45585_fns f2fs_sync_file fndecl 2-3 45585 NULL
 wpan_phy_new_fndecl_45593_fns wpan_phy_new fndecl 2 45593 NULL
@@ -3256,6 +3561,7 @@ smbase_kvm_vcpu_arch_45895_fns smbase kvm_vcpu_arch 0 45895 NULL
 ath6kl_lrssi_roam_read_fndecl_45901_fns ath6kl_lrssi_roam_read fndecl 3 45901 NULL
 dfs_num_of_radar_detections_read_fndecl_45903_fns dfs_num_of_radar_detections_read fndecl 3 45903 NULL
 alloc_sglist_fndecl_45919_fns alloc_sglist fndecl 1 45919 NULL
+lpfc_idiag_queacc_write_fndecl_45920_fns lpfc_idiag_queacc_write fndecl 3 45920 NULL
 sdhci_pltfm_register_fndecl_45940_fns sdhci_pltfm_register fndecl 3 45940 NULL
 sigma_fw_load_samplerates_fndecl_45951_fns sigma_fw_load_samplerates fndecl 3 45951 NULL
 i40e_calculate_l2fpm_size_fndecl_45987_fns i40e_calculate_l2fpm_size fndecl 1-2-3-4 45987 NULL
@@ -3265,6 +3571,7 @@ rx_size_qed_cb_ll2_info_46006_fns rx_size qed_cb_ll2_info 0 46006 NULL
 add_del_listener_fndecl_46013_fns add_del_listener fndecl 0 46013 NULL
 get_derived_key_fndecl_46015_fns get_derived_key fndecl 4 46015 NULL
 afs_proc_cells_write_fndecl_46016_fns afs_proc_cells_write fndecl 3 46016 NULL
+p9_client_prepare_req_fndecl_46048_fns p9_client_prepare_req fndecl 3 46048 NULL
 event_oom_late_read_fndecl_46052_fns event_oom_late_read fndecl 3 46052 NULL nohasharray
 num_wsm_mib_beacon_filter_table_46052_fns num wsm_mib_beacon_filter_table 0 46052 &event_oom_late_read_fndecl_46052_fns
 sys_lsetxattr_fndecl_46058_fns sys_lsetxattr fndecl 4 46058 NULL
@@ -3282,6 +3589,7 @@ __irq_alloc_domain_generic_chips_fndecl_46285_fns __irq_alloc_domain_generic_chi
 ffs_prepare_buffer_fndecl_46311_fns ffs_prepare_buffer fndecl 2 46311 NULL
 biovec_create_pool_fndecl_46325_fns biovec_create_pool fndecl 1 46325 NULL
 max_vnic_func_qlcnic_hardware_context_46334_fns max_vnic_func qlcnic_hardware_context 0 46334 NULL
+__qsfp_debugfs_write_fndecl_46356_fns __qsfp_debugfs_write fndecl 3 46356 NULL
 shadow_image_fndecl_46361_fns shadow_image fndecl 3 46361 NULL
 ring_cons_per_user_data_46365_fns ring_cons per_user_data 0 46365 NULL
 device_create_with_groups_fndecl_46371_fns device_create_with_groups fndecl 3 46371 NULL
@@ -3312,6 +3620,8 @@ transfer_buffer_length_usbip_header_cmd_submit_46658_fns transfer_buffer_length
 display_crc_ctl_write_fndecl_46690_fns display_crc_ctl_write fndecl 3 46690 NULL
 printer_write_fndecl_46695_fns printer_write fndecl 3 46695 NULL
 __kfifo_from_user_r_fndecl_46762_fns __kfifo_from_user_r fndecl 3-5 46762 NULL
+bytes_remaining_parser_context_46791_fns bytes_remaining parser_context 0 46791 NULL
+dccp_setsockopt_fndecl_46812_fns dccp_setsockopt fndecl 5 46812 NULL
 buffer_size_snd_rawmidi_params_46813_fns buffer_size snd_rawmidi_params 0 46813 NULL
 kvm_mmu_get_page_fndecl_46824_fns kvm_mmu_get_page fndecl 2 46824 NULL nohasharray
 numberoflines_tmHWStreamParameters_46824_fns numberoflines tmHWStreamParameters 0 46824 &kvm_mmu_get_page_fndecl_46824_fns
@@ -3319,6 +3629,7 @@ mthca_alloc_resize_buf_fndecl_46841_fns mthca_alloc_resize_buf fndecl 3 46841 NU
 n_channels_wmi_scan_chan_list_arg_46842_fns n_channels wmi_scan_chan_list_arg 0 46842 NULL
 len_wl12xx_rx_filter_field_46843_fns len wl12xx_rx_filter_field 0 46843 NULL
 driver_names_read_fndecl_46844_fns driver_names_read fndecl 3 46844 NULL
+ksi_nthreads_max_ksock_sched_info_46891_fns ksi_nthreads_max ksock_sched_info 0 46891 NULL
 buffer_size_snd_urb_ctx_46897_fns buffer_size snd_urb_ctx 0 46897 NULL
 osd_req_read_kern_fndecl_46917_fns osd_req_read_kern fndecl 5 46917 NULL
 squashfs_max_decompressors_fndecl_46937_fns squashfs_max_decompressors fndecl 0 46937 NULL
@@ -3405,10 +3716,13 @@ setgain_fndecl_48010_fns setgain fndecl 0 48010 &init_pci_cap_msi_perm_fndecl_48
 size_netlbl_unlhsh_tbl_48011_fns size netlbl_unlhsh_tbl 0 48011 NULL
 selinux_transaction_write_fndecl_48013_fns selinux_transaction_write fndecl 3 48013 NULL
 drm_malloc_gfp_fndecl_48018_fns drm_malloc_gfp fndecl 1-2 48018 NULL
+lpfc_idiag_baracc_write_fndecl_48021_fns lpfc_idiag_baracc_write fndecl 3 48021 NULL
+_find_next_bit_le_fndecl_48027_fns _find_next_bit_le fndecl 0 48027 NULL
 __cvmx_bootmem_desc_get_fndecl_48105_fns __cvmx_bootmem_desc_get fndecl 0 48105 NULL
 namelen_xensyms_48117_fns namelen xensyms 0 48117 NULL
 vma_kernel_pagesize_fndecl_48131_fns vma_kernel_pagesize fndecl 0 48131 NULL
 tx_tx_retry_template_read_fndecl_48132_fns tx_tx_retry_template_read fndecl 3 48132 NULL
+rsa_edesc_alloc_fndecl_48134_fns rsa_edesc_alloc fndecl 2 48134 NULL
 hpi_cobranet_hmi_write_fndecl_48158_fns hpi_cobranet_hmi_write fndecl 3 48158 NULL
 r3964_write_fndecl_48173_fns r3964_write fndecl 4 48173 NULL
 mr_read_fndecl_48180_fns mr_read fndecl 0 48180 NULL
@@ -3419,6 +3733,7 @@ b_map_count_xfs_buf_48228_fns b_map_count xfs_buf 0 48228 NULL
 qib_make_grh_fndecl_48250_fns qib_make_grh fndecl 0 48250 NULL
 ib_uverbs_create_xsrq_fndecl_48257_fns ib_uverbs_create_xsrq fndecl 4-5 48257 NULL
 compat_sys_set_mempolicy_fndecl_48285_fns compat_sys_set_mempolicy fndecl 3 48285 NULL
+ion_test_ioctl_fndecl_48340_fns ion_test_ioctl fndecl 2 48340 NULL
 ivtv_read_fndecl_48343_fns ivtv_read fndecl 3 48343 NULL
 flash_read_fndecl_48352_fns flash_read fndecl 3 48352 NULL
 qib_make_rc_ack_fndecl_48361_fns qib_make_rc_ack fndecl 4 48361 NULL
@@ -3436,6 +3751,7 @@ copy_to_user_fromio_fndecl_48459_fns copy_to_user_fromio fndecl 3 48459 NULL
 num_msix_irqs_octeon_device_48465_fns num_msix_irqs octeon_device 0 48465 NULL
 enclosure_register_fndecl_48471_fns enclosure_register fndecl 3 48471 NULL
 __origin_write_fndecl_48487_fns __origin_write fndecl 2 48487 NULL
+rss_key_write_fndecl_48498_fns rss_key_write fndecl 3 48498 NULL
 sys_pselect6_fndecl_48506_fns sys_pselect6 fndecl 1 48506 NULL
 octeon_read_device_mem32_fndecl_48520_fns octeon_read_device_mem32 fndecl 0 48520 NULL
 copy_in_user_fndecl_48525_fns copy_in_user fndecl 3 48525 NULL
@@ -3456,8 +3772,10 @@ aggr_size_tx_agg_rate_read_fndecl_48607_fns aggr_size_tx_agg_rate_read fndecl 3
 read_file_spectral_fft_period_fndecl_48618_fns read_file_spectral_fft_period fndecl 3 48618 NULL
 get_bridge_ifindices_fndecl_48632_fns get_bridge_ifindices fndecl 0 48632 NULL
 nsymbols_dsp_symbol_desc_48638_fns nsymbols dsp_symbol_desc 0 48638 NULL
+savemem_fndecl_48642_fns savemem fndecl 3 48642 NULL
 ipv6_flowlabel_opt_fndecl_48644_fns ipv6_flowlabel_opt fndecl 3 48644 NULL nohasharray
 slhc_init_fndecl_48644_fns slhc_init fndecl 1-2 48644 &ipv6_flowlabel_opt_fndecl_48644_fns
+libcfs_kvzalloc_cpt_fndecl_48651_fns libcfs_kvzalloc_cpt fndecl 3 48651 NULL
 length_fw_cdev_send_request_48658_fns length fw_cdev_send_request 0 48658 NULL
 nn_rs_control_48667_fns nn rs_control 0 48667 NULL
 max_rds_rings_netxen_adapter_48699_fns max_rds_rings netxen_adapter 0 48699 NULL
@@ -3470,20 +3788,24 @@ profile_load_fndecl_48776_fns profile_load fndecl 3 48776 NULL
 acpi_ds_build_internal_package_obj_fndecl_48780_fns acpi_ds_build_internal_package_obj fndecl 3 48780 NULL
 iscsi_decode_text_input_fndecl_48807_fns iscsi_decode_text_input fndecl 4 48807 NULL
 r100_mm_rreg_fndecl_48823_fns r100_mm_rreg fndecl 0 48823 NULL
+omap_device_count_resources_fndecl_48829_fns omap_device_count_resources fndecl 0 48829 NULL
 __generic_file_fsync_fndecl_48835_fns __generic_file_fsync fndecl 2-3 48835 NULL
 tx_tx_start_int_templates_read_fndecl_48839_fns tx_tx_start_int_templates_read fndecl 3 48839 NULL
 vmalloc_to_sg_fndecl_48865_fns vmalloc_to_sg fndecl 2 48865 NULL
 mpls_count_nexthops_fndecl_48869_fns mpls_count_nexthops fndecl 0 48869 NULL
 __copy_from_user_swizzled_fndecl_48882_fns __copy_from_user_swizzled fndecl 2-4 48882 NULL
 bylength_atto_vda_ae_hdr_48890_fns bylength atto_vda_ae_hdr 0 48890 NULL
+radeon_ttm_gtt_read_fndecl_48900_fns radeon_ttm_gtt_read fndecl 3 48900 NULL
 xt_alloc_table_info_fndecl_48956_fns xt_alloc_table_info fndecl 1 48956 NULL
 user_dlm_lock_fndecl_48959_fns user_dlm_lock fndecl 6 48959 NULL
 xfs_mru_cache_create_fndecl_48964_fns xfs_mru_cache_create fndecl 3 48964 NULL
 vtpm_proxy_fops_write_fndecl_48972_fns vtpm_proxy_fops_write fndecl 3 48972 NULL
+dma40_prep_dma_cyclic_fndecl_48976_fns dma40_prep_dma_cyclic fndecl 4-3 48976 NULL
 sel_read_handle_unknown_fndecl_48990_fns sel_read_handle_unknown fndecl 3 48990 NULL
 ip_set_alloc_fndecl_49010_fns ip_set_alloc fndecl 1 49010 NULL
 compat_writev_fndecl_49017_fns compat_writev fndecl 3 49017 NULL
 rx_reset_counter_read_fndecl_49026_fns rx_reset_counter_read fndecl 3 49026 NULL
+usb_dmac_prep_slave_sg_fndecl_49027_fns usb_dmac_prep_slave_sg fndecl 3 49027 NULL
 devno_skd_device_49051_fns devno skd_device 0 49051 NULL
 do_writepage_fndecl_49068_fns do_writepage fndecl 2 49068 NULL
 dev_priv_size_drm_buf_49086_fns dev_priv_size drm_buf 0 49086 NULL
@@ -3493,6 +3815,7 @@ alloc_rbio_fndecl_49128_fns alloc_rbio fndecl 3 49128 NULL
 mad_seg_size_ib_mad_recv_wc_49134_fns mad_seg_size ib_mad_recv_wc 0 49134 NULL
 ufx_reg_clear_and_set_bits_fndecl_49150_fns ufx_reg_clear_and_set_bits fndecl 0 49150 NULL
 ipr_alloc_ucode_buffer_fndecl_49172_fns ipr_alloc_ucode_buffer fndecl 1 49172 NULL
+allocate_probes_fndecl_49183_fns allocate_probes fndecl 1 49183 NULL
 fsl_edma_prep_dma_cyclic_fndecl_49197_fns fsl_edma_prep_dma_cyclic fndecl 3 49197 NULL nohasharray
 of_get_child_count_fndecl_49197_fns of_get_child_count fndecl 0 49197 &fsl_edma_prep_dma_cyclic_fndecl_49197_fns
 ocrdma_dbgfs_ops_read_fndecl_49211_fns ocrdma_dbgfs_ops_read fndecl 3 49211 NULL
@@ -3514,6 +3837,7 @@ x509_akid_note_serial_fndecl_49380_fns x509_akid_note_serial fndecl 5 49380 NULL
 pe_data_len_ip_vs_conn_49384_fns pe_data_len ip_vs_conn 0 49384 NULL
 tty_prepare_flip_string_fndecl_49408_fns tty_prepare_flip_string fndecl 3 49408 NULL
 next_bio_fndecl_49410_fns next_bio fndecl 2 49410 NULL
+lstcon_group_list_fndecl_49413_fns lstcon_group_list fndecl 2 49413 NULL
 mthca_array_init_fndecl_49440_fns mthca_array_init fndecl 2 49440 NULL
 fw_device_op_read_fndecl_49445_fns fw_device_op_read fndecl 3 49445 NULL
 broadsheetfb_write_fndecl_49467_fns broadsheetfb_write fndecl 3 49467 NULL
@@ -3567,9 +3891,12 @@ size_ubifs_data_node_50154_fns size ubifs_data_node 0 50154 NULL
 max_inbound_iu_length_pqi_ctrl_info_50155_fns max_inbound_iu_length pqi_ctrl_info 0 50155 NULL
 fops_read_fndecl_50163_fns fops_read fndecl 3 50163 NULL
 pci_enable_resources_fndecl_50171_fns pci_enable_resources fndecl 0 50171 NULL
+ubi_more_update_data_fndecl_50182_fns ubi_more_update_data fndecl 4 50182 NULL
 nested_cr3_nested_state_50183_fns nested_cr3 nested_state 0 50183 NULL
+echo_client_kbrw_fndecl_50193_fns echo_client_kbrw fndecl 6 50193 NULL
 pwr_cont_miss_bcns_spread_read_fndecl_50241_fns pwr_cont_miss_bcns_spread_read fndecl 3 50241 NULL nohasharray
 r128_compat_ioctl_fndecl_50241_fns r128_compat_ioctl fndecl 2 50241 &pwr_cont_miss_bcns_spread_read_fndecl_50241_fns
+lprocfs_wr_root_squash_fndecl_50252_fns lprocfs_wr_root_squash fndecl 2 50252 NULL
 posix_acl_to_xattr_fndecl_50262_fns posix_acl_to_xattr fndecl 0 50262 NULL
 buf_struct_size_vb2_queue_50266_fns buf_struct_size vb2_queue 0 50266 NULL
 rx_filter_protection_filter_read_fndecl_50273_fns rx_filter_protection_filter_read fndecl 3 50273 NULL
@@ -3584,14 +3911,17 @@ sbp_count_se_tpg_luns_fndecl_50444_fns sbp_count_se_tpg_luns fndecl 0 50444 NULL
 nfsd_drc_mem_used_vardecl_50456_fns nfsd_drc_mem_used vardecl 0 50456 NULL
 __ath6kl_wmi_send_mgmt_cmd_fndecl_50472_fns __ath6kl_wmi_send_mgmt_cmd fndecl 7 50472 NULL
 buf_size_dmatest_params_50477_fns buf_size dmatest_params 0 50477 NULL
+lpfc_idiag_extacc_write_fndecl_50501_fns lpfc_idiag_extacc_write fndecl 3 50501 NULL
 OSDSetBlock_fndecl_50521_fns OSDSetBlock fndecl 2-4 50521 NULL
 get_nodes_fndecl_50551_fns get_nodes fndecl 3 50551 NULL
 do_write_kmem_fndecl_50584_fns do_write_kmem fndecl 0-1-3 50584 NULL
 pwrite_dvb_ringbuffer_50594_fns pwrite dvb_ringbuffer 0 50594 NULL
-__kfifo_to_user_r_fndecl_50624_fns __kfifo_to_user_r fndecl 3-5 50624 NULL
+__kfifo_to_user_r_fndecl_50624_fns __kfifo_to_user_r fndecl 3-5 50624 NULL nohasharray
+buffer_depth_etb_drvdata_50624_fns buffer_depth etb_drvdata 0 50624 &__kfifo_to_user_r_fndecl_50624_fns
 keymap_size_dell_dmi_results_50640_fns keymap_size dell_dmi_results 0 50640 NULL
 tomoyo_truncate_fndecl_50642_fns tomoyo_truncate fndecl 0 50642 NULL
 xor_sources_dmatest_params_50653_fns xor_sources dmatest_params 0 50653 NULL
+qsfp2_debugfs_write_fndecl_50656_fns qsfp2_debugfs_write fndecl 3 50656 NULL
 proc_coredump_filter_read_fndecl_50658_fns proc_coredump_filter_read fndecl 3 50658 NULL
 da9150_i2c_write_device_fndecl_50670_fns da9150_i2c_write_device fndecl 3 50670 NULL
 nclips_bttv_overlay_50673_fns nclips bttv_overlay 0 50673 NULL
@@ -3599,6 +3929,7 @@ alloc_ring_fndecl_50684_fns alloc_ring fndecl 4-2 50684 NULL
 get_device_info_fndecl_50718_fns get_device_info fndecl 0 50718 NULL
 dm_create_fndecl_50754_fns dm_create fndecl 1 50754 NULL
 ip_vs_sync_buff_create_fndecl_50787_fns ip_vs_sync_buff_create fndecl 2 50787 NULL
+xhci_alloc_segments_for_ring_fndecl_50793_fns xhci_alloc_segments_for_ring fndecl 7 50793 NULL
 ib_uverbs_get_context_fndecl_50799_fns ib_uverbs_get_context fndecl 4-5 50799 NULL
 persistent_ram_buffer_map_fndecl_50803_fns persistent_ram_buffer_map fndecl 1-2 50803 NULL
 malloc_size__BIG_IOCTL_Command_struct_50805_fns malloc_size _BIG_IOCTL_Command_struct 0 50805 NULL
@@ -3616,6 +3947,7 @@ pkt_add_fndecl_50890_fns pkt_add fndecl 3 50890 &ie_len_ieee80211_if_ibss_50890_
 req_len_proxy_dev_50912_fns req_len proxy_dev 0 50912 NULL
 exofs_read_kern_fndecl_50914_fns exofs_read_kern fndecl 6 50914 NULL nohasharray
 oom_score_adj_read_fndecl_50914_fns oom_score_adj_read fndecl 3 50914 &exofs_read_kern_fndecl_50914_fns
+sa11x0_dma_prep_dma_cyclic_fndecl_50916_fns sa11x0_dma_prep_dma_cyclic fndecl 3-4 50916 NULL
 init_sc_pools_and_sizes_fndecl_50922_fns init_sc_pools_and_sizes fndecl 0 50922 NULL
 first_minor_gendisk_50925_fns first_minor gendisk 0 50925 NULL
 read_file_modal_eeprom_fndecl_50934_fns read_file_modal_eeprom fndecl 3 50934 NULL
@@ -3631,6 +3963,7 @@ usif_ioctl_fndecl_50986_fns usif_ioctl fndecl 3 50986 NULL
 ib_uverbs_create_srq_fndecl_51025_fns ib_uverbs_create_srq fndecl 4-5 51025 NULL
 int_proc_write_fndecl_51045_fns int_proc_write fndecl 3 51045 NULL
 mlxsw_sp_port_prio_tc_set_fndecl_51047_fns mlxsw_sp_port_prio_tc_set fndecl 0 51047 NULL
+cl_req_alloc_fndecl_51056_fns cl_req_alloc fndecl 4 51056 NULL
 datablob_format_fndecl_51072_fns datablob_format fndecl 2 51072 NULL
 pp_write_fndecl_51089_fns pp_write fndecl 3 51089 NULL
 copy_chunked_from_user_fndecl_51106_fns copy_chunked_from_user fndecl 3 51106 NULL
@@ -3651,6 +3984,7 @@ max_num_vringh_kiov_51202_fns max_num vringh_kiov 0 51202 NULL
 kvm_clear_guest_fndecl_51207_fns kvm_clear_guest fndecl 3-2 51207 NULL
 get_ucode_user_fndecl_51241_fns get_ucode_user fndecl 3 51241 NULL
 cdev_add_fndecl_51251_fns cdev_add fndecl 3 51251 NULL
+imxdma_prep_dma_cyclic_fndecl_51257_fns imxdma_prep_dma_cyclic fndecl 4-3 51257 NULL
 osd_req_list_partition_collections_fndecl_51292_fns osd_req_list_partition_collections fndecl 5 51292 NULL
 ramoops_read_kmsg_hdr_fndecl_51300_fns ramoops_read_kmsg_hdr fndecl 0 51300 NULL
 mthca_alloc_icm_table_fndecl_51311_fns mthca_alloc_icm_table fndecl 3-4 51311 NULL
@@ -3661,6 +3995,7 @@ xfs_bmbt_to_bmdr_fndecl_51344_fns xfs_bmbt_to_bmdr fndecl 3 51344 NULL nohasharr
 xfs_bmdr_to_bmbt_fndecl_51344_fns xfs_bmdr_to_bmbt fndecl 5 51344 &xfs_bmbt_to_bmdr_fndecl_51344_fns
 dev_change_flags_fndecl_51349_fns dev_change_flags fndecl 0 51349 NULL
 isr_rx_headers_read_fndecl_51366_fns isr_rx_headers_read fndecl 3 51366 NULL
+lprocfs_wr_nosquash_nids_fndecl_51370_fns lprocfs_wr_nosquash_nids fndecl 2 51370 NULL
 uvc_try_frame_interval_fndecl_51372_fns uvc_try_frame_interval fndecl 0-2 51372 NULL
 ucma_query_path_fndecl_51378_fns ucma_query_path fndecl 3 51378 NULL
 num_queues_virtio_scsi_51387_fns num_queues virtio_scsi 0 51387 NULL nohasharray
@@ -3671,7 +4006,8 @@ nr_segments_blkif_request_indirect_51457_fns nr_segments blkif_request_indirect
 compat_sys_rt_sigpending_fndecl_51480_fns compat_sys_rt_sigpending fndecl 2 51480 NULL
 num_vectors_mic_irq_info_51485_fns num_vectors mic_irq_info 0 51485 NULL
 end_soundfont_sample_info_51497_fns end soundfont_sample_info 0 51497 NULL
-pkt_alloc_packet_data_fndecl_51515_fns pkt_alloc_packet_data fndecl 1 51515 NULL
+pkt_alloc_packet_data_fndecl_51515_fns pkt_alloc_packet_data fndecl 1 51515 NULL nohasharray
+_rtw_malloc_fndecl_51515_fns _rtw_malloc fndecl 1 51515 &pkt_alloc_packet_data_fndecl_51515_fns
 nfp_net_rx_ring_alloc_fndecl_51524_fns nfp_net_rx_ring_alloc fndecl 3 51524 NULL
 fifo_alloc_fndecl_51546_fns fifo_alloc fndecl 1 51546 NULL nohasharray
 scan_bytes_iio_dev_51546_fns scan_bytes iio_dev 0 51546 &fifo_alloc_fndecl_51546_fns
@@ -3680,6 +4016,8 @@ rds_rdma_extra_size_fndecl_51573_fns rds_rdma_extra_size fndecl 0 51573 NULL
 persistent_ram_old_size_fndecl_51582_fns persistent_ram_old_size fndecl 0 51582 NULL
 aggr_recv_addba_req_evt_fndecl_51590_fns aggr_recv_addba_req_evt fndecl 4 51590 NULL
 wilc_add_beacon_fndecl_51601_fns wilc_add_beacon fndecl 6-4 51601 NULL
+vfp_get_fndecl_51605_fns vfp_get fndecl 3-4 51605 NULL
+etb_get_buffer_depth_fndecl_51607_fns etb_get_buffer_depth fndecl 0 51607 NULL
 cifs_send_async_read_fndecl_51630_fns cifs_send_async_read fndecl 2 51630 NULL
 sysfs_do_create_link_fndecl_51632_fns sysfs_do_create_link fndecl 0 51632 NULL
 wil_vring_init_bcast_fndecl_51633_fns wil_vring_init_bcast fndecl 3 51633 NULL
@@ -3699,6 +4037,7 @@ num_req_context_skd_device_51707_fns num_req_context skd_device 0 51707 NULL
 f2fs_kmalloc_fndecl_51712_fns f2fs_kmalloc fndecl 2 51712 NULL
 nlimbs_gcry_mpi_51721_fns nlimbs gcry_mpi 0 51721 NULL nohasharray
 ib_uverbs_modify_qp_fndecl_51721_fns ib_uverbs_modify_qp fndecl 4-5 51721 &nlimbs_gcry_mpi_51721_fns
+output_sync_fndecl_51729_fns output_sync fndecl 3 51729 NULL
 acpi_copy_property_array_u32_fndecl_51744_fns acpi_copy_property_array_u32 fndecl 0 51744 NULL
 rbio_add_io_page_fndecl_51775_fns rbio_add_io_page fndecl 6 51775 NULL
 btusb_qca_send_vendor_req_fndecl_51785_fns btusb_qca_send_vendor_req fndecl 4 51785 NULL
@@ -3729,7 +4068,9 @@ rd_allocate_sgl_table_fndecl_52188_fns rd_allocate_sgl_table fndecl 3 52188 NULL
 regmap_calc_reg_len_fndecl_52195_fns regmap_calc_reg_len fndecl 0 52195 NULL
 qp_broker_alloc_fndecl_52197_fns qp_broker_alloc fndecl 6-5 52197 NULL
 audit_init_entry_fndecl_52199_fns audit_init_entry fndecl 1 52199 NULL
+write_enabled_file_bool_fndecl_52213_fns write_enabled_file_bool fndecl 3 52213 NULL
 snd_hda_get_conn_list_fndecl_52255_fns snd_hda_get_conn_list fndecl 0 52255 NULL
+channels_count_gb_light_52264_fns channels_count gb_light 0 52264 NULL
 num_alt_cx231xx_audio_52283_fns num_alt cx231xx_audio 0 52283 NULL
 rts51x_get_max_lun_fndecl_52294_fns rts51x_get_max_lun fndecl 0 52294 NULL
 cmd_len_c2h_evt_hdr_52322_fns cmd_len c2h_evt_hdr 0 52322 NULL
@@ -3780,17 +4121,22 @@ rx_decrypt_key_not_found_read_fndecl_52911_fns rx_decrypt_key_not_found_read fnd
 cqc_entry_sz_mlx4_dev_cap_52916_fns cqc_entry_sz mlx4_dev_cap 0 52916 NULL
 smk_read_logging_fndecl_52927_fns smk_read_logging fndecl 3 52927 NULL
 minor_drbd_genlmsghdr_52949_fns minor drbd_genlmsghdr 0 52949 NULL
+__arm_iommu_alloc_attrs_fndecl_52955_fns __arm_iommu_alloc_attrs fndecl 2 52955 NULL
 sys_setxattr_fndecl_52971_fns sys_setxattr fndecl 4 52971 NULL
 tty_insert_flip_string_fixed_flag_fndecl_53031_fns tty_insert_flip_string_fixed_flag fndecl 4 53031 NULL
 sys_getxattr_fndecl_53049_fns sys_getxattr fndecl 4 53049 NULL
 acpi_os_allocate_zeroed_fndecl_53053_fns acpi_os_allocate_zeroed fndecl 1 53053 NULL
+pxad_prep_memcpy_fndecl_53065_fns pxad_prep_memcpy fndecl 4 53065 NULL
 kvm_vcpu_write_guest_page_fndecl_53070_fns kvm_vcpu_write_guest_page fndecl 5-2 53070 NULL
+omap_hwmod_mux_init_fndecl_53072_fns omap_hwmod_mux_init fndecl 2 53072 NULL
 fru_alloc_fndecl_53073_fns fru_alloc fndecl 1 53073 NULL
 ntfs_dir_fsync_fndecl_53093_fns ntfs_dir_fsync fndecl 2-3 53093 NULL
+wilc_spi_read_fndecl_53099_fns wilc_spi_read fndecl 4 53099 NULL
 brcmf_fw_nvram_strip_fndecl_53102_fns brcmf_fw_nvram_strip fndecl 2 53102 NULL
 logi_dj_recv_forward_hidpp_fndecl_53117_fns logi_dj_recv_forward_hidpp fndecl 3 53117 NULL
 xz_dec_test_write_fndecl_53124_fns xz_dec_test_write fndecl 3 53124 NULL
 private_data_len_ib_cm_sidr_req_param_53150_fns private_data_len ib_cm_sidr_req_param 0 53150 NULL
+lpfc_debugfs_max_disc_trc_vardecl_lpfc_debugfs_c_53169_fns lpfc_debugfs_max_disc_trc vardecl_lpfc_debugfs.c 0 53169 NULL
 num_tx_rings_nfp_net_53170_fns num_tx_rings nfp_net 0 53170 NULL
 xhci_alloc_streams_fndecl_53185_fns xhci_alloc_streams fndecl 5 53185 NULL
 SYSC_mbind_fndecl_53221_fns SYSC_mbind fndecl 5 53221 NULL
@@ -3810,11 +4156,14 @@ SYSC_getxattr_fndecl_53377_fns SYSC_getxattr fndecl 4 53377 NULL
 viafb_iga1_odev_proc_write_fndecl_53378_fns viafb_iga1_odev_proc_write fndecl 3 53378 NULL
 vmsplice_to_user_fndecl_53382_fns vmsplice_to_user fndecl 3 53382 NULL nohasharray
 rproc_recovery_read_fndecl_53382_fns rproc_recovery_read fndecl 3 53382 &vmsplice_to_user_fndecl_53382_fns
+jz4740_dma_prep_slave_sg_fndecl_53383_fns jz4740_dma_prep_slave_sg fndecl 3 53383 NULL
 command_setformat_fndecl_53392_fns command_setformat fndecl 0 53392 NULL
 wil_agg_size_fndecl_53398_fns wil_agg_size fndecl 0-2 53398 NULL
 num_entries_s2io_nic_53404_fns num_entries s2io_nic 0 53404 NULL
 set_rcvarray_entry_fndecl_53410_fns set_rcvarray_entry fndecl 6 53410 NULL
+cfs_hash_buckets_realloc_fndecl_53415_fns cfs_hash_buckets_realloc fndecl 4 53415 NULL
 rxHeader3_edgeport_serial_53418_fns rxHeader3 edgeport_serial 0 53418 NULL
+codec_reg_read_file_fndecl_53419_fns codec_reg_read_file fndecl 3 53419 NULL
 compat_sys_mbind_fndecl_53427_fns compat_sys_mbind fndecl 5 53427 NULL
 ad7879_spi_xfer_fndecl_53444_fns ad7879_spi_xfer fndecl 3 53444 NULL
 nouveau_cli_create_fndecl_53462_fns nouveau_cli_create fndecl 3 53462 NULL
@@ -3839,6 +4188,7 @@ device_add_class_symlinks_fndecl_53634_fns device_add_class_symlinks fndecl 0 53
 write_file_antenna_fndecl_53645_fns write_file_antenna fndecl 3 53645 NULL
 generic_ocp_read_fndecl_53653_fns generic_ocp_read fndecl 3 53653 NULL
 acl_alloc_fndecl_53656_fns acl_alloc fndecl 1 53656 NULL
+__videobuf_alloc_fndecl_53676_fns __videobuf_alloc fndecl 1 53676 NULL
 list_lru_count_one_fndecl_53682_fns list_lru_count_one fndecl 0 53682 NULL
 gpio_power_read_fndecl_53704_fns gpio_power_read fndecl 3 53704 NULL
 mtip_hw_read_device_status_fndecl_53729_fns mtip_hw_read_device_status fndecl 3 53729 NULL
@@ -3862,6 +4212,7 @@ of_iomap_fndecl_53930_fns of_iomap fndecl 2 53930 NULL
 i40e_init_lan_hmc_fndecl_53935_fns i40e_init_lan_hmc fndecl 2-3-4-5 53935 NULL
 hiddev_ioctl_fndecl_53955_fns hiddev_ioctl fndecl 2 53955 NULL
 proc_fault_inject_read_fndecl_53969_fns proc_fault_inject_read fndecl 3 53969 NULL
+gb_operation_create_core_fndecl_54045_fns gb_operation_create_core fndecl 3 54045 NULL
 tunables_read_fndecl_54066_fns tunables_read fndecl 3 54066 NULL
 sctp_tsnmap_init_fndecl_54093_fns sctp_tsnmap_init fndecl 3 54093 NULL
 bytes_read_usbvision_frame_54101_fns bytes_read usbvision_frame 0 54101 NULL
@@ -3870,6 +4221,7 @@ gfs2_inode_ra_len_fndecl_54141_fns gfs2_inode_ra_len fndecl 0 54141 NULL
 __hwahc_op_set_ptk_fndecl_54157_fns __hwahc_op_set_ptk fndecl 5 54157 NULL
 b43_nphy_load_samples_fndecl_54162_fns b43_nphy_load_samples fndecl 3 54162 NULL
 cpu_type_read_fndecl_54191_fns cpu_type_read fndecl 3 54191 NULL
+smsusb_sendrequest_fndecl_54196_fns smsusb_sendrequest fndecl 3 54196 NULL
 p_filesz_elf32_phdr_54204_fns p_filesz elf32_phdr 0 54204 NULL
 numeraseregions_mtd_info_54223_fns numeraseregions mtd_info 0 54223 NULL
 __kfifo_to_user_fndecl_54232_fns __kfifo_to_user fndecl 3 54232 NULL
@@ -3899,6 +4251,7 @@ do_preadv_fndecl_54493_fns do_preadv fndecl 3 54493 NULL
 sys_setsockopt_fndecl_54507_fns sys_setsockopt fndecl 5 54507 NULL
 bio_segments_fndecl_54531_fns bio_segments fndecl 0 54531 NULL
 b43_debugfs_write_fndecl_54533_fns b43_debugfs_write fndecl 3 54533 NULL
+__i2c_debugfs_read_fndecl_54556_fns __i2c_debugfs_read fndecl 3 54556 NULL
 cp_nr_rings_bnxt_54565_fns cp_nr_rings bnxt 0 54565 NULL
 acpi_system_write_wakeup_device_fndecl_54582_fns acpi_system_write_wakeup_device fndecl 3 54582 NULL
 mipi_dsi_dcs_write_fndecl_54605_fns mipi_dsi_dcs_write fndecl 4 54605 NULL
@@ -3913,16 +4266,20 @@ proc_setgroups_write_fndecl_54732_fns proc_setgroups_write fndecl 3 54732 NULL
 hwdep_read_locked_fndecl_54734_fns hwdep_read_locked fndecl 3 54734 NULL
 pwr_connection_out_of_sync_read_fndecl_54758_fns pwr_connection_out_of_sync_read fndecl 3 54758 NULL
 cqm_max_rmid_vardecl_cqm_c_54798_fns cqm_max_rmid vardecl_cqm.c 0 54798 NULL
+spk_msg_set_fndecl_54801_fns spk_msg_set fndecl 3 54801 NULL
 buf_size__BIG_IOCTL_Command_struct_54806_fns buf_size _BIG_IOCTL_Command_struct 0 54806 NULL
 persistent_ram_update_user_fndecl_54807_fns persistent_ram_update_user fndecl 4 54807 NULL
 pci_request_regions_fndecl_54816_fns pci_request_regions fndecl 0 54816 NULL
 kernel_readv_fndecl_54834_fns kernel_readv fndecl 3 54834 NULL
+i2c1_debugfs_write_fndecl_54837_fns i2c1_debugfs_write fndecl 3 54837 NULL
 spi_register_board_info_fndecl_54864_fns spi_register_board_info fndecl 2 54864 NULL
+usb_dmac_desc_get_fndecl_54869_fns usb_dmac_desc_get fndecl 2 54869 NULL
 compress_sliced_buf_fndecl_54891_fns compress_sliced_buf fndecl 0 54891 NULL
 num_uars_mlx5_uuar_info_54898_fns num_uars mlx5_uuar_info 0 54898 NULL
 buffer_size_qcaspi_54902_fns buffer_size qcaspi 0 54902 NULL
 rds_page_copy_user_fndecl_54904_fns rds_page_copy_user fndecl 4 54904 NULL
 sd_start_ov361x_fndecl_54922_fns sd_start_ov361x fndecl 0 54922 NULL
+gb_operation_create_flags_fndecl_54976_fns gb_operation_create_flags fndecl 3 54976 NULL
 fence_wait_any_timeout_fndecl_54982_fns fence_wait_any_timeout fndecl 2 54982 NULL
 alloc_netdev_mqs_fndecl_54989_fns alloc_netdev_mqs fndecl 5-6-1 54989 NULL
 udf_alloc_i_data_fndecl_55001_fns udf_alloc_i_data fndecl 2 55001 NULL
@@ -3931,9 +4288,11 @@ pvr2_hdw_cpufw_get_fndecl_55011_fns pvr2_hdw_cpufw_get fndecl 0-2-4 55011 NULL
 command_setcompressionparams_fndecl_55026_fns command_setcompressionparams fndecl 0 55026 NULL
 hpi_alloc_control_cache_fndecl_55044_fns hpi_alloc_control_cache fndecl 1 55044 NULL
 restart_sge_fndecl_55067_fns restart_sge fndecl 0-4-3 55067 NULL
+stm32_dma_prep_slave_sg_fndecl_55074_fns stm32_dma_prep_slave_sg fndecl 3 55074 NULL
 read_kmem_fndecl_55103_fns read_kmem fndecl 3 55103 NULL
 fake_alloc_consistent_fndecl_55132_fns fake_alloc_consistent fndecl 2 55132 NULL
 btrfs_search_old_slot_fndecl_55133_fns btrfs_search_old_slot fndecl 0 55133 NULL
+buffer_to_user_fndecl_55164_fns buffer_to_user fndecl 3 55164 NULL
 virtqueue_get_vring_size_fndecl_55188_fns virtqueue_get_vring_size fndecl 0 55188 NULL
 efx_mcdi_rpc_async_quiet_fndecl_55191_fns efx_mcdi_rpc_async_quiet fndecl 4-5 55191 NULL
 rxpipe_tx_xfr_host_int_trig_rx_data_read_fndecl_55233_fns rxpipe_tx_xfr_host_int_trig_rx_data_read fndecl 3 55233 NULL
@@ -3958,6 +4317,7 @@ find_phys_blocks_fndecl_55388_fns find_phys_blocks fndecl 0 55388 NULL
 nprim_symtab_55398_fns nprim symtab 0 55398 NULL
 periodic_size_oxu_hcd_55401_fns periodic_size oxu_hcd 0 55401 NULL
 shmem_pread_fast_fndecl_55408_fns shmem_pread_fast fndecl 3 55408 NULL
+len_wm_coeff_parsed_coeff_55454_fns len wm_coeff_parsed_coeff 0 55454 NULL
 start_genius_cam_fndecl_55469_fns start_genius_cam fndecl 0 55469 NULL
 bl_pipe_downcall_fndecl_55499_fns bl_pipe_downcall fndecl 3 55499 NULL
 setup_nodes_for_search_fndecl_55515_fns setup_nodes_for_search fndecl 0 55515 NULL
@@ -3975,6 +4335,7 @@ kvm_vcpu_gfn_to_page_fndecl_55725_fns kvm_vcpu_gfn_to_page fndecl 2 55725 NULL
 mpi_from_key_fndecl_55729_fns mpi_from_key fndecl 0 55729 NULL
 cnt_mon_text_ptr_55741_fns cnt mon_text_ptr 0 55741 NULL
 vga_switcheroo_debugfs_write_fndecl_55763_fns vga_switcheroo_debugfs_write fndecl 3 55763 NULL
+cmd_read_size_wiimote_state_55772_fns cmd_read_size wiimote_state 0 55772 NULL
 rx_rx_xfr_read_fndecl_55779_fns rx_rx_xfr_read fndecl 3 55779 NULL
 qed_cxt_get_proto_tid_count_fndecl_55797_fns qed_cxt_get_proto_tid_count fndecl 0 55797 NULL
 lbs_lowrssi_write_fndecl_55802_fns lbs_lowrssi_write fndecl 3 55802 NULL
@@ -3987,6 +4348,7 @@ cw1200_queue_init_fndecl_55860_fns cw1200_queue_init fndecl 4 55860 &ceph_msgpoo
 do_raw_getsockopt_fndecl_55863_fns do_raw_getsockopt fndecl 0 55863 NULL
 nports_cyclades_card_55865_fns nports cyclades_card 0 55865 NULL
 cnic_alloc_dma_fndecl_55874_fns cnic_alloc_dma fndecl 3 55874 NULL
+ad7280_chain_setup_fndecl_55912_fns ad7280_chain_setup fndecl 0 55912 NULL
 isr_fiqs_read_fndecl_55916_fns isr_fiqs_read fndecl 3 55916 NULL
 response_length_mlx5_ib_create_wq_resp_55932_fns response_length mlx5_ib_create_wq_resp 0 55932 NULL
 do_readv_writev_fndecl_55934_fns do_readv_writev fndecl 4 55934 NULL
@@ -4003,6 +4365,7 @@ proc_thread_self_readlink_fndecl_56102_fns proc_thread_self_readlink fndecl 3 56
 maximum_input_absinfo_56108_fns maximum input_absinfo 0 56108 NULL
 block_size_ecryptfs_write_tag_70_packet_silly_stack_56117_fns block_size ecryptfs_write_tag_70_packet_silly_stack 0 56117 NULL
 ssl_prev_nilfs_snapshot_list_56120_fns ssl_prev nilfs_snapshot_list 0 56120 NULL
+usbvision_v4l2_read_fndecl_56129_fns usbvision_v4l2_read fndecl 3 56129 NULL
 av7110_vbi_write_fndecl_56131_fns av7110_vbi_write fndecl 3 56131 NULL
 iwl_calib_set_fndecl_56179_fns iwl_calib_set fndecl 3 56179 NULL nohasharray
 ivtv_read_pos_fndecl_56179_fns ivtv_read_pos fndecl 3 56179 &iwl_calib_set_fndecl_56179_fns
@@ -4026,6 +4389,7 @@ alloc_gid_table_fndecl_56444_fns alloc_gid_table fndecl 1 56444 NULL
 _pci_add_cap_save_buffer_fndecl_56466_fns _pci_add_cap_save_buffer fndecl 4 56466 NULL
 banks_mca_config_56472_fns banks mca_config 0 56472 NULL
 pp_read_fndecl_56489_fns pp_read fndecl 3 56489 NULL
+batadv_socket_receive_packet_fndecl_56509_fns batadv_socket_receive_packet fndecl 2 56509 NULL
 __vb2_wait_for_done_vb_fndecl_56525_fns __vb2_wait_for_done_vb fndecl 0 56525 NULL
 vp_modern_find_vqs_fndecl_56530_fns vp_modern_find_vqs fndecl 2 56530 NULL
 cachefiles_cook_key_fndecl_56553_fns cachefiles_cook_key fndecl 2 56553 NULL
@@ -4052,6 +4416,7 @@ count_subheaders_fndecl_56868_fns count_subheaders fndecl 0 56868 NULL
 scsi_execute_fndecl_56879_fns scsi_execute fndecl 5 56879 NULL
 ack_gen_tipc_mon_domain_56881_fns ack_gen tipc_mon_domain 0 56881 NULL
 cifs_fsync_fndecl_56917_fns cifs_fsync fndecl 2-3 56917 NULL
+comedi_buf_write_n_allocated_fndecl_56919_fns comedi_buf_write_n_allocated fndecl 0 56919 NULL
 usb_gstrings_attach_fndecl_56924_fns usb_gstrings_attach fndecl 3 56924 NULL
 nrealreaders_vardecl_rcuperf_c_56929_fns nrealreaders vardecl_rcuperf.c 0 56929 NULL
 csize_jffs2_tmp_dnode_info_56933_fns csize jffs2_tmp_dnode_info 0 56933 NULL
@@ -4065,6 +4430,7 @@ i2c_hack_wm8775_fndecl_57014_fns i2c_hack_wm8775 fndecl 4-6 57014 NULL
 expand_corename_fndecl_57021_fns expand_corename fndecl 2 57021 NULL
 sys_keyctl_fndecl_57023_fns sys_keyctl fndecl 4 57023 NULL nohasharray
 xs_send_kvec_fndecl_57023_fns xs_send_kvec fndecl 3 57023 &sys_keyctl_fndecl_57023_fns
+__qcom_scm_hdcp_req_fndecl_57026_fns __qcom_scm_hdcp_req fndecl 3 57026 NULL
 vifs_state_read_fndecl_57073_fns vifs_state_read fndecl 3 57073 NULL
 mcs7830_get_reg_fndecl_57103_fns mcs7830_get_reg fndecl 3 57103 NULL
 bgx_cnt_hw_info_57124_fns bgx_cnt hw_info 0 57124 NULL
@@ -4072,17 +4438,20 @@ size_nvif_notify_57130_fns size nvif_notify 0 57130 NULL
 joydev_ioctl_fndecl_57132_fns joydev_ioctl fndecl 2 57132 NULL
 msg_controllen_msghdr_57136_fns msg_controllen msghdr 0 57136 NULL
 iblock_get_bio_fndecl_57139_fns iblock_get_bio fndecl 3 57139 NULL
+qcom_scm_call_fndecl_57160_fns qcom_scm_call fndecl 5-7 57160 NULL
 pd_points_ath5k_pdgain_info_57180_fns pd_points ath5k_pdgain_info 0 57180 NULL
 irq_pkt_threshold_read_fndecl_57183_fns irq_pkt_threshold_read fndecl 3 57183 NULL
+cfs_trace_copyin_string_fndecl_57191_fns cfs_trace_copyin_string fndecl 4 57191 NULL
 mon_buff_area_free_fndecl_57212_fns mon_buff_area_free fndecl 2 57212 NULL
 le_min_key_size_read_fndecl_57214_fns le_min_key_size_read fndecl 3 57214 NULL
 ovs_vport_alloc_fndecl_57296_fns ovs_vport_alloc fndecl 1 57296 NULL
 create_entry_fndecl_57300_fns create_entry fndecl 2 57300 NULL
 tcp_off_tso_state_57305_fns tcp_off tso_state 0 57305 NULL
-ip_setsockopt_fndecl_57308_fns ip_setsockopt fndecl 0 57308 NULL
+ip_setsockopt_fndecl_57308_fns ip_setsockopt fndecl 0-5 57308 NULL
 aggr_size_rx_size_read_fndecl_57317_fns aggr_size_rx_size_read fndecl 3 57317 NULL
 fb_read_fndecl_57329_fns fb_read fndecl 3 57329 NULL
 page_bytes_remain_capsule_info_57335_fns page_bytes_remain capsule_info 0 57335 NULL
+musb_test_mode_write_fndecl_57341_fns musb_test_mode_write fndecl 3 57341 NULL
 setup_glists_fndecl_57343_fns setup_glists fndecl 3 57343 NULL
 lbs_debugfs_write_fndecl_57358_fns lbs_debugfs_write fndecl 3 57358 NULL
 asix_read_cmd_fndecl_57362_fns asix_read_cmd fndecl 5 57362 NULL
@@ -4095,6 +4464,8 @@ nfs4_alloc_pages_fndecl_57401_fns nfs4_alloc_pages fndecl 1 57401 NULL
 key_size_ecryptfs_crypt_stat_57436_fns key_size ecryptfs_crypt_stat 0 57436 NULL
 send_control_msg_fndecl_57441_fns send_control_msg fndecl 6 57441 NULL
 diva_os_copy_to_user_fndecl_57455_fns diva_os_copy_to_user fndecl 4 57455 NULL
+wm_coeff_tlv_put_fndecl_57463_fns wm_coeff_tlv_put fndecl 3 57463 NULL
+r8712_usbctrl_vendorreq_fndecl_57466_fns r8712_usbctrl_vendorreq fndecl 6 57466 NULL
 command_resume_fndecl_57510_fns command_resume fndecl 0 57510 NULL
 igb_rd32_fndecl_57524_fns igb_rd32 fndecl 0 57524 NULL
 nvbios_extend_fndecl_57525_fns nvbios_extend fndecl 2 57525 NULL
@@ -4108,18 +4479,22 @@ nfsctl_transaction_read_fndecl_57705_fns nfsctl_transaction_read fndecl 3 57705
 read_file_recv_fndecl_57723_fns read_file_recv fndecl 3 57723 NULL
 x509_akid_note_kid_fndecl_57725_fns x509_akid_note_kid fndecl 5 57725 NULL
 partition_sched_domains_fndecl_57727_fns partition_sched_domains fndecl 1 57727 NULL
+hi6220_register_clkdiv_fndecl_57729_fns hi6220_register_clkdiv fndecl 7 57729 NULL
 max_devs_vardecl_aic94xx_hwi_c_57731_fns max_devs vardecl_aic94xx_hwi.c 0 57731 NULL
 compat_sys_io_getevents_fndecl_57736_fns compat_sys_io_getevents fndecl 3 57736 NULL
+batadv_socket_read_fndecl_57746_fns batadv_socket_read fndecl 3 57746 NULL
 raydium_i2c_send_message_fndecl_57747_fns raydium_i2c_send_message fndecl 4 57747 NULL
 acpi_ex_convert_to_ascii_fndecl_57750_fns acpi_ex_convert_to_ascii fndecl 0 57750 NULL
 cache_write_pipefs_fndecl_57757_fns cache_write_pipefs fndecl 3 57757 NULL
 tidcnt_hfi1_tid_info_57758_fns tidcnt hfi1_tid_info 0 57758 NULL
 send_set_info_fndecl_57779_fns send_set_info fndecl 7 57779 NULL
 fp_array_size_bnx2x_57781_fns fp_array_size bnx2x 0 57781 NULL
+spk_xe_vardecl_57804_fns spk_xe vardecl 0 57804 NULL
 tx_frag_init_called_read_fndecl_57834_fns tx_frag_init_called_read fndecl 3 57834 NULL
 vd_dsr_au_count_gru_vma_data_57855_fns vd_dsr_au_count gru_vma_data 0 57855 NULL
 joydev_handle_JSIOCSAXMAP_fndecl_57873_fns joydev_handle_JSIOCSAXMAP fndecl 3 57873 NULL
 xdi_copy_to_user_fndecl_57879_fns xdi_copy_to_user fndecl 4 57879 NULL
+exynos_srom_alloc_reg_dump_fndecl_57914_fns exynos_srom_alloc_reg_dump fndecl 2 57914 NULL
 ntb_transport_rx_enqueue_fndecl_57929_fns ntb_transport_rx_enqueue fndecl 4 57929 NULL
 event_heart_beat_read_fndecl_57938_fns event_heart_beat_read fndecl 3 57938 NULL
 nand_ecc_test_run_fndecl_57941_fns nand_ecc_test_run fndecl 1 57941 NULL
@@ -4136,6 +4511,7 @@ num_sqsets_csio_hw_58048_fns num_sqsets csio_hw 0 58048 NULL
 scsi_register_fndecl_58069_fns scsi_register fndecl 2 58069 NULL
 pt_read_fndecl_58083_fns pt_read fndecl 3 58083 NULL
 nentries_xpc_registration_58085_fns nentries xpc_registration 0 58085 NULL
+ll_max_cached_mb_seq_write_fndecl_58097_fns ll_max_cached_mb_seq_write fndecl 3 58097 NULL
 walk_pmd_range_fndecl_58100_fns walk_pmd_range fndecl 0 58100 NULL
 ore_get_rw_state_fndecl_58120_fns ore_get_rw_state fndecl 4-5 58120 NULL
 nvkm_disp_new__fndecl_58125_fns nvkm_disp_new_ fndecl 4 58125 NULL
@@ -4143,13 +4519,16 @@ sys_setgroups_fndecl_58127_fns sys_setgroups fndecl 1 58127 NULL nohasharray
 sm501_create_subdev_fndecl_58127_fns sm501_create_subdev fndecl 4-3 58127 &sys_setgroups_fndecl_58127_fns
 bufsize_vardecl_subpagetest_c_58128_fns bufsize vardecl_subpagetest.c 0 58128 NULL
 do_ip_vs_set_ctl_fndecl_58130_fns do_ip_vs_set_ctl fndecl 4 58130 NULL
-n_bitrates_ieee80211_supported_band_58136_fns n_bitrates ieee80211_supported_band 0 58136 NULL
+n_bitrates_ieee80211_supported_band_58136_fns n_bitrates ieee80211_supported_band 0 58136 NULL nohasharray
+ll_rw_extents_stats_pp_seq_write_fndecl_58136_fns ll_rw_extents_stats_pp_seq_write fndecl 3 58136 &n_bitrates_ieee80211_supported_band_58136_fns
 nvif_object_init_fndecl_58137_fns nvif_object_init fndecl 5 58137 NULL
+qsfp2_debugfs_read_fndecl_58142_fns qsfp2_debugfs_read fndecl 3 58142 NULL
 altera_drscan_fndecl_58153_fns altera_drscan fndecl 2 58153 NULL
 cui_nextents_xfs_cui_log_format_58174_fns cui_nextents xfs_cui_log_format 0 58174 NULL
 total_num_uuars_mlx5_ib_alloc_ucontext_req_v2_58191_fns total_num_uuars mlx5_ib_alloc_ucontext_req_v2 0 58191 NULL
 npages_ttm_page_pool_58200_fns npages ttm_page_pool 0 58200 NULL nohasharray
 nvmet_rdma_alloc_cmds_fndecl_58200_fns nvmet_rdma_alloc_cmds fndecl 2 58200 &npages_ttm_page_pool_58200_fns
+lpfc_idiag_drbacc_write_fndecl_58203_fns lpfc_idiag_drbacc_write fndecl 3 58203 NULL
 __pci_enable_msix_range_fndecl_58224_fns __pci_enable_msix_range fndecl 4 58224 NULL
 ubifs_jnl_write_data_fndecl_58229_fns ubifs_jnl_write_data fndecl 5 58229 NULL
 spi_replace_transfers_fndecl_58231_fns spi_replace_transfers fndecl 6-4 58231 NULL
@@ -4157,6 +4536,7 @@ ath6kl_regwrite_read_fndecl_58232_fns ath6kl_regwrite_read fndecl 3 58232 NULL
 ath6kl_usb_bmi_read_fndecl_58234_fns ath6kl_usb_bmi_read fndecl 3 58234 NULL
 i915_displayport_test_active_write_fndecl_58241_fns i915_displayport_test_active_write fndecl 3 58241 NULL
 gpiod_count_fndecl_58262_fns gpiod_count fndecl 0 58262 NULL
+mvneta_check_mtu_valid_fndecl_58264_fns mvneta_check_mtu_valid fndecl 0-2 58264 NULL
 viafb_dvp1_proc_write_fndecl_58355_fns viafb_dvp1_proc_write fndecl 3 58355 NULL
 __ffs_ep0_read_events_fndecl_58359_fns __ffs_ep0_read_events fndecl 3 58359 NULL
 ingr_start_sge_58376_fns ingr_start sge 0 58376 NULL
@@ -4187,6 +4567,7 @@ qib_copy_from_sge_fndecl_58565_fns qib_copy_from_sge fndecl 3 58565 NULL
 acpi_gpio_package_count_fndecl_58585_fns acpi_gpio_package_count fndecl 0 58585 NULL
 ext4_kvzalloc_fndecl_58598_fns ext4_kvzalloc fndecl 1 58598 NULL
 sctp_ssnmap_new_fndecl_58603_fns sctp_ssnmap_new fndecl 2-1 58603 NULL
+cache_read_pipefs_fndecl_58604_fns cache_read_pipefs fndecl 3 58604 NULL
 thermal_tx_resume_read_fndecl_58616_fns thermal_tx_resume_read fndecl 3 58616 NULL
 mousedev_read_fndecl_58624_fns mousedev_read fndecl 3 58624 NULL
 ath10k_wmi_alloc_host_mem_fndecl_58627_fns ath10k_wmi_alloc_host_mem fndecl 4-3 58627 NULL
@@ -4207,11 +4588,14 @@ tx_internal_desc_overflow_read_fndecl_58839_fns tx_internal_desc_overflow_read f
 kvm_debugfs_num_entries_vardecl_kvm_main_c_58842_fns kvm_debugfs_num_entries vardecl_kvm_main.c 0 58842 NULL
 nr_scratch_dwc3_58852_fns nr_scratch dwc3 0 58852 NULL
 ucs2_utf8size_fndecl_58859_fns ucs2_utf8size fndecl 0 58859 NULL
+pd_groupsize_ptlrpcd_58864_fns pd_groupsize ptlrpcd 0 58864 NULL
 usb_stor_bulk_transfer_sg_fndecl_58896_fns usb_stor_bulk_transfer_sg fndecl 5 58896 NULL
 v9fs_file_fsync_fndecl_58898_fns v9fs_file_fsync fndecl 2-3 58898 NULL
 vhci_read_fndecl_58901_fns vhci_read fndecl 3 58901 NULL
+comedi_write_fndecl_58917_fns comedi_write fndecl 3 58917 NULL
 fore200e_pca_dma_chunk_alloc_fndecl_58927_fns fore200e_pca_dma_chunk_alloc fndecl 4-3 58927 NULL
 sync_file_set_fence_fndecl_58938_fns sync_file_set_fence fndecl 3 58938 NULL
+cfs_percpt_alloc_fndecl_58941_fns cfs_percpt_alloc fndecl 2 58941 NULL
 drm_simple_display_pipe_init_fndecl_58972_fns drm_simple_display_pipe_init fndecl 5 58972 NULL
 mpi_read_raw_from_sgl_fndecl_58990_fns mpi_read_raw_from_sgl fndecl 2 58990 NULL
 __kvm_read_guest_atomic_fndecl_59011_fns __kvm_read_guest_atomic fndecl 5-2 59011 NULL
@@ -4219,7 +4603,9 @@ nclips_saa7146_overlay_59032_fns nclips saa7146_overlay 0 59032 NULL
 len_nand_bbt_descr_59045_fns len nand_bbt_descr 0 59045 NULL
 posix_acl_alloc_fndecl_59052_fns posix_acl_alloc fndecl 1 59052 NULL nohasharray
 nr_strip_zones_r0conf_59052_fns nr_strip_zones r0conf 0 59052 &posix_acl_alloc_fndecl_59052_fns
+axi_dmac_prep_slave_sg_fndecl_59073_fns axi_dmac_prep_slave_sg fndecl 3 59073 NULL
 buffer_mousedev_client_59098_fns buffer mousedev_client 0 59098 NULL
+wm_latency_write_fndecl_59118_fns wm_latency_write fndecl 3 59118 NULL
 mmc_alloc_host_fndecl_59122_fns mmc_alloc_host fndecl 1 59122 NULL
 tas571x_reg_write_multiword_fndecl_59156_fns tas571x_reg_write_multiword fndecl 4 59156 NULL
 copy_ucs2_from_user_len_fndecl_59162_fns copy_ucs2_from_user_len fndecl 3 59162 NULL
@@ -4232,6 +4618,7 @@ mvumi_alloc_mem_resource_fndecl_59285_fns mvumi_alloc_mem_resource fndecl 3 5928
 alloc_sched_domains_fndecl_59295_fns alloc_sched_domains fndecl 1 59295 NULL
 posix_acl_fix_xattr_from_user_fndecl_59298_fns posix_acl_fix_xattr_from_user fndecl 2 59298 NULL
 qib_copy_sge_fndecl_59314_fns qib_copy_sge fndecl 3 59314 NULL
+pinconf_dbg_config_write_fndecl_59336_fns pinconf_dbg_config_write fndecl 3 59336 NULL
 tree_mod_log_insert_move_fndecl_59356_fns tree_mod_log_insert_move fndecl 5 59356 NULL
 base_tsn_sctp_tsnmap_59358_fns base_tsn sctp_tsnmap 0 59358 NULL
 buf_len_i40e_arq_event_info_59370_fns buf_len i40e_arq_event_info 0 59370 NULL
@@ -4243,11 +4630,12 @@ desc_elems_timb_dma_chan_59416_fns desc_elems timb_dma_chan 0 59416 NULL
 nilfs_cpfile_block_get_checkpoint_fndecl_59441_fns nilfs_cpfile_block_get_checkpoint fndecl 2 59441 NULL
 rng_get_data_fndecl_59453_fns rng_get_data fndecl 0 59453 NULL
 platform_gpio_count_fndecl_59459_fns platform_gpio_count fndecl 0 59459 NULL
-ttm_page_pool_get_pages_fndecl_59468_fns ttm_page_pool_get_pages fndecl 5 59468 NULL
+ttm_page_pool_get_pages_fndecl_59468_fns ttm_page_pool_get_pages fndecl 5-0 59468 NULL
 rx_ringsz_alx_priv_59496_fns rx_ringsz alx_priv 0 59496 NULL
 pci_frontend_enable_msix_fndecl_59501_fns pci_frontend_enable_msix fndecl 3 59501 NULL
 wdata_alloc_and_fillpages_fndecl_59510_fns wdata_alloc_and_fillpages fndecl 1 59510 NULL
 qlcnic_get_vnic_func_count_fndecl_59521_fns qlcnic_get_vnic_func_count fndecl 0 59521 NULL
+gb_connection_recv_request_fndecl_59544_fns gb_connection_recv_request fndecl 4 59544 NULL
 kmsg_read_fndecl_59553_fns kmsg_read fndecl 3 59553 NULL nohasharray
 nouveau_drm_ioctl_fndecl_59553_fns nouveau_drm_ioctl fndecl 2 59553 &kmsg_read_fndecl_59553_fns
 mthca_alloc_cq_buf_fndecl_59555_fns mthca_alloc_cq_buf fndecl 3 59555 NULL
@@ -4260,6 +4648,7 @@ vringh_complete_multi_user_fndecl_59569_fns vringh_complete_multi_user fndecl 3
 key_count_applesmc_registers_59587_fns key_count applesmc_registers 0 59587 NULL
 serverworks_create_gatt_pages_fndecl_59621_fns serverworks_create_gatt_pages fndecl 1 59621 NULL
 amdgpu_kms_compat_ioctl_fndecl_59667_fns amdgpu_kms_compat_ioctl fndecl 2 59667 NULL
+rtw_buf_update_fndecl_59689_fns rtw_buf_update fndecl 4 59689 NULL
 aux_entry_sz_mlx4_dev_cap_59718_fns aux_entry_sz mlx4_dev_cap 0 59718 NULL
 __walk_page_range_fndecl_59729_fns __walk_page_range fndecl 0 59729 NULL
 __netlink_change_ngroups_fndecl_59743_fns __netlink_change_ngroups fndecl 2 59743 NULL
@@ -4279,6 +4668,7 @@ acpi_rs_decode_bitmask_fndecl_59851_fns acpi_rs_decode_bitmask fndecl 0 59851 NU
 length_pm8001_ioctl_payload_59866_fns length pm8001_ioctl_payload 0 59866 NULL
 qlcnic_83xx_sysfs_flash_bulk_write_fndecl_59875_fns qlcnic_83xx_sysfs_flash_bulk_write fndecl 4 59875 NULL
 __hwahc_dev_set_key_fndecl_59883_fns __hwahc_dev_set_key fndecl 5 59883 NULL
+lov_iocontrol_fndecl_59919_fns lov_iocontrol fndecl 3 59919 NULL
 size_wid_59965_fns size wid 0 59965 NULL
 configfs_read_bin_file_fndecl_59987_fns configfs_read_bin_file fndecl 3 59987 NULL
 wlcore_alloc_hw_fndecl_59990_fns wlcore_alloc_hw fndecl 1-3 59990 NULL
@@ -4295,6 +4685,7 @@ cx231xx_init_bulk_fndecl_60067_fns cx231xx_init_bulk fndecl 3 60067 NULL
 level_ubifs_znode_60069_fns level ubifs_znode 0 60069 NULL
 debugfs_create_u32_array_fndecl_60082_fns debugfs_create_u32_array fndecl 5 60082 NULL
 udpv6_sendmsg_fndecl_60103_fns udpv6_sendmsg fndecl 3 60103 NULL
+vfp_set_fndecl_60145_fns vfp_set fndecl 3-4 60145 NULL
 orangefs_dirent_outcount_orangefs_readdir_response_s_60150_fns orangefs_dirent_outcount orangefs_readdir_response_s 0 60150 NULL
 pipeline_dec_packet_in_read_fndecl_60151_fns pipeline_dec_packet_in_read fndecl 3 60151 NULL
 stream_start_fndecl_60166_fns stream_start fndecl 0 60166 NULL
@@ -4303,6 +4694,7 @@ ec_device_read_fndecl_60177_fns ec_device_read fndecl 3 60177 NULL
 snd_compr_write_data_fndecl_60179_fns snd_compr_write_data fndecl 3 60179 NULL
 pci_enable_device_fndecl_60193_fns pci_enable_device fndecl 0 60193 NULL
 request_key_async_with_auxdata_fndecl_60211_fns request_key_async_with_auxdata fndecl 4 60211 NULL
+bo_count_vc4_exec_info_60236_fns bo_count vc4_exec_info 0 60236 NULL
 ah_rf_banks_size_ath5k_hw_60250_fns ah_rf_banks_size ath5k_hw 0 60250 NULL
 erst_dbg_write_fndecl_60264_fns erst_dbg_write fndecl 3 60264 NULL
 wl1271_rx_filter_alloc_field_fndecl_60306_fns wl1271_rx_filter_alloc_field fndecl 5 60306 NULL
@@ -4312,7 +4704,10 @@ hest_ghes_dev_register_fndecl_60349_fns hest_ghes_dev_register fndecl 1 60349 NU
 string_escape_str_fndecl_60365_fns string_escape_str fndecl 0 60365 NULL
 num_counters_vardecl_sysfs_c_60371_fns num_counters vardecl_sysfs.c 0 60371 NULL
 shmem_pwrite_fast_fndecl_60393_fns shmem_pwrite_fast fndecl 3 60393 NULL
+quirk_strict_duplicate_filter_write_fndecl_60446_fns quirk_strict_duplicate_filter_write fndecl 3 60446 NULL
 sd_quota_slots_gfs2_sbd_60466_fns sd_quota_slots gfs2_sbd 0 60466 NULL
+ll_iocontrol_register_fndecl_60517_fns ll_iocontrol_register fndecl 2 60517 NULL
+iommu_dma_alloc_fndecl_60521_fns iommu_dma_alloc fndecl 2 60521 NULL
 pcf2127_i2c_gather_write_fndecl_60523_fns pcf2127_i2c_gather_write fndecl 5 60523 NULL
 tty_buffer_alloc_fndecl_60526_fns tty_buffer_alloc fndecl 2 60526 NULL
 qib_sdma_verbs_send_fndecl_60539_fns qib_sdma_verbs_send fndecl 3 60539 NULL
@@ -4341,6 +4736,7 @@ usbdev_read_fndecl_60713_fns usbdev_read fndecl 3 60713 NULL
 pwr_missing_bcns_cnt_read_fndecl_60714_fns pwr_missing_bcns_cnt_read fndecl 3 60714 NULL
 HighPriorityCredit_mpt3sas_facts_60721_fns HighPriorityCredit mpt3sas_facts 0 60721 NULL
 command_setapcor_fndecl_60740_fns command_setapcor fndecl 0 60740 NULL
+cfs_trace_daemon_command_usrstr_fndecl_60744_fns cfs_trace_daemon_command_usrstr fndecl 2 60744 NULL
 num_cnq_qedr_dev_60757_fns num_cnq qedr_dev 0 60757 NULL
 device_write_fndecl_60791_fns device_write fndecl 3 60791 NULL
 tomoyo_write_self_fndecl_60794_fns tomoyo_write_self fndecl 3 60794 NULL
@@ -4354,6 +4750,8 @@ mlxsw_cmd_mbox_query_aq_cap_max_num_sdqs_get_fndecl_60914_fns mlxsw_cmd_mbox_que
 x509_process_extension_fndecl_60941_fns x509_process_extension fndecl 5 60941 NULL
 posix_acl_xattr_set_fndecl_60952_fns posix_acl_xattr_set fndecl 6 60952 NULL
 get_rdac_req_fndecl_60969_fns get_rdac_req fndecl 3 60969 NULL
+cfs_cpt_weight_fndecl_61020_fns cfs_cpt_weight fndecl 0 61020 NULL
+etnaviv_gpu_cmdbuf_new_fndecl_61036_fns etnaviv_gpu_cmdbuf_new fndecl 3 61036 NULL
 nf_nat_ftp_fmt_cmd_fndecl_61045_fns nf_nat_ftp_fmt_cmd fndecl 0 61045 NULL
 kobject_init_and_add_fndecl_61088_fns kobject_init_and_add fndecl 0 61088 NULL nohasharray
 reply_len_fc_bsg_job_61088_fns reply_len fc_bsg_job 0 61088 &kobject_init_and_add_fndecl_61088_fns
@@ -4365,11 +4763,15 @@ get_free_entries_fndecl_61149_fns get_free_entries fndecl 1 61149 NULL nohasharr
 fnic_reset_stats_read_fndecl_61149_fns fnic_reset_stats_read fndecl 3 61149 &get_free_entries_fndecl_61149_fns
 __vmalloc_node_range_fndecl_61157_fns __vmalloc_node_range fndecl 2 61157 NULL
 sel_commit_bools_write_fndecl_61166_fns sel_commit_bools_write fndecl 3 61166 NULL
+host1x_job_alloc_fndecl_61171_fns host1x_job_alloc fndecl 4-3-2 61171 NULL
 dma_tx_errors_read_fndecl_61183_fns dma_tx_errors_read fndecl 3 61183 NULL
 rdma_set_ib_paths_fndecl_61195_fns rdma_set_ib_paths fndecl 3 61195 NULL
+spk_ys_vardecl_61196_fns spk_ys vardecl 0 61196 NULL
 add_qgroup_rb_fndecl_61197_fns add_qgroup_rb fndecl 2 61197 NULL
 radar_debug_mode_read_fndecl_61223_fns radar_debug_mode_read fndecl 3 61223 NULL
 hidraw_get_report_fndecl_61242_fns hidraw_get_report fndecl 3 61242 NULL
+rcar_dmac_prep_dma_cyclic_fndecl_61249_fns rcar_dmac_prep_dma_cyclic fndecl 4-3 61249 NULL nohasharray
+i2c2_debugfs_write_fndecl_61249_fns i2c2_debugfs_write fndecl 3 61249 &rcar_dmac_prep_dma_cyclic_fndecl_61249_fns
 CombinedStatusBufferLength_DAC960_Controller_61253_fns CombinedStatusBufferLength DAC960_Controller 0 61253 NULL
 smk_write_ambient_fndecl_61288_fns smk_write_ambient fndecl 3 61288 NULL
 ufx_i2c_configure_fndecl_61311_fns ufx_i2c_configure fndecl 0 61311 NULL
@@ -4377,9 +4779,11 @@ dvb_ca_en50221_init_fndecl_61317_fns dvb_ca_en50221_init fndecl 4 61317 NULL
 rw_copy_check_uvector_fndecl_61351_fns rw_copy_check_uvector fndecl 3 61351 NULL nohasharray
 v4l2_ctrl_new_std_fndecl_61351_fns v4l2_ctrl_new_std fndecl 5 61351 &rw_copy_check_uvector_fndecl_61351_fns
 snd_cs46xx_io_read_fndecl_61365_fns snd_cs46xx_io_read fndecl 5 61365 NULL
+osc_checksum_type_seq_write_fndecl_61386_fns osc_checksum_type_seq_write fndecl 3 61386 NULL
 npages_nfs_page_array_61390_fns npages nfs_page_array 0 61390 NULL
 __pci_register_driver_fndecl_61400_fns __pci_register_driver fndecl 0 61400 NULL
 alloc_ts_config_fndecl_61404_fns alloc_ts_config fndecl 1 61404 NULL
+rx_ring_size_rx_queue_61409_fns rx_ring_size rx_queue 0 61409 NULL
 amdgpu_fence_driver_init_ring_fndecl_61431_fns amdgpu_fence_driver_init_ring fndecl 2 61431 NULL
 lbs_rdbbp_read_fndecl_61438_fns lbs_rdbbp_read fndecl 3 61438 NULL
 ocfs2_zero_range_for_truncate_fndecl_61461_fns ocfs2_zero_range_for_truncate fndecl 4 61461 NULL
@@ -4411,6 +4815,9 @@ smt_add_frame_len_fndecl_61748_fns smt_add_frame_len fndecl 2 61748 NULL
 nr_fingers_f11_2d_sensor_queries_61756_fns nr_fingers f11_2d_sensor_queries 0 61756 NULL nohasharray
 SYSC_add_key_fndecl_61756_fns SYSC_add_key fndecl 4 61756 &nr_fingers_f11_2d_sensor_queries_61756_fns
 len_s_skfp_ioctl_61764_fns len s_skfp_ioctl 0 61764 NULL
+__qsfp_debugfs_read_fndecl_61803_fns __qsfp_debugfs_read fndecl 3 61803 NULL
+ttm_get_pages_fndecl_61821_fns ttm_get_pages fndecl 2 61821 NULL
+tracing_resize_saved_cmdlines_fndecl_61823_fns tracing_resize_saved_cmdlines fndecl 1 61823 NULL
 SYSC_set_mempolicy_fndecl_61827_fns SYSC_set_mempolicy fndecl 3 61827 NULL
 num_virt_counters_op_x86_model_spec_61835_fns num_virt_counters op_x86_model_spec 0 61835 NULL
 size_rocker_dma_ring_info_61839_fns size rocker_dma_ring_info 0 61839 NULL
@@ -4433,12 +4840,14 @@ cfg80211_inform_bss_data_fndecl_62065_fns cfg80211_inform_bss_data fndecl 9 6206
 do_tty_write_fndecl_62067_fns do_tty_write fndecl 5 62067 NULL
 max_xid_bnx2fc_hba_62096_fns max_xid bnx2fc_hba 0 62096 NULL
 ofdpa_group_l2_flood_fndecl_62112_fns ofdpa_group_l2_flood fndecl 5 62112 NULL
-tx_queue_status_read_fndecl_62113_fns tx_queue_status_read fndecl 3 62113 NULL
+tx_queue_status_read_fndecl_62113_fns tx_queue_status_read fndecl 3 62113 NULL nohasharray
+__i2c_debugfs_write_fndecl_62113_fns __i2c_debugfs_write fndecl 3 62113 &tx_queue_status_read_fndecl_62113_fns
 bo_offset_vmw_surface_offset_62116_fns bo_offset vmw_surface_offset 0 62116 NULL
 sched_read_attr_fndecl_62123_fns sched_read_attr fndecl 3 62123 NULL
 ofdpa_port_vlan_to_vid_fndecl_62138_fns ofdpa_port_vlan_to_vid fndecl 0 62138 NULL
 free_space_bitmap_size_fndecl_62144_fns free_space_bitmap_size fndecl 0 62144 NULL
 dm_kvzalloc_fndecl_62194_fns dm_kvzalloc fndecl 1 62194 NULL
+wm_adsp_create_control_fndecl_62201_fns wm_adsp_create_control fndecl 4 62201 NULL
 param_count_acpi_evaluate_info_62202_fns param_count acpi_evaluate_info 0 62202 NULL
 sense_len_request_62229_fns sense_len request 0 62229 NULL
 soc_tplg_dapm_widget_dmixer_create_fndecl_62241_fns soc_tplg_dapm_widget_dmixer_create fndecl 2 62241 NULL
@@ -4446,9 +4855,11 @@ mlxsw_reg_write_fndecl_62290_fns mlxsw_reg_write fndecl 0 62290 NULL
 __kvm_read_guest_page_fndecl_62291_fns __kvm_read_guest_page fndecl 2-5 62291 NULL
 num_arq_entries_i40e_adminq_info_62293_fns num_arq_entries i40e_adminq_info 0 62293 NULL
 erst_writer_fndecl_62318_fns erst_writer fndecl 7 62318 NULL
+lov_emerg_alloc_fndecl_62345_fns lov_emerg_alloc fndecl 1 62345 NULL
 switchdev_obj_size_fndecl_62346_fns switchdev_obj_size fndecl 0 62346 NULL
 C_SYSC_select_fndecl_62350_fns C_SYSC_select fndecl 1 62350 NULL
 mpi_resize_fndecl_62353_fns mpi_resize fndecl 2 62353 NULL
+raid56_parity_write_fndecl_62355_fns raid56_parity_write fndecl 4 62355 NULL
 reglen_bfad_s_62360_fns reglen bfad_s 0 62360 NULL
 ts_read_fndecl_62364_fns ts_read fndecl 3 62364 NULL
 sysfs_create_link_fndecl_62366_fns sysfs_create_link fndecl 0 62366 NULL
@@ -4458,6 +4869,7 @@ xfer_to_user_fndecl_62394_fns xfer_to_user fndecl 3 62394 NULL
 WIL_GET_BITS_fndecl_62424_fns WIL_GET_BITS fndecl 0-3-2-1 62424 NULL
 sctp_setsockopt_fndecl_62439_fns sctp_setsockopt fndecl 5 62439 NULL
 rx_dropped_read_fndecl_62444_fns rx_dropped_read fndecl 3 62444 NULL
+__videobuf_copy_stream_fndecl_62450_fns __videobuf_copy_stream fndecl 4 62450 NULL
 symsize_persistent_ram_ecc_info_62489_fns symsize persistent_ram_ecc_info 0 62489 NULL
 filemap_write_and_wait_range_fndecl_62492_fns filemap_write_and_wait_range fndecl 3 62492 NULL
 evtchn_write_fndecl_62493_fns evtchn_write fndecl 3 62493 NULL
@@ -4473,6 +4885,7 @@ get_vm_area_size_fndecl_62631_fns get_vm_area_size fndecl 0 62631 NULL
 fs_path_prepare_for_add_fndecl_62638_fns fs_path_prepare_for_add fndecl 2-0 62638 NULL
 usb_alloc_urb_fndecl_62655_fns usb_alloc_urb fndecl 1 62655 NULL
 nvme_trans_device_id_page_fndecl_62681_fns nvme_trans_device_id_page fndecl 4 62681 NULL
+mvneta_change_mtu_fndecl_62689_fns mvneta_change_mtu fndecl 2 62689 NULL
 tx_tx_data_prepared_read_fndecl_62714_fns tx_tx_data_prepared_read fndecl 3 62714 NULL
 isr_rx_mem_overflow_read_fndecl_62722_fns isr_rx_mem_overflow_read fndecl 3 62722 NULL
 wep_default_key_count_read_fndecl_62728_fns wep_default_key_count_read fndecl 3 62728 NULL
@@ -4484,6 +4897,7 @@ sysfs_create_file_ns_fndecl_62796_fns sysfs_create_file_ns fndecl 0 62796 NULL
 xattr_len_ima_event_data_62811_fns xattr_len ima_event_data 0 62811 NULL
 pof_recoffset_boot_data_62824_fns pof_recoffset boot_data 0 62824 NULL
 wq_len_tx_ring_62826_fns wq_len tx_ring 0 62826 NULL
+cfs_cpt_table_alloc_fndecl_62852_fns cfs_cpt_table_alloc fndecl 1 62852 NULL
 func_num_vardecl_g_ffs_c_62856_fns func_num vardecl_g_ffs.c 0 62856 NULL
 ath6kl_set_assoc_req_ies_fndecl_62882_fns ath6kl_set_assoc_req_ies fndecl 3 62882 NULL
 send_cmd_fndecl_62899_fns send_cmd fndecl 0 62899 NULL
@@ -4496,6 +4910,7 @@ batadv_tt_tvlv_unicast_handler_v1_fndecl_62964_fns batadv_tt_tvlv_unicast_handle
 max_size_mlx5_rl_table_62968_fns max_size mlx5_rl_table 0 62968 NULL
 tool_mw_write_fndecl_62998_fns tool_mw_write fndecl 3 62998 NULL
 cache_size_raw_regmap_63010_fns cache_size_raw regmap 0 63010 NULL
+gpr_get_fndecl_63026_fns gpr_get fndecl 3-4 63026 NULL
 arch_memcpy_to_pmem_fndecl_63041_fns arch_memcpy_to_pmem fndecl 3 63041 NULL
 reset_psn_fndecl_63045_fns reset_psn fndecl 2 63045 NULL
 read_flush_fndecl_63064_fns read_flush fndecl 3 63064 NULL
@@ -4512,18 +4927,21 @@ cache_request_fndecl_63187_fns cache_request fndecl 0 63187 NULL
 squashfs_xz_uncompress_fndecl_63193_fns squashfs_xz_uncompress fndecl 6-5 63193 NULL
 nvm_submit_ppa_list_fndecl_63209_fns nvm_submit_ppa_list fndecl 7 63209 NULL
 map_nr_sbitmap_63216_fns map_nr sbitmap 0 63216 NULL
+write_flush_procfs_fndecl_63224_fns write_flush_procfs fndecl 3 63224 NULL
 tx_frag_failed_read_fndecl_63239_fns tx_frag_failed_read fndecl 3 63239 NULL
 acpi_ut_get_resource_length_fndecl_63256_fns acpi_ut_get_resource_length fndecl 0 63256 NULL
 nvme_init_iod_fndecl_63258_fns nvme_init_iod fndecl 2 63258 NULL
 cachefiles_daemon_write_fndecl_63260_fns cachefiles_daemon_write fndecl 3 63260 NULL
 read_events_fndecl_63261_fns read_events fndecl 3 63261 NULL
 dvb_ca_en50221_io_write_fndecl_63262_fns dvb_ca_en50221_io_write fndecl 3 63262 NULL
+__cyz_load_fw_fndecl_63264_fns __cyz_load_fw fndecl 0 63264 NULL
 proc_read_fndecl_63309_fns proc_read fndecl 3 63309 NULL
 alloc_thread_groups_fndecl_63354_fns alloc_thread_groups fndecl 2 63354 NULL
 start_ms350_cam_fndecl_63372_fns start_ms350_cam fndecl 0 63372 NULL
 max_lun_rts51x_chip_63381_fns max_lun rts51x_chip 0 63381 NULL
 __alloc_alien_cache_fndecl_63429_fns __alloc_alien_cache fndecl 2 63429 NULL
 snd_rme32_playback_copy_fndecl_63431_fns snd_rme32_playback_copy fndecl 5 63431 NULL
+bo_count_drm_vc4_get_hang_state_63455_fns bo_count drm_vc4_get_hang_state 0 63455 NULL
 sctp_setsockopt_active_key_fndecl_63480_fns sctp_setsockopt_active_key fndecl 3 63480 NULL
 _gr_table_len_vardecl_x2apic_uv_x_c_63497_fns _gr_table_len vardecl_x2apic_uv_x.c 0 63497 NULL
 num_usb2_ports_xhci_hcd_63514_fns num_usb2_ports xhci_hcd 0 63514 NULL
@@ -4540,6 +4958,7 @@ sctp_setsockopt_del_key_fndecl_63571_fns sctp_setsockopt_del_key fndecl 3 63571
 xfs_rui_init_fndecl_63573_fns xfs_rui_init fndecl 2 63573 NULL
 ide_raw_taskfile_fndecl_63584_fns ide_raw_taskfile fndecl 4 63584 NULL
 cit_get_packet_size_fndecl_63585_fns cit_get_packet_size fndecl 0 63585 NULL
+jz4740_dma_alloc_desc_fndecl_63644_fns jz4740_dma_alloc_desc fndecl 1 63644 NULL
 mlxsw_pci_fw_area_init_fndecl_63657_fns mlxsw_pci_fw_area_init fndecl 3 63657 NULL
 id_nvdimm_63666_fns id nvdimm 0 63666 NULL
 msnd_fifo_read_fndecl_63669_fns msnd_fifo_read fndecl 0 63669 NULL
@@ -4553,7 +4972,9 @@ spidev_sync_read_fndecl_63757_fns spidev_sync_read fndecl 0 63757 NULL
 pool_allocate_fndecl_63759_fns pool_allocate fndecl 3 63759 NULL
 msix_count_skd_device_63760_fns msix_count skd_device 0 63760 NULL
 index_isi_board_63762_fns index isi_board 0 63762 NULL
+insn_size_kprobe_insn_cache_63777_fns insn_size kprobe_insn_cache 0 63777 NULL
 __hwahc_op_set_gtk_fndecl_63781_fns __hwahc_op_set_gtk fndecl 4 63781 NULL
+alloc_trace_kprobe_fndecl_63786_fns alloc_trace_kprobe fndecl 6 63786 NULL
 ioaccel_maxsg_ctlr_info_63798_fns ioaccel_maxsg ctlr_info 0 63798 NULL
 acpi_ut_create_buffer_object_fndecl_63805_fns acpi_ut_create_buffer_object fndecl 1 63805 NULL
 iwl_mvm_scan_size_fndecl_63834_fns iwl_mvm_scan_size fndecl 0 63834 NULL
@@ -4572,6 +4993,7 @@ vhost_copy_to_user_fndecl_63952_fns vhost_copy_to_user fndecl 4 63952 NULL
 oprofilefs_str_to_user_fndecl_63957_fns oprofilefs_str_to_user fndecl 3 63957 NULL
 pvr2_send_request_fndecl_63959_fns pvr2_send_request fndecl 3-5 63959 NULL
 write_file_beacon_fndecl_63962_fns write_file_beacon fndecl 3 63962 NULL
+len_wm_coeff_ctl_63967_fns len wm_coeff_ctl 0 63967 NULL
 pla_ocp_read_fndecl_63976_fns pla_ocp_read fndecl 3 63976 NULL
 snd_midi_event_decode_fndecl_64015_fns snd_midi_event_decode fndecl 0 64015 NULL
 dpm_sysfs_add_fndecl_64023_fns dpm_sysfs_add fndecl 0 64023 NULL
@@ -4583,6 +5005,7 @@ set_arg_fndecl_64091_fns set_arg fndecl 3 64091 NULL
 cxgbi_hbas_add_fndecl_64102_fns cxgbi_hbas_add fndecl 3 64102 NULL
 rx_mini_pending_ethtool_ringparam_64104_fns rx_mini_pending ethtool_ringparam 0 64104 NULL
 nvme_trans_unit_serial_page_fndecl_64108_fns nvme_trans_unit_serial_page fndecl 4 64108 NULL
+btmrvl_fwdump_write_fndecl_64113_fns btmrvl_fwdump_write fndecl 3 64113 NULL
 of_property_count_strings_fndecl_64124_fns of_property_count_strings fndecl 0 64124 NULL
 xpc_kmalloc_cacheline_aligned_fndecl_64156_fns xpc_kmalloc_cacheline_aligned fndecl 1 64156 NULL
 sctp_getsockopt_maxburst_fndecl_64174_fns sctp_getsockopt_maxburst fndecl 2 64174 NULL
@@ -4592,7 +5015,8 @@ sys_sethostname_fndecl_64193_fns sys_sethostname fndecl 2 64193 NULL
 f2fs_move_file_range_fndecl_64227_fns f2fs_move_file_range fndecl 4 64227 NULL
 compat_udpv6_setsockopt_fndecl_64246_fns compat_udpv6_setsockopt fndecl 5 64246 NULL
 pwr_ap_sleep_counter_read_fndecl_64248_fns pwr_ap_sleep_counter_read fndecl 3 64248 NULL
-nfs_idmap_get_desc_fndecl_64253_fns nfs_idmap_get_desc fndecl 2-4 64253 NULL
+nfs_idmap_get_desc_fndecl_64253_fns nfs_idmap_get_desc fndecl 2-4 64253 NULL nohasharray
+rtw_os_xmit_resource_alloc_fndecl_64253_fns rtw_os_xmit_resource_alloc fndecl 3 64253 &nfs_idmap_get_desc_fndecl_64253_fns
 denominator_v4l2_fract_64280_fns denominator v4l2_fract 0 64280 NULL
 sys_vmsplice_fndecl_64310_fns sys_vmsplice fndecl 3 64310 NULL nohasharray
 snd_emux_create_port_fndecl_64310_fns snd_emux_create_port fndecl 3 64310 &sys_vmsplice_fndecl_64310_fns
@@ -4611,13 +5035,16 @@ switchdev_deferred_enqueue_fndecl_64474_fns switchdev_deferred_enqueue fndecl 3
 set_aoe_iflist_fndecl_64482_fns set_aoe_iflist fndecl 2 64482 NULL
 ax25_setsockopt_fndecl_64487_fns ax25_setsockopt fndecl 5 64487 NULL
 dvb_demux_ioctl_fndecl_64510_fns dvb_demux_ioctl fndecl 2 64510 NULL
+partition_create_desc_fndecl_64535_fns partition_create_desc fndecl 3 64535 NULL
 ath10k_p2p_noa_ie_len_compute_fndecl_64548_fns ath10k_p2p_noa_ie_len_compute fndecl 0 64548 NULL
+num_channels_sh_tmu_device_64556_fns num_channels sh_tmu_device 0 64556 NULL
 hiddev_compat_ioctl_fndecl_64564_fns hiddev_compat_ioctl fndecl 2 64564 NULL
 rq_enc_pages_num_rpc_rqst_64573_fns rq_enc_pages_num rpc_rqst 0 64573 NULL
 erst_read_fndecl_64575_fns erst_read fndecl 0 64575 NULL
 vtpm_proxy_tpm_op_send_fndecl_64582_fns vtpm_proxy_tpm_op_send fndecl 3 64582 NULL
 alloc_context_fndecl_64592_fns alloc_context fndecl 1 64592 NULL
 of_count_phandle_with_args_fndecl_64600_fns of_count_phandle_with_args fndecl 0 64600 NULL
+gpr_set_fndecl_64611_fns gpr_set fndecl 3-4 64611 NULL
 objio_alloc_io_state_fndecl_64631_fns objio_alloc_io_state fndecl 6-7 64631 NULL
 kmp_init_fndecl_64654_fns kmp_init fndecl 2 64654 NULL
 num_allowed_vlans_qlcnic_sriov_64661_fns num_allowed_vlans qlcnic_sriov 0 64661 NULL
@@ -4637,7 +5064,10 @@ iio_device_alloc_fndecl_64755_fns iio_device_alloc fndecl 1 64755 NULL
 smtcfb_read_fndecl_64764_fns smtcfb_read fndecl 3 64764 NULL
 pmsg_size_ramoops_context_64804_fns pmsg_size ramoops_context 0 64804 NULL
 alloc_align_snd_array_64806_fns alloc_align snd_array 0 64806 NULL
+fpa_get_fndecl_64809_fns fpa_get fndecl 3-4 64809 NULL
 atr_csum_cm4000_dev_64828_fns atr_csum cm4000_dev 0 64828 NULL
+lprocfs_write_frac_helper_fndecl_64841_fns lprocfs_write_frac_helper fndecl 2 64841 NULL
+edma_prep_dma_cyclic_fndecl_64842_fns edma_prep_dma_cyclic fndecl 4-3 64842 NULL
 tool_dbfn_write_fndecl_64852_fns tool_dbfn_write fndecl 3 64852 NULL nohasharray
 _req_append_segment_fndecl_64852_fns _req_append_segment fndecl 2 64852 &tool_dbfn_write_fndecl_64852_fns
 rh_inc_fndecl_64864_fns rh_inc fndecl 2 64864 NULL
@@ -4647,6 +5077,7 @@ f_audio_buffer_alloc_fndecl_64901_fns f_audio_buffer_alloc fndecl 1 64901 NULL
 ubi_eba_create_table_fndecl_64916_fns ubi_eba_create_table fndecl 2 64916 NULL
 dma_attach_fndecl_64917_fns dma_attach fndecl 5-6 64917 NULL
 roccat_read_fndecl_64918_fns roccat_read fndecl 3 64918 NULL
+dvb_ca_write_fndecl_64960_fns dvb_ca_write fndecl 3 64960 NULL
 count_acpi_processor_power_64969_fns count acpi_processor_power 0 64969 NULL
 tx_frag_mpdu_alloc_failed_read_fndecl_64988_fns tx_frag_mpdu_alloc_failed_read fndecl 3 64988 NULL
 __mlxsw_item_get32_fndecl_64999_fns __mlxsw_item_get32 fndecl 0 64999 NULL
@@ -4657,6 +5088,7 @@ bus_add_driver_fndecl_65060_fns bus_add_driver fndecl 0 65060 NULL
 flag_node_footer_65063_fns flag node_footer 0 65063 NULL
 capi_ttyminors_vardecl_capi_c_65086_fns capi_ttyminors vardecl_capi.c 0 65086 NULL
 num_tx_bds_bcmgenet_priv_65087_fns num_tx_bds bcmgenet_priv 0 65087 NULL
+rtw_android_get_macaddr_fndecl_65095_fns rtw_android_get_macaddr fndecl 0 65095 NULL
 ntb_mw_count_fndecl_65108_fns ntb_mw_count fndecl 0 65108 NULL
 nilfs_cpfile_is_snapshot_fndecl_65110_fns nilfs_cpfile_is_snapshot fndecl 2 65110 NULL
 hsi_alloc_controller_fndecl_65113_fns hsi_alloc_controller fndecl 1 65113 NULL
@@ -4669,20 +5101,27 @@ nilfs_palloc_entry_blkoff_fndecl_65206_fns nilfs_palloc_entry_blkoff fndecl 0 65
 read_gssp_fndecl_65224_fns read_gssp fndecl 3 65224 NULL
 ssid_len_connect_attr_65228_fns ssid_len connect_attr 0 65228 NULL
 range_end_writeback_control_65245_fns range_end writeback_control 0 65245 NULL
+etb_read_fndecl_65249_fns etb_read fndecl 3 65249 NULL
 portnames_read_fndecl_65269_fns portnames_read fndecl 3 65269 NULL
 hpfs_translate_name_fndecl_65290_fns hpfs_translate_name fndecl 3 65290 NULL
 usb_stor_probe2_fndecl_65298_fns usb_stor_probe2 fndecl 0 65298 NULL
+rockchip_clk_init_fndecl_65312_fns rockchip_clk_init fndecl 3 65312 NULL
 dm_get_reserved_rq_based_ios_fndecl_65322_fns dm_get_reserved_rq_based_ios fndecl 0 65322 NULL
 brcmf_flowring_attach_fndecl_65325_fns brcmf_flowring_attach fndecl 2 65325 NULL
 ath6kl_endpoint_stats_read_fndecl_65345_fns ath6kl_endpoint_stats_read fndecl 3 65345 NULL
+wm_coeff_read_control_fndecl_65358_fns wm_coeff_read_control fndecl 3 65358 NULL
 fbucket_size_qlcnic_filter_hash_65369_fns fbucket_size qlcnic_filter_hash 0 65369 NULL
 nfsd_readv_fndecl_65378_fns nfsd_readv fndecl 4 65378 NULL
 batadv_tvlv_container_ogm_append_fndecl_65383_fns batadv_tvlv_container_ogm_append fndecl 4 65383 NULL
 rng_dev_read_fndecl_65406_fns rng_dev_read fndecl 3 65406 NULL
+lstcon_batch_list_fndecl_65416_fns lstcon_batch_list fndecl 2 65416 NULL
 tcp_hdrlen_fndecl_65433_fns tcp_hdrlen fndecl 0 65433 NULL
 data_in_size_mpt3_ioctl_command_65434_fns data_in_size mpt3_ioctl_command 0 65434 NULL
 lbs_bcnmiss_write_fndecl_65438_fns lbs_bcnmiss_write fndecl 3 65438 NULL
+spi_cmd_complete_fndecl_65442_fns spi_cmd_complete fndecl 5 65442 NULL
 rx_rx_pre_complt_read_fndecl_65446_fns rx_rx_pre_complt_read fndecl 3 65446 NULL
 squashfs_cache_init_fndecl_65451_fns squashfs_cache_init fndecl 3-2 65451 NULL
 raw_notifier_call_chain_fndecl_65500_fns raw_notifier_call_chain fndecl 0 65500 NULL
 sys_pwritev_fndecl_65513_fns sys_pwritev fndecl 3 65513 NULL
+bcm2835_dma_prep_dma_memcpy_fndecl_65534_fns bcm2835_dma_prep_dma_memcpy fndecl 4 65534 NULL nohasharray
+connector_write_fndecl_65534_fns connector_write fndecl 3 65534 &bcm2835_dma_prep_dma_memcpy_fndecl_65534_fns
diff --git a/scripts/gcc-plugins/size_overflow_plugin/e_vars.data b/scripts/gcc-plugins/size_overflow_plugin/e_vars.data
index a825f18145be..8f86ad7350a4 100644
--- a/scripts/gcc-plugins/size_overflow_plugin/e_vars.data
+++ b/scripts/gcc-plugins/size_overflow_plugin/e_vars.data
@@ -16,12 +16,14 @@ rx_buf_sz_vardecl_r8169_c_9136_vars rx_buf_sz vardecl_r8169.c 0 9136 NULL
 _max_socket_vardecl_x2apic_uv_x_c_9456_vars _max_socket vardecl_x2apic_uv_x.c 0 9456 NULL
 kdb_max_commands_vardecl_kdb_main_c_9529_vars kdb_max_commands vardecl_kdb_main.c 0 9529 NULL
 legacy_count_vardecl_pty_c_9908_vars legacy_count vardecl_pty.c 0 9908 NULL
+max_ptlrpcds_vardecl_ptlrpcd_c_9939_vars max_ptlrpcds vardecl_ptlrpcd.c 0 9939 NULL
 read_buffer_size_vardecl_legousbtower_c_10184_vars read_buffer_size vardecl_legousbtower.c 0 10184 NULL
 iio_devt_vardecl_industrialio_core_c_10237_vars iio_devt vardecl_industrialio-core.c 0 10237 NULL
 dma_rx_num_vardecl_altera_tse_main_c_10728_vars dma_rx_num vardecl_altera_tse_main.c 0 10728 NULL
 default_rds_buf_vardecl_fmdrv_common_c_11072_vars default_rds_buf vardecl_fmdrv_common.c 0 11072 NULL
 snd_efw_resp_buf_size_vardecl_11291_vars snd_efw_resp_buf_size vardecl 0 11291 NULL
 _max_pnode_vardecl_x2apic_uv_x_c_11492_vars _max_pnode vardecl_x2apic_uv_x.c 0 11492 NULL
+slave_num_vardecl_shdma_base_c_11603_vars slave_num vardecl_shdma-base.c 0 11603 NULL
 c4iw_wr_log_size_order_vardecl_device_c_13134_vars c4iw_wr_log_size_order vardecl_device.c 0 13134 NULL
 vhci_num_controllers_vardecl_13178_vars vhci_num_controllers vardecl 0 13178 NULL
 max_sets_vardecl_ip_set_core_c_13393_vars max_sets vardecl_ip_set_core.c 0 13393 NULL
@@ -41,6 +43,7 @@ nwriters_vardecl_rcuperf_c_20234_vars nwriters vardecl_rcuperf.c 0 20234 NULL
 mpegbufs_vardecl_cx231xx_417_c_20303_vars mpegbufs vardecl_cx231xx-417.c 0 20303 NULL
 major_vardecl_dm_c_21185_vars major vardecl_dm.c 0 21185 NULL
 acpi_current_gpe_count_vardecl_21469_vars acpi_current_gpe_count vardecl 0 21469 NULL
+max_nr_vardecl_exynos_combiner_c_21761_vars max_nr vardecl_exynos-combiner.c 0 21761 NULL
 xprt_max_tcp_slot_table_entries_vardecl_xprtsock_c_21949_vars xprt_max_tcp_slot_table_entries vardecl_xprtsock.c 0 21949 NULL
 ch_count_vardecl_ib_srp_c_22190_vars ch_count vardecl_ib_srp.c 0 22190 NULL
 nreaders_stress_vardecl_locktorture_c_22217_vars nreaders_stress vardecl_locktorture.c 0 22217 NULL
@@ -62,6 +65,8 @@ num_rcv_urbs_vardecl_usbatm_c_32830_vars num_rcv_urbs vardecl_usbatm.c 0 32830 N
 _min_socket_vardecl_x2apic_uv_x_c_33176_vars _min_socket vardecl_x2apic_uv_x.c 0 33176 NULL
 num_ae_requests_vardecl_33594_vars num_ae_requests vardecl 0 33594 NULL
 blkdev_minors_vardecl_dev_c_34365_vars blkdev_minors vardecl_dev.c 0 34365 NULL
+cpu_npartitions_vardecl_linux_cpu_c_34622_vars cpu_npartitions vardecl_linux-cpu.c 0 34622 NULL
+at_max_vardecl_35692_vars at_max vardecl 0 35692 NULL
 nwriters_stress_vardecl_locktorture_c_36080_vars nwriters_stress vardecl_locktorture.c 0 36080 NULL
 max_sg_segs_vardecl_st_c_36551_vars max_sg_segs vardecl_st.c 0 36551 NULL
 null_major_vardecl_null_blk_c_36718_vars null_major vardecl_null_blk.c 0 36718 NULL
diff --git a/scripts/package/Makefile b/scripts/package/Makefile
index 71b4a8af9d4d..dcb89c580691 100644
--- a/scripts/package/Makefile
+++ b/scripts/package/Makefile
@@ -40,7 +40,7 @@ if test "$(objtree)" != "$(srctree)"; then \
 fi ; \
 $(srctree)/scripts/setlocalversion --save-scmversion; \
 ln -sf $(srctree) $(2); \
-tar -cz $(RCS_TAR_IGNORE) -f $(2).tar.gz \
+tar --owner=root --group=root -cz $(RCS_TAR_IGNORE) -f $(2).tar.gz \
 	$(addprefix $(2)/,$(TAR_CONTENT) $(3)); \
 rm -f $(2) $(objtree)/.scmversion
 
diff --git a/scripts/package/mkspec b/scripts/package/mkspec
index 57673bae5597..c722dc460008 100755
--- a/scripts/package/mkspec
+++ b/scripts/package/mkspec
@@ -120,22 +120,33 @@ echo 'rm -f $RPM_BUILD_ROOT'"/lib/modules/$KERNELRELEASE/{build,source}"
 echo "mkdir -p "'$RPM_BUILD_ROOT'"/usr/src/kernels/$KERNELRELEASE"
 echo "EXCLUDES=\"$RCS_TAR_IGNORE --exclude .tmp_versions --exclude=*vmlinux* --exclude=*.o --exclude=*.ko --exclude=*.cmd --exclude=Documentation --exclude=firmware --exclude .config.old --exclude .missing-syscalls.d\""
 echo "tar "'$EXCLUDES'" -cf- . | (cd "'$RPM_BUILD_ROOT'"/usr/src/kernels/$KERNELRELEASE;tar xvf -)"
-echo 'cd $RPM_BUILD_ROOT'"/lib/modules/$KERNELRELEASE"
-echo "ln -sf /usr/src/kernels/$KERNELRELEASE build"
-echo "ln -sf /usr/src/kernels/$KERNELRELEASE source"
 fi
 
 echo ""
 echo "%clean"
 echo 'rm -rf $RPM_BUILD_ROOT'
 echo ""
+echo "%pre"
+echo 'chmod -f 0500 /boot'
+echo 'if [ -d /lib/modules ]; then'
+echo 'chmod -f 0500 /lib/modules'
+echo 'fi'
+echo 'if [ -d /lib32/modules ]; then'
+echo 'chmod -f 0500 /lib32/modules'
+echo 'fi'
+echo 'if [ -d /lib64/modules ]; then'
+echo 'chmod -f 0500 /lib64/modules'
+echo 'fi'
+echo ""
+echo "%post devel"
+echo "ln -sf /usr/src/kernels/$KERNELRELEASE /lib/modules/$KERNELRELEASE/build"
+echo "ln -sf /usr/src/kernels/$KERNELRELEASE /lib/modules/$KERNELRELEASE/source"
+echo ""
 echo "%post"
-echo "if [ -x /sbin/installkernel -a -r /boot/vmlinuz-$KERNELRELEASE -a -r /boot/System.map-$KERNELRELEASE ]; then"
-echo "cp /boot/vmlinuz-$KERNELRELEASE /boot/.vmlinuz-$KERNELRELEASE-rpm"
-echo "cp /boot/System.map-$KERNELRELEASE /boot/.System.map-$KERNELRELEASE-rpm"
-echo "rm -f /boot/vmlinuz-$KERNELRELEASE /boot/System.map-$KERNELRELEASE"
-echo "/sbin/installkernel $KERNELRELEASE /boot/.vmlinuz-$KERNELRELEASE-rpm /boot/.System.map-$KERNELRELEASE-rpm"
-echo "rm -f /boot/.vmlinuz-$KERNELRELEASE-rpm /boot/.System.map-$KERNELRELEASE-rpm"
+echo "if [ -x /sbin/dracut ]; then"
+echo '/sbin/new-kernel-pkg --dracut --mkinitrd --depmod --install --make-default '"$KERNELRELEASE"' || exit $?'
+echo "else"
+echo '/sbin/new-kernel-pkg --mkinitrd --depmod --install --make-default '"$KERNELRELEASE"' || exit $?'
 echo "fi"
 echo ""
 echo "%preun"
@@ -149,10 +160,10 @@ echo "/sbin/update-bootloader --remove $KERNELRELEASE"
 echo "fi"
 echo ""
 echo "%files"
-echo '%defattr (-, root, root)'
-echo "/lib/modules/$KERNELRELEASE"
+echo '%defattr (400, root, root, 500)'
 echo "%exclude /lib/modules/$KERNELRELEASE/build"
 echo "%exclude /lib/modules/$KERNELRELEASE/source"
+echo "/lib/modules/$KERNELRELEASE"
 echo "/lib/firmware/$KERNELRELEASE"
 echo "/boot/*"
 echo ""
@@ -162,9 +173,11 @@ echo "/usr/include"
 echo ""
 if ! $PREBUILT; then
 echo "%files devel"
-echo '%defattr (-, root, root)'
+echo '%defattr (400, root, root, 500)'
+echo "%dir /lib/modules/$KERNELRELEASE"
 echo "/usr/src/kernels/$KERNELRELEASE"
-echo "/lib/modules/$KERNELRELEASE/build"
-echo "/lib/modules/$KERNELRELEASE/source"
+echo "%attr (500, root, root) /usr/src/kernels/$KERNELRELEASE/scripts/recordmcount"
+echo "%attr (500, root, root) /usr/src/kernels/$KERNELRELEASE/scripts/basic/fixdep"
+echo "%attr (500, root, root) /usr/src/kernels/$KERNELRELEASE/scripts/mod/modpost"
 echo ""
 fi
diff --git a/security/Kconfig b/security/Kconfig
index edbc0fd9486a..3312d822f7c9 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -4,7 +4,7 @@
 
 menu "Security options"
 
-menu "PaX"
+menu "Grsecurity"
 
 config ARCH_TRACK_EXEC_LIMIT
 	bool
@@ -18,9 +18,240 @@ config TASK_SIZE_MAX_SHIFT
 	default 47 if !PAX_PER_CPU_PGD
 	default 42 if PAX_PER_CPU_PGD
 
+config PAX_ENABLE_PAE
+	bool
+	default y if (X86_32 && (MPENTIUM4 || MK8 || MPSC || MCORE2 || MATOM))
+
+config GRKERNSEC
+	bool "Grsecurity"
+	select CRYPTO
+	select CRYPTO_SHA256
+	select PROC_FS
+	select STOP_MACHINE
+	select TTY
+	select DEBUG_KERNEL
+	select DEBUG_LIST
+	select MULTIUSER
+	select BUG
+	help
+	  If you say Y here, you will be able to configure many features
+	  that will enhance the security of your system.  It is highly
+	  recommended that you say Y here and read through the help
+	  for each option so that you fully understand the features and
+	  can evaluate their usefulness for your machine.
+
+choice
+	prompt "Configuration Method"
+	depends on GRKERNSEC
+	default GRKERNSEC_CONFIG_CUSTOM
+	help
+
+config GRKERNSEC_CONFIG_AUTO
+	bool "Automatic"
+	help
+	  If you choose this configuration method, you'll be able to answer a small
+	  number of simple questions about how you plan to use this kernel.
+	  The settings of grsecurity and PaX will be automatically configured for
+	  the highest commonly-used settings within the provided constraints.
+
+	  If you require additional configuration, custom changes can still be made
+	  from the "custom configuration" menu.
+
+config GRKERNSEC_CONFIG_CUSTOM
+	bool "Custom"
+	help
+	  If you choose this configuration method, you'll be able to configure all
+	  grsecurity and PaX settings manually.  Via this method, no options are
+	  automatically enabled.
+
+	  Take note that if menuconfig is exited with this configuration method
+	  chosen, you will not be able to use the automatic configuration methods
+	  without starting again with a kernel configuration with no grsecurity
+	  or PaX options specified inside.
+
+endchoice
+
+choice
+	prompt "Usage Type"
+	depends on (GRKERNSEC && GRKERNSEC_CONFIG_AUTO)
+	default GRKERNSEC_CONFIG_SERVER
+	help
+
+config GRKERNSEC_CONFIG_SERVER
+	bool "Server"
+	help
+	  Choose this option if you plan to use this kernel on a server.
+
+config GRKERNSEC_CONFIG_DESKTOP
+	bool "Desktop"
+	help
+	  Choose this option if you plan to use this kernel on a desktop.
+
+endchoice
+
+choice
+	prompt "Virtualization Type"
+	depends on (GRKERNSEC && X86 && GRKERNSEC_CONFIG_AUTO)
+	default GRKERNSEC_CONFIG_VIRT_NONE
+	help
+
+config GRKERNSEC_CONFIG_VIRT_NONE
+	bool "None"
+	help
+	  Choose this option if this kernel will be run on bare metal.
+
+config GRKERNSEC_CONFIG_VIRT_GUEST
+	bool "Guest"
+	help
+	  Choose this option if this kernel will be run as a VM guest.
+
+config GRKERNSEC_CONFIG_VIRT_HOST
+	bool "Host"
+	help
+	  Choose this option if this kernel will be run as a VM host.
+
+endchoice
+
+choice
+	prompt "Virtualization Hardware"
+	depends on (GRKERNSEC && X86 && GRKERNSEC_CONFIG_AUTO && (GRKERNSEC_CONFIG_VIRT_GUEST || GRKERNSEC_CONFIG_VIRT_HOST))
+	help
+
+config GRKERNSEC_CONFIG_VIRT_EPT
+	bool "EPT/RVI Processor Support"
+	depends on X86
+	help
+	  Choose this option if your CPU supports the EPT or RVI features of 2nd-gen
+	  hardware virtualization.  This allows for additional kernel hardening protections
+	  to operate without additional performance impact.
+
+	  To see if your Intel processor supports EPT, see:
+	  http://ark.intel.com/Products/VirtualizationTechnology
+	  (Most Core i3/5/7 support EPT)
+
+	  To see if your AMD processor supports RVI, see:
+	  http://support.amd.com/us/kbarticles/Pages/GPU120AMDRVICPUsHyperVWin8.aspx
+
+config GRKERNSEC_CONFIG_VIRT_SOFT
+	bool "First-gen/No Hardware Virtualization"
+	help
+	  Choose this option if you use an Atom/Pentium/Core 2 processor that either doesn't
+	  support hardware virtualization or doesn't support the EPT/RVI extensions.
+
+endchoice
+
+choice
+	prompt "Virtualization Software"
+	depends on (GRKERNSEC && GRKERNSEC_CONFIG_AUTO && (GRKERNSEC_CONFIG_VIRT_GUEST || GRKERNSEC_CONFIG_VIRT_HOST))
+	help
+
+config GRKERNSEC_CONFIG_VIRT_XEN
+	bool "Xen"
+	help
+	  Choose this option if this kernel is running as a Xen guest or host.
+
+config GRKERNSEC_CONFIG_VIRT_VMWARE
+	bool "VMWare"
+	help
+	  Choose this option if this kernel is running as a VMWare guest or host.
+
+config GRKERNSEC_CONFIG_VIRT_KVM
+	bool "KVM"
+	help
+	  Choose this option if this kernel is running as a KVM guest or host.
+
+config GRKERNSEC_CONFIG_VIRT_VIRTUALBOX
+	bool "VirtualBox"
+	help
+	  Choose this option if this kernel is running as a VirtualBox guest or host.
+
+config GRKERNSEC_CONFIG_VIRT_HYPERV
+	bool "Hyper-V"
+	help
+	  Choose this option if this kernel is running as a Hyper-V guest.
+
+endchoice
+
+choice
+	prompt "Required Priorities"
+	depends on (GRKERNSEC && GRKERNSEC_CONFIG_AUTO)
+	default GRKERNSEC_CONFIG_PRIORITY_PERF
+	help
+
+config GRKERNSEC_CONFIG_PRIORITY_PERF
+	bool "Performance"
+	help
+	  Choose this option if performance is of highest priority for this deployment
+	  of grsecurity.  Features like UDEREF on a 64bit kernel, kernel stack clearing,
+	  clearing of structures intended for userland, and freed memory sanitizing will
+	  be disabled.
+
+config GRKERNSEC_CONFIG_PRIORITY_SECURITY
+	bool "Security"
+	help
+	  Choose this option if security is of highest priority for this deployment of
+	  grsecurity.  UDEREF, kernel stack clearing, clearing of structures intended
+	  for userland, and freed memory sanitizing will be enabled for this kernel.
+	  In a worst-case scenario, these features can introduce a 20% performance hit
+	  (UDEREF on x64 contributing half of this hit).
+
+endchoice
+
+menu "Default Special Groups"
+depends on (GRKERNSEC && GRKERNSEC_CONFIG_AUTO)
+
+config GRKERNSEC_PROC_GID
+	int "GID exempted from /proc restrictions"
+	default 1001
+	help
+	  Setting this GID determines which group will be exempted from
+	  grsecurity's /proc restrictions, allowing users of the specified
+	  group  to view network statistics and the existence of other users'
+	  processes on the system.  This GID may also be chosen at boot time
+	  via "grsec_proc_gid=" on the kernel commandline.
+
+config GRKERNSEC_TPE_UNTRUSTED_GID
+        int "GID for TPE-untrusted users"
+        depends on GRKERNSEC_CONFIG_SERVER && GRKERNSEC_TPE && !GRKERNSEC_TPE_INVERT
+        default 1005
+        help
+	  Setting this GID determines which group untrusted users should
+	  be added to.  These users will be placed under grsecurity's Trusted Path
+	  Execution mechanism, preventing them from executing their own binaries.
+	  The users will only be able to execute binaries in directories owned and
+	  writable only by the root user.  If the sysctl option is enabled, a sysctl
+	  option with name "tpe_gid" is created.
+
+config GRKERNSEC_TPE_TRUSTED_GID
+        int "GID for TPE-trusted users"
+        depends on GRKERNSEC_CONFIG_SERVER && GRKERNSEC_TPE && GRKERNSEC_TPE_INVERT
+        default 1005
+        help
+          Setting this GID determines what group TPE restrictions will be
+          *disabled* for.  If the sysctl option is enabled, a sysctl option
+          with name "tpe_gid" is created.
+
+config GRKERNSEC_SYMLINKOWN_GID
+        int "GID for users with kernel-enforced SymlinksIfOwnerMatch"
+        depends on GRKERNSEC_CONFIG_SERVER
+        default 1006
+        help
+          Setting this GID determines what group kernel-enforced
+          SymlinksIfOwnerMatch will be enabled for.  If the sysctl option
+          is enabled, a sysctl option with name "symlinkown_gid" is created.
+
+
+endmenu
+
+menu "Customize Configuration"
+depends on GRKERNSEC
+
+menu "PaX"
+
 config PAX
 	bool "Enable various PaX features"
-	depends on ALPHA || ARM || AVR32 || IA64 || MIPS || PARISC || PPC || SPARC || X86
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC && (ALPHA || ARM || AVR32 || IA64 || MIPS || PARISC || PPC || SPARC || X86)
 	help
 	  This allows you to enable various PaX features.  PaX adds
 	  intrusion prevention mechanisms to the kernel that reduce
@@ -42,7 +273,8 @@ config PAX_SOFTMODE
 	  at runtime via the entries in /proc/sys/kernel/pax.
 
 config PAX_EI_PAX
-	bool 'Use legacy ELF header marking' if EXPERT
+	bool 'Use legacy ELF header marking'
+	default y if GRKERNSEC_CONFIG_AUTO
 	help
 	  Enabling this option will allow you to control PaX features on
 	  a per executable basis via the 'chpax' utility available at
@@ -61,6 +293,7 @@ config PAX_EI_PAX
 
 config PAX_PT_PAX_FLAGS
 	bool 'Use ELF program header marking'
+	default y if GRKERNSEC_CONFIG_AUTO
 	help
 	  Enabling this option will allow you to control PaX features on
 	  a per executable basis via the 'paxctl' utility available at
@@ -81,6 +314,7 @@ config PAX_PT_PAX_FLAGS
 
 config PAX_XATTR_PAX_FLAGS
 	bool 'Use filesystem extended attributes marking'
+	default y if GRKERNSEC_CONFIG_AUTO
 	select CIFS_XATTR if CIFS
 	select EXT2_FS_XATTR if EXT2_FS
 	select EXT3_FS_XATTR if EXT3_FS
@@ -111,7 +345,7 @@ config PAX_XATTR_PAX_FLAGS
 
 choice
 	prompt 'MAC system integration'
-	default PAX_NO_ACL_FLAGS
+	default PAX_HAVE_ACL_FLAGS
 	help
 	  Mandatory Access Control systems have the option of controlling
 	  PaX flags on a per executable basis, choose the method supported
@@ -140,6 +374,7 @@ menu "Non-executable pages"
 
 config PAX_NOEXEC
 	bool "Enforce non-executable pages"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on ALPHA || (ARM && (CPU_V6 || CPU_V6K || CPU_V7)) || IA64 || MIPS || PARISC || PPC || S390 || SPARC || X86
 	help
 	  By design some architectures do not allow for protecting memory
@@ -168,8 +403,8 @@ config PAX_NOEXEC
 
 config PAX_PAGEEXEC
 	bool "Paging based non-executable pages"
-	depends on PAX_NOEXEC && (!X86_32 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MCORE2 || MPENTIUM4 || MPSC || MATOM || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2 || MVIAC7)
-	select X86_PAE if X86_32 && !HIGHMEM4G && (MCORE2 || MPSC || MATOM || MK8)
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on PAX_NOEXEC && (!X86_32 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MCORE2 || MATOM || MPENTIUM4 || MPSC || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2 || MVIAC7)
 	select ARCH_TRACK_EXEC_LIMIT if X86_32
 	help
 	  This implementation is based on the paging feature of the CPU.
@@ -189,6 +424,7 @@ config PAX_PAGEEXEC
 
 config PAX_SEGMEXEC
 	bool "Segmentation based non-executable pages"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on PAX_NOEXEC && X86_32
 	help
 	  This implementation is based on the segmentation feature of the
@@ -197,8 +433,9 @@ config PAX_SEGMEXEC
 	  3 GB.
 
 config PAX_EMUTRAMP
-	bool "Emulate trampolines" if (PAX_PAGEEXEC || PAX_SEGMEXEC) && (PARISC || X86)
-	default y if PARISC
+	bool "Emulate trampolines"
+	default y if PARISC || GRKERNSEC_CONFIG_AUTO
+	depends on (PAX_PAGEEXEC || PAX_SEGMEXEC) && (PARISC || X86)
 	help
 	  There are some programs and libraries that for one reason or
 	  another attempt to execute special small code snippets from
@@ -255,6 +492,7 @@ config PAX_EMUSIGRT
 
 config PAX_MPROTECT
 	bool "Restrict mprotect()"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on (PAX_PAGEEXEC || PAX_SEGMEXEC)
 	help
 	  Enabling this option will prevent programs from
@@ -270,8 +508,20 @@ config PAX_MPROTECT
 	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
 	  this feature on a per file basis.
 
+config PAX_MPROTECT_COMPAT
+	bool "Use legacy/compat protection demoting (read help)"
+	depends on PAX_MPROTECT
+	default n
+	help
+	  The current implementation of PAX_MPROTECT denies RWX allocations/mprotects
+	  by sending the proper error code to the application.  For some older
+	  userland, this can cause problems with applications that assume such
+	  allocations will not be prevented by PaX or SELinux and other access
+	  control systems and have no fallback mechanisms.  For modern distros,
+	  this option should generally be set to 'N'.
+
 config PAX_ELFRELOCS
-	bool "Allow ELF text relocations"
+	bool "Allow ELF text relocations (read help)"
 	depends on PAX_MPROTECT
 	default n
 	help
@@ -330,6 +580,7 @@ config PAX_DLRESOLVE
 
 config PAX_KERNEXEC
 	bool "Enforce non-executable kernel pages"
+	default y if GRKERNSEC_CONFIG_AUTO && (!X86 || GRKERNSEC_CONFIG_VIRT_NONE || (GRKERNSEC_CONFIG_VIRT_EPT && GRKERNSEC_CONFIG_VIRT_GUEST) || (GRKERNSEC_CONFIG_VIRT_EPT && GRKERNSEC_CONFIG_VIRT_KVM))
 	depends on (X86 || (ARM && (CPU_V6 || CPU_V6K || CPU_V7) && !(ARM_LPAE && MODULES))) && !XEN
 	select PAX_PER_CPU_PGD if X86_64 || (X86_32 && X86_PAE)
 	select ARM_KERNMEM_PERMS if ARM
@@ -338,6 +589,14 @@ config PAX_KERNEXEC
 	  that is, enabling this option will make it harder to inject
 	  and execute 'foreign' code in kernel memory itself.
 
+	  Note that on amd64, CONFIG_EFI enabled with "efi=old_map" on
+	  the kernel command-line will result in an RWX physical map.
+
+	  Likewise, the EFI runtime services are necessarily mapped as
+	  RWX.  If CONFIG_EFI is enabled on an EFI-capable system, it
+	  is recommended that you boot with "noefi" on the kernel
+	  command-line if possible to eliminate the mapping.
+
 config PAX_KERNEXEC_PLUGIN
 	bool
 	depends on GCC_PLUGINS && X86_64
@@ -398,7 +657,8 @@ endchoice
 
 config PAX_KERNEXEC_MODULE_TEXT
 	int "Minimum amount of memory reserved for module code"
-	default "4"
+	default "8" if (!GRKERNSEC_CONFIG_AUTO || GRKERNSEC_CONFIG_SERVER)
+	default "12" if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_DESKTOP)
 	depends on PAX_KERNEXEC && X86_32
 	help
 	  Due to implementation details the kernel must reserve a fixed
@@ -424,6 +684,7 @@ menu "Address Space Layout Randomization"
 
 config PAX_ASLR
 	bool "Address Space Layout Randomization"
+	default y if GRKERNSEC_CONFIG_AUTO
 	help
 	  Many if not most exploit techniques rely on the knowledge of
 	  certain addresses in the attacked program.  The following options
@@ -452,6 +713,7 @@ config PAX_ASLR
 
 config PAX_RANDKSTACK
 	bool "Randomize kernel stack base"
+	default y if GRKERNSEC_CONFIG_AUTO && !(GRKERNSEC_CONFIG_VIRT_HOST && GRKERNSEC_CONFIG_VIRT_VIRTUALBOX)
 	depends on X86_TSC && X86
 	help
 	  By saying Y here the kernel will randomize every task's kernel
@@ -469,6 +731,7 @@ config PAX_RANDUSTACK
 
 config PAX_RANDMMAP
 	bool "Randomize user stack and mmap() bases"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on PAX_ASLR
 	select PAX_RANDUSTACK
 	help
@@ -503,7 +766,7 @@ menu "Miscellaneous hardening features"
 
 config PAX_MEMORY_SANITIZE
 	bool "Sanitize all freed memory"
-	depends on !DEBUG_PAGEALLOC
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_PRIORITY_SECURITY)
 	help
 	  By saying Y here the kernel will erase memory pages and slab objects
 	  as soon as they are freed.  This in turn reduces the lifetime of data
@@ -540,6 +803,7 @@ config PAX_MEMORY_SANITIZE
 
 config PAX_MEMORY_STACKLEAK
 	bool "Sanitize kernel stack"
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_PRIORITY_SECURITY)
 	depends on X86 && GCC_PLUGINS
 	help
 	  By saying Y here the kernel will erase the kernel stack before it
@@ -565,6 +829,7 @@ config PAX_MEMORY_STACKLEAK
 
 config PAX_MEMORY_STRUCTLEAK
 	bool "Forcibly initialize local variables copied to userland"
+	default y if (GRKERNSEC_CONFIG_AUTO && GRKERNSEC_CONFIG_PRIORITY_SECURITY)
 	depends on GCC_PLUGINS
 	help
 	  By saying Y here the kernel will zero initialize some local
@@ -582,6 +847,7 @@ config PAX_MEMORY_STRUCTLEAK
 
 config PAX_MEMORY_UDEREF
 	bool "Prevent invalid userland pointer dereference"
+	default y if GRKERNSEC_CONFIG_AUTO && !(X86_64 && GRKERNSEC_CONFIG_PRIORITY_PERF) && !(X86_64 && GRKERNSEC_CONFIG_VIRT_HOST && GRKERNSEC_CONFIG_VIRT_VIRTUALBOX) && (!X86 || GRKERNSEC_CONFIG_VIRT_NONE || GRKERNSEC_CONFIG_VIRT_EPT)
 	depends on (X86 || (ARM && (CPU_V6 || CPU_V6K || CPU_V7) && !ARM_LPAE)) && !UML_X86 && !XEN
 	select PAX_PER_CPU_PGD if X86_64
 	help
@@ -606,7 +872,8 @@ config PAX_MEMORY_UDEREF
 
 config PAX_REFCOUNT
 	bool "Prevent various kernel object reference counter overflows"
-	depends on (ARM && (CPU_V6 || CPU_V6K || CPU_V7)) || MIPS || PPC || SPARC64 || X86
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC && ((ARM && (CPU_V6 || CPU_V6K || CPU_V7)) || MIPS || PPC || SPARC64 || X86)
 	help
 	  By saying Y here the kernel will detect and prevent overflowing
 	  various (but not all) kinds of object reference counters.  Such
@@ -625,7 +892,8 @@ config PAX_REFCOUNT
 
 config PAX_USERCOPY
 	bool "Harden memory copies between kernel and userland"
-	depends on HAVE_ARCH_HARDENED_USERCOPY
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC && HAVE_ARCH_HARDENED_USERCOPY
 	select HARDENED_USERCOPY
 	help
 	  By saying Y here the kernel will enforce the size of heap objects
@@ -654,6 +922,7 @@ config PAX_USERCOPY
 
 config PAX_CONSTIFY_PLUGIN
 	bool "Automatically constify eligible structures"
+	default y
 	depends on !UML && PAX_KERNEXEC && GCC_PLUGINS
 	help
 	  By saying Y here the compiler will automatically constify a class
@@ -669,9 +938,17 @@ config PAX_CONSTIFY_PLUGIN
 	  can be found in PaX itself (the no_const attribute) and for some
 	  out-of-tree modules at http://www.grsecurity.net/~paxguy1/ .
 
+
+config PAX_USERCOPY_DEBUG
+	bool
+	depends on X86 && PAX_USERCOPY
+	default n
+
 config PAX_SIZE_OVERFLOW
 	bool "Prevent various integer overflows in function size parameters"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on GCC_PLUGINS
+	depends on !SPARC64 && !ARM64
 	help
 	  By saying Y here the kernel recomputes expressions of function
 	  arguments marked by a size_overflow attribute with double integer
@@ -691,6 +968,7 @@ config PAX_SIZE_OVERFLOW
 
 config PAX_SIZE_OVERFLOW_EXTRA
 	bool "Increase coverage of size overflow checking"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on PAX_SIZE_OVERFLOW
 	help
 	  By saying Y here the kernel will instrument more size argument
@@ -734,6 +1012,7 @@ config PAX_INITIFY_VERBOSE
 
 config PAX_LATENT_ENTROPY
 	bool "Generate some entropy during boot and runtime"
+	default y if GRKERNSEC_CONFIG_AUTO
 	depends on GCC_PLUGINS
 	select GCC_PLUGIN_LATENT_ENTROPY
 	help
@@ -759,6 +1038,7 @@ config PAX_LATENT_ENTROPY
 config PAX_RAP
 	bool "Prevent code reuse attacks"
 	depends on X86_64 && GCC_PLUGINS
+	default y if GRKERNSEC_CONFIG_AUTO
 	help
 	  By saying Y here the kernel will check indirect control transfers
 	  in order to detect and prevent attacks that try to hijack control
@@ -778,6 +1058,12 @@ endmenu
 
 endmenu
 
+source grsecurity/Kconfig
+
+endmenu
+
+endmenu
+
 source security/keys/Kconfig
 
 config SECURITY_DMESG_RESTRICT
@@ -963,4 +1249,3 @@ config DEFAULT_SECURITY
 	default "" if DEFAULT_SECURITY_DAC
 
 endmenu
-
diff --git a/security/apparmor/file.c b/security/apparmor/file.c
index 4d2af4b01033..608971ac6781 100644
--- a/security/apparmor/file.c
+++ b/security/apparmor/file.c
@@ -349,8 +349,8 @@ static inline bool xindex_is_subset(u32 link, u32 target)
 int aa_path_link(struct aa_profile *profile, struct dentry *old_dentry,
 		 const struct path *new_dir, struct dentry *new_dentry)
 {
-	struct path link = { new_dir->mnt, new_dentry };
-	struct path target = { new_dir->mnt, old_dentry };
+	struct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };
+	struct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };
 	struct path_cond cond = {
 		d_backing_inode(old_dentry)->i_uid,
 		d_backing_inode(old_dentry)->i_mode
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 06670d3b39ab..411695cdc9f0 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -176,7 +176,7 @@ static int common_perm_dir_dentry(int op, const struct path *dir,
 				  struct dentry *dentry, u32 mask,
 				  struct path_cond *cond)
 {
-	struct path path = { dir->mnt, dentry };
+	struct path path = { .mnt = dir->mnt, .dentry = dentry };
 
 	return common_perm(op, &path, mask, cond);
 }
@@ -306,8 +306,8 @@ static int apparmor_path_rename(const struct path *old_dir, struct dentry *old_d
 
 	profile = aa_current_profile();
 	if (!unconfined(profile)) {
-		struct path old_path = { old_dir->mnt, old_dentry };
-		struct path new_path = { new_dir->mnt, new_dentry };
+		struct path old_path = { .mnt = old_dir->mnt, .dentry = old_dentry };
+		struct path new_path = { .mnt = new_dir->mnt, .dentry = new_dentry };
 		struct path_cond cond = { d_backing_inode(old_dentry)->i_uid,
 					  d_backing_inode(old_dentry)->i_mode
 		};
diff --git a/security/commoncap.c b/security/commoncap.c
index 8df676fbd393..77e2cb5f351a 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -433,6 +433,32 @@ int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data
 	return 0;
 }
 
+/* returns:
+	1 for suid privilege
+	2 for sgid privilege
+	3 for fscap privilege
+*/
+int is_privileged_binary(const struct dentry *dentry)
+{
+	struct cpu_vfs_cap_data capdata;
+	struct inode *inode = dentry->d_inode;
+
+	if (!inode || S_ISDIR(inode->i_mode))
+		return 0;
+
+	if (inode->i_mode & S_ISUID)
+		return 1;
+	if ((inode->i_mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
+		return 2;
+
+	if (!get_vfs_caps_from_disk(dentry, &capdata)) {
+		if (!cap_isclear(capdata.inheritable) || !cap_isclear(capdata.permitted))
+			return 3;
+	}
+
+	return 0;
+}
+
 /*
  * Attempt to get the on-exec apply capability sets for an executable file from
  * its xattrs and, if present, apply them to the proposed credentials being
@@ -631,6 +657,9 @@ int cap_bprm_secureexec(struct linux_binprm *bprm)
 	const struct cred *cred = current_cred();
 	kuid_t root_uid = make_kuid(cred->user_ns, 0);
 
+	if (gr_acl_enable_at_secure())
+		return 1;
+
 	if (!uid_eq(cred->uid, root_uid)) {
 		if (bprm->cap_effective)
 			return 1;
diff --git a/security/keys/internal.h b/security/keys/internal.h
index 68555bb294f9..898c675f11b0 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -196,7 +196,7 @@ struct request_key_auth {
 	void			*callout_info;
 	size_t			callout_len;
 	pid_t			pid;
-};
+} __randomize_layout;
 
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index d580ad06b792..283a3ed6c45a 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,
 
 	if (_payload) {
 		ret = -ENOMEM;
-		payload = kmalloc(plen, GFP_KERNEL | __GFP_NOWARN);
+		payload = kmalloc(plen, GFP_KERNEL | GFP_USERCOPY | __GFP_NOWARN);
 		if (!payload) {
 			if (plen <= PAGE_SIZE)
 				goto error2;
@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,
 	payload = NULL;
 	if (_payload) {
 		ret = -ENOMEM;
-		payload = kmalloc(plen, GFP_KERNEL);
+		payload = kmalloc(plen, GFP_KERNEL | GFP_USERCOPY);
 		if (!payload)
 			goto error;
 
@@ -616,7 +616,7 @@ long keyctl_describe_key(key_serial_t keyid,
 
 	/* calculate how much information we're going to return */
 	ret = -ENOMEM;
-	infobuf = kasprintf(GFP_KERNEL,
+	infobuf = kasprintf(GFP_KERNEL | GFP_USERCOPY,
 			    "%s;%d;%d;%08x;",
 			    key->type->name,
 			    from_kuid_munged(current_user_ns(), key->uid),
@@ -1064,7 +1064,7 @@ long keyctl_instantiate_key_common(key_serial_t id,
 
 	if (from) {
 		ret = -ENOMEM;
-		payload = kmalloc(plen, GFP_KERNEL);
+		payload = kmalloc(plen, GFP_KERNEL | GFP_USERCOPY);
 		if (!payload) {
 			if (plen <= PAGE_SIZE)
 				goto error;
diff --git a/security/tomoyo/file.c b/security/tomoyo/file.c
index 7041a580019e..223f21ffa632 100644
--- a/security/tomoyo/file.c
+++ b/security/tomoyo/file.c
@@ -692,7 +692,7 @@ int tomoyo_path_number_perm(const u8 type, const struct path *path,
 {
 	struct tomoyo_request_info r;
 	struct tomoyo_obj_info obj = {
-		.path1 = *path,
+		.path1 = { .mnt = path->mnt, .dentry = path->dentry },
 	};
 	int error = -ENOMEM;
 	struct tomoyo_path_info buf;
@@ -740,7 +740,7 @@ int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
 	struct tomoyo_path_info buf;
 	struct tomoyo_request_info r;
 	struct tomoyo_obj_info obj = {
-		.path1 = *path,
+		.path1 = { .mnt = path->mnt, .dentry = path->dentry },
 	};
 	int idx;
 
@@ -786,7 +786,7 @@ int tomoyo_path_perm(const u8 operation, const struct path *path, const char *ta
 {
 	struct tomoyo_request_info r;
 	struct tomoyo_obj_info obj = {
-		.path1 = *path,
+		.path1 = { .mnt = path->mnt, .dentry = path->dentry },
 	};
 	int error;
 	struct tomoyo_path_info buf;
@@ -843,7 +843,7 @@ int tomoyo_mkdev_perm(const u8 operation, const struct path *path,
 {
 	struct tomoyo_request_info r;
 	struct tomoyo_obj_info obj = {
-		.path1 = *path,
+		.path1 = { .mnt = path->mnt, .dentry = path->dentry },
 	};
 	int error = -ENOMEM;
 	struct tomoyo_path_info buf;
@@ -890,8 +890,8 @@ int tomoyo_path2_perm(const u8 operation, const struct path *path1,
 	struct tomoyo_path_info buf2;
 	struct tomoyo_request_info r;
 	struct tomoyo_obj_info obj = {
-		.path1 = *path1,
-		.path2 = *path2,
+		.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },
+		.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }
 	};
 	int idx;
 
diff --git a/security/tomoyo/mount.c b/security/tomoyo/mount.c
index 14b53fb2a0cf..8829296de5e6 100644
--- a/security/tomoyo/mount.c
+++ b/security/tomoyo/mount.c
@@ -118,6 +118,10 @@ static int tomoyo_mount_acl(struct tomoyo_request_info *r,
 		   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {
 		need_dev = -1; /* dev_name is a directory */
 	} else {
+		if (!capable(CAP_SYS_ADMIN)) {
+			error = -EPERM;
+			goto out;
+		}
 		fstype = get_fs_type(type);
 		if (!fstype) {
 			error = -ENODEV;
diff --git a/security/tomoyo/tomoyo.c b/security/tomoyo/tomoyo.c
index 75c998700190..b9569d497df2 100644
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@ -165,7 +165,7 @@ static int tomoyo_path_truncate(const struct path *path)
  */
 static int tomoyo_path_unlink(const struct path *parent, struct dentry *dentry)
 {
-	struct path path = { parent->mnt, dentry };
+	struct path path = { .mnt = parent->mnt, .dentry = dentry };
 	return tomoyo_path_perm(TOMOYO_TYPE_UNLINK, &path, NULL);
 }
 
@@ -181,7 +181,7 @@ static int tomoyo_path_unlink(const struct path *parent, struct dentry *dentry)
 static int tomoyo_path_mkdir(const struct path *parent, struct dentry *dentry,
 			     umode_t mode)
 {
-	struct path path = { parent->mnt, dentry };
+	struct path path = { .mnt = parent->mnt, .dentry = dentry };
 	return tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,
 				       mode & S_IALLUGO);
 }
@@ -196,7 +196,7 @@ static int tomoyo_path_mkdir(const struct path *parent, struct dentry *dentry,
  */
 static int tomoyo_path_rmdir(const struct path *parent, struct dentry *dentry)
 {
-	struct path path = { parent->mnt, dentry };
+	struct path path = { .mnt = parent->mnt, .dentry = dentry };
 	return tomoyo_path_perm(TOMOYO_TYPE_RMDIR, &path, NULL);
 }
 
@@ -212,7 +212,7 @@ static int tomoyo_path_rmdir(const struct path *parent, struct dentry *dentry)
 static int tomoyo_path_symlink(const struct path *parent, struct dentry *dentry,
 			       const char *old_name)
 {
-	struct path path = { parent->mnt, dentry };
+	struct path path = { .mnt = parent->mnt, .dentry = dentry };
 	return tomoyo_path_perm(TOMOYO_TYPE_SYMLINK, &path, old_name);
 }
 
@@ -229,7 +229,7 @@ static int tomoyo_path_symlink(const struct path *parent, struct dentry *dentry,
 static int tomoyo_path_mknod(const struct path *parent, struct dentry *dentry,
 			     umode_t mode, unsigned int dev)
 {
-	struct path path = { parent->mnt, dentry };
+	struct path path = { .mnt = parent->mnt, .dentry = dentry };
 	int type = TOMOYO_TYPE_CREATE;
 	const unsigned int perm = mode & S_IALLUGO;
 
@@ -268,8 +268,8 @@ static int tomoyo_path_mknod(const struct path *parent, struct dentry *dentry,
 static int tomoyo_path_link(struct dentry *old_dentry, const struct path *new_dir,
 			    struct dentry *new_dentry)
 {
-	struct path path1 = { new_dir->mnt, old_dentry };
-	struct path path2 = { new_dir->mnt, new_dentry };
+	struct path path1 = { .mnt = new_dir->mnt, .dentry = old_dentry };
+	struct path path2 = { .mnt = new_dir->mnt, .dentry = new_dentry };
 	return tomoyo_path2_perm(TOMOYO_TYPE_LINK, &path1, &path2);
 }
 
@@ -288,8 +288,8 @@ static int tomoyo_path_rename(const struct path *old_parent,
 			      const struct path *new_parent,
 			      struct dentry *new_dentry)
 {
-	struct path path1 = { old_parent->mnt, old_dentry };
-	struct path path2 = { new_parent->mnt, new_dentry };
+	struct path path1 = { .mnt = old_parent->mnt, .dentry = old_dentry };
+	struct path path2 = { .mnt = new_parent->mnt, .dentry = new_dentry };
 	return tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path1, &path2);
 }
 
@@ -417,7 +417,7 @@ static int tomoyo_sb_mount(const char *dev_name, const struct path *path,
  */
 static int tomoyo_sb_umount(struct vfsmount *mnt, int flags)
 {
-	struct path path = { mnt, mnt->mnt_root };
+	struct path path = { .mnt = mnt, .dentry = mnt->mnt_root };
 	return tomoyo_path_perm(TOMOYO_TYPE_UMOUNT, &path, NULL);
 }
 
diff --git a/security/yama/Kconfig b/security/yama/Kconfig
index 90c605eea892..bf3a29ae1f49 100644
--- a/security/yama/Kconfig
+++ b/security/yama/Kconfig
@@ -1,6 +1,6 @@
 config SECURITY_YAMA
 	bool "Yama support"
-	depends on SECURITY
+	depends on SECURITY && !GRKERNSEC
 	default n
 	help
 	  This selects Yama, which extends DAC support with additional
diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index a0209204ae48..55579f6b8cb2 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -33,13 +33,13 @@ static int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *inf
  * MIDI emulation operators
  */
 static struct snd_midi_op emux_ops = {
-	snd_emux_note_on,
-	snd_emux_note_off,
-	snd_emux_key_press,
-	snd_emux_terminate_note,
-	snd_emux_control,
-	snd_emux_nrpn,
-	snd_emux_sysex,
+	.note_on = snd_emux_note_on,
+	.note_off = snd_emux_note_off,
+	.key_press = snd_emux_key_press,
+	.note_terminate = snd_emux_terminate_note,
+	.control = snd_emux_control,
+	.nrpn = snd_emux_nrpn,
+	.sysex = snd_emux_sysex,
 };
 
 
diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c
index ab3c280a23d1..e5cb2929a835 100644
--- a/sound/usb/line6/driver.c
+++ b/sound/usb/line6/driver.c
@@ -337,7 +337,7 @@ int line6_read_data(struct usb_line6 *line6, unsigned address, void *data,
 {
 	struct usb_device *usbdev = line6->usbdev;
 	int ret;
-	unsigned char len;
+	unsigned char *plen;
 	unsigned count;
 
 	if (address > 0xffff || datalen > 0xff)
@@ -354,6 +354,10 @@ int line6_read_data(struct usb_line6 *line6, unsigned address, void *data,
 		return ret;
 	}
 
+	plen = kmalloc(1, GFP_KERNEL);
+	if (plen == NULL)
+		return -ENOMEM;
+
 	/* Wait for data length. We'll get 0xff until length arrives. */
 	for (count = 0; count < LINE6_READ_WRITE_MAX_RETRIES; count++) {
 		mdelay(LINE6_READ_WRITE_STATUS_DELAY);
@@ -361,30 +365,35 @@ int line6_read_data(struct usb_line6 *line6, unsigned address, void *data,
 		ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), 0x67,
 				      USB_TYPE_VENDOR | USB_RECIP_DEVICE |
 				      USB_DIR_IN,
-				      0x0012, 0x0000, &len, 1,
+				      0x0012, 0x0000, plen, 1,
 				      LINE6_TIMEOUT * HZ);
 		if (ret < 0) {
 			dev_err(line6->ifcdev,
 				"receive length failed (error %d)\n", ret);
+			kfree(plen);
 			return ret;
 		}
 
-		if (len != 0xff)
+		if (*plen != 0xff)
 			break;
 	}
 
-	if (len == 0xff) {
+	if (*plen == 0xff) {
 		dev_err(line6->ifcdev, "read failed after %d retries\n",
 			count);
+		kfree(plen);
 		return -EIO;
-	} else if (len != datalen) {
+	} else if (*plen != datalen) {
 		/* should be equal or something went wrong */
 		dev_err(line6->ifcdev,
 			"length mismatch (expected %d, got %d)\n",
-			(int)datalen, (int)len);
+			(int)datalen, (int)*plen);
+		kfree(plen);
 		return -EIO;
 	}
 
+	kfree(plen);
+
 	/* receive the result: */
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), 0x67,
 			      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
@@ -408,7 +417,7 @@ int line6_write_data(struct usb_line6 *line6, unsigned address, void *data,
 {
 	struct usb_device *usbdev = line6->usbdev;
 	int ret;
-	unsigned char status;
+	unsigned char *status;
 	int count;
 
 	if (address > 0xffff || datalen > 0xffff)
@@ -425,6 +434,10 @@ int line6_write_data(struct usb_line6 *line6, unsigned address, void *data,
 		return ret;
 	}
 
+	status = kmalloc(1, GFP_KERNEL);
+	if (status == NULL)
+		return -ENOMEM;
+
 	for (count = 0; count < LINE6_READ_WRITE_MAX_RETRIES; count++) {
 		mdelay(LINE6_READ_WRITE_STATUS_DELAY);
 
@@ -433,27 +446,32 @@ int line6_write_data(struct usb_line6 *line6, unsigned address, void *data,
 				      USB_TYPE_VENDOR | USB_RECIP_DEVICE |
 				      USB_DIR_IN,
 				      0x0012, 0x0000,
-				      &status, 1, LINE6_TIMEOUT * HZ);
+				      status, 1, LINE6_TIMEOUT * HZ);
 
 		if (ret < 0) {
 			dev_err(line6->ifcdev,
 				"receiving status failed (error %d)\n", ret);
+			kfree(status);
 			return ret;
 		}
 
-		if (status != 0xff)
+		if (*status != 0xff)
 			break;
 	}
 
-	if (status == 0xff) {
+	if (*status == 0xff) {
 		dev_err(line6->ifcdev, "write failed after %d retries\n",
 			count);
+		kfree(status);
 		return -EIO;
-	} else if (status != 0) {
+	} else if (*status != 0) {
 		dev_err(line6->ifcdev, "write failed (error %d)\n", ret);
+		kfree(status);
 		return -EIO;
 	}
 
+	kfree(status);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(line6_write_data);
diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 8e22f430d700..2f5e18c3c138 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -367,13 +367,19 @@ static bool toneport_has_source_select(struct usb_line6_toneport *toneport)
 */
 static void toneport_setup(struct usb_line6_toneport *toneport)
 {
-	int ticks;
+	int *ticks;
 	struct usb_line6 *line6 = &toneport->line6;
 	struct usb_device *usbdev = line6->usbdev;
 
+	ticks = kmalloc(sizeof(int), GFP_KERNEL);
+	if (ticks == NULL)
+		return;
+
 	/* sync time on device with host: */
-	ticks = (int)get_seconds();
-	line6_write_data(line6, 0x80c6, &ticks, 4);
+	*ticks = (int)get_seconds();
+	line6_write_data(line6, 0x80c6, ticks, sizeof(int));
+
+	kfree(ticks);
 
 	/* enable device: */
 	toneport_send_cmd(usbdev, 0x0301, 0x0000);
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index f144f1518629..07aea886e77d 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -577,6 +577,10 @@ static int kvm_create_vm_debugfs(struct kvm *kvm, int fd)
 	struct kvm_stat_data *stat_data;
 	struct kvm_stats_debugfs_item *p;
 
+#ifdef CONFIG_GRKERNSEC_SYSFS_RESTRICT
+	return 0;
+#endif
+
 	if (!debugfs_initialized())
 		return 0;
 
