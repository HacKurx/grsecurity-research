diff --git a/arch/parisc/include/asm/uaccess.h b/arch/parisc/include/asm/uaccess.h
index 0497cec..58b097a 100644
--- a/arch/parisc/include/asm/uaccess.h
+++ b/arch/parisc/include/asm/uaccess.h
@@ -256,10 +256,10 @@ static inline void copy_user_overflow(int size, unsigned long count)
 static __always_inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
-	int sz = __compiletime_object_size(to);
+	size_t sz = __compiletime_object_size(to);
 	unsigned long ret = n;
 
-	if (likely(sz < 0 || sz >= n)) {
+	if (likely(sz == (size_t)-1 || sz >= n)) {
 		check_object_size(to, n, false);
 		ret = __copy_from_user(to, from, n);
 	} else if (!__builtin_constant_p(n))
@@ -267,7 +267,7 @@ copy_from_user(void *to, const void __user *from, unsigned long n)
 	else
 		__bad_copy_user();
 
-	if (unlikely(ret))
+	if (unlikely(ret && (long)ret > 0))
 		memset(to + (n - ret), 0, ret);
 
 	return ret;
@@ -276,9 +276,9 @@ copy_from_user(void *to, const void __user *from, unsigned long n)
 static __always_inline unsigned long __must_check
 copy_to_user(void __user *to, const void *from, unsigned long n)
 {
-	int sz = __compiletime_object_size(from);
+	size_t sz = __compiletime_object_size(to);
 
-	if (likely(sz < 0 || sz >= n)) {
+	if (likely(sz == (size_t)-1 || sz >= n)) {
 		check_object_size(from, n, true);
 		n = __copy_to_user(to, from, n);
 	} else if (!__builtin_constant_p(n))
diff --git a/arch/powerpc/platforms/cell/spufs/file.c b/arch/powerpc/platforms/cell/spufs/file.c
index 0625446..139a0aa 100644
--- a/arch/powerpc/platforms/cell/spufs/file.c
+++ b/arch/powerpc/platforms/cell/spufs/file.c
@@ -263,9 +263,9 @@ spufs_mem_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	return VM_FAULT_NOPAGE;
 }
 
-static int spufs_mem_mmap_access(struct vm_area_struct *vma,
+static ssize_t spufs_mem_mmap_access(struct vm_area_struct *vma,
 				unsigned long address,
-				void *buf, int len, int write)
+				void *buf, size_t len, int write)
 {
 	struct spu_context *ctx = vma->vm_file->private_data;
 	unsigned long offset = address - vma->vm_start;
