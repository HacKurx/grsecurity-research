diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 01753cd..b65d17a 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -110,7 +110,7 @@ void machine_shutdown(void)
  * activity (executing tasks, handling interrupts). smp_send_stop()
  * achieves this.
  */
-void machine_halt(void)
+void __noreturn machine_halt(void)
 {
 	local_irq_disable();
 	smp_send_stop();
@@ -123,12 +123,13 @@ void machine_halt(void)
  * achieves this. When the system power is turned off, it will take all CPUs
  * with it.
  */
-void machine_power_off(void)
+void __noreturn machine_power_off(void)
 {
 	local_irq_disable();
 	smp_send_stop();
 	if (pm_power_off)
 		pm_power_off();
+	while(1);
 }
 
 /*
@@ -140,7 +141,7 @@ void machine_power_off(void)
  * executing pre-reset code, and using RAM that the primary CPU's code wishes
  * to use. Implementing such co-ordination would be essentially impossible.
  */
-void machine_restart(char *cmd)
+void __noreturn machine_restart(char *cmd)
 {
 	/* Disable interrupts first */
 	local_irq_disable();
diff --git a/arch/x86/include/asm/emergency-restart.h b/arch/x86/include/asm/emergency-restart.h
index 77a99ac..39ff7f5 100644
--- a/arch/x86/include/asm/emergency-restart.h
+++ b/arch/x86/include/asm/emergency-restart.h
@@ -1,6 +1,6 @@
 #ifndef _ASM_X86_EMERGENCY_RESTART_H
 #define _ASM_X86_EMERGENCY_RESTART_H
 
-extern void machine_emergency_restart(void);
+extern void machine_emergency_restart(void) __noreturn;
 
 #endif /* _ASM_X86_EMERGENCY_RESTART_H */
